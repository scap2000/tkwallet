webpackJsonp([8],{

/***/ 1000:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletRecoverPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__ = __webpack_require__(1001);







let WalletRecoverPage = class WalletRecoverPage {
    constructor(profileProvider, navCtrl, logger) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
    }
    ionViewWillEnter() {
        this.profileProvider.getProfileLegacy().then(oldProfile => {
            if (!oldProfile)
                return;
            this.logger.debug(`Legacy profile exist. Typeof: ${typeof oldProfile}`);
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](oldProfile)) {
                oldProfile = JSON.parse(oldProfile);
            }
            this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](oldProfile.credentials, value => {
                return value && (value.mnemonic || value.mnemonicEncrypted);
            });
            this.logger.debug(`${this.wallets.length} wallets with mnemonics found in legacy profile`);
        });
    }
    openWalletMnemonicRecoverPage(name, credential) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__["a" /* WalletMnemonicRecoverPage */], { name, credential });
    }
};
WalletRecoverPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-recover-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/wallet-recover-page/wallet-recover-page.html"*/'<wide-header-page title="Old Wallet Recovery Tool">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button ion-item *ngFor="let wallet of wallets" (click)="openWalletMnemonicRecoverPage(wallet.walletName, wallet)">\n        <ion-icon class="item-img" item-start>\n          <img src="assets/img/currencies/{{wallet.coin}}.svg" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" />\n        </ion-icon>\n        <ion-label>\n          {{wallet.walletName}}\n        </ion-label>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/wallet-recover-page/wallet-recover-page.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */]])
], WalletRecoverPage);

//# sourceMappingURL=wallet-recover-page.js.map

/***/ }),

/***/ 1001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletMnemonicRecoverPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(25);









let WalletMnemonicRecoverPage = class WalletMnemonicRecoverPage {
    constructor(logger, navParams, form, popupProvider, translate, bwcProvider, errorsProvider) {
        this.logger = logger;
        this.navParams = navParams;
        this.form = form;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.bwcProvider = bwcProvider;
        this.errorsProvider = errorsProvider;
        this.mnemonicPhrase = '';
        this.mnemonicEncrypted =
            this.navParams.data.credential.mnemonic === undefined;
        if (!this.mnemonicEncrypted) {
            this.mnemonicPhrase = this.navParams.data.credential.mnemonic;
        }
        this.title = this.navParams.data.name;
        this.passwordForm = this.form.group({
            encryptPassword: [null]
        });
    }
    decryptMnemonic() {
        if (!this.passwordForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        else {
            this._decryptMnemonic(this.passwordForm.value.encryptPassword, this.navParams.data.credential);
        }
    }
    _decryptMnemonic(password, credential) {
        let mnemonic = '';
        if (!credential.xPrivKeyEncrypted)
            throw new Error('Private key is not encrypted');
        try {
            if (credential.mnemonicEncrypted) {
                mnemonic = this.bwcProvider
                    .getSJCL()
                    .decrypt(password, credential.mnemonicEncrypted);
                this.mnemonicPhrase = mnemonic;
                this.mnemonicEncrypted = false;
            }
        }
        catch (ex) {
            this.showErrorInfoSheet('Could Not Decrypt', 'Error');
        }
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        this.errorsProvider.showDefaultError(err, infoSheetTitle);
    }
};
WalletMnemonicRecoverPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-mnemonic-recover-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/wallet-recover-page/wallet-mnemonic-recover-page/wallet-mnemonic-recover-page.html"*/'<wide-header-page title="{{ title }}">\n  <div page-content>\n    <div class="container">\n      <label-tip class="no-arrowhead" type="warn" margin-top>\n        <span label-tip-title>Mnemonic Recovery Warning</span>\n        <div label-tip-body>\n          <span>\n            It\'s recommended that you write down your recovery phrase and store it\n            securely so that your wallet can be recovered in the case your device\n            was lost or stolen.</span>\n        </div>\n      </label-tip>\n\n      <form class="form-container" [formGroup]="passwordForm" *ngIf="mnemonicEncrypted">\n        <ion-item>\n          <ion-label floating>Password</ion-label>\n          <ion-input type="password" formControlName="encryptPassword">\n            Enter Encrypt Password\n          </ion-input>\n        </ion-item>\n        <button class="decrypt-button" (click)="decryptMnemonic()">Enter</button>\n      </form>\n\n      <div class="mnemonic-phrase-container" *ngIf="!mnemonicEncrypted">\n        <div class="mnemonic-word-container">{{ mnemonicPhrase }}</div>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/wallet-recover-page/wallet-mnemonic-recover-page/wallet-mnemonic-recover-page.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__["a" /* ErrorsProvider */]])
], WalletMnemonicRecoverPage);

//# sourceMappingURL=wallet-mnemonic-recover-page.js.map

/***/ }),

/***/ 1002:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AltCurrencyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_splash_screen__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);




// native

// Providers






let AltCurrencyPage = class AltCurrencyPage {
    constructor(configProvider, logger, navCtrl, rate, splashScreen, platformProvider, persistenceProvider, actionSheetProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.rate = rate;
        this.splashScreen = splashScreen;
        this.platformProvider = platformProvider;
        this.persistenceProvider = persistenceProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.PAGE_COUNTER = 3;
        this.SHOW_LIMIT = 10;
        this.completeAlternativeList = [];
        this.altCurrencyList = [];
        this.unusedCurrencyList = [
            {
                isoCode: 'LTL'
            },
            {
                isoCode: 'BTC'
            },
            {
                isoCode: 'EDU'
            },
            {
                isoCode: 'TIK'
            },
            {
                isoCode: 'BCH'
            },
            {
                isoCode: 'ETH'
            },
            {
                isoCode: 'XRP'
            },
            {
                isoCode: 'USDC'
            },
            {
                isoCode: 'GUSD'
            },
            {
                isoCode: 'PAX'
            },
            {
                isoCode: 'BUSD'
            },
            {
                isoCode: 'DAI'
            },
            {
                isoCode: 'WBTC'
            }
        ];
    }
    ionViewWillEnter() {
        this.rate
            .whenRatesAvailable('btc')
            .then(() => {
            this.completeAlternativeList = this.rate.listAlternatives(true);
            let idx = __WEBPACK_IMPORTED_MODULE_10_lodash__["keyBy"](this.unusedCurrencyList, 'isoCode');
            let idx2 = __WEBPACK_IMPORTED_MODULE_10_lodash__["keyBy"](this.lastUsedAltCurrencyList, 'isoCode');
            this.completeAlternativeList = __WEBPACK_IMPORTED_MODULE_10_lodash__["reject"](this.completeAlternativeList, c => {
                return idx[c.isoCode] || idx2[c.isoCode];
            });
            this.altCurrencyList = this.completeAlternativeList.slice(0, 20);
        })
            .catch(err => {
            this.logger.error(err);
        });
        let config = this.configProvider.get();
        this.currentCurrency = config.wallet.settings.alternativeIsoCode;
        this.persistenceProvider
            .getLastCurrencyUsed()
            .then(lastUsedAltCurrency => {
            this.lastUsedAltCurrencyList = lastUsedAltCurrency
                ? lastUsedAltCurrency
                : [];
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    loadAltCurrencies(loading) {
        if (this.altCurrencyList.length === this.completeAlternativeList.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.altCurrencyList = this.completeAlternativeList.slice(0, this.PAGE_COUNTER * this.SHOW_LIMIT);
            this.PAGE_COUNTER++;
            if (this.searchedAltCurrency)
                this.findCurrency();
            loading.complete();
        }, 300);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AltCurrencyPage');
    }
    save(newAltCurrency) {
        var opts = {
            wallet: {
                settings: {
                    alternativeName: newAltCurrency.name,
                    alternativeIsoCode: newAltCurrency.isoCode
                }
            }
        };
        if (__WEBPACK_IMPORTED_MODULE_10_lodash__["some"](this.completeAlternativeList, ['isoCode', newAltCurrency.isoCode])) {
            this.configProvider.set(opts);
            this.saveLastUsed(newAltCurrency);
            this.navCtrl.popToRoot().then(() => {
                this.reload();
            });
        }
        else {
            // To stop showing currencies that are no longer supported
            this.showErrorAndRemoveAltCurrency(newAltCurrency);
        }
    }
    showErrorAndRemoveAltCurrency(altCurrency) {
        const params = {
            name: altCurrency.name,
            isoCode: altCurrency.isoCode,
            error: true
        };
        const infoSheet = this.actionSheetProvider.createInfoSheet('unsupported-alt-currency', params);
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            this.lastUsedAltCurrencyList = __WEBPACK_IMPORTED_MODULE_10_lodash__["reject"](this.lastUsedAltCurrencyList, [
                'isoCode',
                altCurrency.isoCode
            ]);
            this.persistenceProvider
                .setLastCurrencyUsed(JSON.stringify(this.lastUsedAltCurrencyList))
                .then(() => { });
        });
    }
    reload() {
        window.location.reload();
        if (this.platformProvider.isCordova)
            this.splashScreen.show();
    }
    saveLastUsed(newAltCurrency) {
        this.lastUsedAltCurrencyList.unshift(newAltCurrency);
        this.lastUsedAltCurrencyList = __WEBPACK_IMPORTED_MODULE_10_lodash__["uniqBy"](this.lastUsedAltCurrencyList, 'isoCode');
        this.lastUsedAltCurrencyList = this.lastUsedAltCurrencyList.slice(0, 3);
        this.persistenceProvider
            .setLastCurrencyUsed(JSON.stringify(this.lastUsedAltCurrencyList))
            .then(() => { });
    }
    findCurrency() {
        this.altCurrencyList = __WEBPACK_IMPORTED_MODULE_10_lodash__["filter"](this.completeAlternativeList, item => {
            var val = item.name;
            var val2 = item.isoCode;
            return (__WEBPACK_IMPORTED_MODULE_10_lodash__["includes"](val.toLowerCase(), this.searchedAltCurrency.toLowerCase()) ||
                __WEBPACK_IMPORTED_MODULE_10_lodash__["includes"](val2.toLowerCase(), this.searchedAltCurrency.toLowerCase()));
        });
    }
};
AltCurrencyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-alt-currency',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/alt-currency/alt-currency.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Display Currency\' | translate }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n    <ion-toolbar class="wide-header__title">\n      <expandable-header-primary>\n        {{ \'Display Currency\' | translate }}\n      </expandable-header-primary>\n    </ion-toolbar>\n  </expandable-header>\n\n  <ion-item class="search-container" no-lines padding>\n    <ion-input class="search-wrapper" placeholder="{{\'Search currency\' | translate}}" [(ngModel)]="searchedAltCurrency" (ngModelChange)="findCurrency()"></ion-input>\n  </ion-item>\n  <ion-list class="settings-list bp-list">\n    <ion-item *ngFor="let lastUsedAltCurrency of lastUsedAltCurrencyList" (click)="save(lastUsedAltCurrency)">\n      {{ lastUsedAltCurrency.name }}\n      <span class="currency" item-end>{{lastUsedAltCurrency.isoCode}}</span>\n    </ion-item>\n  </ion-list>\n  <div class="line-divider"></div>\n  <div *ngIf="altCurrencyList[0] && lastUsedAltCurrencyList[0]" padding></div>\n  <ion-list class="settings-list bp-list">\n    <ion-item *ngFor="let alt of altCurrencyList" (click)="save(alt)">\n      {{ alt.name }}\n      <ion-note item-end>{{alt.isoCode}}</ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-spinner class="loading" *ngIf="!altCurrencyList[0]" name="crescent"></ion-spinner>\n\n  <ion-infinite-scroll (ionInfinite)="loadAltCurrencies($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/alt-currency/alt-currency.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */]])
], AltCurrencyPage);

//# sourceMappingURL=alt-currency.js.map

/***/ }),

/***/ 1003:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeePolicyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__ = __webpack_require__(148);




// Providers


const COIN = 'btc';
const NETWORK = 'livenet';
let FeePolicyPage = class FeePolicyPage {
    constructor(logger, feeProvider, configProvider) {
        this.logger = logger;
        this.feeProvider = feeProvider;
        this.configProvider = configProvider;
        this.feeOpts = this.feeProvider.getFeeOpts();
        delete this.feeOpts['custom']; // Remove custom level
        this.currentFeeLevel = this.feeProvider.getCurrentFeeLevel();
    }
    ionViewDidEnter() {
        this.error = null;
        return this.feeProvider
            .getFeeLevels(COIN, NETWORK)
            .then(data => {
            this.feeLevels = data.levels;
            this.updateCurrentValues();
        })
            .catch(err => {
            this.logger.error(err);
            this.error = err;
        });
    }
    save() {
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.currentFeeLevel) ||
            this.currentFeeLevel == this.feeProvider.getCurrentFeeLevel())
            return;
        this.logger.debug('New fee level: ' + this.currentFeeLevel);
        this.updateCurrentValues();
        this.setFee();
    }
    updateCurrentValues() {
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.feeLevels) || __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.currentFeeLevel))
            return;
        let value = __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.feeLevels, feeLevel => feeLevel.level == this.currentFeeLevel);
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](value))
            return;
        this.feePerSatByte = (value['feePerKb'] / 1000).toFixed();
        this.avgConfirmationTime = value['nbBlocks'] * 10;
    }
    setFee() {
        let opts = {
            wallet: {
                settings: {
                    feeLevel: this.currentFeeLevel
                }
            }
        };
        this.configProvider.set(opts);
    }
};
FeePolicyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-fee-policy',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/fee-policy/fee-policy.html"*/'<wide-header-page title="{{\'Bitcoin Network Fee Policy\'|translate}}">\n  <div page-content>\n\n    <div class="explanation" padding>\n      <div class="heading" translate>Bitcoin transactions include a fee collected by miners on the network.</div>\n      <div class="description" translate>The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.</div>\n      <div class="estimates">\n        <div>\n          <span translate>Average confirmation time</span>:\n          <span class="fee-minutes" *ngIf="avgConfirmationTime">{{avgConfirmationTime | amDuration: \'minute\'}}</span>\n          <span class="fee-minutes" *ngIf="!avgConfirmationTime && !error">...</span>\n          <span class="fee-minutes error" *ngIf="!avgConfirmationTime && error" translate>Error</span>\n        </div>\n        <div>\n          <span translate>Current fee rate for this policy</span>:\n          <span class="fee-rate" *ngIf="feePerSatByte">{{feePerSatByte}} satoshis/byte</span>\n          <span class="fee-rate" *ngIf="!feePerSatByte && !error">...</span>\n          <span class="fee-rate error" *ngIf="!feePerSatByte && error" translate>Error</span>\n        </div>\n      </div>\n    </div>\n\n    <ion-list radio-group [(ngModel)]="currentFeeLevel" (ionChange)="save()" class="settings-list bp-list">\n      <ion-item *ngFor="let data of feeOpts | keys">\n        <ion-label>{{data.value}}</ion-label>\n        <ion-radio [value]="data.key"></ion-radio>\n      </ion-item>\n    </ion-list>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/fee-policy/fee-policy.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */]])
], FeePolicyPage);

//# sourceMappingURL=fee-policy.js.map

/***/ }),

/***/ 1004:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeySettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__add_add__ = __webpack_require__(396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__backup_backup_key_backup_key__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__key_settings_key_name_key_name__ = __webpack_require__(1005);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__key_settings_key_onboarding_key_onboarding__ = __webpack_require__(389);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_settings_wallet_settings__ = __webpack_require__(513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(515);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__clear_encrypt_password_clear_encrypt_password__ = __webpack_require__(1013);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__extended_private_key_extended_private_key__ = __webpack_require__(1014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__key_delete_key_delete__ = __webpack_require__(1015);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__key_qr_export_key_qr_export__ = __webpack_require__(1016);





// providers







// pages










let KeySettingsPage = class KeySettingsPage {
    constructor(profileProvider, logger, walletProvider, navCtrl, navParams, externalLinkProvider, translate, keyProvider, derivationPathHelperProvider, modalCtrl, errorsProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.externalLinkProvider = externalLinkProvider;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.modalCtrl = modalCtrl;
        this.errorsProvider = errorsProvider;
        this.deleted = false;
        this.logger.info('Loaded:  KeySettingsPage');
        this.keyId = this.navParams.data.keyId;
        this.showReorder = false;
    }
    ionViewWillEnter() {
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.wallets = this.profileProvider.getWalletsFromGroup({
            keyId: this.keyId,
            showHidden: true
        });
        this.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(this.wallets[0].credentials.rootPath);
        this.canSign = this.walletsGroup.canSign;
        this.isDeletedSeed = this.walletsGroup.isDeletedSeed;
        this.needsBackup = this.walletsGroup.needsBackup;
        this.encryptEnabled = this.walletsGroup.isPrivKeyEncrypted;
    }
    touchIdChange() {
        if (this.touchIdPrevValue == this.touchIdEnabled)
            return;
        const newStatus = this.touchIdEnabled;
        this.walletProvider
            .setTouchId(this.wallets, newStatus)
            .then(() => {
            this.touchIdPrevValue = this.touchIdEnabled;
            this.logger.debug('Touch Id status changed: ' + newStatus);
        })
            .catch(err => {
            this.logger.error('Error with fingerprint:', err);
            this.touchIdEnabled = this.touchIdPrevValue;
        });
    }
    encryptChange() {
        const val = this.encryptEnabled;
        this.profileProvider.removeProfileLegacy();
        if (val && !this.walletsGroup.isPrivKeyEncrypted) {
            this.logger.debug('Encrypting private key for', this.walletsGroup.name);
            this.keyProvider
                .encrypt(this.keyId)
                .then(() => {
                const key = this.keyProvider.getKey(this.keyId);
                const replaceKey = true;
                this.keyProvider.addKey(key, replaceKey);
                this.profileProvider.walletsGroups[this.keyId].isPrivKeyEncrypted = true;
                this.logger.debug('Key encrypted');
            })
                .catch(err => {
                this.encryptEnabled = false;
                const title = this.translate.instant('Could not encrypt wallet');
                this.showErrorInfoSheet(err, title);
            });
        }
        else if (!val && this.walletsGroup.isPrivKeyEncrypted) {
            this.keyProvider
                .decrypt(this.keyId)
                .then(() => {
                const key = this.keyProvider.getKey(this.keyId);
                const replaceKey = true;
                this.keyProvider.addKey(key, replaceKey);
                this.profileProvider.walletsGroups[this.keyId].isPrivKeyEncrypted = false;
                this.logger.debug('Key decrypted');
            })
                .catch(err => {
                this.encryptEnabled = true;
                if (err === 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    const title = this.translate.instant('Could not decrypt wallet');
                    this.showErrorInfoSheet(err, title);
                }
            });
        }
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.warn('Could not encrypt/decrypt group wallets:', err);
        this.errorsProvider.showDefaultError(err, infoSheetTitle);
    }
    openBackupSettings() {
        if (this.derivationStrategy == 'BIP45') {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */], {
                walletId: this.wallets[0].credentials.walletId
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
                keyId: this.keyId
            });
        }
    }
    openClearEncryptPasswordPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__clear_encrypt_password_clear_encrypt_password__["a" /* ClearEncryptPasswordPage */], {
            keyId: this.keyId
        });
    }
    openWalletGroupDelete() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_20__key_delete_key_delete__["a" /* KeyDeletePage */], {
            keyId: this.keyId
        });
    }
    openQrExport() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__key_qr_export_key_qr_export__["a" /* KeyQrExportPage */], {
            keyId: this.keyId
        });
    }
    openWalletGroupExtendedPrivateKey() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__extended_private_key_extended_private_key__["a" /* ExtendedPrivateKeyPage */], {
            keyId: this.keyId
        });
    }
    openSupportEncryptPassword() {
        const url = 'https://support.tkcoin.org/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openWalletSettings(id) {
        if (this.showReorder)
            return;
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_settings_wallet_settings__["a" /* WalletSettingsPage */], { walletId: id });
    }
    reorder() {
        this.showReorder = !this.showReorder;
    }
    reorderAccounts(indexes) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const element = this.wallets[indexes.from];
            this.wallets.splice(indexes.from, 1);
            this.wallets.splice(indexes.to, 0, element);
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](this.wallets, (wallet, index) => {
                this.profileProvider.setWalletOrder(wallet.id, index);
            });
            yield new Promise(resolve => setTimeout(resolve, 1000));
            this.profileProvider.setOrderedWalletsByGroup();
        });
    }
    goToAddPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__add_add__["a" /* AddPage */], { keyId: this.keyId });
    }
    openWalletGroupName() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__key_settings_key_name_key_name__["a" /* KeyNamePage */], {
            keyId: this.keyId
        });
    }
    showKeyOnboardingSlides() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_15__key_settings_key_onboarding_key_onboarding__["a" /* KeyOnboardingPage */], null, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
    }
};
KeySettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-key-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-settings.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{canSign ? (\'Key Settings\' | translate) : (\'Read Only Wallets\' | translate) }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea no-bounce class="add-bottom-safe-area">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          {{canSign ? (\'Key Settings\' | translate) : (\'Read Only Wallets\' | translate) }}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n    <div class="subtitle-container" *ngIf="wallets && canSign">\n      <div class="subtitle">\n        {{\'This key contains {walletsLength} wallets\' | translate: { walletsLength: wallets.length } }}.\n      </div>\n      <div class="onboarding-modal" (click)="showKeyOnboardingSlides()">\n        <ion-icon name="md-help-circle"></ion-icon>\n      </div>\n    </div>\n\n    <label-tip class="no-arrowhead" *ngIf="!canSign" type="warn">\n      <span label-tip-title translate>No Private Key</span>\n      <div label-tip-body translate>\n        Read Only wallets don\'t include the private key.\n      </div>\n    </label-tip>\n\n    <ion-list class="settings-list bp-list">\n      <button ion-item (click)="openWalletGroupName()">\n        <div translate float-left>Key Name</div>\n        <ion-note item-end>\n          {{walletsGroup?.name}}\n        </ion-note>\n      </button>\n\n      <ion-item-divider *ngIf="canSign">{{\'Wallets\' | translate}}\n        <button class="reorder-option" ion-button item-end clear *ngIf="!showReorder && wallets?.length > 1" (click)="reorder()">\n          <img src="assets/img/sort.svg">\n        </button>\n        <button class="reorder-option" ion-button item-end clear *ngIf="showReorder" (click)="reorder()">\n          {{\'Done\' | translate}}\n        </button>\n      </ion-item-divider>\n      <ion-list reorder="{{showReorder}}" (ionItemReorder)="reorderAccounts($event)">\n        <button class="wallets-list" [attr.detail-none]="showReorder ? true : null" ion-item *ngFor="let wallet of wallets" (click)="openWalletSettings(wallet.id)">\n          <coin-icon [coin]="wallet.coin" [network]="wallet.network" item-left></coin-icon>\n          <ion-label>\n            <div class="main-label">\n              {{wallet.name}}\n            </div>\n          </ion-label>\n          <ion-note *ngIf="wallet.hidden" item-end>\n            {{\'Hidden\'|translate}}\n          </ion-note>\n        </button>\n      </ion-list>\n      <button ion-item detail-none class="create-button" *ngIf="wallets && wallets[0].canAddNewAccount" (click)="goToAddPage()">\n        {{\'Create a new wallet\' | translate }}\n      </button>\n\n      <ion-item-divider *ngIf="canSign || touchIdAvailable">{{\'Security\' | translate}}</ion-item-divider>\n      <button ion-item *ngIf="canSign" (click)="openBackupSettings()" [ngClass]="{warn: needsBackup}">\n        <span translate>Backup</span>\n        <ion-note *ngIf="needsBackup" class="wallet-warning" item-end>\n          {{\'Needs backup\' | translate}}\n        </ion-note>\n      </button>\n\n      <div *ngIf="canSign && !needsBackup">\n        <ion-item class="with-label no-border">\n          <ion-label>{{\'Request Encrypt Password\' | translate}}</ion-label>\n          <ion-toggle [(ngModel)]="encryptEnabled" (ionChange)="encryptChange()"></ion-toggle>\n        </ion-item>\n        <label-tip type="info">\n          <span label-tip-title translate>Password Not Recoverable</span>\n          <div label-tip-body>\n            <span translate>This password cannot be recovered. If this password is lost, funds can only be recovered by reimporting your 12-word recovery phrase.</span>\n            <br>\n            <a class="label-tip-link" (click)="openSupportEncryptPassword()" translate>Learn More</a>\n          </div>\n        </label-tip>\n      </div>\n\n      <button ion-item *ngIf="encryptEnabled && derivationStrategy !== \'BIP45\'" (click)="openClearEncryptPasswordPage()">\n        <span translate>Clear Encrypt Password</span>\n      </button>\n\n      <div *ngIf="touchIdAvailable">\n        <ion-item>\n          <ion-label [ngClass]="{\'disabled\': needsBackup}">{{\'Request Fingerprint\'| translate}}</ion-label>\n          <ion-toggle [(ngModel)]="touchIdEnabled" (ionChange)="touchIdChange()"></ion-toggle>\n        </ion-item>\n      </div>\n\n\n      <ion-item-divider *ngIf="canSign">{{\'Advanced\' | translate}}</ion-item-divider>\n\n      <button *ngIf="!needsBackup && canSign && !isDeletedSeed" ion-item (click)="openQrExport()">\n        <span translate>Export Key</span>\n      </button>\n\n      <button *ngIf="!needsBackup && canSign" ion-item (click)="openWalletGroupExtendedPrivateKey()">\n        <span translate>Extended Private Key</span>\n      </button>\n\n      <button *ngIf="canSign" ion-item (click)="openWalletGroupDelete()">\n        <span translate>Delete</span>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__["a" /* ErrorsProvider */]])
], KeySettingsPage);

//# sourceMappingURL=key-settings.js.map

/***/ }),

/***/ 1005:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyNamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(17);






// providers

let KeyNamePage = class KeyNamePage {
    constructor(profileProvider, navCtrl, navParams, formBuilder, logger, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.translate = translate;
        this.walletGroupNameForm = this.formBuilder.group({
            walletGroupName: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: KeyNamePage');
    }
    ionViewWillEnter() {
        this.walletGroup = this.profileProvider.getWalletGroup(this.navParams.data.keyId);
        this.walletGroupNameForm.value.walletGroupName = this.walletGroup.name;
        this.description = this.translate.instant('You can change the name displayed on this device below.');
    }
    save() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.profileProvider.setWalletGroupName(this.navParams.data.keyId, this.walletGroupNameForm.value.walletGroupName);
            this.navCtrl.pop();
        });
    }
};
KeyNamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-key-name',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-name/key-name.html"*/'<wide-header-page title="{{\'Key Name\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <div class="settings-explanation">\n        <div class="settings-heading" translate>What do you call this key?</div>\n        <div class="settings-description">\n          {{description}}\n        </div>\n      </div>\n      <form [formGroup]="walletGroupNameForm">\n        <ion-item>\n          <ion-label stacked>{{\'Name\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="walletGroupName" [value]="walletGroupNameForm.value.walletGroupName" required></ion-input>\n        </ion-item>\n        <button ion-button class="button-standard" (click)="save()" [disabled]="!walletGroupNameForm.valid">\n          {{\'Save\' | translate}}\n        </button>\n      </form>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-name/key-name.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], KeyNamePage);

//# sourceMappingURL=key-name.js.map

/***/ }),

/***/ 1006:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDeletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__ = __webpack_require__(143);




// providers






let WalletDeletePage = class WalletDeletePage {
    constructor(profileProvider, navCtrl, navParams, popupProvider, onGoingProcessProvider, logger, translate, keyProvider, pushNotificationsProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletDeletePage');
    }
    ionViewWillEnter() {
        const walletId = this.navParams.data.walletId;
        this.keyId = this.navParams.data.keyId;
        this.wallet = this.profileProvider.getWallet(walletId);
    }
    showDeletePopup() {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete this wallet?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider.removeProfileLegacy();
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            const keyInUse = this.profileProvider.isKeyInUse(this.keyId);
            if (!keyInUse) {
                this.keyProvider.removeKey(this.keyId);
                this.goHome();
            }
            else {
                this.logger.warn('Key was not removed. Still in use');
                this.goHome();
            }
        }))
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Could not remove all wallet data: ', err);
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err.message || err);
        });
    }
    goHome() {
        setTimeout(() => {
            this.navCtrl.popToRoot();
        }, 1000);
    }
};
WalletDeletePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-delete',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-delete/wallet-delete.html"*/'<wide-header-page title="{{\'Delete Wallet\' | translate}}">\n  <div page-content>\n    <h3 class="assertive" translate>Warning!</h3>\n    <p translate>\n      Permanently delete this wallet.\n    </p>\n    <p translate>\n      THIS ACTION CANNOT BE REVERSED\n    </p>\n    <button ion-button class="button-standard" color="danger" (click)="showDeletePopup()">\n      {{\'Delete\' | translate}}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-delete/wallet-delete.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], WalletDeletePage);

//# sourceMappingURL=wallet-delete.js.map

/***/ }),

/***/ 1007:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletNamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);






// providers



let WalletNamePage = class WalletNamePage {
    constructor(profileProvider, navCtrl, navParams, configProvider, formBuilder, events, logger, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.logger = logger;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.walletNameForm = this.formBuilder.group({
            walletName: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletNamePage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.config = this.configProvider.get();
        let alias = this.config.aliasFor &&
            this.config.aliasFor[this.wallet.credentials.walletId];
        this.walletNameForm.value.walletName = alias
            ? alias
            : this.wallet.credentials.walletName;
        this.walletName = this.wallet.credentials.walletName;
        this.description = this.replaceParametersProvider.replace(this.translate.instant('When this wallet was created, it was called "{{walletName}}". You can change the name displayed on this device below.'), { walletName: this.walletName });
    }
    save() {
        let opts = {
            aliasFor: {}
        };
        opts.aliasFor[this.wallet.credentials.walletId] = this.walletNameForm.value.walletName;
        this.configProvider.set(opts);
        this.events.publish('Local/ConfigUpdate', {
            walletId: this.wallet.credentials.walletId
        });
        this.profileProvider.setOrderedWalletsByGroup();
        this.navCtrl.pop();
    }
};
WalletNamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-name',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/'<wide-header-page title="{{\'Wallet Name\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <div class="settings-explanation">\n        <div class="settings-heading" translate>What do you call this wallet?</div>\n        <div class="settings-description">\n          {{description}}\n        </div>\n      </div>\n      <form [formGroup]="walletNameForm">\n        <ion-item>\n          <ion-label stacked>{{\'Name\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="walletName" [value]="walletNameForm.value.walletName" required></ion-input>\n        </ion-item>\n        <button ion-button class="button-standard" (click)="save()" [disabled]="!walletNameForm.valid">\n          {{\'Save\' | translate}}\n        </button>\n      </form>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], WalletNamePage);

//# sourceMappingURL=wallet-name.js.map

/***/ }),

/***/ 1008:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AllAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(13);




// native

// providers



let AllAddressesPage = class AllAddressesPage {
    constructor(navParams, viewCtrl, onGoingProcessProvider, socialSharing, appProvider, logger, platformProvider) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.walletName = this.navParams.data.walletName;
        this.noBalance = this.navParams.data.noBalance;
        this.withBalance = this.navParams.data.withBalance;
        this.coin = this.navParams.data.coin;
        this.allAddresses = this.noBalance.concat(this.withBalance);
        this.isCordova = this.platformProvider.isCordova;
    }
    dismiss() {
        this.viewCtrl.dismiss();
    }
    formatDate(ts) {
        const dateObj = new Date(ts * 1000);
        if (!dateObj) {
            this.logger.warn('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    sendByEmail() {
        this.onGoingProcessProvider.set('sendingByEmail');
        setTimeout(() => {
            this.onGoingProcessProvider.clear();
            const appName = this.appProvider.info.nameCase;
            let body = appName +
                ' Wallet "' +
                this.walletName +
                '" Addresses\n  Only Main Addresses are  shown.\n\n';
            body += '\n';
            body += this.allAddresses
                .map(v => {
                return ('* ' +
                    v.address +
                    ' xpub' +
                    v.path.substring(1) +
                    ' ' +
                    this.formatDate(v.createdOn));
            })
                .join('\n');
            const subject = appName + ' Addresses';
            // Check if sharing via email is supported
            this.socialSharing
                .canShareViaEmail()
                .then(() => {
                this.logger.info('sharing via email is possible');
                this.socialSharing
                    .shareViaEmail(body, subject, null, // TO: must be null or an array
                null, // CC: must be null or an array
                null, // BCC: must be null or an array
                null // FILES: can be null, a string, or an array
                )
                    .then(data => {
                    this.logger.info('Email created successfully: ', data);
                })
                    .catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            })
                .catch(() => {
                this.logger.warn('sharing via email is not possible');
                this.socialSharing.share(body, subject).catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            });
        });
    }
};
AllAddressesPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-all-addresses',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/'<wide-header-page title="{{\'All addresses\' | translate}}">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="dismiss()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <ion-item-divider *ngIf="withBalance && withBalance[0]">{{\'Addresses with balance\' | translate}}</ion-item-divider>\n      <ion-item *ngFor="let w of withBalance" copy-to-clipboard="{{w.address}}">\n        <div class="address-container">{{w.address}}</div>\n        <p class="info">\n          {{w.amount | satToUnit: coin}}\n        </p>\n      </ion-item>\n\n      <ion-item-divider *ngIf="noBalance && noBalance[0]">{{\'Unused addresses\' | translate}}</ion-item-divider>\n      <ion-item *ngFor="let u of noBalance" copy-to-clipboard="{{u.address}}">\n        <div class="address-container">{{u.address}}</div>\n        <p>\n          {{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}\n        </p>\n      </ion-item>\n    </ion-list>\n  </div>\n  <div footer-content>\n    <ion-toolbar *ngIf="isCordova && allAddresses[0]">\n      <button ion-button full class="button-footer" (click)="sendByEmail()">\n        <span translate>Send addresses by email</span>\n      </button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */]])
], AllAddressesPage);

//# sourceMappingURL=all-addresses.js.map

/***/ }),

/***/ 1009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDuplicatePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__ = __webpack_require__(31);






// Providers










let WalletDuplicatePage = class WalletDuplicatePage {
    constructor(walletProvider, onGoingProcessProvider, pushNotificationsProvider, externalLinkProvider, bwcErrorProvider, logger, translate, events, navParams, configProvider, navCtrl, profileProvider, derivationPathHelperProvider, errorsProvider) {
        this.walletProvider = walletProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.errorsProvider = errorsProvider;
        this.defaults = this.configProvider.getDefaults();
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        const derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(this.wallet.credentials.rootPath);
        // Filter out already duplicated wallets
        let walletsBCH = this.profileProvider.getWallets({
            coin: 'bch',
            network: 'livenet'
        });
        let xPubKeyIndex = __WEBPACK_IMPORTED_MODULE_4_lodash__["keyBy"](walletsBCH, 'credentials.xPubKey');
        if (xPubKeyIndex[this.wallet.credentials.xPubKey]) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Already duplicated');
        }
        else if (derivationStrategy != 'BIP44') {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Non BIP44 wallet');
        }
        else if (!this.wallet.canSign) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Read only wallet');
        }
        else if (this.wallet.needsBackup) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Wallet Needs Backup');
            this.nonEligibleWallet.body = this.translate.instant(`Before duplicating your wallet, it's recommended that you first write down your recovery phrase and store it securely so that your wallet can be recovered in the case your device was lost or stolen.`);
        }
        else {
            this.availableWallet = this.wallet;
        }
        if (!this.availableWallet)
            return;
    }
    setErr(err) {
        const errorMsg = this.bwcErrorProvider.msg(err, 'Could not duplicate');
        this.logger.warn('Duplicate BCH', errorMsg);
        this.errorsProvider.showDefaultError(errorMsg, this.translate.instant('Error'));
        return;
    }
    duplicate(wallet) {
        this.logger.info(`Duplicating wallet for BCH: ${wallet.id} - ${wallet.name}`);
        let opts = {
            useLegacyCoinType: true,
            useLegacyPurpose: true,
            name: `${wallet.name} [BCH duplicate]`,
            m: wallet.m,
            n: wallet.n,
            myName: wallet.credentials.copayerName,
            networkName: wallet.network,
            coin: __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__["a" /* Coin */].BCH,
            walletPrivKey: wallet.credentials.walletPrivKey,
            compliantDerivation: wallet.credentials.compliantDerivation,
            bwsurl: this.defaults.bws.url,
            derivationStrategy: wallet.credentials.derivationStrategy,
            addressType: wallet.credentials.addressType
        };
        this.walletProvider
            .getKeys(wallet)
            .then(key => {
            opts.extendedPrivateKey = key.xPrivKey;
            opts.duplicateKeyId = wallet.credentials.keyId;
            this.logger.debug('Duplicating Wallet. using key :', opts.duplicateKeyId);
            this.onGoingProcessProvider.set('duplicatingWallet');
            this.importOrCreate(wallet, opts)
                .then(result => {
                let newWallet = result.walletBch;
                let isNew = result.isNew;
                this.walletProvider.updateRemotePreferences(newWallet);
                this.pushNotificationsProvider.updateSubscription(newWallet);
                // Multisig wallets? add Copayers
                this.addCopayers(wallet, newWallet, isNew)
                    .then(() => {
                    this.onGoingProcessProvider.clear();
                    if (isNew) {
                        this.walletProvider.startScan(newWallet).catch(err => {
                            this.logger.warn(err);
                        });
                    }
                    this.events.publish('status:updated');
                    this.navCtrl.popToRoot();
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    this.setErr(err);
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.setErr(err);
            });
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    this.setErr(this.bwcErrorProvider.msg(err));
                }
            }
        });
    }
    addCopayers(wallet, newWallet, isNew) {
        if (!isNew)
            return Promise.resolve();
        if (wallet.n == 1)
            return Promise.resolve();
        this.logger.debug(`Adding copayers for BCH wallet config: ${wallet.m} - ${wallet.n}`);
        return this.walletProvider.copyCopayers(wallet, newWallet);
    }
    importOrCreate(wallet, opts) {
        return this.walletProvider.fetchStatus(wallet, {}).then(status => {
            opts.singleAddress = status.wallet.singleAddress;
            // first try to import
            return this.profileProvider
                .importWithDerivationPath(opts)
                .then(walletBch => {
                return Promise.resolve({ walletBch });
            })
                .catch(() => {
                this.logger.warn('Could not import. Trying to create wallet');
                return this.profileProvider.createWallet(opts).then(walletBch => {
                    return Promise.resolve({ walletBch, isNew: true });
                });
            });
        });
    }
    openHelpExternalLink() {
        let url = 'https://support.tkcoin.org/hc/en-us/articles/115005019583-How-Can-I-Recover-Bitcoin-Cash-BCH-from-My-Wallet-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
WalletDuplicatePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-duplicate',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-duplicate/wallet-duplicate.html"*/'<wide-header-page title="Duplicate Wallet">\n  <div page-content>\n    <div *ngIf="availableWallet">\n      <div class="explanation">\n        <span translate>\n          This feature duplicates a Bitcoin wallet on the Bitcoin Cash chain, enabling access to pre-fork coins. This should only be used if there are unclaimed funds before the Bitcoin Cash fork day on the wallet. The resulting wallet will use the same derivation path as the original BTC wallet.\n        </span>\n        <a (click)="openHelpExternalLink()" translate>\n          <span translate>Help &amp; support</span>\n        </a>\n      </div>\n    </div>\n\n    <div *ngIf="nonEligibleWallet">\n      <label-tip class="no-arrowhead" type="warn">\n        <span label-tip-title>{{nonEligibleWallet.excludeReason}}</span>\n        <div label-tip-body>{{nonEligibleWallet.body}}</div>\n      </label-tip>\n    </div>\n\n    <button ion-button class="button-standard" (click)="duplicate(availableWallet)" [disabled]="nonEligibleWallet">\n      {{\'Duplicate to BCH\' | translate}}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-duplicate/wallet-duplicate.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_errors_errors__["a" /* ErrorsProvider */]])
], WalletDuplicatePage);

//# sourceMappingURL=wallet-duplicate.js.map

/***/ }),

/***/ 1010:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletInformationPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(17);




// providers



let WalletInformationPage = class WalletInformationPage {
    constructor(profileProvider, currencyProvider, navParams, logger) {
        this.profileProvider = profileProvider;
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletInformationPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.walletName = this.wallet.name;
        this.coin = this.wallet.coin.toUpperCase();
        this.unitToSatoshi = this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi;
        this.walletId = this.wallet.credentials.walletId;
        this.N = this.wallet.credentials.n;
        this.M = this.wallet.credentials.m;
        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallet.cachedStatus)) {
            this.copayers = this.wallet.cachedStatus.wallet.copayers;
        }
        this.copayerId = this.wallet.credentials.copayerId;
        this.balanceByAddress = this.wallet.balanceByAddress;
        this.account = this.wallet.credentials.account;
        this.network = this.wallet.credentials.network;
        this.addressType = this.wallet.credentials.addressType || 'P2SH';
        this.rootPath = this.wallet.credentials.rootPath;
        this.pubKeys = __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.wallet.credentials.publicKeyRing, 'xPubKey');
        this.externalSource = null;
        this.canSign = this.wallet.canSign;
        this.linkedEthWalletName = this.wallet.linkedEthWalletName;
    }
    isUtxoCoin() {
        return this.currencyProvider.isUtxoCoin(this.wallet.coin);
    }
};
WalletInformationPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-information',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/'<wide-header-page title="{{\'Wallet Information\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <ion-item>\n        <div translate float-left>Name (at creation)</div>\n        <ion-note item-end>\n          {{walletName}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span translate>Coin</span>\n        <ion-note item-end>\n          {{coin}}\n        </ion-note>\n      </ion-item>\n      <ion-item copy-to-clipboard="{{walletId}}">\n        <span>Wallet Id</span>\n        <div padding-top>\n          <div text-wrap>\n            {{walletId}}\n          </div>\n        </div>\n      </ion-item>\n      <ion-item *ngIf="linkedEthWalletName">\n        <span translate>Linked Ethereum Wallet</span>\n        <ion-note item-end>\n          {{linkedEthWalletName}}\n        </ion-note>\n      </ion-item>\n\n      <ion-item>\n        <span translate>Configuration (m-n)</span>\n        <ion-note item-end>\n          {{M}}-{{N}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span translate>Network</span>\n        <ion-note item-end>\n          {{network}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="wallet && isUtxoCoin()">\n        <span translate>Address Type</span>\n        <ion-note item-end>\n          {{addressType}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span translate>Derivation Path</span>\n        <ion-note item-end>\n          {{rootPath}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="!canSign">\n        <span translate>Read Only Wallet</span>\n        <ion-note item-end>\n          <span translate>No private key</span>\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span translate>Account</span>\n        <ion-note item-end>\n          #{{account}}\n        </ion-note>\n      </ion-item>\n      <ion-item-divider *ngIf="copayers">Copayers</ion-item-divider>\n      <ion-item *ngFor="let copayer of copayers">\n        <span>{{copayer.name}}</span>\n        <ion-note *ngIf="copayer.id == copayerId" item-end>\n          ({{\'Me\' | translate}})\n        </ion-note>\n      </ion-item>\n      <ion-item-divider>{{\'Extended Public Keys\' | translate}}</ion-item-divider>\n      <ion-item *ngFor="let pk of pubKeys; let i=index" copy-to-clipboard="{{pk}}">\n        <span>Copayer {{i}}</span>\n        <div padding-top>\n          <div text-wrap>\n            {{pk}}\n          </div>\n        </div>\n        <span *ngIf="i == 0">({{rootPath}})</span>\n      </ion-item>\n      <ion-item-divider *ngIf="balanceByAddress">Balance By Address</ion-item-divider>\n      <ion-item class="item" *ngFor="let a of balanceByAddress" copy-to-clipboard="{{a.address}}">\n        <span>{{a.address}}</span>\n        <ion-note item-end>\n          {{(a.amount / unitToSatoshi).toFixed(8)}} {{coin}}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */]])
], WalletInformationPage);

//# sourceMappingURL=wallet-information.js.map

/***/ }),

/***/ 1011:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletServiceUrlPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_splash_screen__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);






// native

// providers






let WalletServiceUrlPage = class WalletServiceUrlPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, app, logger, persistenceProvider, formBuilder, events, splashScreen, platformProvider, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.app = app;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.splashScreen = splashScreen;
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.success = false;
        this.walletServiceForm = this.formBuilder.group({
            bwsurl: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletServiceUrlPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.defaults = this.configProvider.getDefaults();
        this.config = this.configProvider.get();
        let appName = this.app.info.nameCase;
        this.comment = this.replaceParametersProvider.replace(this.translate.instant("{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.tkcoin.org (TKCoin's public BWS instance)."), { appName });
        this.walletServiceForm.value.bwsurl =
            (this.config.bwsFor &&
                this.config.bwsFor[this.wallet.credentials.walletId]) ||
                this.defaults.bws.url;
    }
    resetDefaultUrl() {
        this.walletServiceForm.value.bwsurl = this.defaults.bws.url;
    }
    save() {
        let bws;
        switch (this.walletServiceForm.value.bwsurl) {
            case 'prod':
            case 'production':
                bws = 'https://bws.tkcoin.org/bws/api';
                break;
            case 'sta':
            case 'staging':
                bws = 'https://bws-staging.b-pay.net/bws/api';
                break;
            case 'loc':
            case 'local':
                bws = 'http://localhost:3232/bws/api';
                break;
        }
        if (bws) {
            this.logger.info('Using BWS URL Alias to ' + bws);
            this.walletServiceForm.value.bwsurl = bws;
        }
        let opts = {
            bwsFor: {}
        };
        opts.bwsFor[this.wallet.credentials.walletId] = this.walletServiceForm.value.bwsurl;
        this.configProvider.set(opts);
        this.persistenceProvider.setCleanAndScanAddresses(this.wallet.credentials.walletId);
        this.events.publish('Local/ConfigUpdate', {
            walletId: this.wallet.credentials.walletId
        });
        this.navCtrl.popToRoot().then(() => {
            this.reload();
        });
    }
    reload() {
        window.location.reload();
        if (this.platformProvider.isCordova)
            this.splashScreen.show();
    }
};
WalletServiceUrlPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-service-url',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/'<wide-header-page title="Wallet Service URL">\n  <div page-content>\n    <ion-list class="bp-list">\n      <form [formGroup]="walletServiceForm">\n        <ion-item>\n          <ion-label stacked>Wallet Service URL</ion-label>\n          <ion-input type="text" formControlName="bwsurl" [value]="walletServiceForm.value.bwsurl" required></ion-input>\n        </ion-item>\n        <div class="explanation">\n          <span>{{comment}}</span>\n          <a (click)="resetDefaultUrl()" translate>\n            Use default url\n          </a>\n        </div>\n        <button ion-button class="button-standard" (click)="save()" [disabled]="!walletServiceForm.valid">\n          {{\'Save\' | translate}}\n        </button>\n      </form>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], WalletServiceUrlPage);

//# sourceMappingURL=wallet-service-url.js.map

/***/ }),

/***/ 1012:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTransactionHistoryPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_papaparse__ = __webpack_require__(2008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_papaparse___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_papaparse__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__wallet_details_wallet_details__ = __webpack_require__(144);






// Providers







// Pages

let WalletTransactionHistoryPage = class WalletTransactionHistoryPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, currencyProvider, logger, platformProvider, appProvider, translate, walletProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.walletProvider = walletProvider;
        this.csvReady = false;
        this.csvContent = [];
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletTransactionHistoryPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.currency = this.wallet.coin.toUpperCase();
        this.isCordova = this.platformProvider.isCordova;
        this.appName = this.appProvider.info.nameCase;
        this.config = this.configProvider.get();
        const { unitToSatoshi } = this.currencyProvider.getPrecision(this.wallet.coin);
        this.satToUnit = 1 / unitToSatoshi;
        this.csvHistory();
    }
    formatDate(date) {
        const dateObj = new Date(date);
        if (!dateObj) {
            this.logger.warn('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    // TODO : move this to walletService.
    csvHistory() {
        this.logger.info('Generating CSV from History');
        this.walletProvider
            .fetchTxHistory(this.wallet, null, {})
            .then(txs => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txs)) {
                this.logger.warn('Failed to generate CSV: no transactions');
                this.err = this.translate.instant('No transactions');
                return;
            }
            this.logger.debug('Wallet Transaction History Length:', txs.length);
            const data = txs;
            this.csvFilename = this.appName + '-' + this.wallet.name + '.csv';
            this.csvHeader = [
                'Date',
                'Destination',
                'Description',
                'Amount',
                'Currency',
                'Txid',
                'Creator',
                'Copayers',
                'Comment'
            ];
            let _amount, _note, _copayers, _creator, _comment;
            data.forEach(it => {
                let amount = it.amount;
                if (it.action == 'moved')
                    amount = 0;
                _copayers = '';
                _creator = '';
                if (it.actions && it.actions.length > 1) {
                    for (let i = 0; i < it.actions.length; i++) {
                        _copayers +=
                            it.actions[i].copayerName + ':' + it.actions[i].type + ' - ';
                    }
                    _creator =
                        it.creatorName && it.creatorName != 'undefined'
                            ? it.creatorName
                            : '';
                }
                _amount =
                    (it.action == 'sent' ? '-' : '') +
                        (amount * this.satToUnit).toFixed(8);
                _note = it.message || '';
                _comment = it.note ? it.note.body : '';
                if (it.action == 'moved')
                    _note += ' Sent to self:' + (it.amount * this.satToUnit).toFixed(8);
                this.csvContent.push({
                    Date: this.formatDate(it.time * 1000),
                    Destination: it.addressTo || '',
                    Description: _note,
                    Amount: _amount,
                    Currency: this.currency,
                    Txid: it.txid,
                    Creator: _creator,
                    Copayers: _copayers,
                    Comment: _comment
                });
                if (it.fees && (it.action == 'moved' || it.action == 'sent')) {
                    const _fee = (it.fees * this.satToUnit).toFixed(8);
                    this.csvContent.push({
                        Date: this.formatDate(it.time * 1000),
                        Destination: 'Bitcoin Network Fees',
                        Description: '',
                        Amount: '-' + _fee,
                        Currency: this.currency,
                        Txid: '',
                        Creator: '',
                        Copayers: ''
                    });
                }
            });
            this.csvReady = true;
        })
            .catch(err => {
            if (err == 'HISTORY_IN_PROGRESS') {
                this.logger.debug('History in progress: Trying again in 5 secs...');
                setTimeout(() => {
                    this.csvHistory();
                }, 5000);
                return;
            }
            this.logger.warn('Failed to generate CSV:', err);
            this.err = err;
        });
    }
    downloadCSV() {
        if (!this.csvReady)
            return;
        const csv = __WEBPACK_IMPORTED_MODULE_5_papaparse__["unparse"]({
            fields: this.csvHeader,
            data: this.csvContent
        });
        const blob = new Blob([csv]);
        const a = window.document.createElement('a');
        a.href = window.URL.createObjectURL(blob);
        a.download = this.csvFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    clearTransactionHistory() {
        this.logger.info('Removing Transaction history ' + this.wallet.id);
        this.walletProvider.clearTxHistory(this.wallet);
        this.logger.info('Transaction history cleared for :' + this.wallet.id);
        this.navCtrl.popToRoot().then(() => {
            setTimeout(() => {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                    walletId: this.wallet.credentials.walletId
                });
            }, 1000);
        });
    }
};
WalletTransactionHistoryPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-transaction-history',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/'<wide-header-page title="{{\'Transaction History\' | translate}}">\n  <div page-content>\n    <ion-list>\n      <button ion-button class="button-standard" *ngIf="!isCordova" (click)="downloadCSV()" [disabled]="!csvReady">\n        <span *ngIf="csvReady" translate>Export to file</span>\n        <span *ngIf="!csvReady && !err">\n          {{\'preparing...\' | translate}}\n        </span>\n        <span *ngIf="!csvReady && err">\n          {{err}}\n        </span>\n      </button>\n\n      <div class="explanation" translate>\n        The transaction history and every new incoming transaction are cached in the app. Clearing the cache cleans up the transaction history and synchronizes again from the server.\n      </div>\n      <button ion-button class="button-standard" color="danger" (click)="clearTransactionHistory()">\n        <span translate>Clear cache</span>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__["a" /* WalletProvider */]])
], WalletTransactionHistoryPage);

//# sourceMappingURL=wallet-transaction-history.js.map

/***/ }),

/***/ 1013:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClearEncryptPasswordPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__ = __webpack_require__(166);



// providers


// pages

let ClearEncryptPasswordPage = class ClearEncryptPasswordPage {
    constructor(logger, navParams, navCtrl, externalLinkProvider) {
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ClearEncryptPasswordPage');
    }
    reImportWallets() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__["a" /* ImportWalletPage */], { keyId: this.navParams.data.keyId });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
ClearEncryptPasswordPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-clear-encrypt-password',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/clear-encrypt-password/clear-encrypt-password.html"*/'<wide-header-page title="{{\'Clear Encrypt Password\' | translate}}">\n  <div page-content>\n    <div padding>\n      <span translate>Because your encrypted password is not stored by TKCoin, there is no way to reset it.</span>\n    </div>\n    <div padding>\n      <span translate>If you need to regain access to your wallet because you have forgotten or lost the encrypt password, you must restore the wallet using the 12 word recovery phrase.</span>\n    </div>\n    <div padding>\n      <span translate>If you do not have the recovery phrase, you will not be able to regain access to your wallet.</span>\n      <a (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/115003004403-I-forgot-my-wallet-s-encrypted-password-What-can-I-do-\')" translate>\n        Read more\n      </a>\n    </div>\n  </div>\n  <div footer-content>\n    <ion-toolbar>\n      <button ion-button full class="button-footer" (click)="reImportWallets()" translate>Continue</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/clear-encrypt-password/clear-encrypt-password.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], ClearEncryptPasswordPage);

//# sourceMappingURL=clear-encrypt-password.js.map

/***/ }),

/***/ 1014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExtendedPrivateKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(17);




// providers





let ExtendedPrivateKeyPage = class ExtendedPrivateKeyPage {
    constructor(profileProvider, logger, navParams, navCtrl, translate, bwcErrorProvider, keyProvider, errorsProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.translate = translate;
        this.bwcErrorProvider = bwcErrorProvider;
        this.keyProvider = keyProvider;
        this.errorsProvider = errorsProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletExtendedPrivateKeyPage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.keysEncrypted = this.walletsGroup.isPrivKeyEncrypted;
    }
    ionViewDidEnter() {
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            const keys = this.keyProvider.get(this.keyId, password);
            this.xPrivKey = keys.xPrivKey;
            this.keysEncrypted = false;
        })
            .catch(err => {
            if (err && err.message != 'PASSWORD_CANCELLED') {
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    let title = this.translate.instant('Could not decrypt wallet');
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
                }
            }
            this.navCtrl.pop();
        });
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        this.errorsProvider.showDefaultError(err, infoSheetTitle);
    }
};
ExtendedPrivateKeyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-extended-private-key',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/extended-private-key/extended-private-key.html"*/'<wide-header-page title="{{\'Extended Private Key\' | translate}}">\n  <div page-content>\n    <div class="container">\n      <h3 translate>Warning!</h3>\n      <div class="warning-message">\n        <p translate>\n          Your extended private keys are all that is needed to access your funds. Be sure to protect your private keys and store them only on secure devices. TKCoin does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.\n        </p>\n      </div>\n      <div *ngIf="!keysEncrypted">\n        <button ion-button class="button-standard" copy-to-clipboard="{{xPrivKey}}">\n          {{\'Copy to clipboard\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/extended-private-key/extended-private-key.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_errors_errors__["a" /* ErrorsProvider */]])
], ExtendedPrivateKeyPage);

//# sourceMappingURL=extended-private-key.js.map

/***/ }),

/***/ 1015:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyDeletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(143);




// providers








let KeyDeletePage = class KeyDeletePage {
    constructor(profileProvider, navCtrl, navParams, popupProvider, onGoingProcessProvider, logger, translate, keyProvider, persistanceProvider, configProvider, pushNotificationsProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.persistanceProvider = persistanceProvider;
        this.configProvider = configProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: KeyDeletePage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
    }
    showDeletePopup() {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete all wallets using this key?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (res)
                this.deleteWalletGroup();
        });
    }
    deleteWalletGroup() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider.removeProfileLegacy();
        const opts = {
            keyId: this.keyId,
            showHidden: true
        };
        const wallets = this.profileProvider.getWalletsFromGroup(opts);
        this.profileProvider
            .deleteWalletGroup(this.keyId, wallets)
            .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            const keyInUse = this.profileProvider.isKeyInUse(this.keyId);
            if (!keyInUse) {
                wallets.forEach(wallet => {
                    this.pushNotificationsProvider.unsubscribe(wallet);
                    this.persistanceProvider.removeLastKnownBalance(wallet.id);
                    this.configProvider.removeBwsFor(wallet.credentials.walletId);
                });
                this.keyProvider.removeKey(this.keyId);
                this.goHome();
            }
            else {
                this.logger.warn('Key was not removed. Still in use');
                this.goHome();
            }
        }))
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Could not remove all wallet data: ', err);
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err.message || err);
        });
    }
    goHome() {
        setTimeout(() => {
            this.navCtrl.popToRoot();
        }, 1000);
    }
};
KeyDeletePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-key-delete',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-delete/key-delete.html"*/'<wide-header-page title="{{\'Delete Key\' | translate}}">\n  <div class="container" page-content>\n    <h3 class="assertive" translate>Warning!</h3>\n    <p translate>\n      Permanently delete all wallets using this key.\n    </p>\n    <p translate>\n      THIS ACTION CANNOT BE REVERSED\n    </p>\n    <button ion-button class="button-standard" color="danger" (click)="showDeletePopup()">\n      {{\'Delete\' | translate}}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-delete/key-delete.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], KeyDeletePage);

//# sourceMappingURL=key-delete.js.map

/***/ }),

/***/ 1016:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyQrExportPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(17);




// providers






let KeyQrExportPage = class KeyQrExportPage {
    constructor(profileProvider, logger, navParams, navCtrl, translate, bwcErrorProvider, keyProvider, appProvider, errorsProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.translate = translate;
        this.bwcErrorProvider = bwcErrorProvider;
        this.keyProvider = keyProvider;
        this.appProvider = appProvider;
        this.errorsProvider = errorsProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: KeyQrExportPage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.keysEncrypted = this.walletsGroup.isPrivKeyEncrypted;
        this.appName = this.appProvider.info.nameCase;
    }
    ionViewDidEnter() {
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            const keys = this.keyProvider.get(this.keyId, password);
            this.keysEncrypted = false;
            this.generateQrCode(keys);
        })
            .catch(err => {
            if (err && err.message != 'PASSWORD_CANCELLED') {
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    let title = this.translate.instant('Could not decrypt wallet');
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
                }
            }
            this.navCtrl.pop();
        });
    }
    generateQrCode(keys) {
        if (!keys || !keys.mnemonic) {
            const err = this.translate.instant('Exporting via QR not supported for this wallet');
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(err, title);
            return;
        }
        const mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(this.keyId);
        this.code =
            '1|' + keys.mnemonic + '|null|null|' + mnemonicHasPassphrase + '|null';
        this.logger.debug('QR code generated. mnemonicHasPassphrase: ' + mnemonicHasPassphrase);
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        this.errorsProvider.showDefaultError(err, infoSheetTitle);
    }
};
KeyQrExportPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-key-qr-export',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-qr-export/key-qr-export.html"*/'<wide-header-page title="{{\'Export Key\' | translate}}">\n  <div page-content>\n    <div class="container">\n      <h3 translate>Warning!</h3>\n      <div class="warning-message">\n        <p translate>\n          Your Key is all that is needed to access your funds. Be sure to protect your key and store it only on secure devices. TKCoin does not have access to your keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach.\n        </p>\n        <p>\n          {{ \'You can import this Key into other devices through the {appName} scanner\' | translate: {appName: appName} }}\n        </p>\n      </div>\n      <div *ngIf="!keysEncrypted">\n        <ngx-qrcode *ngIf="code" hide-toast="true" qrc-value="{{code}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n        <span *ngIf="walletsGroup && code">{{ walletsGroup.name }}</span>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-qr-export/key-qr-export.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_errors_errors__["a" /* ErrorsProvider */]])
], KeyQrExportPage);

//# sourceMappingURL=key-qr-export.js.map

/***/ }),

/***/ 1017:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguagePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_language_language__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__ = __webpack_require__(31);




// providers




let LanguagePage = class LanguagePage {
    constructor(navCtrl, languageProvider, externalLinkProvider, profileProvider, walletProvider, translate) {
        this.navCtrl = navCtrl;
        this.languageProvider = languageProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.currentLanguage = this.languageProvider.getCurrent();
        this.languages = this.languageProvider.getAvailables();
    }
    openExternalLink() {
        let url = 'https://crowdin.com/project/copay';
        let optIn = true;
        let title = this.translate.instant('Open Translation Community');
        let message = this.translate.instant('You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!');
        let okText = this.translate.instant('Open Crowdin');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    save(newLang) {
        this.languageProvider.set(newLang);
        this.navCtrl.pop();
        setTimeout(() => {
            const opts = {
                showHidden: true
            };
            let wallets = this.profileProvider.getWallets(opts);
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
};
LanguagePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-language',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/language/language.html"*/'<wide-header-page title="{{\'Language\'|translate}}">\n  <div page-content>\n    <ion-list radio-group [(ngModel)]="currentLanguage" class="settings-list bp-list">\n      <ion-item *ngFor="let language of languages">\n        <ion-label>\n          {{ language.name }}\n        </ion-label>\n        <ion-radio (click)="save(language.isoCode)" [value]="language.isoCode"></ion-radio>\n      </ion-item>\n      <div class="explanation">\n        <div translate>\n          We are always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.\n        </div>\n        <div translate>\n          Don\'t see your language on Crowdin? Contact the Owner on Crowdin! We\'d love to support your language.\n        </div>\n      </div>\n    </ion-list>\n\n    <button ion-button class="button-standard" (click)="openExternalLink()">\n      {{\'Contribute translations\' | translate}}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/language/language.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], LanguagePage);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 1018:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalThemePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers__ = __webpack_require__(27);


// providers

let LocalThemePage = class LocalThemePage {
    constructor(logger, themeProvider, iabCardProvider, platformProvider) {
        this.logger = logger;
        this.themeProvider = themeProvider;
        this.iabCardProvider = iabCardProvider;
        this.platformProvider = platformProvider;
        this.selectedTheme = this.themeProvider.getSelectedTheme();
        this.availableThemes = this.themeProvider.availableThemes;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: LocalThemePage');
        this.themeProvider.getDetectedSystemTheme().then(theme => {
            this.autoDetectedTheme = theme;
        });
    }
    save(theme) {
        this.themeProvider.setActiveTheme(theme, this.autoDetectedTheme);
        if (this.platformProvider.isCordova) {
            this.iabCardProvider.setTheme();
        }
    }
};
LocalThemePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-local-theme',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/local-theme/local-theme.html"*/'<wide-header-page title="{{ \'Themes\' | translate }}">\n  <div page-content>\n    <ion-list radio-group [(ngModel)]="selectedTheme" class="settings-list bp-list">\n      <ion-item *ngFor="let t of availableThemes | keys">\n        <ion-label>\n          {{ t.value.name }}\n        </ion-label>\n        <ion-radio (click)="save(t.key)" [value]="t.key"></ion-radio>\n      </ion-item>\n      <ion-item>\n        <ion-label>\n          {{ \'System Default\' | translate }}\n        </ion-label>\n        <ion-radio (click)="save(\'system\')" [value]="\'system\'"></ion-radio>\n      </ion-item>\n    </ion-list>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/local-theme/local-theme.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["_22" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["_3" /* PlatformProvider */]])
], LocalThemePage);

//# sourceMappingURL=local-theme.js.map

/***/ }),

/***/ 1019:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LockPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pin_pin_modal_pin_modal__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);




// pages

// providers




let LockPage = class LockPage {
    constructor(configProvider, modalCtrl, touchIdProvider, profileProvider, translate) {
        this.configProvider = configProvider;
        this.modalCtrl = modalCtrl;
        this.touchIdProvider = touchIdProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.options = [];
        this.checkLockOptions();
    }
    checkLockOptions() {
        this.lockOptions = this.configProvider.get().lock;
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            let needsBackup = this.needsBackup();
            this.options = [
                {
                    label: this.translate.instant('Disabled'),
                    method: 'disabled',
                    enabled: !this.lockOptions.method ||
                        (this.lockOptions.method &&
                            this.lockOptions.method.toLowerCase() == 'disabled'
                            ? true
                            : false),
                    disabled: false
                },
                {
                    label: this.translate.instant('PIN'),
                    method: 'pin',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'pin'
                        ? true
                        : false,
                    disabled: needsBackup
                },
                {
                    label: this.translate.instant('Biometric'),
                    method: 'fingerprint',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'fingerprint'
                        ? true
                        : false,
                    disabled: !isAvailable || needsBackup
                }
            ];
        });
    }
    select(method) {
        switch (method) {
            case 'disabled':
                this.removeLockMethod();
                break;
            case 'pin':
                this.openPinModal('pinSetUp');
                break;
            case 'fingerprint':
                this.lockByFingerprint();
                break;
        }
    }
    removeLockMethod() {
        let lock = { method: 'disabled', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(() => {
            this.checkLockOptions();
        });
    }
    lockByFingerprint() {
        let lock = { method: 'fingerprint', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    needsBackup() {
        let wallets = this.profileProvider.getWallets();
        let singleLivenetWallet = wallets.length == 1 &&
            wallets[0].network == 'livenet' &&
            wallets[0].needsBackup;
        let atLeastOneLivenetWallet = __WEBPACK_IMPORTED_MODULE_8_lodash__["find"](wallets, w => {
            return w.network == 'livenet' && w.needsBackup;
        });
        if (singleLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Back up your wallet before using this function');
            return true;
        }
        else if (atLeastOneLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Back up all your wallets before using this function');
            return true;
        }
        else {
            this.needsBackupMsg = null;
            return false;
        }
    }
};
LockPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-lock',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/lock/lock.html"*/'<wide-header-page title="{{\'Lock\'|translate}}">\n  <div page-content>\n    <ion-list class="bp-list" radio-group>\n      <ion-item *ngFor="let opt of options">\n        <ion-label>{{opt.label}}</ion-label>\n        <ion-radio (click)="select(opt.method)" value="{{opt.method}}" checked="{{opt.enabled}}" disabled="{{opt.disabled}}"></ion-radio>\n      </ion-item>\n    </ion-list>\n\n    <div *ngIf="needsBackupMsg" class="msg-container" text-wrap>\n      <span class="assertive">{{needsBackupMsg}}</span>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/lock/lock.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], LockPage);

//# sourceMappingURL=lock.js.map

/***/ }),

/***/ 1020:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js
var esm5_forms = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/@ngx-translate/core.es5.js
var core_es5 = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger_logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/app/app.ts
var app = __webpack_require__(23);

// EXTERNAL MODULE: ./src/providers/config/config.ts
var config = __webpack_require__(11);

// EXTERNAL MODULE: ./src/providers/email-notifications/email-notifications.ts
var email_notifications = __webpack_require__(291);

// EXTERNAL MODULE: ./src/providers/external-link/external-link.ts
var external_link = __webpack_require__(21);

// EXTERNAL MODULE: ./src/providers/persistence/persistence.ts + 3 modules
var persistence = __webpack_require__(20);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ./src/providers/push-notifications/push-notifications.ts
var push_notifications = __webpack_require__(143);

// CONCATENATED MODULE: ./src/validators/email.ts
class EmailValidator {
    constructor(cnf, eml) {
        EmailValidator.cnf = cnf;
        EmailValidator.eml = eml;
    }
    isValid(control) {
        let config = EmailValidator.cnf.get();
        let latestEmail = EmailValidator.eml.getEmailIfEnabled(config);
        let validEmail = /^[a-zA-Z0-9.!#$%&*+=?^_{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(control.value);
        if (validEmail && control.value != latestEmail) {
            return null;
        }
        return {
            'Invalid Email': true
        };
    }
}
//# sourceMappingURL=email.js.map
// CONCATENATED MODULE: ./src/pages/settings/notifications/notifications.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return notifications_NotificationsPage; });






// providers







// validators

let notifications_NotificationsPage = class NotificationsPage {
    constructor(navCtrl, formBuilder, configProvider, appProvider, platformProvider, pushProvider, emailProvider, externalLinkProvider, logger, persistenceProvider, translate) {
        this.navCtrl = navCtrl;
        this.formBuilder = formBuilder;
        this.configProvider = configProvider;
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.pushProvider = pushProvider;
        this.emailProvider = emailProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.emailForm = this.formBuilder.group({
            email: [
                '',
                esm5_forms["h" /* Validators */].compose([
                    esm5_forms["h" /* Validators */].required,
                    new EmailValidator(configProvider, emailProvider).isValid
                ])
            ]
        });
        this.isCopay = this.appProvider.info.name == 'copay' ? true : false;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: NotificationsPage');
        this.updateConfig();
    }
    updateConfig() {
        const config = this.configProvider.get();
        this.appName = this.appProvider.info.nameCase;
        this.usePushNotifications = this.platformProvider.isCordova;
        this.isIOSApp =
            this.platformProvider.isIOS && this.platformProvider.isCordova;
        this.isElectron = this.platformProvider.isElectron;
        this.pushNotifications = config.pushNotifications
            ? config.pushNotifications.enabled
            : false;
        this.desktopNotifications = config.desktopNotifications
            ? config.desktopNotifications.enabled
            : false;
        this.confirmedTxsNotifications = config.confirmedTxsNotifications
            ? config.confirmedTxsNotifications.enabled
            : false;
        this.productsUpdates = config.productsUpdates
            ? config.productsUpdates.enabled
            : false;
        this.offersAndPromotions = config.offersAndPromotions
            ? config.offersAndPromotions.enabled
            : false;
        this.emailForm.setValue({
            email: this.emailProvider.getEmailIfEnabled(config) || ''
        });
        this.emailNotifications = config.emailNotifications
            ? config.emailNotifications.enabled
            : false;
    }
    pushNotificationsChange() {
        const opts = {
            pushNotifications: { enabled: this.pushNotifications }
        };
        this.configProvider.set(opts);
        if (opts.pushNotifications.enabled)
            this.pushProvider.init();
        else
            this.pushProvider.disable();
    }
    desktopNotificationChange() {
        const opts = {
            desktopNotifications: { enabled: this.desktopNotifications }
        };
        this.configProvider.set(opts);
    }
    confirmedTxsNotificationsChange() {
        const opts = {
            confirmedTxsNotifications: {
                enabled: this.confirmedTxsNotifications
            }
        };
        this.configProvider.set(opts);
    }
    productsUpdatesChange() {
        const opts = {
            productsUpdates: {
                enabled: this.productsUpdates
            }
        };
        this.configProvider.set(opts);
        this.updateTopic(this.productsUpdates, 'productsupdates');
    }
    offersAndPromotionsChange() {
        const opts = {
            offersAndPromotions: {
                enabled: this.offersAndPromotions
            }
        };
        this.configProvider.set(opts);
        this.updateTopic(this.offersAndPromotions, 'offersandpromotions');
    }
    updateTopic(enabled, topic) {
        if (enabled)
            this.pushProvider.subscribeToTopic(topic);
        else
            this.pushProvider.unsubscribeFromTopic(topic);
    }
    emailNotificationsChange() {
        const opts = {
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        };
        this.emailProvider.updateEmail(opts);
    }
    saveEmail() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.emailProvider.updateEmail({
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        });
        this.navCtrl.pop();
    }
    openPrivacyPolicy() {
        const url = 'https://tkcoin.org/about/privacy';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Privacy Notice');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
notifications_NotificationsPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-notifications',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/notifications/notifications.html"*/'<wide-header-page title="{{\'Notifications\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <div *ngIf="usePushNotifications">\n        <ion-item>\n          <ion-label>{{ \'Enable push notifications\' | translate }}</ion-label>\n          <ion-toggle [(ngModel)]="pushNotifications" (ionChange)="pushNotificationsChange()"></ion-toggle>\n        </ion-item>\n      </div>\n\n      <ion-item-divider *ngIf="!usePushNotifications && isIOSApp">\n        <span translate>\n          Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.\n        </span>\n      </ion-item-divider>\n\n\n      <div *ngIf="isElectron">\n        <ion-item>\n          <ion-label>{{ \'Enable desktop notifications\' | translate }}</ion-label>\n          <ion-toggle [(ngModel)]="desktopNotifications" (ionChange)="desktopNotificationChange()"></ion-toggle>\n        </ion-item>\n      </div>\n\n      <ion-item [ngClass]="{\'with-label\': emailNotifications}" class="no-border">\n        <ion-label>{{ \'Enable email notifications\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="emailNotifications" (ionChange)="emailNotificationsChange()"></ion-toggle>\n      </ion-item>\n\n      <label-tip *ngIf="emailNotifications" type="info" header="no-header">\n        <div label-tip-body translate>\n          By providing your email address, you give explicit consent to TKCoin to use your email address to send you email notifications about payments.\n          <br>\n          <a (click)="openPrivacyPolicy()" translate>View Privacy Notice</a>\n        </div>\n      </label-tip>\n\n      <form *ngIf="emailNotifications" [formGroup]="emailForm">\n        <ion-item>\n          <ion-label stacked>{{ \'Email\' | translate }}</ion-label>\n          <ion-input formControlName="email" type="email"></ion-input>\n        </ion-item>\n        <div text-center>\n          <button ion-button class="button-standard" (click)="saveEmail()" [disabled]="emailForm.invalid">\n            {{\'Save\' | translate}}\n          </button>\n        </div>\n      </form>\n\n      <ion-item-divider *ngIf="usePushNotifications && pushNotifications">\n        {{\'Notifications Preferences\' | translate}}\n      </ion-item-divider>\n\n      <div *ngIf="usePushNotifications && pushNotifications">\n        <ion-item>\n          <ion-label>{{ \'Confirmed transactions\' | translate }}</ion-label>\n          <ion-toggle [(ngModel)]="confirmedTxsNotifications" (ionChange)="confirmedTxsNotificationsChange()"></ion-toggle>\n        </ion-item>\n        <ion-item *ngIf="!isCopay">\n          <ion-label>{{ \'Product updates\' | translate }}</ion-label>\n          <ion-toggle [(ngModel)]="productsUpdates" (ionChange)="productsUpdatesChange()"></ion-toggle>\n        </ion-item>\n        <ion-item *ngIf="!isCopay">\n          <ion-label>{{ \'Offers & promotions\' | translate }}</ion-label>\n          <ion-toggle [(ngModel)]="offersAndPromotions" (ionChange)="offersAndPromotionsChange()"></ion-toggle>\n        </ion-item>\n      </div>\n\n    </ion-list>\n\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/notifications/notifications.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        esm5_forms["a" /* FormBuilder */],
        config["a" /* ConfigProvider */],
        app["a" /* AppProvider */],
        platform["a" /* PlatformProvider */],
        push_notifications["a" /* PushNotificationsProvider */],
        email_notifications["a" /* EmailNotificationsProvider */],
        external_link["a" /* ExternalLinkProvider */],
        logger_logger["a" /* Logger */],
        persistence["b" /* PersistenceProvider */],
        core_es5["f" /* TranslateService */]])
], notifications_NotificationsPage);

//# sourceMappingURL=notifications.js.map

/***/ }),

/***/ 1021:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinIdPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_in_app_browser_in_app_browser__ = __webpack_require__(381);


// providers




let TKCoinIdPage = class TKCoinIdPage {
    constructor(events, logger, navParams, bitPayIdProvider, navCtrl, popupProvider, persistenceProvider, actionSheetProvider, changeDetectorRef, translate, iab) {
        this.events = events;
        this.logger = logger;
        this.navParams = navParams;
        this.bitPayIdProvider = bitPayIdProvider;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.changeDetectorRef = changeDetectorRef;
        this.translate = translate;
        this.iab = iab;
        this.tkcoinIdSettings = this.getDefaultTKCoinIdSettings();
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.userBasicInfo = this.navParams.data;
            this.changeDetectorRef.detectChanges();
            this.network = this.bitPayIdProvider.getEnvironment().network;
            this.tkcoinIdSettings =
                (yield this.persistenceProvider.getTKCoinIdSettings(this.network)) ||
                    this.getDefaultTKCoinIdSettings();
            this.originalBitpayIdSettings = JSON.stringify(this.tkcoinIdSettings);
            this.logger.info('Loaded: TKCoinID page');
        });
    }
    ionViewWillLeave() {
        const settingsChanged = this.originalBitpayIdSettings !== JSON.stringify(this.tkcoinIdSettings);
        if (settingsChanged) {
            this.events.publish('TKCoinId/SettingsChanged');
        }
    }
    getDefaultTKCoinIdSettings() {
        return {
            syncGiftCardPurchases: false
        };
    }
    onSettingsChange() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.persistenceProvider.setTKCoinIdSettings(this.network, this.tkcoinIdSettings);
        });
    }
    disconnectTKCoinID() {
        this.popupProvider
            .ionicConfirm(this.translate.instant('Disconnect TKCoin ID'), this.translate.instant('Are you sure you would like to disconnect your TKCoin ID?'))
            .then(res => {
            if (res) {
                this.bitPayIdProvider.disconnectTKCoinID(() => {
                    const infoSheet = this.actionSheetProvider.createInfoSheet('in-app-notification', {
                        title: 'TKCoin ID',
                        body: this.translate.instant('TKCoin ID successfully disconnected.')
                    });
                    this.iab.refs.card.executeScript({
                        code: `window.postMessage(${JSON.stringify({
                            message: 'bitPayIdDisconnected'
                        })}, '*')`
                    }, () => {
                        infoSheet.present();
                        setTimeout(() => {
                            this.navCtrl.popToRoot();
                        }, 400);
                    });
                    this.events.publish('TKCoinId/Disconnected');
                    this.events.publish('CardAdvertisementUpdate', {
                        status: 'disconnected'
                    });
                }, err => {
                    this.logger.log(err);
                });
            }
        });
    }
};
TKCoinIdPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'tkcoin-id',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/tkcoin-id/tkcoin-id.html"*/'<ion-header>\n  <ion-navbar> <ion-title> {{\'TKCoin ID\' |translate}} </ion-title> </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="tkcoin-id__container">\n    <img\n      src="assets/img/app/icon-flat.svg"\n      class="tkcoin-id__icon"\n      width="40"\n    />\n    <div class="col">\n      <ion-label>{{userBasicInfo?.givenName}} {{userBasicInfo?.familyName}}</ion-label>\n      <ion-label>{{userBasicInfo?.email}}</ion-label>\n    </div>\n  </div>\n  <ion-list class="bp-list tkcoin-id__settings-list">\n    <ion-item>\n      <ion-label>{{\'Sync gift card purchases\' | translate}}</ion-label>\n      <ion-toggle\n        [(ngModel)]="tkcoinIdSettings.syncGiftCardPurchases"\n        (ionChange)="onSettingsChange()"\n      ></ion-toggle>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body>\n        <span translate>If enabled, your gift card purchases will be associated with your TKCoin ID, allowing you to keep track of your gift card purchases even if this device is lost.</span>\n      </div>\n    </label-tip>\n  </ion-list>\n  <button\n    ion-button\n    class="button-standard button-secondary tkcoin-id__disconnect-button"\n    (click)="disconnectTKCoinID()"\n  >\n    {{\'Disconnect\' | translate}}\n  </button>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/tkcoin-id/tkcoin-id.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_19" /* TKCoinIdProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_4" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ChangeDetectorRef"],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_in_app_browser_in_app_browser__["a" /* InAppBrowserProvider */]])
], TKCoinIdPage);

//# sourceMappingURL=tkcoin-id.js.map

/***/ }),

/***/ 1022:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_add__ = __webpack_require__(396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__backup_backup_key_backup_key__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__integrations_coinbase_coinbase_account_coinbase_account__ = __webpack_require__(392);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__settings_settings__ = __webpack_require__(506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__wallet_details_wallet_details__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__proposals_notifications_proposals_notifications__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__ = __webpack_require__(31);





// Pages







// Providers








let WalletsPage = class WalletsPage {
    constructor(plt, navCtrl, profileProvider, walletProvider, bwcErrorProvider, logger, events, homeIntegrationsProvider, persistenceProvider, translate, modalCtrl, actionSheetProvider, coinbaseProvider) {
        this.plt = plt;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.events = events;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.actionSheetProvider = actionSheetProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.coinbaseData = {};
        this.walletFocusHandler = opts => {
            this.logger.debug('RECV Local/WalletFocus @home', opts);
            opts = opts || {};
            opts.alsoUpdateHistory = true;
            this.fetchWalletStatus(opts);
        };
        this.walletActionHandler = opts => {
            this.logger.debug('RECV Local/TxAction @home', opts);
            opts = opts || {};
            opts.alsoUpdateHistory = true;
            this.fetchWalletStatus(opts);
        };
        this.debounceFetchWalletStatus = __WEBPACK_IMPORTED_MODULE_4_lodash__["debounce"]((walletId, alsoUpdateHistory) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.fetchWalletStatus({ walletId, alsoUpdateHistory });
        }), 3000);
        // BWS events can come many at time (publish,sign, broadcast...)
        this.bwsEventHandler = (walletId, type, n) => {
            // NewBlock, NewCopayer, NewAddress, NewTxProposal, TxProposalAcceptedBy, TxProposalRejectedBy, txProposalFinallyRejected,
            // txProposalFinallyAccepted, TxProposalRemoved, NewIncomingTx, NewOutgoingTx
            const wallet = this.profileProvider.getWallet(walletId);
            if (!wallet)
                return;
            if (wallet.copayerId == n.creatorId)
                return;
            this.logger.info(`BWS Event: ${type}: `, n);
            let alsoUpdateHistory = false;
            switch (type) {
                case 'NewAddress':
                    this.walletProvider.expireAddress(walletId);
                    return;
                case 'NewIncomingTx':
                case 'NewOutgoingTx':
                case 'NewBlock':
                    alsoUpdateHistory = true;
            }
            this.walletProvider.invalidateCache(wallet);
            this.debounceFetchWalletStatus(walletId, alsoUpdateHistory);
        };
        this.debounceSetWallets = __WEBPACK_IMPORTED_MODULE_4_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.profileProvider.setOrderedWalletsByGroup();
            this.walletsGroups = this.profileProvider.orderedWalletsByGroup;
        }), 5000, {
            leading: true
        });
        this.debounceSetCoinbase = __WEBPACK_IMPORTED_MODULE_4_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.coinbaseProvider.updateExchangeRates();
            this.setCoinbase(true);
        }), 5000, {
            leading: true
        });
        // Names:
        // .fetch => from BWS
        // .update => to UI
        /* This is the only .getStatus call in Copay */
        this.fetchWalletStatus = (opts) => {
            if (!opts.walletId) {
                this.logger.error('Error no walletId in update Wallet');
                return;
            }
            this.events.publish('Local/WalletUpdate', {
                walletId: opts.walletId,
                finished: false
            });
            this.logger.debug('fetching status for: ' +
                opts.walletId +
                ' alsohistory:' +
                opts.alsoUpdateHistory);
            const wallet = this.profileProvider.getWallet(opts.walletId);
            if (!wallet)
                return;
            this.walletProvider
                .fetchStatus(wallet, opts)
                .then(status => {
                wallet.cachedStatus = status;
                wallet.error = wallet.errorObj = null;
                const balance = wallet.coin === 'xrp'
                    ? wallet.cachedStatus.availableBalanceStr
                    : wallet.cachedStatus.totalBalanceStr;
                this.persistenceProvider.setLastKnownBalance(wallet.id, balance);
                // Update txps
                this.updateTxps();
                this.events.publish('Local/WalletUpdate', {
                    walletId: opts.walletId,
                    finished: true
                });
                if (opts.alsoUpdateHistory) {
                    this.fetchTxHistory({ walletId: opts.walletId, force: opts.force });
                }
            })
                .catch(err => {
                if (err == 'INPROGRESS')
                    return;
                this.logger.warn('Update error:', err);
                this.processWalletError(wallet, err);
                this.events.publish('Local/WalletUpdate', {
                    walletId: opts.walletId,
                    finished: true,
                    error: wallet.error
                });
                if (opts.alsoUpdateHistory) {
                    this.fetchTxHistory({ walletId: opts.walletId, force: opts.force });
                }
            });
        };
        this.collapsedGroups = {};
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
    }
    ionViewDidEnter() {
        this._didEnter();
    }
    ionViewWillEnter() {
        this.walletsGroups = this.profileProvider.orderedWalletsByGroup;
        // Get Coinbase Accounts and UserInfo
        this.setCoinbase();
    }
    setCoinbase(force) {
        this.showCoinbase = this.homeIntegrationsProvider.shouldShowInHome('coinbase');
        if (!this.showCoinbase)
            return;
        this.coinbaseLinked = this.coinbaseProvider.isLinked();
        if (this.coinbaseLinked) {
            if (force || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseData)) {
                this.zone.run(() => {
                    this.coinbaseProvider.preFetchAllData(this.coinbaseData);
                });
            }
            else
                this.coinbaseData = this.coinbaseProvider.coinbaseData;
        }
    }
    _didEnter() {
        this.updateTxps();
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletsPage');
        const subscribeEvents = () => {
            // BWS Events: Update Status per Wallet -> Update txps
            // NewBlock, NewCopayer, NewAddress, NewTxProposal, TxProposalAcceptedBy, TxProposalRejectedBy, txProposalFinallyRejected,
            // txProposalFinallyAccepted, TxProposalRemoved, NewIncomingTx, NewOutgoingTx
            this.events.subscribe('bwsEvent', this.bwsEventHandler);
            // Reject, Remove, OnlyPublish and SignAndBroadcast -> Update Status per Wallet -> Update txps
            this.events.subscribe('Local/TxAction', this.walletActionHandler);
            // Wallet is focused on some inner view, therefore, we refresh its status and txs
            this.events.subscribe('Local/WalletFocus', this.walletFocusHandler);
        };
        subscribeEvents();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            subscribeEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
            this.events.unsubscribe('Local/TxAction', this.walletFocusHandler);
            this.events.unsubscribe('Local/WalletFocus', this.walletFocusHandler);
        });
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    fetchTxHistory(opts) {
        if (!opts.walletId) {
            this.logger.error('Error no walletId in update History');
            return;
        }
        const wallet = this.profileProvider.getWallet(opts.walletId);
        const progressFn = ((_, newTxs) => {
            let args = {
                walletId: opts.walletId,
                finished: false,
                progress: newTxs
            };
            this.events.publish('Local/WalletHistoryUpdate', args);
        }).bind(this);
        // Fire a startup event, to allow UI to show the spinner
        this.events.publish('Local/WalletHistoryUpdate', {
            walletId: opts.walletId,
            finished: false
        });
        this.walletProvider
            .fetchTxHistory(wallet, progressFn, opts)
            .then(txHistory => {
            wallet.completeHistory = txHistory;
            this.events.publish('Local/WalletHistoryUpdate', {
                walletId: opts.walletId,
                finished: true
            });
        })
            .catch(err => {
            if (err != 'HISTORY_IN_PROGRESS') {
                this.logger.warn('WalletHistoryUpdate ERROR', err);
                this.events.publish('Local/WalletHistoryUpdate', {
                    walletId: opts.walletId,
                    finished: false,
                    error: err
                });
            }
        });
    }
    updateTxps() {
        this.profileProvider
            .getTxps({ limit: 3 })
            .then(data => {
            this.events.publish('Local/UpdateTxps', {
                n: data.n
            });
            this.zone.run(() => {
                this.txpsN = data.n;
            });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    processWalletError(wallet, err) {
        wallet.error = wallet.errorObj = null;
        if (!err || err == 'INPROGRESS')
            return;
        wallet.cachedStatus = null;
        wallet.errorObj = err;
        if (err.message === '403') {
            wallet.error = this.translate.instant('Access denied');
        }
        else if (err === 'WALLET_NOT_REGISTERED') {
            wallet.error = this.translate.instant('Wallet not registered');
        }
        else {
            wallet.error = this.bwcErrorProvider.msg(err);
        }
        this.logger.warn(this.bwcErrorProvider.msg(wallet.error, 'Error updating status for ' + wallet.id));
    }
    goToWalletDetails(wallet) {
        if (wallet.isComplete()) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                walletId: wallet.credentials.walletId
            });
        }
        else {
            const copayerModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__["a" /* CopayersPage */], {
                walletId: wallet.credentials.walletId
            }, {
                cssClass: 'wallet-details-modal'
            });
            copayerModal.present();
        }
    }
    openProposalsNotificationsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__proposals_notifications_proposals_notifications__["a" /* ProposalsNotificationsPage */]);
    }
    doRefresh(refresher) {
        this.debounceSetWallets();
        this.debounceSetCoinbase();
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
    settings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__settings_settings__["a" /* SettingsPage */]);
    }
    collapseGroup(keyId) {
        this.collapsedGroups[keyId] = this.collapsedGroups[keyId] ? false : true;
    }
    isCollapsed(keyId) {
        return this.collapsedGroups[keyId] ? true : false;
    }
    addWallet(keyId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_add__["a" /* AddPage */], {
            keyId
        });
    }
    openBackupPage(keyId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId
        });
    }
    showMoreOptions() {
        const walletTabOptionsAction = this.actionSheetProvider.createWalletTabOptions({ walletsGroups: this.walletsGroups });
        walletTabOptionsAction.present();
        walletTabOptionsAction.onDidDismiss(data => {
            if (data)
                data.keyId
                    ? this.addWallet(data.keyId)
                    : this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_add__["a" /* AddPage */], {
                        isZeroState: true
                    });
        });
    }
    getNativeBalance(amount, currency) {
        return this.coinbaseProvider.getNativeCurrencyBalance(amount, currency);
    }
    goToCoinbaseAccount(id) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__integrations_coinbase_coinbase_account_coinbase_account__["a" /* CoinbaseAccountPage */], {
            id
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('priceCard'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], WalletsPage.prototype, "priceCard", void 0);
WalletsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallets',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallets/wallets.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Wallets\' | translate }}\n      </div>\n    </ion-title>\n    <ion-buttons right class="settings-button" *ngIf="walletsGroups && walletsGroups[0]">\n      <button class="option-button disable-hover" (click)="showMoreOptions()" ion-button icon-only>\n        <ion-icon name="ios-more" md="ios-more"></ion-icon>\n      </button>\n      <button ion-button clear icon-only color="grey" *ngIf="txpsN > 0" (click)="openProposalsNotificationsPage()">\n        <ion-badge class="notifications-badge">{{ txpsN }}</ion-badge>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          {{ \'Wallets\' | translate }}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <create-new-wallet *ngIf="!walletsGroups || !walletsGroups[0]"></create-new-wallet>\n\n    <div *ngFor="let walletGroup of walletsGroups; let i = index" class="wallets-container">\n      <div class="section-header" *ngIf="walletGroup[0].canSign && walletsGroups.length > 1">\n        <ion-icon class="item-img" item-start>\n          <img src="assets/img/settings-icons/icon-key.svg" width="15" />\n        </ion-icon>\n        <ion-label class="key-name">\n          <span>{{ profileProvider.getWalletGroup(walletGroup[0].keyId).name }}</span>\n        </ion-label>\n        <div class="collapse">\n          <div *ngIf="!walletGroup[0].canAddNewAccount" class="legacy-tag">Legacy</div>\n          <div *ngIf="walletGroup[0].canAddNewAccount" (click)="addWallet(walletGroup[0].keyId)">\n            <ion-icon class="item-img">\n              <img src="assets/img/plus-gray.svg" width="15" />\n            </ion-icon>\n          </div>\n          <div class="collapse-btn" *ngIf="walletsGroups.length > 1" (click)="collapseGroup(walletGroup[0].keyId)">\n            <ion-icon *ngIf="!isCollapsed(walletGroup[0].keyId)" name="ios-arrow-down"></ion-icon>\n            <ion-icon *ngIf="isCollapsed(walletGroup[0].keyId)" name="ios-arrow-up"></ion-icon>\n          </div>\n        </div>\n      </div>\n      <div class="section-header" *ngIf="walletGroup[0].keyId == \'read-only\'">\n        <ion-icon class="item-img" item-start>\n          <img src="assets/img/settings-icons/icon-read-only.svg" width="20" />\n        </ion-icon>\n        <ion-label class="key-name">\n          <span translate>Read Only Wallets</span>\n        </ion-label>\n      </div>\n      <ion-list no-lines class="bp-list" [ngClass]="{ collapsed: isCollapsed(walletGroup[0].keyId) }">\n        <wallet-item-content *ngFor="let wallet of walletGroup" [wallet]="wallet" (click)="goToWalletDetails(wallet)"></wallet-item-content>\n      </ion-list>\n      <label-tip type="warn" *ngIf="walletGroup && walletGroup[0] && walletGroup[0].needsBackup" header="no-header" margin-top>\n        <div label-tip-body>\n          <span translate>Before retrieving your wallets addresses, it\'s recommended that you first write down your recovery phrase and store it securely so that your wallets can be recovered in the case your device was lost or stolen.</span>\n          <br>\n          <a class="label-tip-link" (click)="openBackupPage(walletGroup[0].keyId)" translate>Backup now</a>\n        </div>\n      </label-tip>\n    </div>\n\n    <div *ngIf="showCoinbase && coinbaseLinked">\n      <div class="section-header">\n        <ion-icon class="item-img" item-start>\n          <img src="assets/img/coinbase/coinbase-icon.png" width="20" />\n        </ion-icon>\n        <ion-label class="key-name">\n          <span *ngIf="!coinbaseData?.user">...</span>\n          <span *ngIf="coinbaseData?.user">{{ coinbaseData.user.name }}\'s Coinbase Account</span>\n        </ion-label>\n        <div class="collapse">\n          <div class="collapse-btn" *ngIf="coinbaseData?.accounts.length > 1" (click)="collapsedAccounts = !collapsedAccounts">\n            <ion-icon *ngIf="!collapsedAccounts" name="ios-arrow-down"></ion-icon>\n            <ion-icon *ngIf="collapsedAccounts" name="ios-arrow-up"></ion-icon>\n          </div>\n        </div>\n      </div>\n      <div *ngIf="!coinbaseData?.accounts" translate>Loading accounts...</div>\n      <div *ngFor="let ac of coinbaseData?.accounts">\n        <ion-list no-lines class="bp-list" [hidden]="collapsedAccounts">\n          <button ion-item detail-none (click)="goToCoinbaseAccount(ac.id)">\n            <coin-icon [coin]="ac.currency.code.toLowerCase()" [network]="livenet" item-left></coin-icon>\n            <ion-label>\n              {{ac.name}}\n            </ion-label>\n            <ion-note item-end>\n              <div class="main-note">{{ac.balance.amount | number:\'1.2-8\'}}</div>\n              <div class="secondary-note" *ngIf="getNativeBalance(ac.balance.amount, ac.balance.currency)">\n                {{ getNativeBalance(ac.balance.amount, ac.balance.currency) | currency:\' \':\' \' }} {{ coinbaseData.user.native_currency }}\n              </div>\n            </ion-note>\n          </button>\n        </ion-list>\n      </div>\n    </div>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallets/wallets.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_15__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_12__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_coinbase_coinbase__["a" /* CoinbaseProvider */]])
], WalletsPage);

//# sourceMappingURL=wallets.js.map

/***/ }),

/***/ 1023:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExchangeCheckoutPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__integrations_changelly_changelly__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__integrations_changelly_changelly_terms_changelly_terms__ = __webpack_require__(1024);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_changelly_changelly__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_exchange_crypto_exchange_crypto__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__ = __webpack_require__(31);






// Pages



// Providers














let ExchangeCheckoutPage = class ExchangeCheckoutPage {
    constructor(actionSheetProvider, analyticsProvider, logger, navParams, modalCtrl, changellyProvider, navCtrl, platformProvider, profileProvider, translate, configProvider, currencyProvider, rateProvider, exchangeCryptoProvider, walletProvider, bwcErrorProvider, bwcProvider, onGoingProcessProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.analyticsProvider = analyticsProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.modalCtrl = modalCtrl;
        this.changellyProvider = changellyProvider;
        this.navCtrl = navCtrl;
        this.platformProvider = platformProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.rateProvider = rateProvider;
        this.exchangeCryptoProvider = exchangeCryptoProvider;
        this.walletProvider = walletProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.onGoingProcessProvider.set(this.translate.instant('Getting data from the exchange...'));
        this.isCordova = this.platformProvider.isCordova;
        this.fromWalletSelected = this.profileProvider.getWallet(this.navParams.data.fromWalletSelectedId);
        this.toWalletSelected = this.profileProvider.getWallet(this.navParams.data.toWalletSelectedId);
        this.useSendMax = this.navParams.data.useSendMax;
        this.sendMaxInfo = this.navParams.data.sendMaxInfo;
        this.amountFrom = this.navParams.data.amountFrom;
        this.fixedRateId = this.navParams.data.fixedRateId;
        this.rate = this.navParams.data.rate;
        this.alternativeIsoCode =
            this.configProvider.get().wallet.settings.alternativeIsoCode || 'USD';
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.termsAccepted = false;
        this.createFixTransaction();
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ExchangeCheckoutPage');
        this.navCtrl.swipeBackEnabled = false;
    }
    createFixTransaction() {
        this.walletProvider
            .getAddress(this.toWalletSelected, false)
            .then((addressTo) => {
            this.addressTo = addressTo;
            this.walletProvider
                .getAddress(this.fromWalletSelected, false)
                .then((refundAddress) => {
                if (this.fromWalletSelected.coin == 'bch') {
                    this.addressFrom = this.walletProvider.getProtoAddress(this.fromWalletSelected.coin, this.fromWalletSelected.network, refundAddress);
                }
                else {
                    this.addressFrom = refundAddress;
                }
                const data = {
                    amountFrom: this.amountFrom,
                    coinFrom: this.fromWalletSelected.coin,
                    coinTo: this.toWalletSelected.coin,
                    addressTo: this.addressTo,
                    refundAddress: this.addressFrom,
                    fixedRateId: this.fixedRateId
                };
                this.changellyProvider
                    .createFixTransaction(this.fromWalletSelected, data)
                    .then(data => {
                    if (data.error) {
                        this.logger.error('Changelly createFixTransaction Error: ' +
                            data.error.message);
                        if (Math.abs(data.error.code) == 32602 ||
                            Math.abs(data.error.code) == 32603) {
                            this.logger.debug('Changelly rateId was expired or already used. Generating a new one');
                            this.updateReceivingAmount();
                        }
                        else {
                            this.showErrorAndBack(null, data.error.message);
                        }
                        return;
                    }
                    if (Number(data.result.changellyFee) > 0 ||
                        Number(data.result.apiExtraFee > 0)) {
                        // changellyFee and apiExtraFee (Bitpay fee) are in percents
                        const receivingPercentage = 100 -
                            Number(data.result.changellyFee) -
                            Number(data.result.apiExtraFee);
                        this.exchangeFee =
                            (Number(data.result.changellyFee) * data.result.amountTo) /
                                receivingPercentage;
                        this.tkcoinFee =
                            (Number(data.result.apiExtraFee) * data.result.amountTo) /
                                receivingPercentage;
                        this.totalExchangeFee = this.exchangeFee + this.tkcoinFee;
                        this.logger.debug(`Changelly fee: ${this.exchangeFee} - TKCoin fee: ${this.tkcoinFee} - Total fee: ${this.totalExchangeFee}`);
                    }
                    if (this.fromWalletSelected.coin == 'bch') {
                        this.payinAddress = this.bitcoreCash
                            .Address(data.result.payinAddress)
                            .toString(true);
                    }
                    else {
                        this.payinAddress = data.result.payinAddress;
                    }
                    this.payinExtraId = data.result.payinExtraId; // (destinationTag) Used for coins like: XRP, XLM, EOS, IGNIS, BNB, XMR, ARDOR, DCT, XEM
                    this.exchangeTxId = data.result.id;
                    this.amountFrom = data.result.amountExpectedFrom;
                    this.amountTo = data.result.amountTo;
                    this.status = data.result.status;
                    this.fiatAmountTo = this.rateProvider.toFiat(Number(this.amountTo) *
                        this.currencyProvider.getPrecision(this.toWalletSelected.coin).unitToSatoshi, this.alternativeIsoCode, this.toWalletSelected.coin);
                    this.paymentTimeControl(data.result.payTill);
                    // To Sat
                    const depositSat = Number((this.amountFrom *
                        this.currencyProvider.getPrecision(this.fromWalletSelected.coin).unitToSatoshi).toFixed(0));
                    this.onGoingProcessProvider.set('creatingTx');
                    this.createTx(this.fromWalletSelected, this.payinAddress, depositSat, this.payinExtraId)
                        .then(ctxp => {
                        this.onGoingProcessProvider.clear();
                        this.ctxp = ctxp;
                        this.fee = this.ctxp.fee;
                        if (this.useSendMax) {
                            this.showWarningSheet();
                        }
                        return;
                    })
                        .catch(err => {
                        this.showErrorAndBack(err.title, err.message);
                        return;
                    });
                })
                    .catch(err => {
                    this.logger.error('Changelly createFixTransaction Error: ', err);
                    this.showErrorAndBack(null, this.translate.instant('Changelly is not available at this moment. Please, try again later.'));
                    return;
                });
            })
                .catch(err => {
                this.logger.error('Could not get returnAddress address', err);
                this.showErrorAndBack(null, this.translate.instant('There was a problem retrieving the returnAddress. Please, try again later.'));
                return;
            });
        })
            .catch(err => {
            this.logger.error('Could not get withdrawalAddress address', err);
            this.showErrorAndBack(null, this.translate.instant('There was a problem retrieving the withdrawalAddress. Please, try again later.'));
            return;
        });
    }
    updateReceivingAmount() {
        if (!this.fromWalletSelected || !this.toWalletSelected || !this.amountFrom)
            return;
        const data = {
            amountFrom: this.amountFrom,
            coinFrom: this.fromWalletSelected.coin,
            coinTo: this.toWalletSelected.coin
        };
        this.changellyProvider
            .getFixRateForAmount(this.fromWalletSelected, data)
            .then(data => {
            if (data.error) {
                const msg = 'Changelly getFixRateForAmount Error: ' + data.error.message;
                this.showErrorAndBack(null, msg);
                return;
            }
            this.fixedRateId = data.result[0].id;
            this.amountTo = Number(data.result[0].amountTo);
            this.rate = Number(data.result[0].result); // result == rate
            this.createFixTransaction();
        })
            .catch(err => {
            this.logger.error(err);
            let msg = this.translate.instant('Changelly is not available at this moment. Please, try again later.');
            this.showErrorAndBack(null, msg);
        });
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        const countDown = setInterval(() => {
            this.setExpirationTime(expirationTime, countDown);
        }, 1000);
    }
    setExpirationTime(expirationTime, countDown) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (countDown) {
                /* later */
                clearInterval(countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    createTx(wallet, payinAddress, depositSat, destTag) {
        return new Promise((resolve, reject) => {
            this.message =
                this.fromWalletSelected.coin.toUpperCase() +
                    ' to ' +
                    this.toWalletSelected.coin.toUpperCase();
            let outputs = [];
            outputs.push({
                toAddress: payinAddress,
                amount: depositSat,
                message: this.message
            });
            let txp = {
                toAddress: payinAddress,
                amount: depositSat,
                outputs,
                message: this.message,
                excludeUnconfirmedUtxos: true,
                customData: {
                    changelly: payinAddress,
                    service: 'changelly'
                }
            };
            if (this.currencyProvider.isERCToken(wallet.coin)) {
                let tokenAddress;
                let tokens = this.currencyProvider.getAvailableTokens();
                const token = tokens.find(x => x.symbol == wallet.coin.toUpperCase());
                tokenAddress = token.address;
                if (tokenAddress) {
                    txp.tokenAddress = tokenAddress;
                    for (const output of txp.outputs) {
                        if (!output.data) {
                            output.data = this.bwcProvider
                                .getCore()
                                .Transactions.get({ chain: 'ERC20' })
                                .encodeData({
                                recipients: [
                                    { address: output.toAddress, amount: output.amount }
                                ],
                                tokenAddress
                            });
                        }
                    }
                }
            }
            if (this.useSendMax && this.sendMaxInfo) {
                txp.inputs = this.sendMaxInfo.inputs;
                txp.fee = this.sendMaxInfo.fee;
            }
            else {
                if (wallet.coin == 'btc' || wallet.coin == 'edu' || wallet.coin == 'tik' || this.getChain(wallet.coin) == 'eth')
                    txp.feeLevel = 'priority'; // Avoid expired order due to slow TX confirmation
            }
            if (destTag)
                txp.destinationTag = destTag;
            this.walletProvider
                .createTx(wallet, txp)
                .then(ctxp => {
                return resolve(ctxp);
            })
                .catch(err => {
                return reject({
                    title: this.translate.instant('Could not create transaction'),
                    message: this.bwcErrorProvider.msg(err)
                });
            });
        });
    }
    showWarningSheet() {
        if (!this.sendMaxInfo || !this.ctxp)
            return;
        let msg, infoSheetType;
        if (this.useSendMax) {
            const warningMsg = this.exchangeCryptoProvider.verifyExcludedUtxos(this.ctxp.coin, this.sendMaxInfo);
            msg = !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](warningMsg) ? warningMsg : '';
            infoSheetType = 'miner-fee-notice';
        }
        const coinName = this.currencyProvider.getCoinName(this.fromWalletSelected.coin);
        const { unitToSatoshi } = this.currencyProvider.getPrecision(this.ctxp.coin);
        const fee = this.sendMaxInfo.fee / unitToSatoshi;
        const minerFeeNoticeInfoSheet = this.actionSheetProvider.createInfoSheet(infoSheetType, {
            coinName,
            fee,
            coin: this.ctxp.coin.toUpperCase(),
            msg
        });
        minerFeeNoticeInfoSheet.present();
    }
    getChain(coin) {
        return this.currencyProvider.getChain(coin).toLowerCase();
    }
    makePayment() {
        this.onGoingProcessProvider.set('broadcastingTx');
        this.publishAndSign(this.fromWalletSelected, this.ctxp)
            .then(_txSent => {
            this.onGoingProcessProvider.clear();
            this.saveChangellyData();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(this.bwcErrorProvider.msg(err));
            this.showErrorAndBack(null, this.translate.instant('Could not send transaction'));
            return;
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    saveChangellyData() {
        const now = __WEBPACK_IMPORTED_MODULE_5_moment__().unix() * 1000;
        let newData = {
            exchangeTxId: this.exchangeTxId,
            date: now,
            amountTo: this.amountTo,
            coinTo: this.toWalletSelected.coin,
            addressTo: this.addressTo,
            amountFrom: this.amountFrom,
            coinFrom: this.fromWalletSelected.coin,
            refundAddress: this.addressFrom || null,
            payinAddress: this.payinAddress,
            payinExtraId: this.payinExtraId || null,
            totalExchangeFee: this.totalExchangeFee,
            status: this.status,
            error: null
        };
        this.changellyProvider.saveChangelly(newData, null).then(() => {
            this.logger.debug('Saved exchange with status: ' + (newData.status || newData.error));
            this.analyticsProvider.logEvent('exchange_crypto_payment_sent', {
                userId: this.fromWalletSelected.id,
                coinFrom: this.fromWalletSelected.coin,
                coinTo: this.toWalletSelected.coin
            });
            this.openFinishModal();
        });
    }
    openFinishModal() {
        let finishText = 'Transaction Sent';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText, coin: this.fromWalletSelected.coin }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__integrations_changelly_changelly__["a" /* ChangellyPage */], null, { animate: false });
        }));
    }
    openTermsModal() {
        this.logger.debug('Changelly Terms modal opened');
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_8__integrations_changelly_changelly_terms_changelly_terms__["a" /* ChangellyTermsPage */], null, {
            showBackdrop: true,
            enableBackdropDismiss: false
        });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.debug('Changelly Terms modal closed');
        }));
    }
    showErrorAndBack(title, msg, noExit) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.error && msg.error.message ? msg.error.message : msg;
        const errorActionSheet = this.actionSheetProvider.createInfoSheet('default-error', {
            msg,
            title
        });
        errorActionSheet.present();
        errorActionSheet.onDidDismiss(_option => {
            if (!noExit) {
                this.onGoingProcessProvider.clear();
                this.navCtrl.pop();
            }
        });
    }
    canContinue() {
        return this.termsAccepted && this.exchangeTxId && !this.paymentExpired;
    }
    cancelExchange() {
        this.navCtrl.popToRoot();
    }
};
ExchangeCheckoutPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-exchange-checkout',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-checkout/exchange-checkout.html"*/'<wide-header-page title="{{\'Exchange Crypto\' | translate}}" hideBackButton="true" [hasSlideButton]="isCordova">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="cancelExchange()" ion-button>\n      <span translate>Cancel</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-spinner name="crescent" *ngIf="loading"></ion-spinner>\n\n    <ion-list class="bp-list" *ngIf="!loading">\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label">SUMMARY</div>\n        </ion-label>\n      </ion-item>\n\n      <ion-item ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Receiving</span>\n          </div>\n        </ion-label>\n\n        <ion-note item-end text-left>\n          <ion-row align-items-center class="wallet" *ngIf="toWalletSelected">\n            <ion-col>\n              <coin-icon [coin]="toWalletSelected.coin" [network]="toWalletSelected.network"></coin-icon>\n            </ion-col>\n            <ion-col>\n              <span class="note-container ellipsis">{{toWalletSelected.name}}</span>\n            </ion-col>\n          </ion-row>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Selling</span>\n          </div>\n        </ion-label>\n\n        <ion-note item-end text-left>\n          <ion-row align-items-center class="wallet" *ngIf="fromWalletSelected">\n            <ion-col>\n              <coin-icon [coin]="fromWalletSelected.coin" [network]="fromWalletSelected.network"></coin-icon>\n            </ion-col>\n            <ion-col>\n              <span class="note-container ellipsis">{{fromWalletSelected.name}}</span>\n            </ion-col>\n          </ion-row>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span>{{"Paying" | translate}}</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            <span>\n              {{ amountFrom | number:\'1.0-6\'}} {{ fromWalletSelected.coin | uppercase }}\n            </span>\n          </div>\n        </ion-note>\n      </ion-item>\n      <div *ngIf="useSendMax" class="amount-details send-max-note">\n        <div class="secondary-note">\n          <span translate>\n            Sending maximum amount\n          </span>\n        </div>\n      </div>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span>{{"Miner Fee" | translate}}</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            <span>\n              {{ fee | satToUnit: getChain(fromWalletSelected.coin) }}\n            </span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span>{{"Exchange Fee" | translate}}</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            <span>\n              {{ totalExchangeFee | number:\'1.0-6\'}} {{ toWalletSelected.coin | uppercase }}\n            </span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span>{{"Expires" | translate}}</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            <span *ngIf="!paymentExpired">{{remainingTimeStr}}</span>\n            <span *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}">{{\'Expired\' | translate}}</span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="summary-line"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="main-label total-label">{{\'TOTAL TO RECEIVE\' | translate}}</div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="total-amount">\n            <span>{{ amountTo }} {{ toWalletSelected.coin | uppercase }}</span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="amount-details">\n        <div class="secondary-note">\n          <span>\n            ~{{ fiatAmountTo | number : \'1.2-2\' }} {{ alternativeIsoCode }}\n          </span>\n        </div>\n      </div>\n\n      <ion-item>\n        <ion-label class="terms-checkbox">\n          <span translate>Exchange services provided by Changelly. By clicking Accept, I acknowledge and understand that my transaction may trigger AML/KYC verification according to Changelly AML/KYC</span>\n        </ion-label>\n        <ion-checkbox class="check" [(ngModel)]="termsAccepted"></ion-checkbox>\n      </ion-item>\n      <ion-item (click)="openTermsModal()">\n        <ion-label class="terms">\n          <span translate>Review Changelly policies</span>\n        </ion-label>\n        <ion-note item-end>\n          <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n  </div>\n  <div footer-content>\n    <page-slide-to-accept #slideButton *ngIf="isCordova && canContinue()" [disabled]="!canContinue()" buttonText="{{\'Slide to Make Payment\' | translate}}" [isDogecoin]="fromWalletSelected && fromWalletSelected.coin == \'doge\'"  (slideDone)="makePayment()">\n    </page-slide-to-accept>\n    <ion-toolbar *ngIf="!isCordova">\n      <button ion-button full class="button-footer" (click)="makePayment()" [disabled]="!canContinue()">{{\'Continue & Make Payment\' | translate}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-checkout/exchange-checkout.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_changelly_changelly__["a" /* ChangellyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_19__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_14__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_exchange_crypto_exchange_crypto__["a" /* ExchangeCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], ExchangeCheckoutPage);

//# sourceMappingURL=exchange-checkout.js.map

/***/ }),

/***/ 1024:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChangellyTermsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_theme_theme__ = __webpack_require__(56);



// Proviers



let ChangellyTermsPage = class ChangellyTermsPage {
    constructor(logger, externalLinkProvider, viewCtrl, themeProvider) {
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.viewCtrl = viewCtrl;
        this.themeProvider = themeProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ChangellyTermsPage');
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
ChangellyTermsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-changelly-terms',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly-terms/changelly-terms.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">\n      {{\'Changelly Policies\' | translate}}\n    </ion-title>\n    <ion-buttons right>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content text-center class="add-bottom-safe-area" no-bounce>\n  <ion-list class="bp-list">\n    <ion-item (click)="openExternalLink(\'https://changelly.com/privacy-policy\')">\n      <ion-label translate>{{ \'Privacy Policy\' | translate}}</ion-label>\n      <ion-note item-end>\n        <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n      </ion-note>\n    </ion-item>\n    <ion-item (click)="openExternalLink(\'https://changelly.com/terms-of-use\')">\n      <ion-label>{{ \'Terms of Use\' | translate}}</ion-label>\n      <ion-note item-end>\n        <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n      </ion-note>\n    </ion-item>\n    <ion-item (click)="openExternalLink(\'https://changelly.com/aml-kyc\')">\n      <ion-label>{{ \'AML/KYC Policy\' | translate}}</ion-label>\n      <ion-note item-end>\n        <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <div class="bottom-absolute">\n    <div class="partner">\n      <span>{{\'Powered by\' | translate}}</span>\n      <img src="assets/img/exchange-crypto/changelly-vector-logo{{themeProvider.isDarkModeEnabled() ? \'-dark\' : \'\'}}.svg" width="120">\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly-terms/changelly-terms.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_theme_theme__["a" /* ThemeProvider */]])
], ChangellyTermsPage);

//# sourceMappingURL=changelly-terms.js.map

/***/ }),

/***/ 1025:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_clipboard_clipboard__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_incoming_data_incoming_data__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__add_copayers_copayers__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__add_import_wallet_import_wallet__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__add_join_wallet_join_wallet__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__integrations_coinbase_coinbase__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__integrations_invoice_select_invoice_select_invoice__ = __webpack_require__(518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__integrations_simplex_simplex__ = __webpack_require__(397);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__integrations_tkcoin_card_tkcoin_card_intro_tkcoin_card_intro__ = __webpack_require__(400);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__paper_wallet_paper_wallet__ = __webpack_require__(519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__send_confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__send_select_inputs_select_inputs__ = __webpack_require__(1026);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__settings_addressbook_add_add__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__wallet_details_wallet_details__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__multi_send_multi_send__ = __webpack_require__(1027);






// Providers











// Pages















let SendPage = class SendPage {
    constructor(currencyProvider, navCtrl, navParams, payproProvider, logger, incomingDataProvider, addressProvider, events, actionSheetProvider, appProvider, translate, errorsProvider, onGoingProcessProvider, bwcErrorProvider, plt, clipboardProvider) {
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.payproProvider = payproProvider;
        this.logger = logger;
        this.incomingDataProvider = incomingDataProvider;
        this.addressProvider = addressProvider;
        this.events = events;
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.errorsProvider = errorsProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.plt = plt;
        this.clipboardProvider = clipboardProvider;
        this.search = '';
        this.validDataTypeMap = [
            'BitcoinAddress',
            'EducoinAddress',
            'TKCoinAddress',
            'BitcoinCashAddress',
            'EthereumAddress',
            'EthereumUri',
            'RippleAddress',
            'DogecoinAddress',
            'RippleUri',
            'BitcoinUri',
            'EducoinUri',
            'TKCoinUri',
            'BitcoinCashUri',
            'DogecoinUri',
            'TKCoinUri'
        ];
        this.pageMap = {
            AddressbookAddPage: __WEBPACK_IMPORTED_MODULE_29__settings_addressbook_add_add__["a" /* AddressbookAddPage */],
            AmountPage: __WEBPACK_IMPORTED_MODULE_26__send_amount_amount__["a" /* AmountPage */],
            TKCoinCardIntroPage: __WEBPACK_IMPORTED_MODULE_23__integrations_tkcoin_card_tkcoin_card_intro_tkcoin_card_intro__["a" /* TKCoinCardIntroPage */],
            CoinbasePage: __WEBPACK_IMPORTED_MODULE_20__integrations_coinbase_coinbase__["a" /* CoinbasePage */],
            ConfirmPage: __WEBPACK_IMPORTED_MODULE_27__send_confirm_confirm__["a" /* ConfirmPage */],
            CopayersPage: __WEBPACK_IMPORTED_MODULE_17__add_copayers_copayers__["a" /* CopayersPage */],
            ImportWalletPage: __WEBPACK_IMPORTED_MODULE_18__add_import_wallet_import_wallet__["a" /* ImportWalletPage */],
            JoinWalletPage: __WEBPACK_IMPORTED_MODULE_19__add_join_wallet_join_wallet__["a" /* JoinWalletPage */],
            PaperWalletPage: __WEBPACK_IMPORTED_MODULE_24__paper_wallet_paper_wallet__["a" /* PaperWalletPage */],
            SimplexPage: __WEBPACK_IMPORTED_MODULE_22__integrations_simplex_simplex__["a" /* SimplexPage */],
            SelectInvoicePage: __WEBPACK_IMPORTED_MODULE_21__integrations_invoice_select_invoice_select_invoice__["a" /* SelectInvoicePage */],
            WalletDetailsPage: __WEBPACK_IMPORTED_MODULE_30__wallet_details_wallet_details__["a" /* WalletDetailsPage */]
        };
        this.SendPageRedirEventHandler = nextView => {
            const currentIndex = this.navCtrl.getActive().index;
            const currentView = this.navCtrl.getViews();
            nextView.params.fromWalletDetails = true;
            nextView.params.walletId = this.wallet.credentials.walletId;
            this.navCtrl
                .push(this.pageMap[nextView.name], nextView.params, { animate: false })
                .then(() => {
                if (currentView[currentIndex].name == 'ScanPage')
                    this.navCtrl.remove(currentIndex);
            });
        };
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
        this.wallet = this.navParams.data.wallet;
        this.events.subscribe('Local/AddressScan', this.updateAddressHandler);
        this.events.subscribe('SendPageRedir', this.SendPageRedirEventHandler);
        this.events.subscribe('Desktop/onFocus', () => {
            this.setDataFromClipboard();
        });
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.setDataFromClipboard();
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SendPage');
    }
    ionViewDidEnter() {
        this.setDataFromClipboard();
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScan', this.updateAddressHandler);
        this.events.unsubscribe('SendPageRedir', this.SendPageRedirEventHandler);
        this.events.unsubscribe('Desktop/onFocus');
        this.onResumeSubscription.unsubscribe();
    }
    setDataFromClipboard() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.validDataFromClipboard = yield this.clipboardProvider.getValidData(this.wallet.coin);
        });
    }
    shouldShowZeroState() {
        return (this.wallet &&
            this.wallet.cachedStatus &&
            !this.wallet.cachedStatus.totalBalanceSat);
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_25__scan_scan__["a" /* ScanPage */], { fromSend: true }, { animate: false });
    }
    showOptions(coin) {
        return ((this.currencyProvider.isMultiSend(coin) ||
            this.currencyProvider.isUtxoCoin(coin)) &&
            !this.shouldShowZeroState());
    }
    checkCoinAndNetwork(data, isPayPro) {
        let isValid, addrData;
        if (isPayPro) {
            isValid =
                data &&
                    data.chain == this.currencyProvider.getChain(this.wallet.coin) &&
                    data.network == this.wallet.network;
        }
        else {
            addrData = this.addressProvider.getCoinAndNetwork(data, this.wallet.network);
            isValid =
                this.currencyProvider.getChain(this.wallet.coin).toLowerCase() ==
                    addrData.coin && addrData.network == this.wallet.network;
        }
        // TODO FIX: Fix address validation
        isValid = true;
        if (isValid) {
            this.invalidAddress = false;
            return true;
        }
        else {
            this.invalidAddress = true;
            let network = isPayPro ? data.network : addrData.network;
            if (this.wallet.coin === 'bch' && this.wallet.network === network) {
                const isLegacy = this.checkIfLegacy();
                isLegacy ? this.showLegacyAddrMessage() : this.showErrorMessage();
            }
            else {
                this.showErrorMessage();
            }
        }
        return false;
    }
    redir() {
        this.incomingDataProvider.redir(this.search, {
            activePage: 'SendPage',
            amount: this.navParams.data.amount,
            coin: this.navParams.data.coin // TODO ???? what is this for ?
        });
        this.search = '';
    }
    showErrorMessage() {
        const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
        const title = this.translate.instant('Error');
        this.errorsProvider.showDefaultError(msg, title, () => {
            this.search = '';
        });
    }
    showLegacyAddrMessage() {
        const appName = this.appProvider.info.nameCase;
        const infoSheet = this.actionSheetProvider.createInfoSheet('legacy-address-info', { appName });
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                const legacyAddr = this.search;
                const cashAddr = this.addressProvider.translateToCashAddress(legacyAddr);
                this.search = cashAddr;
                this.processInput();
            }
        });
    }
    cleanSearch() {
        this.search = '';
        this.invalidAddress = false;
    }
    processInput() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.search == '')
                this.invalidAddress = false;
            const hasContacts = yield this.checkIfContact();
            if (!hasContacts) {
                const parsedData = this.incomingDataProvider.parseData(this.search.toLowerCase());
                if ((parsedData && parsedData.type == 'PayPro') ||
                    (parsedData && parsedData.type == 'InvoiceUri')) {
                    try {
                        const invoiceUrl = this.incomingDataProvider.getPayProUrl(this.search);
                        const payproOptions = yield this.payproProvider.getPayProOptions(invoiceUrl);
                        const selected = payproOptions.paymentOptions.find(option => option.selected &&
                            this.wallet.coin.toUpperCase() === option.currency);
                        if (selected) {
                            const activePage = 'SendPage';
                            const isValid = this.checkCoinAndNetwork(selected, true);
                            if (isValid) {
                                this.incomingDataProvider.goToPayPro(payproOptions.payProUrl, this.wallet.coin, undefined, true, activePage);
                            }
                        }
                        else {
                            this.redir();
                        }
                    }
                    catch (err) {
                        this.onGoingProcessProvider.clear();
                        this.invalidAddress = true;
                        this.logger.warn(this.bwcErrorProvider.msg(err));
                        this.errorsProvider.showDefaultError(this.bwcErrorProvider.msg(err), this.translate.instant('Error'));
                    }
                }
                else if (parsedData &&
                    __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.validDataTypeMap, parsedData.type) != -1) {
                    const isValid = this.checkCoinAndNetwork(this.search);
                    if (isValid)
                        this.redir();
                }
                else if (parsedData && parsedData.type == 'TKCoinCard') {
                    // this.close();
                    this.incomingDataProvider.redir(this.search, {
                        activePage: 'SendPage'
                    });
                }
                else if (parsedData && parsedData.type == 'PrivateKey') {
                    this.incomingDataProvider.redir(this.search, {
                        activePage: 'SendPage'
                    });
                }
                else {
                    this.invalidAddress = true;
                }
            }
            else {
                this.invalidAddress = false;
            }
        });
    }
    checkIfContact() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].timer(50).toPromise();
            return this.transferTo.hasContactsOrWallets;
        });
    }
    checkIfLegacy() {
        return (this.incomingDataProvider.isValidBitcoinCashLegacyAddress(this.search) ||
            this.incomingDataProvider.isValidBitcoinCashUriWithLegacyAddress(this.search));
    }
    showMoreOptions() {
        const optionsSheet = this.actionSheetProvider.createOptionsSheet('send-options', {
            isUtxoCoin: this.currencyProvider.isUtxoCoin(this.wallet.coin),
            isMultiSend: this.currencyProvider.isMultiSend(this.wallet.coin)
        });
        optionsSheet.present();
        optionsSheet.onDidDismiss(option => {
            if (option == 'multi-send')
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_31__multi_send_multi_send__["a" /* MultiSendPage */], {
                    wallet: this.wallet
                });
            if (option == 'select-inputs')
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_28__send_select_inputs_select_inputs__["a" /* SelectInputsPage */], {
                    wallet: this.wallet
                });
        });
    }
    pasteFromClipboard() {
        this.search = this.validDataFromClipboard || '';
        this.validDataFromClipboard = null;
        this.clipboardProvider.clear();
        this.processInput();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('transferTo'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], SendPage.prototype, "transferTo", void 0);
SendPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-send',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/send.html"*/'<wide-header-page title="{{\'Send to\' | translate}}">\n  <ion-buttons right *ngIf="showOptions(wallet?.coin)">\n    <button wide-header-bar-button clear class="option-button" (click)="showMoreOptions()" ion-button icon-only>\n      <ion-icon name="ios-more" md="ios-more"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div class="prompt-user-fullscreen-container" *ngIf="shouldShowZeroState()">\n      <div>\n        <div class="prompt-user">\n          <div class="title-icon larger-icon">\n            <img *ngIf="wallet.coin !== \'doge\'" src="assets/img/ghost-straight-face.svg">\n            <img *ngIf="wallet.coin === \'doge\'" src="assets/img/sad-doge.svg">\n          </div>\n          <div class="title-info">\n            <span translate>Mmm...</span>\n          </div>\n          <div class="subtitle-info" *ngIf="wallet.coin !== \'xrp\'; else minXrp">\n            <span translate>It appears that you do not have any money to send.</span>\n          </div>\n        </div>\n\n        <ng-template #minXrp>\n          <div class="subtitle-info">\n            <p translate>You need a minimum of 20 XRP to send funds.</p>\n          </div>\n        </ng-template>\n      </div>\n    </div>\n\n    <div *ngIf="!shouldShowZeroState()">\n      <div class="send-header-wrapper">\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Search contact or enter address\' | translate}}" [(ngModel)]="search" (ngModelChange)="processInput()"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="cleanSearch()"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n      </div>\n\n      <div text-center>\n        <button [disabled]="!validDataFromClipboard" ion-button item-end clear (click)="pasteFromClipboard()" translate>\n          Paste from Clipboard\n        </button>\n      </div>\n\n      <page-transfer-to [wallet]="wallet" [searchInput]="search" [useAsModal]="false" [fromWalletDetails]="true" #transferTo></page-transfer-to>\n\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/send.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_16__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_10__providers_clipboard_clipboard__["a" /* ClipboardProvider */]])
], SendPage);

//# sourceMappingURL=send.js.map

/***/ }),

/***/ 1026:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectInputsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__transfer_to_modal_transfer_to_modal__ = __webpack_require__(520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_incoming_data_incoming_data__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__ = __webpack_require__(31);





// Pages




// Providers











let SelectInputsPage = class SelectInputsPage {
    constructor(navCtrl, currencyProvider, navParams, incomingDataProvider, addressProvider, appProvider, errorsProvider, translate, actionSheetProvider, logger, bwcProvider, events, modalCtrl, txFormatProvider, walletProvider, configProvider) {
        this.navCtrl = navCtrl;
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.incomingDataProvider = incomingDataProvider;
        this.addressProvider = addressProvider;
        this.appProvider = appProvider;
        this.errorsProvider = errorsProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.events = events;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.configProvider = configProvider;
        this.inputs = [];
        this.totalAmount = 0;
        this.selectedInputs = [];
        this.validDataTypeMap = [
            'BitcoinAddress',
            'EducoinAddress',
            'TKCoinAddress',
            'BitcoinCashAddress',
            'EthereumAddress',
            'DogecoinAddress',
            'EthereumUri',
            'BitcoinUri',
            'EducoinUri',
            'TKCoinUri',
            'BitcoinCashUri',
            'DogecoinUri'
        ];
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
        this.bitcore = {
            btc: this.bwcProvider.getBitcore(),
            edu: this.bwcProvider.getBitcoreEdu(),
            tik: this.bwcProvider.getBitcoreTik(),
            bch: this.bwcProvider.getBitcoreCash(),
            doge: this.bwcProvider.getBitcoreDoge()
        };
        this.wallet = this.navParams.data.wallet;
        this.events.subscribe('Local/AddressScanSelectInputs', this.updateAddressHandler);
        this.events.subscribe('addRecipient', newRecipient => {
            this.addRecipient(newRecipient);
        });
        this.getInputs(this.wallet);
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('Loaded: SelectInputsPage');
        });
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScanSelectInputs', this.updateAddressHandler);
        this.events.unsubscribe('addRecipient', newRecipient => {
            this.addRecipient(newRecipient);
        });
    }
    getInputs(wallet) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                this.inputs = yield this.walletProvider.getUtxos(wallet);
            }
            catch (error) {
                this.logger.warn(error);
            }
            const config = this.configProvider.get();
            const spendUnconfirmed = config.wallet.spendUnconfirmed;
            if (spendUnconfirmed)
                return;
            this.inputs = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.inputs, i => {
                return i.confirmations !== 0;
            });
        });
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__scan_scan__["a" /* ScanPage */], { fromSelectInputs: true });
    }
    processInput() {
        if (this.search && this.search.trim() != '') {
            this.parsedData = this.incomingDataProvider.parseData(this.search);
            if (this.parsedData && this.parsedData.type == 'PayPro') {
                this.invalidAddress = true;
            }
            else if (this.parsedData &&
                __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.validDataTypeMap, this.parsedData.type) != -1) {
                const isValid = this.checkCoinAndNetwork(this.search);
                if (isValid) {
                    this.invalidAddress = false;
                    this.newRecipient();
                }
            }
            else {
                this.invalidAddress = true;
            }
        }
    }
    newRecipient() {
        let newRecipient;
        if (this.parsedData &&
            (this.parsedData.type === 'BitcoinUri' ||
                this.parsedData.type === 'BitcoinCashUri' ||
                this.parsedData.type === 'EthereumUri')) {
            let parsed;
            let toAddress;
            let amount;
            let recipientType;
            try {
                if (this.bitcore[this.wallet.coin]) {
                    parsed = this.bitcore[this.wallet.coin].URI(this.search);
                }
                const address = this.incomingDataProvider.extractAddress(this.search);
                toAddress =
                    parsed && parsed.address
                        ? parsed.address.toString()
                        : __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](address);
                // keep address in original format
                if (parsed &&
                    parsed.address &&
                    this.search.indexOf(toAddress) < 0 &&
                    this.wallet.coin == 'bch') {
                    toAddress = parsed.address.toCashAddress();
                }
                const extractedAmount = /[\?\&]amount|value=(\d+([\,\.]\d+)?)/i.exec(this.search);
                if (parsed && parsed.amount) {
                    amount = parsed.amount;
                }
                else if (extractedAmount) {
                    amount = extractedAmount[1];
                }
                recipientType = 'address';
            }
            catch (_err) {
                // If pasted address isn't a valid uri
                toAddress = __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.search);
                recipientType = 'address';
            }
            newRecipient = {
                amount,
                toAddress,
                recipientType
            };
        }
        else {
            newRecipient = {
                toAddress: __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.search),
                recipientType: 'address'
            };
        }
        this.addRecipient(newRecipient);
    }
    openAmountModal(item) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__amount_amount__["a" /* AmountPage */], {
            wallet: this.wallet,
            useAsModal: true
        }, {
            showBackdrop: false,
            enableBackdropDismiss: true,
            cssClass: 'wallet-details-modal'
        });
        modal.present();
        modal.onDidDismiss(data => {
            this.cleanSearch();
            if (!data)
                return;
            let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, +data.amount);
            item.amount = +data.amount;
            item.altAmountStr = altAmountStr;
            item.fiatAmount = data.fiatAmount;
            item.fiatCode = data.fiatCode;
            item.amountToShow = this.txFormatProvider.formatAmount(this.wallet.coin, +data.amount);
            this.recipient = item;
        });
    }
    cleanSearch() {
        this.search = '';
        this.parsedData = {};
    }
    checkCoinAndNetwork(data) {
        const addrData = this.addressProvider.getCoinAndNetwork(data, this.wallet.network);
        const isValid = this.currencyProvider.getChain(this.wallet.coin).toLowerCase() ==
            addrData.coin && addrData.network == this.wallet.network;
        if (isValid) {
            this.invalidAddress = false;
            return true;
        }
        else {
            this.invalidAddress = true;
            const network = addrData.network;
            if (this.wallet.coin === 'bch' && this.wallet.network === network) {
                const isLegacy = this.checkIfLegacy();
                isLegacy ? this.showLegacyAddrMessage() : this.showErrorMessage();
            }
            else {
                this.showErrorMessage();
            }
        }
        return false;
    }
    showErrorMessage() {
        const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
        const title = this.translate.instant('Error');
        this.errorsProvider.showDefaultError(msg, title, () => {
            this.search = '';
        });
    }
    showLegacyAddrMessage() {
        const appName = this.appProvider.info.nameCase;
        const infoSheet = this.actionSheetProvider.createInfoSheet('legacy-address-info', { appName });
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                const legacyAddr = this.search;
                const cashAddr = this.addressProvider.translateToCashAddress(legacyAddr);
                this.search = cashAddr;
                this.processInput();
            }
        });
    }
    checkIfLegacy() {
        return (this.incomingDataProvider.isValidBitcoinCashLegacyAddress(this.search) ||
            this.incomingDataProvider.isValidBitcoinCashUriWithLegacyAddress(this.search));
    }
    addRecipient(recipient) {
        let amountToShow = +recipient.amount
            ? this.txFormatProvider.formatAmount(this.wallet.coin, +recipient.amount)
            : null;
        let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, ++recipient.amount);
        this.recipient = {
            amount: +recipient.amount ? +recipient.amount : null,
            amountToShow,
            altAmountStr: altAmountStr ? altAmountStr : null,
            toAddress: recipient.toAddress,
            recipientType: recipient.recipientType,
            name: recipient.name,
            email: recipient.email
        };
        this.cleanSearch();
    }
    openTransferToModal() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__transfer_to_modal_transfer_to_modal__["a" /* TransferToModalPage */], {
            wallet: this.wallet,
            fromSelectInputs: true
        });
    }
    goToConfirm() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__confirm_confirm__["a" /* ConfirmPage */], {
            walletId: this.wallet.credentials.walletId,
            fromSelectInputs: true,
            totalInputsAmount: this.totalAmount *
                this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi,
            toAddress: this.recipient.toAddress,
            amount: this.recipient.amount,
            coin: this.wallet.coin,
            network: this.wallet.network,
            useSendMax: false,
            inputs: __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.inputs, 'checked')
        });
    }
    selectInput(input) {
        if (input.checked) {
            input.checked = false;
            const index = __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.selectedInputs, input);
            this.selectedInputs.splice(index, 1);
        }
        else {
            input.checked = true;
            this.selectedInputs.push(input);
        }
        this.totalAmount = Number(__WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](this.selectedInputs, 'amount').toFixed(8));
    }
    removeRecipient() {
        this.recipient = undefined;
        this.selectedInputs = [];
        this.totalAmount = 0;
        this.inputs.forEach(input => {
            input.checked = false;
        });
        this.cleanSearch();
    }
    canContinue() {
        return this.recipient
            ? (this.selectedInputs && this.selectedInputs.length <= 0) ||
                (this.recipient.amountToShow &&
                    this.recipient.amountToShow > this.totalAmount)
            : true;
    }
    shortcuts(selectAll) {
        this.selectedInputs = [];
        this.totalAmount = 0;
        this.inputs.forEach(input => {
            input.checked = selectAll;
            if (selectAll) {
                this.selectedInputs.push(input);
                this.totalAmount = Number(__WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](this.selectedInputs, 'amount').toFixed(8));
            }
        });
    }
};
SelectInputsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-select-inputs',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/select-inputs/select-inputs.html"*/'<wide-header-page title="{{\'Select inputs\' | translate}}">\n  <ion-buttons right>\n    <button *ngIf="!recipient" clear wide-header-bar-button (click)="openTransferToModal()" ion-button icon-only>\n      <span translation>Add Contact</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div>\n      <div class="send-header-wrapper" *ngIf="!recipient">\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Enter {coinName} address\' | translate: {coinName: getCoinName(wallet?.coin)} }}" [(ngModel)]="search" (ngModelChange)="processInput()"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="search = \'\'"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n      </div>\n\n      <ion-list *ngIf="recipient" class="content-list">\n        <ion-item-divider class="item-divider-header">\n          <span class="ellipsis">{{ \'Recipient\' | translate}}</span>\n          <ion-icon class="close-icon pointer" name="ios-close-outline" item-right (click)="removeRecipient()"></ion-icon>\n        </ion-item-divider>\n        <ion-item (click)="openAmountModal(recipient)" class="recipient">\n          <ion-icon class="item-img wallet" item-start>\n            <img *ngIf="recipient.recipientType == \'wallet\'" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" src="assets/img/currencies/{{wallet.coin}}.svg" />\n            <gravatar *ngIf="recipient.recipientType == \'contact\'" [name]="recipient.name" [height]="40" [width]="40" [email]="recipient.email" [coin]="wallet.coin" [network]="wallet.network"></gravatar>\n            <img *ngIf="recipient.recipientType == \'address\'" class="coin-icon" src="assets/img/icon-{{wallet.coin}}-small.svg" alt="Coin" />\n          </ion-icon>\n          <ion-label>\n            <span *ngIf="recipient.recipientType == \'wallet\'">{{recipient.name}}</span>\n            <span *ngIf="recipient.recipientType == \'contact\'">{{recipient.name}}</span>\n            <span *ngIf="recipient.recipientType == \'address\'" class="ellipsis">{{recipient.toAddress}}</span>\n          </ion-label>\n          <ion-note item-end text-end>\n            <div *ngIf="recipient.amountToShow" class="amount">\n              {{recipient.amountToShow}} {{wallet.coin | uppercase}}\n            </div>\n            <div *ngIf="recipient.amountToShow" class="amount-str">\n              {{recipient.altAmountStr}}\n            </div>\n            <span *ngIf="!recipient.amountToShow" ion-text color="primary">{{\'Specify Amount\' | translate}}</span>\n          </ion-note>\n        </ion-item>\n      </ion-list>\n\n      <ion-list *ngIf="recipient" class="content-list">\n        <ion-item-divider class="item-divider-header">\n          <span class="ellipsis">{{ \'Total selected inputs\' | translate}}</span>\n        </ion-item-divider>\n        <ion-item class="total-inputs-content">\n          <div class="total-inputs-str">\n            {{totalAmount}} {{wallet.coin | uppercase}}\n          </div>\n          <div class="total-inputs-warning" *ngIf="recipient.amountToShow && totalAmount < recipient.amountToShow">\n            <small>{{\'This amount should be higher than the amount you are trying to send.\' | translate}}</small>\n          </div>\n        </ion-item>\n      </ion-list>\n\n      <ion-list *ngIf="recipient" class="content-list">\n        <ion-item-divider sticky class="item-divider-header">\n          <span class="ellipsis">{{ \'Wallet Inputs\' | translate}}</span>\n          <button ion-button item-end clear *ngIf="inputs.length > 0" (click)="shortcuts(false)">\n            <ion-icon name="md-trash" color="grey"></ion-icon>\n          </button>\n          <button ion-button item-end clear *ngIf="inputs.length > 0" (click)="shortcuts(true)">\n            <ion-icon name="ios-checkmark-circle" color="grey"></ion-icon>\n          </button>\n        </ion-item-divider>\n        <ion-item *ngIf="inputs.length == 0">\n          <div class="warning">\n            <small>{{\'No available inputs.\' | translate}}</small>\n          </div>\n        </ion-item>\n        <div class="item-wrapper" *ngFor="let input of inputs; let i = index">\n          <ion-item (click)="selectInput(input, i)">\n            <ion-label padding-left>\n              <div class="amount">\n                {{input.amount}} {{wallet.coin | uppercase}}\n              </div>\n              <div class="address">\n                {{input.address}}\n              </div>\n            </ion-label>\n            <ion-checkbox mode="ios" (click)="selectInput(input, i)" [checked]="input.checked"></ion-checkbox>\n          </ion-item>\n        </div>\n      </ion-list>\n    </div>\n    <div *ngIf="!recipient" class="no-wallet-message">\n      <span translate>To get started, you\'ll need to enter a valid address or select an existent contact or wallet.</span>\n    </div>\n  </div>\n\n  <div footer-content>\n    <ion-toolbar>\n      <button ion-button full class="button-footer" (click)="goToConfirm()" [disabled]="canContinue()">{{\'Continue\' | translate}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/select-inputs/select-inputs.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_16__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_12__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_18__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_config_config__["a" /* ConfigProvider */]])
], SelectInputsPage);

//# sourceMappingURL=select-inputs.js.map

/***/ }),

/***/ 1027:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MultiSendPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_incoming_data_incoming_data__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__transfer_to_modal_transfer_to_modal__ = __webpack_require__(520);





// Providers









// Pages




let MultiSendPage = class MultiSendPage {
    constructor(navCtrl, navParams, currencyProvider, logger, incomingDataProvider, addressProvider, events, actionSheetProvider, appProvider, translate, modalCtrl, txFormatProvider, bwcProvider, errorsProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.incomingDataProvider = incomingDataProvider;
        this.addressProvider = addressProvider;
        this.events = events;
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.bwcProvider = bwcProvider;
        this.errorsProvider = errorsProvider;
        this.search = '';
        this.multiRecipients = [];
        this.contactsList = [];
        this.filteredContactsList = [];
        this.filteredWallets = [];
        this.validDataTypeMap = [
            'BitcoinAddress',
            'EducoinAddress',
            'TKCoinAddress',
            'BitcoinCashAddress',
            'EthereumAddress',
            'DogecoinAddress',
            'EthereumUri',
            'BitcoinUri',
            'EducoinUri',
            'TKCoinUri',
            'BitcoinCashUri',
            'DogecoinUri'
        ];
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
        this.bitcore = {
            btc: this.bwcProvider.getBitcore(),
            bch: this.bwcProvider.getBitcoreCash(),
            doge: this.bwcProvider.getBitcoreDoge()
        };
        this.isDisabledContinue = true;
        this.wallet = this.navParams.data.wallet;
        this.events.subscribe('Local/AddressScanMultiSend', this.updateAddressHandler);
        this.events.subscribe('addRecipient', newRecipient => {
            this.addRecipient(newRecipient);
            this.checkGoToConfirmButton();
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: MultiSendPage');
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScanMultiSend', this.updateAddressHandler);
        this.events.unsubscribe('addRecipient');
    }
    openTransferToModal() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__transfer_to_modal_transfer_to_modal__["a" /* TransferToModalPage */], {
            wallet: this.wallet,
            fromMultiSend: true
        });
    }
    openAmountModal(item, index) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_15__amount_amount__["a" /* AmountPage */], {
            wallet: this.wallet,
            useAsModal: true
        }, {
            showBackdrop: false,
            enableBackdropDismiss: true,
            cssClass: 'wallet-details-modal'
        });
        modal.present();
        modal.onDidDismiss(data => {
            this.cleanSearch();
            if (!data)
                return;
            let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, +data.amount);
            item.amount = +data.amount;
            item.altAmountStr = altAmountStr;
            item.fiatAmount = data.fiatAmount;
            item.fiatCode = data.fiatCode;
            item.amountToShow = this.txFormatProvider.formatAmount(this.wallet.coin, +data.amount);
            this.multiRecipients[index] = item;
            this.checkGoToConfirmButton();
        });
    }
    addRecipient(recipient) {
        let amountToShow = +recipient.amount
            ? this.txFormatProvider.formatAmount(this.wallet.coin, +recipient.amount)
            : null;
        let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, ++recipient.amount);
        this.multiRecipients.push({
            amount: +recipient.amount ? +recipient.amount : null,
            amountToShow,
            altAmountStr: altAmountStr ? altAmountStr : null,
            toAddress: recipient.toAddress,
            recipientType: recipient.recipientType,
            recipient
        });
        this.checkGoToConfirmButton();
        this.cleanSearch();
    }
    newRecipient() {
        if (this.parsedData &&
            (this.parsedData.type === 'BitcoinUri' ||
                this.parsedData.type === 'EducoinUri' ||
                this.parsedData.type === 'TKCoinUri' ||
                this.parsedData.type === 'BitcoinCashUri' ||
                this.parsedData.type === 'EthereumUri')) {
            let parsed;
            let toAddress;
            let amount;
            let recipient;
            let recipientType;
            try {
                if (this.bitcore[this.wallet.coin]) {
                    parsed = this.bitcore[this.wallet.coin].URI(this.search);
                }
                const address = this.incomingDataProvider.extractAddress(this.search);
                toAddress =
                    parsed && parsed.address
                        ? parsed.address.toString()
                        : __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](address);
                // keep address in original format
                if (parsed &&
                    parsed.address &&
                    this.search.indexOf(toAddress) < 0 &&
                    this.wallet.coin == 'bch') {
                    toAddress = parsed.address.toCashAddress();
                }
                const extractedAmount = /[\?\&]amount|value=(\d+([\,\.]\d+)?)/i.exec(this.search);
                if (parsed && parsed.amount) {
                    amount = parsed.amount;
                }
                else if (extractedAmount) {
                    amount = extractedAmount[1];
                }
                recipientType = 'address';
                recipient = null;
            }
            catch (_err) {
                // If pasted address isn't a valid uri
                toAddress = __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.search);
                recipientType = 'address';
            }
            const newRecipient = {
                amount,
                toAddress,
                recipientType,
                recipient
            };
            const index = this.multiRecipients.length;
            if (!amount) {
                this.openAmountModal(newRecipient, index);
            }
            else {
                this.addRecipient(newRecipient);
            }
        }
        else {
            const newRecipient = {
                toAddress: __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.search),
                recipientType: 'address'
            };
            const index = this.multiRecipients.length;
            this.openAmountModal(newRecipient, index);
        }
    }
    checkGoToConfirmButton() {
        let b = false;
        this.multiRecipients.forEach(recipient => {
            if (!recipient.amountToShow) {
                b = true;
            }
        });
        this.isDisabledContinue = b;
    }
    cleanSearch() {
        this.search = '';
        this.parsedData = {};
    }
    removeRecipient(index) {
        this.multiRecipients.splice(index, 1);
        this.checkGoToConfirmButton();
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__scan_scan__["a" /* ScanPage */], { fromMultiSend: true });
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    checkCoinAndNetwork(data) {
        const addrData = this.addressProvider.getCoinAndNetwork(data, this.wallet.network);
        const isValid = this.currencyProvider.getChain(this.wallet.coin).toLowerCase() ==
            addrData.coin && addrData.network == this.wallet.network;
        if (isValid) {
            this.invalidAddress = false;
            return true;
        }
        else {
            this.invalidAddress = true;
            const network = addrData.network;
            if (this.wallet.coin === 'bch' && this.wallet.network === network) {
                const isLegacy = this.checkIfLegacy();
                isLegacy ? this.showLegacyAddrMessage() : this.showErrorMessage();
            }
            else {
                this.showErrorMessage();
            }
        }
        return false;
    }
    showErrorMessage() {
        const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
        const title = this.translate.instant('Error');
        this.errorsProvider.showDefaultError(msg, title, () => {
            this.search = '';
        });
    }
    showLegacyAddrMessage() {
        const appName = this.appProvider.info.nameCase;
        const infoSheet = this.actionSheetProvider.createInfoSheet('legacy-address-info', { appName });
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                const legacyAddr = this.search;
                const cashAddr = this.addressProvider.translateToCashAddress(legacyAddr);
                this.search = cashAddr;
                this.processInput();
            }
        });
    }
    processInput() {
        if (this.search && this.search.trim() != '') {
            this.parsedData = this.incomingDataProvider.parseData(this.search);
            if (this.parsedData && this.parsedData.type == 'PayPro') {
                this.invalidAddress = true;
            }
            else if (this.parsedData &&
                __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.validDataTypeMap, this.parsedData.type) != -1) {
                const isValid = this.checkCoinAndNetwork(this.search);
                if (isValid) {
                    this.invalidAddress = false;
                    this.newRecipient();
                }
            }
            else {
                this.invalidAddress = true;
            }
        }
    }
    checkIfLegacy() {
        return (this.incomingDataProvider.isValidBitcoinCashLegacyAddress(this.search) ||
            this.incomingDataProvider.isValidBitcoinCashUriWithLegacyAddress(this.search));
    }
    goToConfirm() {
        let totalAmount = 0;
        this.multiRecipients.forEach(recipient => {
            totalAmount += recipient.amount;
        });
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__confirm_confirm__["a" /* ConfirmPage */], {
            walletId: this.wallet.credentials.walletId,
            fromMultiSend: true,
            totalAmount,
            recipientType: 'multi',
            color: this.wallet.color,
            coin: this.wallet.coin,
            network: this.wallet.network,
            useSendMax: false,
            recipients: this.multiRecipients
        });
    }
};
MultiSendPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-multi-send',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/multi-send/multi-send.html"*/'<wide-header-page title="{{\'Multiple Recipients\' | translate}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="openTransferToModal()" ion-button icon-only>\n      <span translation>Add Contact</span>\n    </button>\n  </ion-buttons>\n\n  <div page-content>\n    <div>\n      <div class="send-header-wrapper">\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Add {coinName} address\' | translate: {coinName: getCoinName(wallet?.coin)} }}" [(ngModel)]="search" (ngModelChange)="processInput()"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="search = \'\'"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n      </div>\n\n      <ion-list class="content-list">\n        <div *ngFor="let item of multiRecipients; let idx = index">\n          <ion-item-divider class="item-divider-header">\n            <span class="ellipsis">{{ \'Recipient\' | translate}} {{idx +1}}</span>\n            <ion-icon class="close-icon pointer" name="ios-close-outline" item-right (click)="removeRecipient(idx)"></ion-icon>\n          </ion-item-divider>\n          <ion-item (click)="openAmountModal(item, idx)" class="recipient">\n            <ion-icon class="item-img wallet" item-start>\n              <img *ngIf="item.recipientType == \'wallet\' && item.recipient" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" src="assets/img/currencies/{{wallet.coin}}.svg" />\n              <gravatar *ngIf="item.recipientType == \'contact\' && item.recipient" [name]="item.recipient.name" [height]="40" [width]="40" [email]="item.recipient.email" [coin]="wallet.coin" [network]="wallet.network"></gravatar>\n              <img *ngIf="item.recipientType == \'address\'" class="coin-icon" src="assets/img/icon-{{wallet.coin}}-small.svg" alt="Coin" />\n            </ion-icon>\n            <ion-label>\n              <span *ngIf="item.recipientType == \'wallet\' && item.recipient">{{item.recipient.name}}</span>\n              <span *ngIf="item.recipientType == \'contact\' && item.recipient">{{item.recipient.name}}</span>\n              <span *ngIf="item.recipientType == \'address\'" class="ellipsis">{{item.toAddress}}</span>\n            </ion-label>\n            <ion-note item-end text-end>\n              <div *ngIf="item.amountToShow" class="amount">\n                {{item.amountToShow}} {{wallet.coin | uppercase}}\n              </div>\n              <div *ngIf="item.amountToShow" class="amount-str">\n                {{item.altAmountStr}}\n              </div>\n            </ion-note>\n          </ion-item>\n        </div>\n      </ion-list>\n    </div>\n    <div *ngIf="multiRecipients.length == 0" class="no-wallet-message">\n      <span translate>To get started, you\'ll need to enter a valid address or select an existent contact or wallet.</span>\n    </div>\n  </div>\n\n  <div footer-content>\n    <ion-toolbar>\n      <button ion-button full class="button-footer" (click)="goToConfirm()" [disabled]="isDisabledContinue || multiRecipients.length == 0">{{\'Continue\' | translate}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/multi-send/multi-send.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["t" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_errors_errors__["a" /* ErrorsProvider */]])
], MultiSendPage);

//# sourceMappingURL=multi-send.js.map

/***/ }),

/***/ 1028:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxDetailsModal; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_address_book_address_book__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_filter_filter__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__ = __webpack_require__(31);






// Providers












let TxDetailsModal = class TxDetailsModal {
    constructor(addressBookProvider, configProvider, currencyProvider, events, externalLinkProvider, logger, navCtrl, navParams, onGoingProcess, popupProvider, profileProvider, txConfirmNotificationProvider, txFormatProvider, walletProvider, translate, filter, rateProvider, viewCtrl) {
        this.addressBookProvider = addressBookProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcess = onGoingProcess;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.filter = filter;
        this.rateProvider = rateProvider;
        this.viewCtrl = viewCtrl;
        this.bwsEventHandler = (_, type, n) => {
            let match = false;
            if (type == 'NewBlock' &&
                n &&
                n.data &&
                this.wallet &&
                n.data &&
                n.data.network == this.wallet.network &&
                n.data.coin == this.wallet.coin) {
                match = true;
                this.updateTxDebounced({ hideLoading: true });
            }
            this.logger.debug('bwsEvent handler @tx-details. Matched: ' + match);
        };
        this.updateTxDebounced = __WEBPACK_IMPORTED_MODULE_4_lodash__["debounce"]((hideLoading) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.updateTx({ hideLoading });
        }), 1000, {
            leading: true
        });
    }
    ionViewDidLoad() {
        this.config = this.configProvider.get();
        this.txId = this.navParams.data.txid;
        this.title = this.translate.instant('Transaction');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.color = this.wallet.color;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.txsUnsubscribedForNotifications = this.config.confirmedTxsNotifications
            ? !this.config.confirmedTxsNotifications.enabled
            : true;
        let defaults = this.configProvider.getDefaults();
        this.blockexplorerUrl = defaults.blockExplorerUrl[this.wallet.coin];
        this.blockexplorerUrlTestnet =
            defaults.blockExplorerUrlTestnet[this.wallet.coin];
        this.txConfirmNotificationProvider.checkIfEnabled(this.txId).then(res => {
            this.txNotification = {
                value: res
            };
        });
        this.updateTx();
    }
    ionViewWillLoad() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillUnload() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    readMore() {
        let url = 'https://support.tkcoin.org/hc/en-us/articles/115004497783-What-does-the-TKCoin-wallet-s-warning-amount-too-low-to-spend-mean-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Read more in our support page');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    updateMemo() {
        this.walletProvider
            .getTxNote(this.wallet, this.btx.txid)
            .then(note => {
            if (!note || note.body == '')
                return;
            this.btx.note = note;
        })
            .catch(err => {
            this.logger.warn('Could not fetch transaction note: ' + err);
            return;
        });
    }
    initActionList() {
        this.actionList = [];
        if ((this.btx.action != 'sent' && this.btx.action != 'moved') ||
            !this.isShared)
            return;
        let actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            failed: this.translate.instant('Execution Failed'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.btx.createdOn,
            description: actionDescriptions.created,
            by: this.btx.creatorName
        });
        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](this.btx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        this.actionList.push({
            type: 'broadcasted',
            time: this.btx.time,
            description: actionDescriptions.broadcasted
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    updateTx(opts) {
        opts = opts ? opts : {};
        if (!opts.hideLoading)
            this.onGoingProcess.set('loadingTxInfo');
        this.walletProvider
            .getTx(this.wallet, this.txId)
            .then(tx => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.btx = this.txFormatProvider.processTx(this.wallet.coin, tx);
            this.btx.network = this.wallet.credentials.network;
            this.btx.coin = this.wallet.coin;
            const chain = this.currencyProvider
                .getChain(this.wallet.coin)
                .toLowerCase();
            this.btx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(chain, tx.fees);
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
                this.btx.feeRateStr =
                    ((this.btx.fees / (this.btx.amount + this.btx.fees)) * 100).toFixed(2) + '%';
            }
            if (!this.btx.note) {
                this.txMemo = this.btx.message;
            }
            if (this.btx.note && this.btx.note.body) {
                this.txMemo = this.btx.note.body;
            }
            if (this.btx.action != 'invalid') {
                if (this.btx.action == 'sent')
                    this.title = this.translate.instant('Sent');
                if (this.btx.action == 'received')
                    this.title = this.translate.instant('Received');
                if (this.btx.action == 'moved')
                    this.title = this.translate.instant('Sent to self');
            }
            this.updateMemo();
            this.initActionList();
            this.contact();
            this.updateFiatRate();
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
                this.walletProvider
                    .getLowAmount(this.wallet)
                    .then((amount) => {
                    this.btx.lowAmount = tx.amount < amount;
                })
                    .catch(err => {
                    this.logger.warn('Error getting low amounts: ' + err);
                    return;
                });
            }
        })
            .catch(err => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.logger.warn('Error getting transaction: ' + err);
            this.navCtrl.pop();
            return this.popupProvider.ionicAlert('Error', this.translate.instant('Transaction not available at this time'));
        });
    }
    saveMemoInfo() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('Saving memo: ', this.txMemo);
            this.btx.note = {
                body: this.txMemo
            };
            let args = {
                txid: this.btx.txid,
                body: this.txMemo
            };
            yield this.walletProvider
                .editTxNote(this.wallet, args)
                .catch((err) => {
                this.logger.error('Could not save tx comment ' + err);
            });
            this.logger.info('Tx Note edited');
        });
    }
    viewOnBlockchain() {
        let btx = this.btx;
        const coin = btx.coin;
        let url;
        switch (coin) {
            case 'doge':
                url =
                    this.wallet.credentials.network === 'livenet'
                        ? `https://${this.blockexplorerUrl}dogecoin/transaction/${btx.txid}`
                        : `https://${this.blockexplorerUrlTestnet}tx/DOGETEST/${btx.txid}`;
                break;
            default:
                url =
                    this.wallet.credentials.network === 'livenet'
                        ? `https://${this.blockexplorerUrl}tx/${btx.txid}`
                        : `https://${this.blockexplorerUrlTestnet}tx/${btx.txid}`;
        }
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Transaction');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    txConfirmNotificationChange() {
        if (this.txNotification.value) {
            this.txConfirmNotificationProvider.subscribe(this.wallet, {
                txid: this.txId,
                amount: this.btx.amount
            });
        }
        else {
            this.txConfirmNotificationProvider.unsubscribe(this.wallet, this.txId);
        }
    }
    contact() {
        let addr = this.btx.addressTo;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                let name = __WEBPACK_IMPORTED_MODULE_4_lodash__["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
    openExternalLink(url) {
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    updateFiatRate() {
        const settings = this.configProvider.get().wallet.settings;
        this.rateProvider
            .getHistoricFiatRate(settings.alternativeIsoCode, this.wallet.coin, (this.btx.time * 1000).toString())
            .then(fiat => {
            if (fiat && fiat.rate) {
                this.btx.fiatRateStr =
                    this.filter.formatFiatAmount(parseFloat((fiat.rate * this.btx.amountValueStr).toFixed(2))) +
                        ' ' +
                        settings.alternativeIsoCode +
                        ' @ ' +
                        this.filter.formatFiatAmount(fiat.rate) +
                        ` ${settings.alternativeIsoCode} per ` +
                        this.wallet.coin.toUpperCase();
            }
            else {
                this.btx.fiatRateStr = this.btx.alternativeAmountStr;
            }
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
TxDetailsModal = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tx-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/tx-details/tx-details.html"*/'<wide-header-page title="{{title | translate}}" hideBackButton="true">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list *ngIf="btx" class="bp-list">\n      <ion-item>\n        <div class="header-container">\n          <div class="amount-label" *ngIf="!(btx.amount === 0 && wallet.coin === \'eth\')">\n            <div class="amount">\n              {{btx.amountValueStr}} {{btx.amountUnitStr | uppercase}}\n            </div>\n            <div class="alternative">\n              <span *ngIf="!btx.fiatRateStr">...</span>\n              <span *ngIf="btx.fiatRateStr">{{btx.fiatRateStr}}</span>\n            </div>\n          </div>\n          <div class="sending-label" *ngIf="btx.amount === 0 && wallet.coin === \'eth\'">\n            <span>{{\'Interaction with contract\' | translate}}</span>\n          </div>\n        </div>\n      </ion-item>\n\n      <label-tip class="low-fees" type="warn" *ngIf="btx.action == \'received\' && btx.lowAmount">\n        <span label-tip-title translate>Amount Too Low To Spend</span>\n        <div label-tip-body translate>\n          This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.\n          <br>\n          <a class="label-tip-link" (click)="readMore()" translate>Learn More</a>\n        </div>\n      </label-tip>\n\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label" translate>DETAILS</div>\n        </ion-label>\n      </ion-item>\n\n      <ion-item *ngIf="btx && btx.feeStr && btx.action != \'received\'">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Miner fee</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            {{btx.feeStr}}\n          </div>\n          <div class="secondary-note fee-details">\n            {{btx.feeFiatStr}}\n            <span *ngIf="btx.feeRateStr">\n              &middot;\n              <span>\n                <span *ngIf="btx.feeRateStr">{{btx.feeRateStr}}\n                  <span translate> of total amount</span>\n                </span>\n              </span>\n            </span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <label-tip *ngIf="btx.action == \'received\' && btx.lowFees" type="danger">\n        <span label-tip-title translate>Low Fee</span>\n        <div label-tip-body translate>\n          This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender.\n        </div>\n      </label-tip>\n\n      <div class="line-divider" *ngIf="btx.action === \'sent\'"></div>\n\n      <page-multiple-outputs *ngIf="btx.action === \'sent\'" [tx]="btx" (openBlockChainEvent)="viewOnBlockchain()"></page-multiple-outputs>\n\n      <div class="line-divider" *ngIf="btx.creatorName && isShared"></div>\n\n      <ion-item *ngIf="btx.creatorName && isShared">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Created by</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">{{btx.creatorName}}</span>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Date</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">\n            <time>{{ (btx.ts || btx.createdOn || btx.time) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n          </span>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Confirmations</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail" *ngIf="!btx.confirmations || btx.confirmations == 0" translate>\n            Unconfirmed\n          </div>\n          <div class="secondary-note fee-details" translate>\n            <span *ngIf="btx.feeRate">\n              <span translate>Fee rate</span>:\n              {{btx.feeRate}}\n            </span>\n          </div>\n          <span class="note-container ellipsis summary-item-detail" *ngIf="btx.confirmations>0 && !btx.safeConfirmed">\n            {{btx.confirmations}}\n          </span>\n          <span class="note-container ellipsis summary-item-detail" *ngIf="btx.safeConfirmed">\n            {{btx.safeConfirmed}}\n          </span>\n        </ion-note>\n      </ion-item>\n\n      <div *ngIf="!btx.confirmations || btx.confirmations == 0" class="unconfirmed-message">\n        <a class="positive" (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/360025484512-Missing-transactions-Why-is-my-transaction-unconfirmed-\')">\n          {{\'Why is my transaction unconfirmed?\' | translate}}\n        </a>\n      </div>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label stacked>\n          <div class="summary-item">{{\'Memo\' | translate}}</div>\n        </ion-label>\n        <ion-textarea class="summary-item-detail" placeholder="{{\'Enter a transaction memo\' | translate}}" (ionBlur)="saveMemoInfo()" [(ngModel)]="txMemo" name="tx.description" autocomplete="off" autocorrect="off"></ion-textarea>\n      </ion-item>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Transaction ID</span>\n          </div>\n        </ion-label>\n        <ion-note item-end copy-to-clipboard="{{ btx.txid }}">\n          <span class="note-container ellipsis summary-item-detail">\n            <time>{{ btx.txid }}</time>\n          </span>\n        </ion-note>\n      </ion-item>\n\n      <ion-item *ngIf="txsUnsubscribedForNotifications">\n        <ion-label>{{\'Notify me if confirmed\' | translate}}</ion-label>\n        <ion-toggle checked="false" *ngIf="!btx.confirmations || btx.confirmations == 0" [(ngModel)]="txNotification.value" (ionChange)="txConfirmNotificationChange()"></ion-toggle>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="actionList && actionList[0]"></div>\n\n      <div *ngIf="actionList && actionList[0] && !wallet.credentials.multisigEthInfo">\n        <ion-item detail-none>\n          <div>{{\'Timeline\' | translate}}</div>\n        </ion-item>\n        <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\'}" *ngFor="let a of actionList; let i = index">\n          <div class="timeline-content">\n            <div class="timeline-content-icon">\n              <div class="rejected" *ngIf="a.type === \'reject\'">!</div>\n              <img src="assets/img/icon-broadcasted.svg" *ngIf="a.type === \'broadcasted\'">\n              <div class="line" *ngIf="a.type !== \'reject\' && a.type !== \'broadcasted\'">{{actionList.length - i}}</div>\n            </div>\n            <div class="timeline-content-label">\n              <div class="action ellipsis">{{a.description}}</div>\n              <div class="name ellipsis">{{a.by}}</div>\n            </div>\n            <ion-note class="ellipsis">\n              <time *ngIf="a.time">{{ a.time * 1000 | amTimeAgo}}</time>\n            </ion-note>\n          </div>\n        </div>\n      </div>\n\n      <div class="line-divider"></div>\n\n      <ion-row justify-content-center class="background-button-content">\n        <div class="background-content">\n          <button ion-button clear (click)="viewOnBlockchain()">\n            {{\'View on blockchain\' | translate}}\n          </button>\n        </div>\n      </ion-row>\n\n    </ion-list>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/tx-details/tx-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_10__providers_filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */]])
], TxDetailsModal);

//# sourceMappingURL=tx-details.js.map

/***/ }),

/***/ 1029:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchTxModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_time_time__ = __webpack_require__(209);




// Providers



let SearchTxModalPage = class SearchTxModalPage {
    constructor(giftCardProvider, navParams, platformProvider, timeProvider, viewCtrl) {
        this.giftCardProvider = giftCardProvider;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.timeProvider = timeProvider;
        this.viewCtrl = viewCtrl;
        this.throttleSearch = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((search) => {
            this.txHistorySearchResults = this.filter(search).slice(0, this.HISTORY_SHOW_LIMIT);
        }, 1000);
        this.HISTORY_SHOW_LIMIT = 10;
        this.currentTxHistoryPage = 0;
        this.txHistorySearchResults = [];
        this.isCordova = this.platformProvider.isCordova;
        this.addressbook = this.navParams.data.addressbook;
        this.completeTxHistory = this.navParams.data.completeHistory;
        this.wallet = this.navParams.data.wallet;
        this.supportedCards = this.giftCardProvider.getSupportedCardMap();
    }
    close(txid) {
        this.viewCtrl.dismiss({ txid });
    }
    updateSearchInput(search) {
        this.currentTxHistoryPage = 0;
        this.throttleSearch(search);
    }
    filter(search) {
        this.filteredTxHistory = [];
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](search)) {
            this.txHistoryShowMore = false;
            return [];
        }
        this.filteredTxHistory = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.completeTxHistory, tx => {
            if (!tx.searcheableString)
                tx.searcheableString = this.computeSearchableString(tx);
            return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](tx.searcheableString, search.toLowerCase());
        });
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.HISTORY_SHOW_LIMIT ? true : false;
        return this.filteredTxHistory;
    }
    computeSearchableString(tx) {
        let addressBook = '';
        if (tx.addressTo && this.addressbook && this.addressbook[tx.addressTo])
            addressBook =
                this.addressbook[tx.addressTo].name ||
                    this.addressbook[tx.addressTo] ||
                    '';
        let searchableDate = this.computeSearchableDate(new Date(tx.time * 1000));
        let message = tx.message ? tx.message : '';
        let comment = tx.note ? tx.note.body : '';
        let addressTo = tx.addressTo ? tx.addressTo : '';
        let txid = tx.txid ? tx.txid : '';
        return (tx.amountStr +
            message +
            addressTo +
            addressBook +
            searchableDate +
            comment +
            txid)
            .toString()
            .toLowerCase();
    }
    computeSearchableDate(date) {
        let day = ('0' + date.getDate()).slice(-2).toString();
        let month = ('0' + (date.getMonth() + 1)).slice(-2).toString();
        let year = date.getFullYear();
        return [month, day, year].join('/');
    }
    moreSearchResults(loading) {
        setTimeout(() => {
            this.currentTxHistoryPage++;
            this.showHistory();
            loading.complete();
        }, 100);
    }
    showHistory() {
        this.txHistorySearchResults = this.filteredTxHistory
            ? this.filteredTxHistory.slice(0, (this.currentTxHistoryPage + 1) * this.HISTORY_SHOW_LIMIT)
            : [];
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.txHistorySearchResults.length;
    }
    trackByFn(index) {
        return index;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
SearchTxModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-search-tx-modal',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{\'Transactions\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-item class="search-container" no-lines padding>\n    <ion-input class="search-wrapper" placeholder="{{\'Search Transactions\' | translate}}" [(ngModel)]="search" (ngModelChange)="updateSearchInput(search)"></ion-input>\n  </ion-item>\n\n  <ion-list *ngIf="txHistorySearchResults && txHistorySearchResults[0]" class="bp-list tx-history">\n    <div>\n      <div *ngFor="let tx of txHistorySearchResults; trackBy: trackByFn; let i = index;">\n        <button ion-item (click)="close(tx.txid)">\n          <ion-icon item-start>\n            <div *ngIf="tx.confirmations == 0">\n              <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n            </div>\n            <div *ngIf="tx.confirmations > 0">\n              <span *ngIf="tx.customData && tx.customData.service">\n                <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'" width="40">\n                <img class="icon-services" src="assets/img/exchange-crypto/changelly-icon.svg" *ngIf="tx.customData.service == \'changelly\'" width="40">\n                <img-loader class="icon-services" *ngIf="tx.customData.service === \'amazon\'" src="https://tkcoin.org/gift-cards/assets/amazoncom/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                <img-loader class="icon-services" *ngIf="tx.customData.service === \'mercadolibre\'" src="https://tkcoin.org/gift-cards/assets/mercadolivre/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                <ng-container *ngIf="supportedCards | async as cardConfig">\n                  <img-loader class="icon-services" *ngIf="tx.customData.service === \'giftcards\'" [src]="cardConfig[tx.customData.giftCardName]?.icon" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                </ng-container>\n                <img class="icon-services" src="assets/img/tkcoin-card/icon-tkcoin.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n              </span>\n              <span *ngIf="!tx.customData || !tx.customData.service">\n                <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n              </span>\n            </div>\n          </ion-icon>\n\n          <div class="action" *ngIf="tx.confirmations == 0">\n            <span *ngIf="(tx.action == \'sent\') && !(addressbook && addressbook[tx.outputs[0].address])">{{\'Sending\'\n              | translate}}</span>\n            <span *ngIf="(tx.action == \'moved\') && !(addressbook && addressbook[tx.outputs[0].address])">{{\'Moving\'\n              | translate}}</span>\n            <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name\n              || addressbook[tx.outputs[0].address]}}</span>\n            <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Received\'\n              | translate}}</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\'">\n            <span *ngIf="!tx.message && (!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Sent\'\n              | translate}}</span>\n            <span *ngIf="tx.message">{{tx.message}}</span>\n            <span *ngIf="!tx.message && tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="!tx.message && addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\'))" translate>Sent to self</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n            <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n          </div>\n\n          <ion-note item-end text-end>\n            <div class="amount">\n              <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\'">{{tx.amount |\n                satToUnit: wallet.coin}}</span>\n              <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n            </div>\n            <div class="date">\n              <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n              <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM D,\n                YYYY\'}}</span>\n            </div>\n          </ion-note>\n        </button>\n      </div>\n    </div>\n    <div class="txs-count" *ngIf="txHistoryShowMore">\n      <span>{{filteredTxHistory.length - txHistorySearchResults.length}} more</span>\n      &nbsp;\n      <ion-icon name="arrow-down"></ion-icon>\n    </div>\n  </ion-list>\n\n  <ion-infinite-scroll *ngIf="txHistoryShowMore" (ionInfinite)="moreSearchResults($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], SearchTxModalPage);

//# sourceMappingURL=search-tx-modal.js.map

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(73);
var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);

var Signature = function Signature(r, s) {
  if (!(this instanceof Signature)) {
    return new Signature(r, s);
  }
  if (r instanceof BN) {
    this.set({
      r: r,
      s: s
    });
  } else if (r) {
    var obj = r;
    this.set(obj);
  }
};

/* jshint maxcomplexity: 7 */
Signature.prototype.set = function(obj) {
  this.r = obj.r || this.r || undefined;
  this.s = obj.s || this.s || undefined;

  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]
  this.compressed = typeof obj.compressed !== 'undefined' ?
    obj.compressed : this.compressed; //whether the recovered pubkey is compressed
  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;
  return this;
};

Signature.fromCompact = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');

  var sig = new Signature();

  var compressed = true;
  var i = buf.slice(0, 1)[0] - 27 - 4;
  if (i < 0) {
    compressed = false;
    i = i + 4;
  }

  var b2 = buf.slice(1, 33);
  var b3 = buf.slice(33, 65);

  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));
  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));
  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));

  sig.compressed = compressed;
  sig.i = i;
  sig.r = BN.fromBuffer(b2);
  sig.s = BN.fromBuffer(b3);

  return sig;
};

Signature.fromDER = Signature.fromBuffer = function(buf, strict) {
  var obj = Signature.parseDER(buf, strict);
  var sig = new Signature();

  sig.r = obj.r;
  sig.s = obj.s;

  return sig;
};

// The format used in a tx
Signature.fromTxFormat = function(buf) {
  var nhashtype = buf.readUInt8(buf.length - 1);
  var derbuf = buf.slice(0, buf.length - 1);
  var sig = new Signature.fromDER(derbuf, false);
  sig.nhashtype = nhashtype;
  return sig;
};

Signature.fromString = function(str) {
  var buf = Buffer.from(str, 'hex');
  return Signature.fromDER(buf);
};


/**
 * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.
 */
Signature.parseDER = function(buf, strict) {
  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));
  if (_.isUndefined(strict)) {
    strict = true;
  }

  var header = buf[0];
  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));

  var length = buf[1];
  var buflength = buf.slice(2).length;
  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));

  length = length < buflength ? length : buflength;

  var rheader = buf[2 + 0];
  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));

  var rlength = buf[2 + 1];
  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
  var r = BN.fromBuffer(rbuf);
  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;
  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));

  var sheader = buf[2 + 2 + rlength + 0];
  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));

  var slength = buf[2 + 2 + rlength + 1];
  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
  var s = BN.fromBuffer(sbuf);
  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;
  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));

  var sumlength = 2 + 2 + rlength + 2 + slength;
  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));

  var obj = {
    header: header,
    length: length,
    rheader: rheader,
    rlength: rlength,
    rneg: rneg,
    rbuf: rbuf,
    r: r,
    sheader: sheader,
    slength: slength,
    sneg: sneg,
    sbuf: sbuf,
    s: s
  };

  return obj;
};


Signature.prototype.toCompact = function(i, compressed) {
  i = typeof i === 'number' ? i : this.i;
  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;

  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
    throw new Error('i must be equal to 0, 1, 2, or 3');
  }

  var val = i + 27 + 4;
  if (compressed === false) {
    val = val - 4;
  }
  var b1 = Buffer.from([val]);
  var b2 = this.r.toBuffer({
    size: 32
  });
  var b3 = this.s.toBuffer({
    size: 32
  });
  return Buffer.concat([b1, b2, b3]);
};

Signature.prototype.toBuffer = Signature.prototype.toDER = function() {
  var rnbuf = this.r.toBuffer();
  var snbuf = this.s.toBuffer();

  var rneg = rnbuf[0] & 0x80 ? true : false;
  var sneg = snbuf[0] & 0x80 ? true : false;

  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;
  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;

  var rlength = rbuf.length;
  var slength = sbuf.length;
  var length = 2 + rlength + 2 + slength;
  var rheader = 0x02;
  var sheader = 0x02;
  var header = 0x30;

  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);
  return der;
};

Signature.prototype.toString = function() {
  var buf = this.toDER();
  return buf.toString('hex');
};

/**
 * This function is translated from bitcoind's IsDERSignature and is used in
 * the script interpreter.  This "DER" format actually includes an extra byte,
 * the nhashtype, at the end. It is really the tx format, not DER format.
 *
 * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
 * Where R and S are not negative (their first byte has its highest bit not set), and not
 * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
 * in which case a single 0 byte is necessary and even required).
 *
 * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
 */
Signature.isTxDER = function(buf) {
  if (buf.length < 9) {
    //  Non-canonical signature: too short
    return false;
  }
  if (buf.length > 73) {
    // Non-canonical signature: too long
    return false;
  }
  if (buf[0] !== 0x30) {
    //  Non-canonical signature: wrong type
    return false;
  }
  if (buf[1] !== buf.length - 3) {
    //  Non-canonical signature: wrong length marker
    return false;
  }
  var nLenR = buf[3];
  if (5 + nLenR >= buf.length) {
    //  Non-canonical signature: S length misplaced
    return false;
  }
  var nLenS = buf[5 + nLenR];
  if ((nLenR + nLenS + 7) !== buf.length) {
    //  Non-canonical signature: R+S length mismatch
    return false;
  }

  var R = buf.slice(4);
  if (buf[4 - 2] !== 0x02) {
    //  Non-canonical signature: R value type mismatch
    return false;
  }
  if (nLenR === 0) {
    //  Non-canonical signature: R length is zero
    return false;
  }
  if (R[0] & 0x80) {
    //  Non-canonical signature: R value negative
    return false;
  }
  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {
    //  Non-canonical signature: R value excessively padded
    return false;
  }

  var S = buf.slice(6 + nLenR);
  if (buf[6 + nLenR - 2] !== 0x02) {
    //  Non-canonical signature: S value type mismatch
    return false;
  }
  if (nLenS === 0) {
    //  Non-canonical signature: S length is zero
    return false;
  }
  if (S[0] & 0x80) {
    //  Non-canonical signature: S value negative
    return false;
  }
  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {
    //  Non-canonical signature: S value excessively padded
    return false;
  }
  return true;
};

/**
 * Compares to bitcoind's IsLowDERSignature
 * See also ECDSA signature algorithm which enforces this.
 * See also BIP 62, "low S values in signatures"
 */
Signature.prototype.hasLowS = function() {
  if (this.s.lt(new BN(1)) ||
    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {
    return false;
  }
  return true;
};

/**
 * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.
 * Translated from bitcoind's IsDefinedHashtypeSignature
 */
Signature.prototype.hasDefinedHashtype = function() {
  if (!JSUtil.isNaturalNumber(this.nhashtype)) {
    return false;
  }
  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit
  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;
  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {
    return false;
  }
  return true;
};

Signature.prototype.toTxFormat = function() {
  var derbuf = this.toDER();
  var buf = Buffer.alloc(1);
  buf.writeUInt8(this.nhashtype, 0);
  return Buffer.concat([derbuf, buf]);
};

Signature.SIGHASH_ALL = 0x01;
Signature.SIGHASH_NONE = 0x02;
Signature.SIGHASH_SINGLE = 0x03;
Signature.SIGHASH_ANYONECANPAY = 0x80;

module.exports = Signature;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1030:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletBalanceModal; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);





let WalletBalanceModal = class WalletBalanceModal {
    constructor(currencyProvider, logger, navParams, viewCtrl) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.status = this.navParams.data.status;
        this.coinName = this.currencyProvider.getCoinName(this.status.wallet.coin);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletBalanceModal');
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
WalletBalanceModal = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-balance',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/'<wide-header-page title="{{\'Spendable balance\' | translate}}" hideBackButton="true">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <label-tip type="warn" header="no-header" class="no-arrowhead">\n        <div label-tip-body>\n          {{\'All of your {coinName} wallet balance may not be available for immediate spending.\' | translate: {coinName: coinName} }}\n        </div>\n      </label-tip>\n      <ion-item>\n        <div class="balance-container">\n          <div class="title">\n            <img src="assets/img/icon-sigma.svg" />\n            <div translate>Total</div>\n          </div>\n          <div class="balance">\n            <span class="total">\n              {{status.totalBalanceStr}}\n            </span>\n            <div>\n              <span class="fiat">\n                {{status.totalBalanceAlternative}} {{status.alternativeIsoCode}}\n              </span>\n            </div>\n          </div>\n        </div>\n      </ion-item>\n      <label-tip type="info" header="no-header">\n        <div label-tip-body>\n          {{\'The total amount of {coinName} stored in this wallet.\' | translate: {coinName: coinName} }}\n        </div>\n      </label-tip>\n\n      <ion-item>\n        <div class="balance-container">\n          <div class="title">\n            <ion-icon ios="ios-checkmark" md="md-checkmark"></ion-icon>\n            <div translate>Available</div>\n          </div>\n          <div class="balance">\n            <span class="available">\n              {{status.spendableBalanceStr}}\n            </span>\n            <div>\n              <span class="fiat">\n                {{status.spendableBalanceAlternative}} {{status.alternativeIsoCode}}\n              </span>\n            </div>\n          </div>\n        </div>\n      </ion-item>\n      <label-tip type="info" header="no-header">\n        <div label-tip-body>\n          {{\'The amount of {coinName} immediately spendable from this wallet.\' | translate: {coinName: coinName} }}\n        </div>\n      </label-tip>\n\n      <ion-item>\n        <div class="balance-container">\n          <div class="title">\n            <img src="assets/img/icon-confirming-clear.svg" />\n            <div translate>Confirming</div>\n          </div>\n          <div class="balance">\n            <span class="confirming">\n              {{status.pendingBalanceStr}}\n            </span>\n            <div>\n              <span class="fiat">\n                {{status.pendingBalanceAlternative}} {{status.alternativeIsoCode}}\n              </span>\n            </div>\n          </div>\n        </div>\n      </ion-item>\n      <label-tip type="info" header="no-header">\n        <div label-tip-body>\n          {{\'The amount of {coinName} stored in this wallet with less than 1 blockchain confirmation.\' | translate: {coinName: coinName} }}\n        </div>\n      </label-tip>\n\n      <ion-item *ngIf="(coinName == \'XRP\' && status.lockedBalanceSat * status.satToUnit >= 20) || coinName != \'XRP\'">\n        <div class="balance-container">\n          <div class="title">\n            <img src="assets/img/icon-lock.svg" />\n            <div translate>Locked</div>\n          </div>\n          <div class="balance">\n            <span *ngIf="coinName != \'XRP\'" class="locked">\n              {{status.lockedBalanceStr}}\n            </span>\n            <span *ngIf="coinName == \'XRP\'" class="locked">\n              {{status.lockedBalanceSat * status.satToUnit - 20}}\n            </span>\n            <div>\n              <span class="fiat">\n                {{status.lockedBalanceAlternative}} {{status.alternativeIsoCode}}\n              </span>\n            </div>\n          </div>\n        </div>\n      </ion-item>\n      <label-tip type="info" header="no-header" *ngIf="(coinName == \'XRP\' && status.lockedBalanceSat * status.satToUnit >= 20) || coinName != \'XRP\'">\n        <div label-tip-body>\n          {{\'The amount of {coinName} stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.\' | translate: {coinName: coinName} }}\n        </div>\n      </label-tip>\n\n      <ion-item *ngIf="coinName == \'XRP\' && status.lockedBalanceSat * status.satToUnit >= 20">\n        <div class="balance-container">\n          <div class="title">\n            <img src="assets/img/icon-lock.svg" />\n            <div translate>XRP Locked Balance</div>\n          </div>\n          <div class="balance">\n            <span class="locked">\n              20 XRP\n            </span>\n            <div>\n              <span class="fiat">\n                {{status.lockedBalanceAlternative}} {{status.alternativeIsoCode}}\n              </span>\n            </div>\n          </div>\n        </div>\n      </ion-item>\n      <label-tip type="info" header="no-header" *ngIf="coinName == \'XRP\' && status.lockedBalanceSat * status.satToUnit >= 20">\n        <div label-tip-body translate>\n          The XRP ledger requires that all wallets maintain a minimum balance of 20 XRP. This non-refundable 20 XRP will remain permanently locked in your wallet.\n        </div>\n      </label-tip>\n\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], WalletBalanceModal);

//# sourceMappingURL=wallet-balance.js.map

/***/ }),

/***/ 1032:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser-dynamic/esm5/platform-browser-dynamic.js + 1 modules
var platform_browser_dynamic = __webpack_require__(1033);

// EXTERNAL MODULE: ./node_modules/web-animations-js/web-animations.min.js
var web_animations_min = __webpack_require__(1036);
var web_animations_min_default = /*#__PURE__*/__webpack_require__.n(web_animations_min);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/http.js
var esm5_http = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/esm5/animations.js + 1 modules
var animations = __webpack_require__(1037);

// EXTERNAL MODULE: ./node_modules/ionic-image-loader/dist/index.js + 4 modules
var dist = __webpack_require__(409);

// EXTERNAL MODULE: ./node_modules/ngx-markdown/dist/lib/index.js
var lib = __webpack_require__(616);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// EXTERNAL MODULE: ./node_modules/ngx-text-overflow-clamp/dist/index.js + 2 modules
var ngx_text_overflow_clamp_dist = __webpack_require__(1057);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/esm5/platform-browser.js
var platform_browser = __webpack_require__(146);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/@ngx-translate/core.es5.js
var core_es5 = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/angular2-moment/index.js
var angular2_moment = __webpack_require__(1061);
var angular2_moment_default = /*#__PURE__*/__webpack_require__.n(angular2_moment);

// EXTERNAL MODULE: ./node_modules/ngx-barcode/index.js
var ngx_barcode = __webpack_require__(1064);

// EXTERNAL MODULE: ./node_modules/ngx-qrcode2/index.js
var ngx_qrcode2 = __webpack_require__(1100);

// EXTERNAL MODULE: ./src/environments/index.ts + 1 modules
var environments = __webpack_require__(170);

// EXTERNAL MODULE: ./node_modules/@ionic-native/device/index.js
var _ionic_native_device = __webpack_require__(171);

// EXTERNAL MODULE: ./node_modules/@ionic-native/screen-orientation/index.js
var screen_orientation = __webpack_require__(782);

// EXTERNAL MODULE: ./node_modules/@ionic-native/splash-screen/index.js
var splash_screen = __webpack_require__(250);

// EXTERNAL MODULE: ./node_modules/@ionic-native/status-bar/index.js
var status_bar = __webpack_require__(319);

// EXTERNAL MODULE: ./node_modules/@ionic-native/user-agent/index.js
var user_agent = __webpack_require__(783);

// EXTERNAL MODULE: ./node_modules/rxjs/Rx.js
var Rx = __webpack_require__(90);
var Rx_default = /*#__PURE__*/__webpack_require__.n(Rx);

// EXTERNAL MODULE: ./src/providers/index.ts + 2 modules
var providers = __webpack_require__(27);

// EXTERNAL MODULE: ./src/providers/persistence/persistence.ts + 3 modules
var persistence = __webpack_require__(20);

// EXTERNAL MODULE: ./src/providers/external-link/external-link.ts
var external_link = __webpack_require__(21);

// CONCATENATED MODULE: ./src/components/advertising/advertising.ts




let AdvertisingComponent = class AdvertisingComponent {
    constructor(externalLinkProvider, viewCtrl, navParams) {
        this.externalLinkProvider = externalLinkProvider;
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.advertising = this.navParams.data.advertising;
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openInBrowser() {
        this.externalLinkProvider.open(this.advertising.takeover_url);
        this.close();
    }
};
AdvertisingComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'advertising',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/advertising/advertising.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-buttons right>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content text-center class="add-bottom-safe-area" no-bounce>\n  <ion-grid (click)="openInBrowser()">\n    <ion-row>\n      <ion-col>\n        <img [src]="advertising?.takeover_image">\n      </ion-col>\n    </ion-row>\n  </ion-grid>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/advertising/advertising.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [external_link["a" /* ExternalLinkProvider */],
        ionic_angular["t" /* ViewController */],
        ionic_angular["n" /* NavParams */]])
], AdvertisingComponent);

//# sourceMappingURL=advertising.js.map
// CONCATENATED MODULE: ./src/constants.ts
const CARD_IAB_CONFIG = 'directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no,hidden=yes,clearcache=yes,hidespinner=yes,disallowoverscroll=yes,zoom=no,transitionstyle=crossdissolve';
//# sourceMappingURL=constants.js.map
// EXTERNAL MODULE: ./src/pages/add-wallet/add-wallet.ts
var add_wallet = __webpack_require__(499);

// EXTERNAL MODULE: ./src/pages/add/copayers/copayers.ts
var copayers = __webpack_require__(232);

// EXTERNAL MODULE: ./src/pages/add/import-wallet/import-wallet.ts
var import_wallet = __webpack_require__(166);

// EXTERNAL MODULE: ./src/pages/add/join-wallet/join-wallet.ts
var join_wallet = __webpack_require__(298);

// EXTERNAL MODULE: ./src/pages/exchange-crypto/exchange-crypto.ts
var exchange_crypto = __webpack_require__(517);

// EXTERNAL MODULE: ./src/providers/touchid/touchid.ts
var touchid = __webpack_require__(205);

// CONCATENATED MODULE: ./src/pages/fingerprint/fingerprint.ts



// Providers

let FingerprintModalPage = class FingerprintModalPage {
    constructor(touchid, platform, viewCtrl) {
        this.touchid = touchid;
        this.platform = platform;
        this.viewCtrl = viewCtrl;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.checkFingerprint();
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.unregister();
            this.viewCtrl.dismiss();
        });
    }
};
FingerprintModalPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-fingerprint',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/fingerprint/fingerprint.html"*/'<ion-content no-bounce fullscreen>\n  <div class="fingerprint-header">\n    <div class="title">\n      <div>\n        {{\'Unlock App\' | translate}}\n      </div>\n    </div>\n    <div class="icon-container">\n      <ion-icon class="app-icon">\n        <img src="assets/img/app/icon-flat.svg" />\n      </ion-icon>\n    </div>\n  </div>\n  <div class="fingerprint-bottom">\n    <button class="button-standard" ion-button (click)="checkFingerprint()">\n      <span>{{\'Scan again\' | translate}}</span>\n      <ion-icon name="finger-print" item-end></ion-icon>\n    </button>\n  </div>\n\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/fingerprint/fingerprint.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [touchid["a" /* TouchIdProvider */],
        ionic_angular["p" /* Platform */],
        ionic_angular["t" /* ViewController */]])
], FingerprintModalPage);

//# sourceMappingURL=fingerprint.js.map
// EXTERNAL MODULE: ./src/pages/integrations/coinbase/coinbase.ts
var coinbase = __webpack_require__(299);

// EXTERNAL MODULE: ./src/pages/integrations/invoice/select-invoice/select-invoice.ts
var select_invoice = __webpack_require__(518);

// EXTERNAL MODULE: ./src/pages/integrations/simplex/simplex.ts
var simplex = __webpack_require__(397);

// EXTERNAL MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-card-intro/tkcoin-card-intro.ts
var tkcoin_card_intro = __webpack_require__(400);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// EXTERNAL MODULE: ./node_modules/@angular/animations/esm5/animations.js
var esm5_animations = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js
var esm5_forms = __webpack_require__(37);

// EXTERNAL MODULE: ./src/providers/card-phases/card-phases.ts
var card_phases = __webpack_require__(970);

// EXTERNAL MODULE: ./src/providers/popup/popup.ts
var popup = __webpack_require__(25);

// EXTERNAL MODULE: ./src/providers/tkcoin-account/tkcoin-account.ts
var tkcoin_account = __webpack_require__(379);

// EXTERNAL MODULE: ./src/providers/tkcoin-card/tkcoin-card.ts
var tkcoin_card = __webpack_require__(208);

// CONCATENATED MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-card-phases/phase-one/phase-one-intro-page/phase-one-intro-page.ts













const AllowedCountries = [
    'FR',
    'DE',
    'NL',
    'IT',
    'ES',
    'PL',
    'AT',
    'BE',
    'CY',
    'EE',
    'FI',
    'GR',
    'IE',
    'LV',
    'LT',
    'LU',
    'MT',
    'PT',
    'SK',
    'BG',
    'HR',
    'CZ',
    'DK',
    'HU',
    'RO',
    'SE',
    'CH',
    'GB',
    'NO',
    'GI',
    'AD',
    'MC',
    'SM',
    'LI',
    'ISL',
    'SI',
    'CA',
    'US',
    'AUS',
    'AU'
];
let phase_one_intro_page_PhaseOneCardIntro = class PhaseOneCardIntro {
    constructor(translate, actionSheetCtrl, bitPayAccountProvider, bitPayCardProvider, cardPhasesProvider, externalLinkProvider, navCtrl, popupProvider, persistenceProvider, changeRef) {
        this.translate = translate;
        this.actionSheetCtrl = actionSheetCtrl;
        this.bitPayAccountProvider = bitPayAccountProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.cardPhasesProvider = cardPhasesProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.changeRef = changeRef;
        this.country = 'US';
        this.countryList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
        this.notifyForm = new esm5_forms["c" /* FormGroup */]({
            email: new esm5_forms["b" /* FormControl */]('', esm5_forms["h" /* Validators */].compose([
                esm5_forms["h" /* Validators */].required,
                esm5_forms["h" /* Validators */].pattern(/(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-Za-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/)
            ])),
            agreement: new esm5_forms["b" /* FormControl */](false, esm5_forms["h" /* Validators */].requiredTrue)
        });
        this.persistenceProvider.getCountries().then(data => {
            if (data) {
                this.countryList = data.filter(c => AllowedCountries.includes(c.shortCode));
            }
        });
    }
    ionViewWillEnter() {
        this.bitPayAccountProvider.getAccounts((err, accounts) => {
            if (err) {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            }
            this.accounts = accounts;
        });
    }
    bitPayCardInfo() {
        let url = 'https://tkcoin.org/visa/faq';
        this.externalLinkProvider.open(url);
    }
    goBack() {
        this.navCtrl.pop();
    }
    joinList() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const status = yield this.persistenceProvider.getWaitingListStatus();
            if (status) {
                this.country = status.split('=')[1];
                this.complete = true;
            }
            else {
                this.joinWaitlist = true;
            }
            this.changeRef.detectChanges();
        });
    }
    addMe() {
        const email = this.notifyForm.get('email').value;
        this.cardPhasesProvider.notify(email, this.country).subscribe(val => {
            if (val['data']['success']) {
                this.complete = true;
                setTimeout(() => {
                    this.goBack();
                    this.persistenceProvider.setWaitingListStatus(`onList?country=${this.country}`);
                }, 2000);
            }
        });
    }
    openPolicy() {
        let url = 'https://tkcoin.org/about/privacy';
        this.externalLinkProvider.open(url);
    }
    orderTKCoinCard() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.bitPayCardProvider.logEvent('legacycard_order', {});
            let url = 'https://tkcoin.org/visa/get-started';
            this.externalLinkProvider.open(url);
        });
    }
    connectTKCoinCard() {
        this.bitPayCardProvider.logEvent('legacycard_connect', {});
        if (this.accounts.length == 0) {
            this.startPairTKCoinAccount();
        }
        else {
            this.showAccountSelector();
        }
    }
    startPairTKCoinAccount() {
        this.navCtrl.popToRoot({ animate: false }); // Back to Root
        let url = 'https://tkcoin.org/visa/dashboard/add-to-tkcoin-wallet-confirm';
        this.externalLinkProvider.open(url);
    }
    showAccountSelector() {
        let options = [];
        lodash["forEach"](this.accounts, account => {
            options.push({
                text: (account.givenName || account.familyName) +
                    ' (' +
                    account.email +
                    ')',
                handler: () => {
                    this.onAccountSelect(account);
                }
            });
        });
        // Add account
        options.push({
            text: this.translate.instant('Add account'),
            handler: () => {
                this.onAccountSelect();
            }
        });
        // Cancel
        options.push({
            text: this.translate.instant('Cancel'),
            role: 'cancel'
        });
        let actionSheet = this.actionSheetCtrl.create({
            title: this.translate.instant('From TKCoin account'),
            buttons: options
        });
        actionSheet.present();
    }
    onAccountSelect(account) {
        if (lodash["isUndefined"](account)) {
            this.startPairTKCoinAccount();
        }
        else {
            this.bitPayCardProvider.sync(account.apiContext, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    return;
                }
                this.navCtrl.pop();
            });
        }
    }
};
phase_one_intro_page_PhaseOneCardIntro = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-tkcoin-phase-one-card-intro',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-phases/phase-one/phase-one-intro-page/phase-one-intro-page.html"*/'<ion-header no-border>\n  <ion-navbar>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="phaseOne__img__container">\n    <img class="phaseOne__img" src="assets/img/card-phase-release/tkcoin-card-spaceman-discover.svg" />\n  </div>\n\n\n  <ng-container *ngIf="complete; else start">\n    <div class="phaseOne__complete" @fade>\n\n      <ng-container *ngIf="country === \'US\' else thanks">\n        <div class="phaseOne__content__title">\n          <span translate>You\'re on the list!</span>\n        </div>\n        <img src="assets/img/card-phase-release/success.svg" />\n        <p class="phaseOne__content__description" translate>\n          We\'ll notify you as soon as the card is ready.\n        </p>\n      </ng-container>\n      <ng-template #thanks>\n        <div class="phaseOne__content__title">\n          <span translate>Thanks!</span>\n        </div>\n        <img src="assets/img/card-phase-release/success.svg" />\n        <p class="phaseOne__content__description phaseOne__content--center" translate>\n          We\'ll let you know as soon as the BitPay Card<br> is available in your area.\n        </p>\n      </ng-template>\n\n    </div>\n  </ng-container>\n\n  <ng-template #start>\n    <div class="phaseOne__content">\n      <div>\n        <div class="phaseOne__content__title">\n          <span translate>Something exciting is arriving</span>\n        </div>\n        <p class="phaseOne__content__description" translate>\n          Join the waitlist and be the first to experience our new card.\n        </p>\n      </div>\n\n      <ng-container *ngIf="joinWaitlist else main">\n\n        <ng-container *ngIf="!countrySelected else enterEmailAndConfirm">\n          <div @fade class="phaseOne__country">\n            <div class="phaseOne__select__container">\n              <div class="phaseOne__label">\n                <label>Select Country</label>\n              </div>\n              <div class="phaseOne__select">\n                <select [(ngModel)]="country">\n                  <option *ngFor="let country of countryList" [value]="country.shortCode">{{country.name}}</option>\n                </select>\n              </div>\n            </div>\n            <button ion-button class="button-standard" [disabled]="false" (click)="countrySelected = true">\n              {{\'Continue\' | translate}}\n            </button>\n          </div>\n        </ng-container>\n\n        <ng-template #enterEmailAndConfirm>\n          <div @fade>\n            <form [formGroup]="notifyForm">\n              <ion-item class="phaseOne__form-item phaseOne__form__dark phaseOne--border-overwrite">\n                <ion-label floating>{{ \'Email\' | translate }}</ion-label>\n                <ion-input mode="md" formControlName="email" type="email"></ion-input>\n              </ion-item>\n\n              <ion-item class="phaseOne__form-item phaseOne__form-group phaseOne__form-privacy">\n                <ion-label class="phaseOne__form-group__label">\n                  <span translate>TKCoin would also like to send you marketing and promotional communications about our products, services and special promotions. You can change your preferences at any time in Settings in our app or by contacting us as set forth in our</span>\n                  <span translate class="phaseOne__form__link" (click)="openPolicy()"> Privacy Notice</span>.\n                </ion-label>\n              </ion-item>\n\n              <ion-item class="phaseOne__form-item phaseOne__form-group">\n                <ion-label (click)="openPolicy()" class="phaseOne__form-group__label phaseOne__form-group--large-lh">\n                  <span translate>Yes, please use my email address to send me exclusive email offers.</span>\n                </ion-label>\n                <ion-toggle formControlName="agreement" color="success"></ion-toggle>\n              </ion-item>\n            </form>\n\n            <button ion-button class="button-standard" [disabled]="notifyForm.invalid" (click)="addMe()">\n              {{\'Add Me\' | translate}}\n            </button>\n          </div>\n\n        </ng-template>\n\n        <div class="phaseOne__form" @fade>\n\n        </div>\n      </ng-container>\n\n      <ng-template #main>\n        <div class="phaseOne__ctas" *ngIf="!joinWaitlist" @fade>\n          <button ion-button class="button-standard" (click)="joinList()">\n            {{\'Continue\' | translate}}\n          </button>\n        </div>\n      </ng-template>\n    </div>\n  </ng-template>\n\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-phases/phase-one/phase-one-intro-page/phase-one-intro-page.html"*/,
        animations: [
            Object(esm5_animations["l" /* trigger */])('fade', [
                Object(esm5_animations["k" /* transition */])(':enter', [
                    Object(esm5_animations["j" /* style */])({ opacity: 0, transform: 'translateY(20px)' }),
                    Object(esm5_animations["e" /* animate */])('400ms 100ms ease', Object(esm5_animations["j" /* style */])({ opacity: 1, transform: 'translateY(0)' }))
                ])
            ])
        ]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core_es5["f" /* TranslateService */],
        ionic_angular["a" /* ActionSheetController */],
        tkcoin_account["a" /* TKCoinAccountProvider */],
        tkcoin_card["a" /* TKCoinCardProvider */],
        card_phases["a" /* CardPhasesProvider */],
        external_link["a" /* ExternalLinkProvider */],
        ionic_angular["m" /* NavController */],
        popup["a" /* PopupProvider */],
        persistence["b" /* PersistenceProvider */],
        core["ChangeDetectorRef"]])
], phase_one_intro_page_PhaseOneCardIntro);

//# sourceMappingURL=phase-one-intro-page.js.map
// EXTERNAL MODULE: ./src/pages/integrations/wallet-connect/wallet-connect.ts
var wallet_connect = __webpack_require__(508);

// EXTERNAL MODULE: ./src/pages/integrations/wyre/wyre.ts
var wyre = __webpack_require__(507);

// EXTERNAL MODULE: ./src/pages/onboarding/disclaimer/disclaimer.ts
var disclaimer = __webpack_require__(297);

// EXTERNAL MODULE: ./src/providers/action-sheet/action-sheet.ts
var action_sheet = __webpack_require__(30);

// EXTERNAL MODULE: ./src/providers/config/config.ts
var config_config = __webpack_require__(11);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger_logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform_platform = __webpack_require__(13);

// EXTERNAL MODULE: ./src/pages/add/select-currency/select-currency.ts
var select_currency = __webpack_require__(186);

// EXTERNAL MODULE: ./src/pages/pin/pin-modal/pin-modal.ts
var pin_modal = __webpack_require__(300);

// CONCATENATED MODULE: ./src/pages/onboarding/lock-method/lock-method.ts



// Providers




// Pages



let lock_method_LockMethodPage = class LockMethodPage {
    constructor(navCtrl, navParams, logger, modalCtrl, touchIdProvider, actionSheetProvider, configProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.touchIdProvider = touchIdProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.pinMethodSelected = false;
        this.pageMap = {
            SelectCurrencyPage: select_currency["a" /* SelectCurrencyPage */],
            ImportWalletPage: import_wallet["a" /* ImportWalletPage */]
        };
        this.nextView = this.navParams.data.nextView;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: LockMethodPage');
    }
    ionViewWillEnter() {
        this.checkLockOptions();
    }
    checkLockOptions() {
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            if (isAvailable) {
                this.biometricMethod =
                    this.touchIdProvider.getIosBiometricMethod() === 'face'
                        ? 'faceId'
                        : 'fingerprint';
            }
            else {
                this.pinMethodSelected = true;
                this.openPinModal();
            }
        });
    }
    verifyBiometricLockMethod() {
        if (this.biometricMethod === 'fingerprint' ||
            this.biometricMethod === 'faceId') {
            this.touchIdProvider.check().then(() => {
                let lock = { method: 'fingerprint', value: null, bannedUntil: null };
                this.configProvider.set({ lock });
                this.navCtrl.push(this.pageMap[this.nextView.name], this.nextView.params);
            });
        }
    }
    openPinModal() {
        const modal = this.modalCtrl.create(pin_modal["a" /* PinModalPage */], {
            action: 'pinSetUp'
        }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(cancelClicked => {
            if (cancelClicked) {
                this.pinMethodSelected = false;
                if (!this.biometricMethod)
                    this.navCtrl.pop();
            }
            else
                this.navCtrl.push(this.pageMap[this.nextView.name], this.nextView.params);
        });
    }
    showInfoSheet(infoSheetType) {
        const infoSheet = this.actionSheetProvider.createInfoSheet(infoSheetType);
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.pinMethodSelected = true;
                this.openPinModal();
            }
        });
    }
};
lock_method_LockMethodPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-lock-method',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/lock-method/lock-method.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton transparent></ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="lock-method" *ngIf="biometricMethod == \'faceId\' && !pinMethodSelected">\n    <div class="lock-method-info">\n      <div class="img-container">\n        <img src="assets/img/onboarding/faceId.svg" />\n      </div>\n      <div class="info">\n        <h3 class="title" translate>Use facial recognition to unlock?</h3>\n        <div class="text" translate>Unlock TKCoin faster by setting up facial recognition.</div>\n      </div>\n    </div>\n  </div>\n  <div class="lock-method" *ngIf="biometricMethod == \'fingerprint\' && !pinMethodSelected">\n    <div class="lock-method-info">\n      <div class="img-container">\n        <img src="assets/img/onboarding/touchId.svg" />\n      </div>\n      <div class="info">\n        <h3 class="title" translate>Use fingerprint authentication to unlock?</h3>\n        <div class="text" translate>Unlock TKCoin faster by setting up fingerprint authentication.</div>\n      </div>\n    </div>\n  </div>\n</ion-content>\n<ion-footer no-border *ngIf="biometricMethod && !pinMethodSelected">\n  <ion-toolbar>\n    <button ion-button class="button-standard no-margin-bottom" (click)="verifyBiometricLockMethod()">\n      {{\'Continue\' | translate}}\n    </button>\n    <button ion-button clear color="primary" class="button-standard" (click)="showInfoSheet(\'pincode-info\')">\n      {{\'No thanks\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/lock-method/lock-method.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        logger_logger["a" /* Logger */],
        ionic_angular["l" /* ModalController */],
        touchid["a" /* TouchIdProvider */],
        action_sheet["a" /* ActionSheetProvider */],
        config_config["a" /* ConfigProvider */]])
], lock_method_LockMethodPage);

//# sourceMappingURL=lock-method.js.map
// CONCATENATED MODULE: ./src/pages/onboarding/feature-education/feature-education.ts



// Providers




// Pages



let feature_education_FeatureEducationPage = class FeatureEducationPage {
    constructor(navCtrl, logger, actionSheetProvider, configProvider, platformProvider) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.platformProvider = platformProvider;
        this.pageMap = {
            SelectCurrencyPage: select_currency["a" /* SelectCurrencyPage */],
            ImportWalletPage: import_wallet["a" /* ImportWalletPage */]
        };
        this.params = {
            isOnboardingFlow: true,
            isZeroState: true
        };
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: FeatureEducationPage');
    }
    ionViewWillLoad() {
        this.featureEducationSlides.lockSwipeToPrev(true);
    }
    slideChanged() {
        // Disable first bounce
        let currentIndex = this.featureEducationSlides.getActiveIndex();
        currentIndex == 0
            ? this.featureEducationSlides.lockSwipeToPrev(true)
            : this.featureEducationSlides.lockSwipeToPrev(false);
    }
    goToNextPage(nextViewName) {
        const config = this.configProvider.get();
        if ((config.lock && config.lock.method) || !this.isCordova)
            this.navCtrl.push(this.pageMap[nextViewName], this.params);
        else
            this.showInfoSheet(nextViewName);
    }
    showInfoSheet(nextViewName) {
        const infoSheet = this.actionSheetProvider.createInfoSheet('protect-money');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option)
                this.goToLockMethodPage(nextViewName);
        });
    }
    goToLockMethodPage(name) {
        let nextView = {
            name,
            params: this.params
        };
        this.navCtrl.push(lock_method_LockMethodPage, { nextView });
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('featureEducationSlides'),
    tslib_es6["__metadata"]("design:type", ionic_angular["q" /* Slides */])
], feature_education_FeatureEducationPage.prototype, "featureEducationSlides", void 0);
feature_education_FeatureEducationPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-feature-education',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/feature-education/feature-education.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton transparent></ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-slides (ionSlideDidChange)="slideChanged()" #featureEducationSlides [pager]="!featureEducationSlides.isEnd()" class="onboarding-slides">\n    <!-- TODO FIX REMOVE UNNEEDED SLIDES\n      <ion-slide *ngIf="appName !== \'Copay\'">\n      <ion-content>\n        <div class="slide-info">\n          <div class="img-container">\n            <img src="assets/img/onboarding/feature-education-1.svg" />\n          </div>\n          <div class="info">\n            <h3 class="title" translate>Turn crypto into dollars using our BitPay Card.</h3>\n            <div class="text" translate>\n              Instantly reload your card balance with no conversion fees. Powered by our competitive exchange rates.\n              <div class="note" translate>\n                *Currently available in the USA. More countries coming soon.\n              </div>\n            </div>\n          </div>\n        </div>\n      </ion-content>\n    </ion-slide>\n    -->\n    <ion-slide *ngIf="appName !== \'Copay\'">\n      <ion-content>\n        <div class="slide-info">\n          <div class="img-container">\n            <img class="tour-2" src="assets/img/onboarding/feature-education-2.svg" />\n          </div>\n          <div class="info">\n            <h3 class="title" translate>EDUCoin, the educational cryptocurrency</h3>\n            <div class="text" translate>\n              You can use EDUCoin for free to learn about cryptocurrencies, without jeopardizing your money.\n            </div>\n          </div>\n        </div>\n      </ion-content>\n    </ion-slide>\n    <ion-slide>\n      <ion-content>\n        <div class="slide-info">\n          <div class="img-container">\n            <img src="assets/img/onboarding/feature-education-3.svg" />\n          </div>\n          <div class="info">\n            <h3 class="title" translate>No-limit learning</h3>\n            <div class="text" translate>\n              Teach your family and friends, send and receive EDUCoin with no costs, try and test without limits.\n            </div>\n          </div>\n        </div>\n      </ion-content>\n    </ion-slide>\n    <ion-slide class="key-creation">\n      <ion-content>\n        <div class="slide-info">\n          <div class="img-container">\n            <img class="tour-1" src="assets/img/onboarding-tour1.svg" />\n          </div>\n          <div class="info">\n            <h3 class="title" translate>Security, trust, ease, speed, decentralization</h3>\n            <div class="text" translate>Evolution: all this in the palm of your hand, on an educational network and a simple and easy-to-use mobile application.</div>\n          </div>\n        </div>\n      </ion-content>\n    </ion-slide>\n  </ion-slides>\n</ion-content>\n<ion-footer no-border *ngIf="!isCordova || featureEducationSlides.isEnd()">\n  <ion-toolbar *ngIf="!featureEducationSlides.isEnd() && !isCordova">\n    <button ion-button class="button-standard" (click)="featureEducationSlides.slideNext()">\n      {{\'Continue\' | translate}}\n    </button>\n  </ion-toolbar>\n  <ion-toolbar *ngIf="featureEducationSlides.isEnd()">\n    <button ion-button class="button-standard no-margin-bottom" (click)="goToNextPage(\'SelectCurrencyPage\')">\n      {{\'Start\' | translate}}\n    </button>\n    <button ion-button clear color="primary" class="button-standard" (click)="goToNextPage(\'ImportWalletPage\')">\n      {{\'Import from backup\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/feature-education/feature-education.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        logger_logger["a" /* Logger */],
        action_sheet["a" /* ActionSheetProvider */],
        config_config["a" /* ConfigProvider */],
        platform_platform["a" /* PlatformProvider */]])
], feature_education_FeatureEducationPage);

//# sourceMappingURL=feature-education.js.map
// EXTERNAL MODULE: ./src/pages/paper-wallet/paper-wallet.ts
var paper_wallet = __webpack_require__(519);

// EXTERNAL MODULE: ./src/pages/send/amount/amount.ts
var amount = __webpack_require__(86);

// EXTERNAL MODULE: ./src/pages/send/confirm/confirm.ts
var confirm_confirm = __webpack_require__(167);

// EXTERNAL MODULE: ./src/pages/settings/about/about.ts
var about = __webpack_require__(510);

// EXTERNAL MODULE: ./src/pages/settings/addressbook/add/add.ts + 1 modules
var add = __webpack_require__(399);

// EXTERNAL MODULE: ./src/pages/tabs/tabs.ts
var tabs = __webpack_require__(501);

// EXTERNAL MODULE: ./src/pages/wallet-details/wallet-details.ts
var wallet_details = __webpack_require__(144);

// CONCATENATED MODULE: ./src/app/app.component.ts










// Providers

// import { ExchangeCryptoProvider } from '../providers/exchange-crypto/exchange-crypto';

// Components

// Pages















// TODO FIX REMOVE UNNEEDED CARDS









// As the handleOpenURL handler kicks in before the App is started,
// declare the handler function at the top of app.component.ts (outside the class definition)
// to track the passed Url
window.handleOpenURL = (url) => {
    window.handleOpenURL_LastURL = url;
};
let app_component_CopayApp = class CopayApp {
    constructor(config, platform, platformProvider, statusBar, splashScreen, events, logger, appProvider, profileProvider, configProvider, 
        // private giftCardProvider: GiftCardProvider,
        imageLoaderConfig, modalCtrl, 
        // TODO FIX
        // private coinbaseProvider: CoinbaseProvider,
        // private walletConnectProvider: WalletConnectProvider,
        // private bitPayCardProvider: TKCoinCardProvider,
        // private buyCryptoProvider: BuyCryptoProvider,
        emailNotificationsProvider, 
        // private exchangeCryptoProvider: ExchangeCryptoProvider,
        screenOrientation, popupProvider, pushNotificationsProvider, incomingDataProvider, renderer, userAgent, device, keyProvider, persistenceProvider, iab, iabCardProvider, tkcoinProvider, tkcoinIdProvider, themeProvider, logsProvider, dynamicLinksProvider, locationProvider) {
        this.config = config;
        this.platform = platform;
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
        this.splashScreen = splashScreen;
        this.events = events;
        this.logger = logger;
        this.appProvider = appProvider;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.imageLoaderConfig = imageLoaderConfig;
        this.modalCtrl = modalCtrl;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.screenOrientation = screenOrientation;
        this.popupProvider = popupProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.renderer = renderer;
        this.userAgent = userAgent;
        this.device = device;
        this.keyProvider = keyProvider;
        this.persistenceProvider = persistenceProvider;
        this.iab = iab;
        this.iabCardProvider = iabCardProvider;
        this.tkcoinProvider = tkcoinProvider;
        this.tkcoinIdProvider = tkcoinIdProvider;
        this.themeProvider = themeProvider;
        this.logsProvider = logsProvider;
        this.dynamicLinksProvider = dynamicLinksProvider;
        this.locationProvider = locationProvider;
        this.NETWORK = 'livenet';
        this.pageMap = {
            AboutPage: about["a" /* AboutPage */],
            AddressbookAddPage: add["a" /* AddressbookAddPage */],
            AmountPage: amount["a" /* AmountPage */],
            TKCoinCardIntroPage: tkcoin_card_intro["a" /* TKCoinCardIntroPage */],
            ExchangeCryptoPage: exchange_crypto["a" /* ExchangeCryptoPage */],
            PhaseOneCardIntro: phase_one_intro_page_PhaseOneCardIntro,
            CoinbasePage: coinbase["a" /* CoinbasePage */],
            ConfirmPage: confirm_confirm["a" /* ConfirmPage */],
            CopayersPage: copayers["a" /* CopayersPage */],
            ImportWalletPage: import_wallet["a" /* ImportWalletPage */],
            JoinWalletPage: join_wallet["a" /* JoinWalletPage */],
            AddWalletPage: add_wallet["a" /* AddWalletPage */],
            PaperWalletPage: paper_wallet["a" /* PaperWalletPage */],
            SimplexPage: simplex["a" /* SimplexPage */],
            SelectInvoicePage: select_invoice["a" /* SelectInvoicePage */],
            WalletConnectPage: wallet_connect["a" /* WalletConnectPage */],
            WalletDetailsPage: wallet_details["a" /* WalletDetailsPage */],
            WyrePage: wyre["a" /* WyrePage */]
        };
        this.imageLoaderConfig.setFileNameCachedWithExtension(true);
        this.imageLoaderConfig.useImageTag(true);
        this.imageLoaderConfig.enableSpinner(false);
        this.initializeApp();
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        if (this.iab) {
            Object.keys(this.iab.refs).forEach(ref => {
                this.iab.refs[ref].close();
            });
        }
    }
    initializeApp() {
        this.config.set('backButtonIcon', 'tab-button-back');
        this.platform
            .ready()
            .then(readySource => {
            this.onPlatformReady(readySource);
        })
            .catch(e => {
            this.logger.error('Platform is not ready.', e);
        });
    }
    onPlatformReady(readySource) {
        this.appProvider
            .load()
            .then(() => {
            this.onAppLoad(readySource);
        })
            .catch(err => {
            const title = 'Could not initialize the app';
            let message;
            try {
                message = err instanceof Error ? err.toString() : JSON.stringify(err);
            }
            catch (error) {
                message = 'Unknown error';
            }
            this.popupProvider.ionicAlert(title, message).then(() => {
                // Share logs
                const platform = this.platformProvider.isCordova
                    ? this.platformProvider.isAndroid
                        ? 'android'
                        : 'ios'
                    : 'desktop';
                this.logsProvider.get(this.appProvider.info.nameCase, platform);
            });
        });
    }
    onAppLoad(readySource) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const deviceInfo = this.platformProvider.getDeviceInfo();
            this.logger.info('Platform ready (' +
                readySource +
                '): ' +
                this.appProvider.info.nameCase +
                ' - v' +
                this.appProvider.info.version +
                ' #' +
                this.appProvider.info.commitHash +
                deviceInfo);
            this.locationProvider.getCountry().then(c => {
                this.logger.info('Set location: ' + c);
            });
            const network = yield this.persistenceProvider.getNetwork();
            if (network) {
                this.NETWORK = network;
            }
            this.logger.debug('TKCoin: setting network', this.NETWORK);
            [
                this.tkcoinProvider,
                this.tkcoinIdProvider,
                this.iabCardProvider /*,
                this.giftCardProvider */
            ].forEach(provider => provider.setNetwork(this.NETWORK));
            this.logger.debug('Setting Cached Total Balance');
            this.appProvider.setTotalBalance();
            if (this.platform.is('cordova')) {
                this.statusBar.show();
                // Set User-Agent
                this.logger.debug('Setting User Agent');
                this.userAgent.set(this.appProvider.info.name +
                    ' ' +
                    this.appProvider.info.version +
                    ' (' +
                    this.device.platform +
                    ' ' +
                    this.device.version +
                    ' - ' +
                    this.device.model +
                    ')');
                // Set to portrait
                this.logger.debug('Setting Screen Orientation');
                this.screenOrientation.lock(this.screenOrientation.ORIENTATIONS.PORTRAIT);
                // Only for iOS
                if (this.platform.is('ios')) {
                    this.statusBar.overlaysWebView(true);
                }
                // Subscribe Resume
                this.logger.debug('On Resume Subscription');
                this.onResumeSubscription = this.platform.resume.subscribe(() => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                    // Check PIN or Fingerprint on Resume
                    this.openLockModal();
                    // Set Theme (light or dark mode)
                    yield this.themeProvider.load();
                    this.themeProvider.apply();
                    // Clear all notifications
                    this.pushNotificationsProvider.clearAllNotifications();
                    // Firebase Dynamic link
                    this.dynamicLinksProvider.init();
                }));
                // Check PIN or Fingerprint
                this.logger.debug('Open Lock Modal');
                this.openLockModal();
                // Clear all notifications
                this.pushNotificationsProvider.clearAllNotifications();
                // Firebase Dynamic link
                this.dynamicLinksProvider.init();
            }
            // Set Theme (light or dark mode)
            this.themeProvider.apply();
            if (this.platformProvider.isElectron)
                this.updateDesktopOnFocus();
            this.registerIntegrations();
            this.incomingDataRedirEvent();
            this.showAdvertisingEvent();
            this.events.subscribe('OpenWallet', (wallet, params) => this.openWallet(wallet, params));
            setTimeout(() => {
                this.logger.debug('Hide Splash Screen');
                this.splashScreen.hide();
            }, 1000);
            this.keyProvider
                .load()
                .then(() => {
                // Check Profile
                this.profileProvider
                    .loadAndBindProfile()
                    .then(onboardingState => {
                    switch (onboardingState) {
                        case 'NONAGREEDDISCLAIMER':
                            this.logger.warn('Non agreed disclaimer');
                            this.rootPage = disclaimer["a" /* DisclaimerPage */];
                            break;
                        case 'UNFINISHEDONBOARDING':
                            this.logger.warn('Unfinished onboarding');
                            this.rootPage =
                                this.appProvider.info.nameCase === 'Copay'
                                    ? disclaimer["a" /* DisclaimerPage */]
                                    : feature_education_FeatureEducationPage;
                            break;
                        default:
                            const profile = this.profileProvider.profile;
                            this.onProfileLoad(profile);
                    }
                })
                    .catch(err => {
                    this.popupProvider
                        .ionicAlert('Could not load the profile', err.message)
                        .then(() => {
                        // Share logs
                        const platform = this.platformProvider.isCordova
                            ? this.platformProvider.isAndroid
                                ? 'android'
                                : 'ios'
                            : 'desktop';
                        this.logsProvider.get(this.appProvider.info.nameCase, platform);
                    });
                });
            })
                .catch(err => {
                this.popupProvider.ionicAlert('Error loading keys', err.message || '');
                this.logger.error('Error loading keys: ', err);
            });
            let [token, cards] = yield Promise.all([
                this.persistenceProvider.getTKCoinIdPairingToken(persistence["a" /* Network */][this.NETWORK]),
                this.persistenceProvider.getBitpayDebitCards(persistence["a" /* Network */][this.NETWORK])
            ]);
            yield this.persistenceProvider.setTempMdesCertOnlyFlag('disabled');
            if (this.platformProvider.isCordova &&
                this.appProvider.info.name === 'tkcoin') {
                const host = this.NETWORK === 'testnet' ? 'test.tkcoin.org' : 'tkcoin.org';
                this.logger.log(`IAB host -> ${host}`);
                // preloading the view
                setTimeout(() => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                    // if (cards && this.platform.is('ios')) {
                    //   try {
                    //     cards = await this.iabCardProvider.checkAppleWallet(cards);
                    //   } catch (err) {
                    //     this.logger.error('apple wallet checkPairedDevices error', err);
                    //   }
                    // }
                    const agent = yield this.userAgent.get();
                    this.logger.debug('TKCoin: create IAB Instance');
                    try {
                        this.cardIAB_Ref = yield this.iab.createIABInstance('card', `${CARD_IAB_CONFIG},OverrideUserAgent=${agent}`, `https://${host}/wallet-card?context=bpa`, `( async () => {
              const sendMessageToWallet = (message) => webkit.messageHandlers.cordova_iab.postMessage(JSON.stringify(message));
              try {
                window.postMessage({message: 'isDarkModeEnabled', payload: {theme: ${this.themeProvider.isDarkModeEnabled()}}},'*');
                window.postMessage({message: 'getAppVersion', payload: ${JSON.stringify(this.appProvider.info.version)}},'*');
                await new Promise((res) => setTimeout(res, 300));
                sessionStorage.setItem('isPaired', ${!!token}); 
                sessionStorage.setItem('cards', ${JSON.stringify(JSON.stringify(cards))});
                sendMessageToWallet({message: 'IABLoaded'});
              } catch(err) {
                sendMessageToWallet({message: 'IABError', log: err});
              }   
              })()`);
                        this.iabCardProvider.init();
                    }
                    catch (err) {
                        this.logger.debug('Error creating IAB instance: ', err.message);
                    }
                }));
            }
        });
    }
    updateDesktopOnFocus() {
        const { remote } = window.require('electron');
        const win = remote.getCurrentWindow();
        win.on('focus', () => {
            if (this.themeProvider.useSystemTheme) {
                this.themeProvider.getDetectedSystemTheme().then(theme => {
                    if (this.themeProvider.currentAppTheme == theme)
                        return;
                    this.themeProvider.setActiveTheme('system', theme);
                });
            }
        });
    }
    onProfileLoad(profile) {
        this.emailNotificationsProvider.init(); // Update email subscription if necessary
        this.initPushNotifications();
        if (this.platform.is('cordova')) {
            this.handleDeepLinks();
        }
        if (this.platformProvider.isElectron) {
            this.handleDeepLinksElectron();
        }
        if (profile) {
            this.logger.info('Profile exists.');
            this.rootPage = tabs["a" /* TabsPage */];
        }
        else {
            this.logger.info('No profile exists.');
            this.profileProvider.createProfile();
            this.rootPage =
                this.appProvider.info.nameCase === 'Copay'
                    ? disclaimer["a" /* DisclaimerPage */]
                    : feature_education_FeatureEducationPage;
        }
    }
    openLockModal() {
        if (this.appProvider.isLockModalOpen)
            return;
        if (this.appProvider.skipLockModal && this.platformProvider.isAndroid) {
            // workaround for android devices that execute pause for system actions
            this.appProvider.skipLockModal = false;
            return;
        }
        const config = this.configProvider.get();
        const lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod || lockMethod === 'disabled') {
            return;
        }
        if (lockMethod == 'pin') {
            this.openPINModal('checkPin');
        }
        else if (lockMethod == 'fingerprint') {
            this.openFingerprintModal();
        }
        this.iabCardProvider.pause();
    }
    openPINModal(action) {
        this.appProvider.isLockModalOpen = true;
        const modal = this.modalCtrl.create(pin_modal["a" /* PinModalPage */], { action }, {
            enableBackdropDismiss: false,
            cssClass: 'fullscreen-modal'
        });
        modal.present({ animate: false });
        modal.onWillDismiss(() => {
            this.onLockWillDismiss();
        });
        modal.onDidDismiss(() => {
            this.onLockDidDismiss();
        });
    }
    openFingerprintModal() {
        this.appProvider.isLockModalOpen = true;
        const modal = this.modalCtrl.create(FingerprintModalPage, {}, {
            enableBackdropDismiss: false,
            cssClass: 'fullscreen-modal'
        });
        modal.present({ animate: false });
        modal.onWillDismiss(() => {
            this.onLockWillDismiss();
        });
        modal.onDidDismiss(() => {
            this.onLockDidDismiss();
        });
    }
    onLockDidDismiss() {
        this.appProvider.isLockModalOpen = false;
        this.events.publish('Local/FetchWallets');
        this.events.publish('Local/showNewFeaturesSlides');
    }
    onLockWillDismiss() {
        this.iabCardProvider.resume();
    }
    registerIntegrations() {
        // TODO FIX REMOVE UNNEEDED FUNCTIONALITIES
        /* // Gift Cards
        // if (this.appProvider.info._enabledExtensions.giftcards)
          // this.giftCardProvider.register();
        // Buy Crypto
        if (
          this.appProvider.info._enabledExtensions.buycrypto &&
          !this.platformProvider.isMacApp()
        ) {
          this.buyCryptoProvider.register();
        }
    
        // Exchange Crypto
        if (
          this.appProvider.info._enabledExtensions.exchangecrypto &&
          !this.platformProvider.isMacApp()
        ) {
          this.exchangeCryptoProvider.register();
        }
    
        // Coinbase
        if (this.appProvider.info._enabledExtensions.coinbase) {
          this.coinbaseProvider.setCredentials();
          this.coinbaseProvider.register();
        }
    
        // Wallet Connect
        if (
          this.appProvider.info._enabledExtensions.walletConnect &&
          !this.platformProvider.isMacApp()
        ) {
          this.walletConnectProvider.register();
          this.persistenceProvider.getWalletConnect().then(walletConnectData => {
            this.walletConnectProvider.retrieveWalletConnector(walletConnectData);
          });
        }
    
        // BitPay Card
        if (this.appProvider.info._enabledExtensions.debitcard)
          this.bitPayCardProvider.register();
        */
    }
    incomingDataRedirEvent() {
        this.events.subscribe('IncomingDataRedir', nextView => {
            if (!nextView.name) {
                setTimeout(() => {
                    this.getGlobalTabs()
                        .goToRoot()
                        .then(_ => {
                        this.getGlobalTabs().select(2);
                    });
                }, 300);
            }
            else if (nextView.name === 'CardsPage') {
                this.getGlobalTabs()
                    .goToRoot()
                    .then(_ => {
                    this.getGlobalTabs().select(3);
                });
            }
            else if (nextView.name === 'WalletConnectPage') {
                const currentIndex = this.nav.getActive().index;
                const currentView = this.nav.getViews();
                const views = this.nav.getActiveChildNavs()[0].getSelected()._views;
                if ((views[views.length - 1].name !== 'WalletConnectPage' &&
                    currentView[currentIndex].name !== 'WalletConnectPage') ||
                    nextView.params.uri.indexOf('bridge') !== -1) {
                    this.getGlobalTabs()
                        .goToRoot()
                        .then(_ => {
                        this.getGlobalTabs().select(4);
                        this.nav.push(this.pageMap[nextView.name], nextView.params);
                    });
                }
                return;
            }
            else {
                if (nextView.params && nextView.params.deepLink) {
                    // No params -> return
                    if (nextView.name == 'DynamicLink')
                        return;
                    // From deepLink
                    setTimeout(() => {
                        this.getGlobalTabs()
                            .goToRoot()
                            .then(_ => {
                            this.getGlobalTabs().select(0);
                            this.nav.push(this.pageMap[nextView.name]);
                        });
                    }, 1000);
                    return;
                }
                this.closeScannerFromWithinWallet();
                // wait for wallets status
                setTimeout(() => {
                    const globalNav = this.getGlobalTabs().getSelected();
                    globalNav
                        .push(this.pageMap[nextView.name], nextView.params)
                        .then(() => {
                        if (typeof nextView.callback === 'function') {
                            nextView.callback();
                        }
                    });
                }, 300);
            }
        });
    }
    showAdvertisingEvent() {
        this.events.subscribe('ShowAdvertising', data => {
            this.getGlobalTabs().select(0);
            const modal = this.modalCtrl.create(AdvertisingComponent, {
                advertising: data
            });
            modal.present();
        });
    }
    openWallet(wallet, params) {
        if (wallet.isComplete()) {
            this.getGlobalTabs().select(1);
            this.nav.push(wallet_details["a" /* WalletDetailsPage */], Object.assign({}, params, { walletId: wallet.credentials.walletId }));
        }
        else {
            // check if modal is already open
            if (this.isCopayerModalOpen) {
                this.copayerModal.dismiss();
            }
            this.isCopayerModalOpen = true;
            this.copayerModal = this.modalCtrl.create(copayers["a" /* CopayersPage */], Object.assign({}, params, { walletId: wallet.credentials.walletId }), {
                cssClass: 'wallet-details-modal'
            });
            this.copayerModal.present();
            this.copayerModal.onDidDismiss(() => {
                this.isCopayerModalOpen = false;
            });
        }
    }
    closeScannerFromWithinWallet() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (!this.getWalletDetailsModal()) {
                return;
            }
            yield this.toggleScannerVisibilityFromWithinWallet(false, 300);
        });
    }
    toggleScannerVisibilityFromWithinWallet(visible, transitionDuration) {
        const walletDetailsModal = this.getWalletDetailsModal();
        visible
            ? this.renderer.addClass(walletDetailsModal, 'scanning')
            : this.renderer.removeClass(walletDetailsModal, 'scanning');
        return Rx["Observable"].timer(transitionDuration).toPromise();
    }
    getWalletDetailsModal() {
        return document.getElementsByClassName('wallet-details-modal')[0];
    }
    initPushNotifications() {
        this.pushNotificationsProvider.init();
    }
    handleDeepLinks() {
        // Check if app was resume by custom url scheme
        window.handleOpenURL = (url) => {
            this.logger.info('App was resumed by custom url scheme');
            this.handleOpenUrl(url);
        };
        // Check if app was opened by custom url scheme
        const lastUrl = window.handleOpenURL_LastURL || '';
        if (lastUrl && lastUrl !== '') {
            delete window.handleOpenURL_LastURL;
            // Important delay to have all views loaded before process URL
            setTimeout(() => {
                this.logger.info('App was opened by custom url scheme');
                this.handleOpenUrl(lastUrl);
            }, 2000);
        }
    }
    handleOpenUrl(url) {
        if (url.includes('wallet-card/order-now')) {
            const context = url.includes('new') ? 'new' : 'fv';
            this.persistenceProvider.setCardFastTrackEnabled(context);
        }
        if (!this.incomingDataProvider.redir(url)) {
            this.logger.warn('Unknown URL! : ' + url);
        }
    }
    handleDeepLinksElectron() {
        const electron = window.require('electron');
        electron.ipcRenderer.on('open-url-event', (_, url) => {
            this.processUrl(url);
        });
    }
    processUrl(pathData) {
        if (pathData.indexOf('bitcoincash:/') != -1) {
            this.logger.debug('Bitcoin Cash URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bitcoincash:/')));
        }
        else if (pathData.indexOf('bitcoin:/') != -1) {
            this.logger.debug('Bitcoin URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bitcoin:/')));
        }
        else if (pathData.indexOf('ethereum:/') != -1) {
            this.logger.debug('Ethereum URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('ethereum:/')));
        }
        else if (pathData.indexOf('ripple:/') != -1) {
            this.logger.debug('Ripple URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('ripple:/')));
        }
        else if (pathData.indexOf('dogecoin:/') != -1) {
            this.logger.debug('Dogecoin URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('dogecoin:/')));
        }
        else if (pathData.indexOf(this.appProvider.info.name + '://') != -1) {
            this.logger.debug(this.appProvider.info.name + ' URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf(this.appProvider.info.name + '://')));
        }
        else {
            this.logger.debug('URL found');
            this.handleOpenUrl(pathData);
        }
    }
    getGlobalTabs() {
        return this.nav.getActiveChildNavs()[0].viewCtrl.instance.tabs;
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('appNav'),
    tslib_es6["__metadata"]("design:type", ionic_angular["m" /* NavController */])
], app_component_CopayApp.prototype, "nav", void 0);
app_component_CopayApp = tslib_es6["__decorate"]([
    Object(core["Component"])({template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/app/app.html"*/'<ion-nav #appNav [root]="rootPage"></ion-nav>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/app/app.html"*/,
        providers: [providers["_25" /* TouchIdProvider */]]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["d" /* Config */],
        ionic_angular["p" /* Platform */],
        providers["_3" /* PlatformProvider */],
        status_bar["a" /* StatusBar */],
        splash_screen["a" /* SplashScreen */],
        ionic_angular["f" /* Events */],
        providers["W" /* Logger */],
        providers["f" /* AppProvider */],
        providers["_5" /* ProfileProvider */],
        providers["s" /* ConfigProvider */],
        dist["b" /* ImageLoaderConfig */],
        ionic_angular["l" /* ModalController */],
        providers["B" /* EmailNotificationsProvider */],
        screen_orientation["a" /* ScreenOrientation */],
        providers["_4" /* PopupProvider */],
        providers["_6" /* PushNotificationsProvider */],
        providers["P" /* IncomingDataProvider */],
        core["Renderer2"],
        user_agent["a" /* UserAgent */],
        _ionic_native_device["a" /* Device */],
        providers["R" /* KeyProvider */],
        persistence["b" /* PersistenceProvider */],
        providers["O" /* InAppBrowserProvider */],
        providers["N" /* IABCardProvider */],
        providers["_20" /* TKCoinProvider */],
        providers["_19" /* TKCoinIdProvider */],
        providers["_22" /* ThemeProvider */],
        providers["X" /* LogsProvider */],
        providers["z" /* DynamicLinksProvider */],
        providers["V" /* LocationProvider */]])
], app_component_CopayApp);

//# sourceMappingURL=app.component.js.map
// EXTERNAL MODULE: ./src/pages/add/add.ts
var add_add = __webpack_require__(396);

// EXTERNAL MODULE: ./src/pages/add/create-wallet/create-wallet.ts
var create_wallet = __webpack_require__(500);

// EXTERNAL MODULE: ./src/pages/backup/backup-game/backup-game.ts
var backup_game = __webpack_require__(972);

// EXTERNAL MODULE: ./src/pages/backup/backup-key/backup-key.ts
var backup_key = __webpack_require__(296);

// EXTERNAL MODULE: ./src/pages/buy-crypto/country-selector/country-selector.ts
var country_selector = __webpack_require__(977);

// EXTERNAL MODULE: ./src/pages/buy-crypto/crypto-coin-selector/crypto-coin-selector.ts
var crypto_coin_selector = __webpack_require__(978);

// EXTERNAL MODULE: ./src/pages/buy-crypto/crypto-offers/crypto-offers.ts
var crypto_offers = __webpack_require__(979);

// EXTERNAL MODULE: ./src/pages/buy-crypto/crypto-order-summary/crypto-order-summary.ts
var crypto_order_summary = __webpack_require__(503);

// EXTERNAL MODULE: ./src/pages/buy-crypto/crypto-payment-method/crypto-payment-method.ts
var crypto_payment_method = __webpack_require__(980);

// EXTERNAL MODULE: ./src/pages/buy-crypto/crypto-settings/crypto-settings.ts
var crypto_settings = __webpack_require__(987);

// EXTERNAL MODULE: ./src/pages/exchange-crypto/exchange-checkout/exchange-checkout.ts
var exchange_checkout = __webpack_require__(1023);

// EXTERNAL MODULE: ./src/pages/exchange-crypto/exchange-crypto-settings/exchange-crypto-settings.ts
var exchange_crypto_settings = __webpack_require__(990);

// EXTERNAL MODULE: ./src/pages/feedback/send-feedback/send-feedback.ts
var send_feedback = __webpack_require__(511);

// EXTERNAL MODULE: ./src/pages/finish/finish.ts
var finish = __webpack_require__(145);

// EXTERNAL MODULE: ./src/pages/new-feature/new-feature.ts
var new_feature = __webpack_require__(502);

// EXTERNAL MODULE: ./src/pages/onboarding/add-funds/add-funds.ts
var add_funds = __webpack_require__(973);

// EXTERNAL MODULE: ./src/providers/app/app.ts
var app = __webpack_require__(23);

// EXTERNAL MODULE: ./src/providers/email-notifications/email-notifications.ts
var email_notifications = __webpack_require__(291);

// CONCATENATED MODULE: ./src/pages/onboarding/collect-email/collect-email.ts





// native

// providers


// pages

let collect_email_CollectEmailPage = class CollectEmailPage {
    constructor(logger, fb, appProvider, http, emailProvider, device, platformProvider) {
        this.logger = logger;
        this.fb = fb;
        this.appProvider = appProvider;
        this.http = http;
        this.emailProvider = emailProvider;
        this.device = device;
        this.platformProvider = platformProvider;
        const regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        this.emailForm = this.fb.group({
            email: [null, [esm5_forms["h" /* Validators */].required, esm5_forms["h" /* Validators */].pattern(regex)]],
            accept: [false]
        });
        this.showConfirmForm = false;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.emailSheetURL
                ? this.appProvider.servicesInfo.emailSheetURL
                : null;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CollectEmailPage');
    }
    showConfirm() {
        this.showConfirmForm = !this.showConfirmForm;
    }
    save() {
        const opts = {
            enabled: true,
            email: this.emailForm.value.email
        };
        // Confirm for notifications
        this.emailProvider.updateEmail(opts);
        // Confirm to get news and updates from TKCoin
        if (this.emailForm.value.accept)
            this.collectEmail();
    }
    collectEmail() {
        if (!this.URL)
            return;
        let version;
        let platform;
        if (this.platformProvider.isElectron) {
            version = this.platformProvider
                .getDeviceInfo()
                .match(/(Electron[\/]\d+(\.\d)*)/i)[0]; // getDeviceInfo example: 5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Copay/5.1.0 Chrome/66.0.3359.181 Electron/3.0.8 Safari/537.36
            platform =
                this.platformProvider.getOS() && this.platformProvider.getOS().OSName;
        }
        else {
            version = this.device.version || 'Unknown version';
            platform = this.device.platform || 'Unknown platform';
        }
        const headers = new esm5_http["c" /* HttpHeaders */]({
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
        });
        const urlSearchParams = new esm5_http["d" /* HttpParams */]()
            .set('App', this.appProvider.info.nameCase)
            .set('Email', this.emailForm.value.email)
            .set('AppVersion', this.appProvider.info.version)
            .set('Platform', platform)
            .set('DeviceVersion', version);
        this.http
            .post(this.URL, null, {
            params: urlSearchParams,
            headers
        })
            .subscribe(() => {
            this.logger.info('SUCCESS: Email collected');
        }, () => {
            this.logger.error('ERROR: Could not collect email');
        });
    }
};
collect_email_CollectEmailPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-collect-email',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/collect-email/collect-email.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton="true">\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="fixed">\n    <h3 class="title" translate>Notifications by email</h3>\n    <div *ngIf="!showConfirmForm">\n      <img src=\'assets/img/app/onboarding/push-notifications.svg\' width="200" />\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer no-border>\n  <div class="email-form" *ngIf="!showConfirmForm">\n    <p class="description" translate>Where would you like to receive email notifications about payments?</p>\n    <form [formGroup]="emailForm" (ngSubmit)="showConfirm()">\n      <ion-item>\n        <ion-input type="email" formControlName="email" placeholder="{{\'Email\' | translate}}"></ion-input>\n      </ion-item>\n\n      <ion-item no-lines>\n        <ion-label>{{\'Get news and updates from TKCoin\' | translate}}</ion-label>\n        <ion-checkbox formControlName="accept" checked="false"></ion-checkbox>\n      </ion-item>\n      <button ion-button class="button-standard" type="submit" [disabled]="!emailForm.valid">\n        {{\'Continue\' | translate}}\n      </button>\n    </form>\n    <button ion-button clear class="button-standard btn-transparent primary-color" (click)="skip()">\n      {{\'Skip\' | translate}}\n    </button>\n  </div>\n\n  <div class="email-form" *ngIf="showConfirmForm">\n    <div>\n      <p translate>Is this email address correct?</p>\n      <p>{{ emailForm.value.email }}</p>\n    </div>\n    <button ion-button class="button-standard" (click)="save()">\n      {{\'Confirm\' | translate}}\n    </button>\n    <button ion-button class="button-standard btn-transparent primary-color" (click)="showConfirm()">\n      {{\'Edit\' | translate}}\n    </button>\n  </div>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/collect-email/collect-email.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [logger_logger["a" /* Logger */],
        esm5_forms["a" /* FormBuilder */],
        app["a" /* AppProvider */],
        esm5_http["a" /* HttpClient */],
        email_notifications["a" /* EmailNotificationsProvider */],
        _ionic_native_device["a" /* Device */],
        platform_platform["a" /* PlatformProvider */]])
], collect_email_CollectEmailPage);

//# sourceMappingURL=collect-email.js.map
// EXTERNAL MODULE: ./src/pages/onboarding/recovery-key/recovery-key.ts
var recovery_key = __webpack_require__(390);

// CONCATENATED MODULE: ./src/pages/slide-to-accept/slide-to-accept.ts



let slide_to_accept_SlideToAcceptPage = class SlideToAcceptPage {
    constructor(navCtrl, navParams, renderer) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.renderer = renderer;
        this.slideDone = new core["EventEmitter"]();
        this.isPressed = false;
        this.delta = 8;
        this.done = false;
        this.isDisabled = false;
        this.isConfirm = false;
    }
    set disabled(disabled) {
        this.isDisabled = disabled !== undefined ? disabled : false;
    }
    get disabled() {
        return this.isDisabled;
    }
    set slideButtonDone(done) {
        this.done = done !== undefined ? done : false;
    }
    get slideButtonDone() {
        return this.done;
    }
    ngOnChanges(changes) {
        if (changes &&
            changes.disabled &&
            changes.disabled.previousValue === true &&
            changes.disabled.firstChange === false) {
            this.animation = false;
            setTimeout(() => {
                this.toggleAnimation();
            }, 300);
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.htmlButtonElem = this.buttonElement.nativeElement;
            this.htmlContainerElem = this.containerElement.nativeElement;
            this.htmlTextElem = this.textElement.nativeElement;
            this.htmlArrowElem = this.arrowElement.nativeElement;
            let buttonConstraints = this.htmlButtonElem.getBoundingClientRect();
            this.origin = {
                left: buttonConstraints.left,
                top: buttonConstraints.top,
                width: buttonConstraints.width
            };
            this.containerWidth = this.htmlContainerElem.clientWidth;
            const subtract = this.containerWidth < 800 ? 75 : 200;
            this.xMax = this.containerWidth - subtract;
        }, 0);
    }
    activateButton(event) {
        this.isPressed = true;
        if (typeof event.touches != 'undefined') {
            this.clickPosition = event.touches[0].pageX;
        }
    }
    dragButton(event) {
        if (typeof event.touches != 'undefined') {
            let xTranslate = event.touches[0].pageX;
            let xDisplacement = this.isPressed ? xTranslate - this.clickPosition : 0;
            // Adjust displacement to consider the delta value
            xDisplacement -= this.delta;
            // Use resource inexpensive translation to perform the sliding
            let posCss = {
                transform: 'translateX(' + xDisplacement + 'px)',
                '-webkit-transform': 'translateX(' + xDisplacement + 'px)'
            };
            let opacityCss = (xDisplacement > 0
                ? 1 - xDisplacement / 200
                : 1).toFixed(2);
            // Move the element while the drag position is less than xMax
            // -delta/2 is a necessary adjustment
            if (xDisplacement >= 0 &&
                xDisplacement <
                    this.containerWidth - (this.origin.width * 30) / 100 + 30 &&
                this.isPressed) {
                // Set element styles
                this.renderer.setStyle(this.htmlButtonElem, 'transform', posCss['transform']);
                this.renderer.setStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
                this.renderer.setStyle(this.htmlTextElem, 'opacity', opacityCss);
                this.renderer.setStyle(this.htmlArrowElem, 'opacity', opacityCss);
            }
            // If the max displacement position is reached
            this.slideButtonDone =
                xDisplacement >= this.xMax - this.delta / 2 ? true : false;
        }
    }
    resetButton() {
        // Only reset if button sliding is not done yet
        if (!this.slideButtonDone || this.isDisabled) {
            this.isConfirm = false;
            // Reset state variables
            // Resets button position
            let posCss = {
                transform: 'translateX(0px)',
                '-webkit-transform': 'translateX(0px)'
            };
            this.renderer.setStyle(this.htmlButtonElem, 'transform', posCss['transform']);
            this.renderer.setStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
            this.renderer.setStyle(this.htmlTextElem, 'opacity', '1');
            this.renderer.setStyle(this.htmlArrowElem, 'opacity', '1');
            this.ngAfterViewInit();
        }
        else if (this.slideButtonDone && !this.isDisabled) {
            this.isConfirm = true;
            this.slideButtonDone = false;
            this.slideDone.emit(true);
        }
    }
    isConfirmed(boolean) {
        if (!boolean) {
            this.resetButton();
        }
    }
    toggleAnimation() {
        if (this.isDisabled)
            return;
        this.animation = true;
        setTimeout(() => {
            this.animation = false;
        }, 300);
    }
};
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", Object)
], slide_to_accept_SlideToAcceptPage.prototype, "slideDone", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], slide_to_accept_SlideToAcceptPage.prototype, "buttonText", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], slide_to_accept_SlideToAcceptPage.prototype, "isDogecoin", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], slide_to_accept_SlideToAcceptPage.prototype, "disabled", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], slide_to_accept_SlideToAcceptPage.prototype, "slideButtonDone", null);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('slideButton', { read: core["ElementRef"] }),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], slide_to_accept_SlideToAcceptPage.prototype, "buttonElement", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('slideButtonContainer'),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], slide_to_accept_SlideToAcceptPage.prototype, "containerElement", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('slideText', { read: core["ElementRef"] }),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], slide_to_accept_SlideToAcceptPage.prototype, "textElement", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('slideArrow', { read: core["ElementRef"] }),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], slide_to_accept_SlideToAcceptPage.prototype, "arrowElement", void 0);
slide_to_accept_SlideToAcceptPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-slide-to-accept',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/slide-to-accept/slide-to-accept.html"*/'<div #slideButtonContainer class="slide__listener" [ngClass]="{\'show\': !isDisabled}">\n  <button class="button-slider" [ngClass]="{\'animation\': animation, \'doge\': isDogecoin}" #slideButton ion-button icon-right large (touchstart)="activateButton($event)" (touchmove)="dragButton($event)" (touchend)="resetButton()" [disabled]="isDisabled" *ngIf="!isConfirm">\n    <div class="slide__bitcoin" [ngClass]="{\'doge\': isDogecoin}" [ngStyle]="bitcoinStyle">\n      <img *ngIf="!isDogecoin" src="assets/img/app/slider-button.svg">\n      <img *ngIf="isDogecoin" src="assets/img/currencies/doge.svg">\n    </div>\n  </button>\n  <div #slideText id="button-text" class="slide__button-text" (touchstart)="toggleAnimation()" (touchmove)="toggleAnimation()" [ngStyle]="textStyle" *ngIf="!isConfirm">\n    {{buttonText}}\n  </div>\n  <div #slideArrow class="slide__arrow " *ngIf="!isConfirm">\n    <img src="assets/img/icon-arrow-right.svg">\n  </div>\n  <div class="slide__status-text" [ngClass]="{\'enter\': isConfirm}" *ngIf="isConfirm">\n    <ion-spinner *ngIf="isConfirm"></ion-spinner>\n  </div>\n</div>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/slide-to-accept/slide-to-accept.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        core["Renderer2"]])
], slide_to_accept_SlideToAcceptPage);

//# sourceMappingURL=slide-to-accept.js.map
// EXTERNAL MODULE: ./src/pages/tx-details/tx-details.ts
var tx_details = __webpack_require__(1028);

// EXTERNAL MODULE: ./src/providers/bwc-error/bwc-error.ts
var bwc_error = __webpack_require__(45);

// EXTERNAL MODULE: ./src/providers/currency/currency.ts + 2 modules
var currency = __webpack_require__(24);

// EXTERNAL MODULE: ./src/providers/errors/errors.ts
var errors = __webpack_require__(41);

// EXTERNAL MODULE: ./src/providers/fee/fee.ts
var fee = __webpack_require__(148);

// EXTERNAL MODULE: ./src/providers/on-going-process/on-going-process.ts
var on_going_process = __webpack_require__(32);

// EXTERNAL MODULE: ./src/providers/paypro/paypro.ts
var paypro = __webpack_require__(185);

// EXTERNAL MODULE: ./src/providers/profile/profile.ts + 1 modules
var profile_profile = __webpack_require__(17);

// EXTERNAL MODULE: ./src/providers/tx-format/tx-format.ts
var tx_format = __webpack_require__(85);

// EXTERNAL MODULE: ./src/providers/wallet/wallet.ts
var wallet_wallet = __webpack_require__(31);

// CONCATENATED MODULE: ./src/pages/txp-details/txp-details.ts





// providers












// pages


let txp_details_TxpDetailsPage = class TxpDetailsPage {
    constructor(navParams, platformProvider, feeProvider, events, logger, popupProvider, walletProvider, onGoingProcessProvider, viewCtrl, configProvider, currencyProvider, profileProvider, txFormatProvider, translate, modalCtrl, payproProvider, bwcErrorProvider, errorsProvider) {
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.events = events;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.walletProvider = walletProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.viewCtrl = viewCtrl;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.payproProvider = payproProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.errorsProvider = errorsProvider;
        this.bwsEventHandler = (walletId, type) => {
            lodash["each"]([
                'TxProposalRejectedBy',
                'TxProposalAcceptedBy',
                'transactionProposalRemoved',
                'TxProposalRemoved',
                'NewOutgoingTx',
                'UpdateTx'
            ], (eventName) => {
                if (walletId == this.wallet.id && type == eventName) {
                    this.updateTxInfo(eventName);
                }
            });
        };
        this.showMultiplesOutputs = false;
        let config = this.configProvider.get().wallet;
        this.tx = this.navParams.data.tx;
        this.wallet = this.tx.wallet
            ? this.tx.wallet
            : this.profileProvider.getWallet(this.tx.walletId);
        this.tx = this.txFormatProvider.processTx(this.wallet.coin, this.tx);
        if (!this.tx.toAddress)
            this.tx.toAddress = this.tx.outputs[0].toAddress;
        this.currentSpendUnconfirmed = config.spendUnconfirmed;
        this.loading = false;
        this.isCordova = this.platformProvider.isCordova;
        this.copayers = this.wallet.cachedStatus.wallet.copayers;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.canSign = this.wallet.canSign;
        this.color = this.wallet.color;
        // To test multiple outputs...
        // var txp = {
        //   message: 'test multi-output',
        //   fee: 1000,
        //   createdOn: Math.floor(Date.now() / 1000),
        //   outputs: [],
        // };
        // for (let i = 0; i < 15; i++) {
        //   txp.outputs.push({
        //     amountStr: "600 BTC",
        //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        //     message: 'output #' + (Number(i) + 1)
        //   });
        // };
        // this.tx = _.merge(this.tx, txp);
        // this.tx.hasMultiplesOutputs = true;
    }
    ionViewDidLoad() {
        this.displayFeeValues();
        this.initActionList();
        this.checkPaypro();
        this.applyButtonText();
        this.amount = this.txFormatProvider.formatAmount(this.wallet.coin, this.tx.amount);
    }
    ionViewWillLoad() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillUnload() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    displayFeeValues() {
        const chain = this.currencyProvider
            .getChain(this.wallet.coin)
            .toLowerCase();
        this.tx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(chain, this.tx.fee);
        if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
            this.tx.feeRateStr =
                ((this.tx.fee / (this.tx.amount + this.tx.fee)) * 100).toFixed(2) + '%';
        }
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelStr = feeOpts[this.tx.feeLevel];
    }
    applyButtonText() {
        var lastSigner = lodash["filter"](this.tx.actions, {
            type: 'accept'
        }).length ==
            this.tx.requiredSignatures - 1;
        if (this.isShared && this.tx.coin === 'eth') {
            this.buttonText = this.translate.instant('Continue');
        }
        else if (lastSigner) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText = this.translate.instant('Payment Accepted');
        }
    }
    initActionList() {
        this.actionList = [];
        if (!this.isShared)
            return;
        var actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            failed: this.translate.instant('Execution Failed'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.tx.createdOn,
            description: actionDescriptions['created'],
            by: this.tx.creatorName
        });
        lodash["each"](this.tx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    checkPaypro() {
        if (this.tx.payProUrl) {
            this.walletProvider
                .getAddress(this.wallet, false)
                .then(address => {
                const payload = {
                    address
                };
                const disableLoader = true;
                this.payproProvider
                    .getPayProDetails({
                    paymentUrl: this.tx.payProUrl,
                    coin: this.tx.coin,
                    payload,
                    disableLoader
                })
                    .then(payProDetails => {
                    this.tx.paypro = payProDetails;
                    this.paymentTimeControl(this.tx.paypro.expires);
                })
                    .catch(err => {
                    this.logger.warn('Error fetching this invoice: ', this.bwcErrorProvider.msg(err));
                    this.paymentExpired = true;
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), this.translate.instant('Error fetching this invoice'));
                });
            })
                .catch(err => {
                this.logger.warn('Error fetching this invoice: ', this.bwcErrorProvider.msg(err));
                this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), this.translate.instant('Error fetching this invoice'));
            });
        }
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        let setExpirationTime = () => {
            let now = Math.floor(Date.now() / 1000);
            if (now > expirationTime) {
                this.paymentExpired = true;
                if (this.countDown)
                    clearInterval(this.countDown);
                return;
            }
            let totalSecs = expirationTime - now;
            let m = Math.floor(totalSecs / 60);
            let s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        };
        this.paymentExpired = false;
        setExpirationTime();
        this.countDown = setInterval(() => {
            setExpirationTime();
        }, 1000);
    }
    showErrorInfoSheet(error, title) {
        this.loading = false;
        if (!error)
            return;
        this.logger.warn('ERROR:', error);
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        if (error.message === 'FINGERPRINT_CANCELLED' ||
            error.message === 'PASSWORD_CANCELLED') {
            return;
        }
        if (error.message === 'WRONG_PASSWORD') {
            this.errorsProvider.showWrongEncryptPasswordError();
            return;
        }
        let infoSheetTitle = title ? title : this.translate.instant('Error');
        this.errorsProvider.showDefaultError(this.bwcErrorProvider.msg(error), infoSheetTitle);
    }
    sign() {
        this.loading = true;
        this.walletProvider
            .publishAndSign(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err, 'Could not send payment');
        });
    }
    reject() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to reject this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.loading = true;
            this.onGoingProcessProvider.set('rejectTx');
            this.walletProvider
                .reject(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.showErrorInfoSheet(err, this.translate.instant('Could not reject payment'));
            });
        });
    }
    remove() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to remove this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.onGoingProcessProvider.set('removeTx');
            this.walletProvider
                .removeTx(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                if (err && !(err.message && err.message.match(/Unexpected/))) {
                    this.showErrorInfoSheet(err, this.translate.instant('Could not delete payment proposal'));
                }
            });
        });
    }
    broadcast() {
        this.loading = true;
        this.onGoingProcessProvider.set('broadcastingTx');
        this.walletProvider
            .broadcastTx(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err, 'Could not broadcast payment');
            this.logger.error('Could not broadcast: ', this.tx.coin, this.tx.network, this.tx.raw);
        });
    }
    updateTxInfo(eventName) {
        this.walletProvider
            .getTxp(this.wallet, this.tx.id)
            .then(tx => {
            let action = lodash["find"](tx.actions, {
                copayerId: this.wallet.credentials.copayerId
            });
            this.tx = this.txFormatProvider.processTx(this.wallet.coin, tx);
            if ((!action || action.type === 'failed') && tx.status == 'pending') {
                this.tx.pendingForUs = true;
                if (action.type === 'failed') {
                    this.executionPending = true;
                }
            }
            this.updateCopayerList();
            this.initActionList();
        })
            .catch(err => {
            if (err.message &&
                err.message == 'Transaction proposal not found' &&
                (eventName == 'transactionProposalRemoved' ||
                    eventName == 'TxProposalRemoved')) {
                this.tx.removed = true;
                this.tx.canBeRemoved = false;
                this.tx.pendingForUs = false;
            }
        });
    }
    updateCopayerList() {
        lodash["map"](this.copayers, (cp) => {
            lodash["each"](this.tx.actions, ac => {
                if (cp.id == ac.copayerId) {
                    cp.action = ac.type;
                }
            });
        });
    }
    onConfirm() {
        if (this.tx.multisigContractAddress) {
            this.goToConfirm();
        }
        else {
            this.sign();
        }
    }
    goToConfirm() {
        let amount = 0;
        this.viewCtrl.dismiss({
            walletId: this.wallet.credentials.walletId,
            amount,
            coin: this.wallet.coin,
            network: this.wallet.network,
            multisigContractAddress: this.wallet.credentials.multisigEthInfo
                .multisigContractAddress,
            toAddress: this.wallet.credentials.multisigEthInfo
                .multisigContractAddress,
            isEthMultisigConfirm: !this.executionPending ? true : false,
            isEthMultisigExecute: this.executionPending ? true : false,
            transactionId: this.tx.multisigTxId
        });
    }
    close() {
        this.loading = false;
        this.viewCtrl.dismiss();
    }
    openFinishModal() {
        let modal = this.modalCtrl.create(finish["a" /* FinishModalPage */], { finishText: this.successText, coin: this.wallet.coin }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.close();
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('slideButton'),
    tslib_es6["__metadata"]("design:type", Object)
], txp_details_TxpDetailsPage.prototype, "slideButton", void 0);
txp_details_TxpDetailsPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-txp-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/txp-details/txp-details.html"*/'<wide-header-page title="{{\'Payment Proposal\'|translate}}" [hasSlideButton]="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && isCordova">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n\n  <div page-content>\n    <div class="line-divider" *ngIf="tx"></div>\n    <ion-list *ngIf="tx" class="bp-list">\n      <ion-item>\n        <div class="header-container">\n          <div class="amount-label">\n            <div class="amount">\n              {{tx.amountValueStr}} {{tx.amountUnitStr | uppercase}}\n            </div>\n            <div class="alternative" *ngIf="tx.alternativeAmountStr">{{tx.alternativeAmountStr}}</div>\n          </div>\n        </div>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="tx && tx.removed"></div>\n\n      <div *ngIf="tx && tx.removed" class="box-notification warning" text-wrap>\n        <span translate>The payment was removed by creator</span>\n      </div>\n      <div class="line-divider" *ngIf="tx && tx.status != \'pending\'"></div>\n\n      <div *ngIf="tx && tx.status != \'pending\'">\n        <div class="box-notification info" text-center *ngIf="tx && tx.status == \'accepted\'">\n          <div text-wrap translate>Payment accepted, but not yet broadcasted</div>\n          <button margin ion-button outline small icon-left (click)="broadcast(tx)" [disabled]="loading">\n            <ion-icon name="cloud-upload"></ion-icon>\n            <span translate>Broadcast Payment</span>\n          </button>\n        </div>\n        <div class="box-notification success" *ngIf="tx && tx.status == \'broadcasted\'" translate>\n          Payment Sent\n        </div>\n        <div class="box-notification warning" *ngIf="tx && tx.status ==\'rejected\'" translate>\n          Payment Rejected\n        </div>\n      </div>\n\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label" translate>DETAILS</div>\n        </ion-label>\n      </ion-item>\n\n      <ion-item *ngIf="tx && tx.feeStr && tx.action != \'received\' && !(isShared && tx.coin === \'eth\')">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Miner fee</span>\n            <b>{{tx.feeLevelName}}</b>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="summary-item-detail">\n            {{tx.feeStr}}\n          </div>\n          <div class="secondary-note fee-details">\n            {{tx.feeFiatStr}}\n            <span *ngIf="tx.feeRateStr">\n              &middot;\n              <span>\n                <span *ngIf="tx.feeRateStr">{{tx.feeRateStr}}\n                  <span translate> of total amount</span>\n                </span>\n              </span>\n            </span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="(tx && !tx.removed) && isShared && (tx && tx.pendingForUs) && !paymentExpired"></div>\n\n      <div padding class="proposal-rejection" *ngIf="(tx && !tx.removed) && isShared && (tx && tx.pendingForUs) && !paymentExpired && !tx.multisigContractAddress">\n        <button ion-button clear color="danger" (click)="reject()" [disabled]="loading">\n          {{\'Reject Payment Proposal\'| translate}}\n        </button>\n      </div>\n\n      <div class="line-divider"></div>\n\n\n      <page-multiple-outputs [tx]="tx"></page-multiple-outputs>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Sending from</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <ion-row align-items-center class="wallet" *ngIf="wallet">\n            <ion-col>\n              <coin-icon [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{wallet.name}}</span>\n            </ion-col>\n          </ion-row>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="tx.creatorName && isShared"></div>\n\n      <ion-item *ngIf="tx.creatorName && isShared">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Created by</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">{{tx.creatorName}}</span>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="tx && tx.ts || tx.createdOn"></div>\n\n      <ion-item *ngIf="tx && tx.ts || tx.createdOn">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Time</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">\n            <time>{{ (tx.ts || tx.createdOn ) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n          </span>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="tx && tx.message"></div>\n\n      <ion-item *ngIf="tx && tx.message">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Memo</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">\n            {{tx.message}}\n          </span>\n        </ion-note>\n      </ion-item>\n\n      <div class="line-divider" *ngIf="tx && tx.paypro"></div>\n\n      <div *ngIf="tx && tx.paypro">\n        <ion-item-divider>{{\'Payment request\' | translate}}</ion-item-divider>\n        <ion-item *ngIf="paymentExpired">\n          <ion-label>\n            {{\'Expired\'|translate}}\n          </ion-label>\n          <ion-note color="danger" item-end>\n            <time>{{tx.paypro.expires | amTimeAgo }}</time>\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="!paymentExpired">\n          <ion-label>\n            {{\'Expires\'|translate}}\n          </ion-label>\n          <ion-note item-end>\n            <time>{{expires}}</time>\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="tx.paypro.memo">\n          <span translate>Merchant Message</span>\n          <div class="item-memo" *ngIf="tx.paypro.memo" text-wrap>\n            <ion-note>{{tx.paypro.memo}}</ion-note>\n          </div>\n        </ion-item>\n      </div>\n\n      <div class="line-divider" *ngIf="actionList && actionList[0]"></div>\n\n      <div *ngIf="actionList && actionList[0]">\n        <ion-item>\n          <span>{{\'Timeline\' | translate}}</span>\n          <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\' || a.type == \'failed\'}" *ngFor="let a of actionList; let i = index">\n            <div class="timeline-content">\n              <div class="timeline-content-icon">\n                <div class="rejected" *ngIf="a.type === \'reject\' || a.type == \'failed\'">!</div>\n                <div class="line" *ngIf="a.type !== \'reject\' && a.type !== \'failed\'">{{actionList.length - i}}</div>\n              </div>\n              <div class="timeline-content-label">\n                <div class="action ellipsis">{{a.description}}</div>\n                <div *ngIf="tx.coin !== \'eth\'" class="name ellipsis">{{a.by}}</div>\n              </div>\n              <ion-note class="ellipsis">\n                <time>{{ a.time * 1000 | amTimeAgo}}</time>\n              </ion-note>\n            </div>\n          </div>\n        </ion-item>\n      </div>\n\n      <div padding class="proposal-deletion" *ngIf="(((tx && !tx.removed) && (tx && tx.canBeRemoved)) || (tx && tx.status == \'accepted\' && !tx.broadcastedOn)) && (!isShared || !tx.multisigContractAddress)">\n        <div class="proposal-deletion-help" *ngIf="isShared" translate>\n          * A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 10 minutes have passed since the proposal was created.\n        </div>\n        <button ion-button clear color="danger" (click)="remove()" [disabled]="loading">\n          {{\'Delete Payment Proposal\' | translate}}\n        </button>\n      </div>\n\n    </ion-list>\n  </div>\n\n  <div footer-content>\n    <page-slide-to-accept #slideButton *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && isCordova && !(isShared && tx.coin === \'eth\')" [buttonText]="buttonText" [isDogecoin]="tx && tx.coin == \'doge\'" (slideDone)="onConfirm()">\n    </page-slide-to-accept>\n    <ion-toolbar *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && (!isCordova || isShared && tx.coin === \'eth\')">\n      <button ion-button full class="button-footer" (click)="onConfirm()">{{buttonText}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/txp-details/txp-details.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["n" /* NavParams */],
        platform_platform["a" /* PlatformProvider */],
        fee["a" /* FeeProvider */],
        ionic_angular["f" /* Events */],
        logger_logger["a" /* Logger */],
        popup["a" /* PopupProvider */],
        wallet_wallet["a" /* WalletProvider */],
        on_going_process["a" /* OnGoingProcessProvider */],
        ionic_angular["t" /* ViewController */],
        config_config["a" /* ConfigProvider */],
        currency["b" /* CurrencyProvider */],
        profile_profile["a" /* ProfileProvider */],
        tx_format["a" /* TxFormatProvider */],
        core_es5["f" /* TranslateService */],
        ionic_angular["l" /* ModalController */],
        paypro["a" /* PayproProvider */],
        bwc_error["a" /* BwcErrorProvider */],
        errors["a" /* ErrorsProvider */]])
], txp_details_TxpDetailsPage);

//# sourceMappingURL=txp-details.js.map
// EXTERNAL MODULE: ./src/pages/wallet-details/search-tx-modal/search-tx-modal.ts
var search_tx_modal = __webpack_require__(1029);

// EXTERNAL MODULE: ./src/pages/wallet-details/wallet-balance/wallet-balance.ts
var wallet_balance = __webpack_require__(1030);

// EXTERNAL MODULE: ./src/pages/integrations/changelly/changelly.ts
var changelly = __webpack_require__(398);

// EXTERNAL MODULE: ./src/pages/integrations/changelly/changelly-details/changelly-details.ts
var changelly_details = __webpack_require__(991);

// EXTERNAL MODULE: ./src/pages/integrations/changelly/changelly-terms/changelly-terms.ts
var changelly_terms = __webpack_require__(1024);

// EXTERNAL MODULE: ./src/pages/integrations/coinbase/coinbase-account/coinbase-account.ts
var coinbase_account = __webpack_require__(392);

// EXTERNAL MODULE: ./src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.ts
var coinbase_settings = __webpack_require__(992);

// EXTERNAL MODULE: ./src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.ts
var coinbase_tx_details = __webpack_require__(981);

// EXTERNAL MODULE: ./src/pages/integrations/coinbase/coinbase-withdraw/coinbase-withdraw.ts
var coinbase_withdraw = __webpack_require__(985);

// EXTERNAL MODULE: ./src/pages/integrations/simplex/simplex-details/simplex-details.ts
var simplex_details = __webpack_require__(988);

// EXTERNAL MODULE: ./src/pages/integrations/wyre/wyre-details/wyre-details.ts
var wyre_details = __webpack_require__(989);

// EXTERNAL MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-card.ts
var tkcoin_card_tkcoin_card = __webpack_require__(505);

// CONCATENATED MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-card-home/tkcoin-card-home.ts



// Providers

// Pages




let tkcoin_card_home_TKCoinCardHome = class TKCoinCardHome {
    constructor(appProvider, navCtrl, iabCardProvider, persistenceProvider, events) {
        this.appProvider = appProvider;
        this.navCtrl = navCtrl;
        this.iabCardProvider = iabCardProvider;
        this.persistenceProvider = persistenceProvider;
        this.events = events;
        this.disableAddCard = true;
        this.persistenceProvider.getWaitingListStatus().then(status => {
            this.alreadyOnWaitList = !!status;
        });
        this.events.subscribe('reachedCardLimit', () => {
            this.disableAddCard = true;
        });
    }
    ngOnInit() {
        this.appName = this.appProvider.info.userVisibleName;
        this.disableAddCard =
            this.tkcoinCardItems &&
                this.tkcoinCardItems.find(c => c.provider === 'galileo');
    }
    goToTKCoinCardIntroPage() {
        this.navCtrl.push(this.waitList ? phase_one_intro_page_PhaseOneCardIntro : tkcoin_card_intro["a" /* TKCoinCardIntroPage */]);
    }
    trackBy(index) {
        return index;
    }
    goToCard(cardId) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.iabCardProvider.loadingWrapper(() => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                const token = yield this.persistenceProvider.getTKCoinIdPairingToken(this.network);
                const email = this.tkcoinCardItems[0].email;
                const message = !token
                    ? `loadDashboard?${cardId}&${email}`
                    : `loadDashboard?${cardId}`;
                this.iabCardProvider.show();
                setTimeout(() => {
                    this.iabCardProvider.sendMessage({
                        message
                    }, () => { });
                });
            }));
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], tkcoin_card_home_TKCoinCardHome.prototype, "showBitpayCardGetStarted", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], tkcoin_card_home_TKCoinCardHome.prototype, "tkcoinCardItems", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], tkcoin_card_home_TKCoinCardHome.prototype, "cardExperimentEnabled", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], tkcoin_card_home_TKCoinCardHome.prototype, "waitList", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], tkcoin_card_home_TKCoinCardHome.prototype, "hasCards", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], tkcoin_card_home_TKCoinCardHome.prototype, "network", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], tkcoin_card_home_TKCoinCardHome.prototype, "initialized", void 0);
tkcoin_card_home_TKCoinCardHome = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'tkcoin-card-home',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-home/tkcoin-card-home.html"*/'<ng-container *ngIf="!hasCards else cards">\n  <div @fade>\n    <action-card-v4>\n      <div action-card-header>\n        <div class="tkcoin-card-header">\n          <ng-container *ngIf="!initialized else headerInitialized">\n            <div class="card-loader__tile" style="width: 100%"></div>\n          </ng-container>\n          <ng-template #headerInitialized>\n            <ng-container *ngIf="waitList else mc">\n              <div class="tkcoin-card-image" style="background: #062150">\n                <img @fade src="assets/img/card-phase-release/tkcoin-card-spaceman-discover-block.svg"\n                     style="transform: scale(1.3)">\n              </div>\n            </ng-container>\n            <ng-template #mc>\n              <div class="tkcoin-card-image tkcoin-card-image--mc">\n                <img @fade src="assets/img/tkcoin-card/tkcoin-card-mc-peek.svg">\n              </div>\n            </ng-template>\n          </ng-template>\n        </div>\n      </div>\n      <div action-card-title>\n        <ng-container *ngIf="!initialized else titleInitialized">\n          <div class="loading--line" style="width: 55%"></div>\n        </ng-container>\n        <ng-template #titleInitialized>\n          <ng-container *ngIf="waitList else mc">\n            <div @fade translate>Something exciting is arriving</div>\n          </ng-container>\n          <ng-template #mc>\n            <div @fade translate>Fund it. Spend it. Live on crypto.</div>\n          </ng-template>\n        </ng-template>\n      </div>\n\n      <div *ngIf="!initialized" action-card-body style="width: 100%">\n        <div class="loading--line" style="width: 30%"></div>\n        <div class="loading--line" style="width: 50%"></div>\n      </div>\n\n      <div *ngIf="initialized && waitList" action-card-body [clamp]="2" translate>\n        Join the waitlist and be first to experience the new card.\n      </div>\n\n      <div *ngIf="initialized && !waitList" action-card-body translate>\n        Instantly reload your card with no conversion fee!*\n      </div>\n\n      <div @fadeUp action-card-button translate *ngIf="initialized" (click)="goToTKCoinCardIntroPage()">\n        <ng-container *ngIf="waitList else mc">\n          <div translate>Notify Me</div>\n        </ng-container>\n        <ng-template #mc>\n          <div translate>Sign Up</div>\n        </ng-template>\n      </div>\n    </action-card-v4>\n  </div>\n</ng-container>\n\n<ng-template #cards>\n  <div class="section-header" translate>\n    Debit Cards\n  </div>\n  <ng-container *ngFor="let card of tkcoinCardItems; let i = index; trackBy: trackBy">\n\n    <div class="card-item" *ngIf="!card.hide">\n      <div class="card-container">\n\n        <ng-container *ngIf="!initialized else cardsInitialized">\n          <div @fadeUp class="card-loader__drawer">\n            <div class="loading--line" style="width: 25%"></div>\n            <div class="loading--line" style="width: 40%"></div>\n          </div>\n          <div class="slit card-loader--box-shadow"></div>\n        </ng-container>\n\n        <ng-template #cardsInitialized>\n          <div @fadeUp class="card" [ngClass]="{dark: tkcoinCardItems?.length === 2 && i === 1}" (click)="goToCard(card.id)"\n               tappable>\n            <div class="number ellipsis">\n              <img\n                  [src]="card.brand === \'Mastercard\' ? \'assets/img/tkcoin-card/mc-logo.svg\' : \'assets/img/tkcoin-card/visa-logo.svg\'">\n            </div>\n            <span class="ellipsis" item-end>\n              <div class="funds ellipsis" style="position: relative;">\n                <span *ngIf="card.cardBalance">\n                  {{ card.cardBalance | formatCurrency: card?.currency: \'minimal\' }}\n                </span>\n                <span *ngIf="!card.cardBalance && card.brand === \'Mastercard\'" class="funds--cta">\n                  {{ \'Add funds\' | translate }}\n                </span>\n              </div>\n            </span>\n          </div>\n          <div class="slit"></div>\n        </ng-template>\n\n      </div>\n    </div>\n  </ng-container>\n\n\n  <ng-container *ngIf="waitList && !alreadyOnWaitList && tkcoinCardItems?.length && !disableAddCard" @fade>\n    <div @fade>\n      <action-card-v4>\n        <div action-card-header>\n          <div class="tkcoin-card-header">\n            <ng-container *ngIf="!initialized else headerInitialized">\n              <div class="card-loader__tile" style="width: 100%"></div>\n            </ng-container>\n            <ng-template #headerInitialized>\n              <div class="tkcoin-card-image" style="background: #062150">\n                <img @fade src="assets/img/card-phase-release/tkcoin-card-spaceman-discover-block.svg"\n                     style="transform: scale(1.3)">\n              </div>\n            </ng-template>\n          </div>\n        </div>\n        <div action-card-title>\n          <ng-container *ngIf="!initialized else titleInitialized">\n            <div class="loading--line" style="width: 60%"></div>\n          </ng-container>\n          <ng-template #titleInitialized>\n            <div @fade translate>Something exciting is arriving</div>\n          </ng-template>\n        </div>\n        <div *ngIf="!initialized" action-card-body style="width: 100%">\n          <div class="loading--line" style="width: 30%"></div>\n          <div class="loading--line" style="width: 50%"></div>\n        </div>\n        <div *ngIf="initialized" action-card-body [clamp]="3" translate>\n          Join the waitlist and be first to experience the new card.\n        </div>\n        <div @fadeUp action-card-button translate *ngIf="initialized" (click)="goToTKCoinCardIntroPage()">\n          <div translate>Notify Me</div>\n        </div>\n      </action-card-v4>\n    </div>\n\n  </ng-container>\n\n  <ng-container *ngIf="cardExperimentEnabled && tkcoinCardItems?.length && !disableAddCard" @fade>\n    <div @fade>\n      <action-card-v4>\n        <div action-card-header>\n          <div class="tkcoin-card-header">\n            <ng-container *ngIf="!initialized else headerInitialized">\n              <div class="card-loader__tile" style="width: 100%"></div>\n            </ng-container>\n            <ng-template #headerInitialized>\n              <div class="tkcoin-card-image tkcoin-card-image--mc">\n                <img @fade src="assets/img/tkcoin-card/tkcoin-card-mc-peek.svg">\n              </div>\n            </ng-template>\n          </div>\n        </div>\n        <div action-card-title>\n          <ng-container *ngIf="!initialized else titleInitialized">\n            <div class="loading--line" style="width: 60%"></div>\n          </ng-container>\n          <ng-template #titleInitialized>\n            <div @fade translate>Fund it. Spend it. Live on crypto.</div>\n          </ng-template>\n        </div>\n        <div *ngIf="!initialized" action-card-body style="width: 100%">\n          <div class="loading--line" style="width: 30%"></div>\n          <div class="loading--line" style="width: 50%"></div>\n        </div>\n        <div *ngIf="initialized" action-card-body translate>\n          Instantly reload your card with no conversion fee!*\n        </div>\n        <div @fadeUp action-card-button translate *ngIf="initialized" (click)="goToTKCoinCardIntroPage()">\n          <div translate>Sign Up</div>\n        </div>\n      </action-card-v4>\n    </div>\n\n  </ng-container>\n\n\n</ng-template>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-home/tkcoin-card-home.html"*/,
        animations: [
            Object(esm5_animations["l" /* trigger */])('fadeUp', [
                Object(esm5_animations["k" /* transition */])(':enter', [
                    Object(esm5_animations["j" /* style */])({
                        transform: 'translateY(5px)',
                        opacity: 0
                    }),
                    Object(esm5_animations["e" /* animate */])('300ms')
                ])
            ]),
            Object(esm5_animations["l" /* trigger */])('fade', [
                Object(esm5_animations["k" /* transition */])(':enter', [
                    Object(esm5_animations["j" /* style */])({
                        opacity: 0
                    }),
                    Object(esm5_animations["e" /* animate */])('300ms')
                ])
            ]),
            Object(esm5_animations["l" /* trigger */])('tileSlideIn', [
                Object(esm5_animations["k" /* transition */])(':enter', [
                    Object(esm5_animations["j" /* style */])({
                        transform: 'translateX(10px)',
                        opacity: 0
                    }),
                    Object(esm5_animations["e" /* animate */])('300ms ease')
                ])
            ])
        ]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [providers["f" /* AppProvider */],
        ionic_angular["m" /* NavController */],
        providers["N" /* IABCardProvider */],
        persistence["b" /* PersistenceProvider */],
        ionic_angular["f" /* Events */]])
], tkcoin_card_home_TKCoinCardHome);

//# sourceMappingURL=tkcoin-card-home.js.map
// EXTERNAL MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-card-topup/tkcoin-card-topup.ts
var tkcoin_card_topup = __webpack_require__(986);

// EXTERNAL MODULE: ./src/pages/integrations/tkcoin-card/tkcoin-settings/tkcoin-settings.ts
var tkcoin_settings = __webpack_require__(995);

// EXTERNAL MODULE: ./src/providers/time/time.ts
var time = __webpack_require__(209);

// CONCATENATED MODULE: ./src/pages/includes/card-item/card-item.ts



let CardItemPage = class CardItemPage {
    constructor(timeProvider) {
        this.timeProvider = timeProvider;
        this.sent = false;
        this.received = false;
        this.pending = false;
    }
    set card(card) {
        this._card = card;
        if (card.pending) {
            this.pending = true;
        }
        else if (card.price.toString().indexOf('-') > -1) {
            this.sent = true;
        }
        else {
            this.received = true;
        }
    }
    get card() {
        return this._card;
    }
    set currency(c) {
        this._currency = c;
    }
    get currency() {
        return this._currency;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], CardItemPage.prototype, "card", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], CardItemPage.prototype, "currency", null);
CardItemPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-card-item',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/card-item/card-item.html"*/'<ion-item *ngIf="card">\n  <ion-icon class="card-icon" item-start>\n    <div class="houston">\n      <img src="assets/img/mcc-icons/{{card.icon}}.svg" class="svg" />\n    </div>\n  </ion-icon>\n  <h4 text-wrap>\n    {{card.merchant.name || \'Unknown Merchant\'}}\n    <span *ngIf="card.pending && card.transactionId" translate>\n      View Confirmation Status\n    </span>\n  </h4>\n  <p class="merchant">\n    {{card.merchant.location}}\n  </p>\n  <ion-note class="amount" item-end text-end>\n    <div [ngClass]="{\'amount--sent\': sent, \'amount--received\': received, \'amount--pending\': pending}" id="price">\n      {{card.price | number:\'1.2-2\' }} {{currency}}\n    </div>\n    <div class="date">\n      {{card.date}}\n    </div>\n  </ion-note>\n</ion-item>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/card-item/card-item.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [time["a" /* TimeProvider */]])
], CardItemPage);

//# sourceMappingURL=card-item.js.map
// EXTERNAL MODULE: ./src/pages/includes/coin-selector/coin-selector.ts
var coin_selector = __webpack_require__(974);

// CONCATENATED MODULE: ./src/pages/includes/create-new-wallet/create-new-wallet.ts



// Pages

let create_new_wallet_CreateNewWalletPage = class CreateNewWalletPage {
    constructor(navCtrl) {
        this.navCtrl = navCtrl;
    }
    goToAddWalletPage() {
        this.navCtrl.push(select_currency["a" /* SelectCurrencyPage */], {
            isZeroState: true
        });
    }
};
create_new_wallet_CreateNewWalletPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'create-new-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/create-new-wallet/create-new-wallet.html"*/'<action-card-v4 (click)="goToAddWalletPage()" tappable>\n  <div action-card-header>\n    <div class="zero-state-wallets">\n      <div class="zero-state-image">\n        <img src="assets/img/zero-state-wallets.svg">\n      </div>\n    </div>\n  </div>\n  <div action-card-title translate>Create or import a wallet</div>\n  <div action-card-body translate>\n    Take control of your crypto\n  </div>\n  <div action-card-button translate>\n    Get Started\n  </div>\n</action-card-v4>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/create-new-wallet/create-new-wallet.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */]])
], create_new_wallet_CreateNewWalletPage);

//# sourceMappingURL=create-new-wallet.js.map
// EXTERNAL MODULE: ./src/providers/analytics/analytics.ts
var analytics = __webpack_require__(68);

// EXTERNAL MODULE: ./src/providers/replace-parameters/replace-parameters.ts
var replace_parameters = __webpack_require__(119);

// CONCATENATED MODULE: ./src/pages/includes/feedback-card/feedback-card.ts





// providers





// pages

let feedback_card_FeedbackCardPage = class FeedbackCardPage {
    constructor(appProvider, navCtrl, logger, persistenceProvider, analyticsProvider, translate, replaceParametersProvider, externalLinkProvider) {
        this.appProvider = appProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.analyticsProvider = analyticsProvider;
        this.translate = translate;
        this.replaceParametersProvider = replaceParametersProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.score = 0;
        this.isShowRateCard = false;
        this.surveyCardShown = false;
    }
    setShowRateCard(value) {
        this.isShowRateCard = value;
        if (this.isShowRateCard) {
            let appName = this.appProvider.info.nameCase;
            this.feedbackCardTitle = this.replaceParametersProvider.replace(this.translate.instant('How satisfied are you with using {{appName}}?'), { appName });
        }
    }
    setShowSurveyCard(value = false) {
        this.surveyCardShown = value;
    }
    hideCard() {
        this.isShowRateCard = false;
        this.logger.debug('Feedback card dismissed.');
        this.persistenceProvider.getFeedbackInfo().then(info => {
            let feedbackInfo = info;
            feedbackInfo.sent = true;
            this.persistenceProvider.setFeedbackInfo(feedbackInfo);
        });
    }
    hideSurvey() {
        this.surveyCardShown = false;
        this.logger.debug('Survey card dismissed.');
        this.persistenceProvider.getFeedbackInfo().then(info => {
            let feedbackInfo = info;
            feedbackInfo.surveyTaken = true;
            this.persistenceProvider.setFeedbackInfo(feedbackInfo);
        });
    }
    takeSurvey() {
        this.externalLinkProvider.open('https://payux.typeform.com/to/DWIC0Kky');
        this.hideSurvey();
    }
    setScore(score) {
        this.score = score;
        switch (this.score) {
            case 1:
                this.button_title = this.translate.instant("I'm disappointed");
                break;
            case 2:
                this.button_title = this.translate.instant("It's ok for now");
                break;
            case 3:
                this.button_title = this.translate.instant('I love it!');
                break;
        }
    }
    goFeedbackFlow() {
        this.hideCard();
        this.analyticsProvider.logEvent('feedback_card_app_sentiment', {
            happinessLevel: this.score
        });
        if (this.score == 1) {
            const url = 'https://payux.typeform.com/to/qYXqqa5q';
            this.externalLinkProvider.open(url);
            return;
        }
        if (this.score == 2) {
            const url = 'https://payux.typeform.com/to/MF01BBKt';
            this.externalLinkProvider.open(url);
            return;
        }
        this.navCtrl.push(send_feedback["a" /* SendFeedbackPage */], {
            score: this.score,
            fromCard: true
        });
    }
};
feedback_card_FeedbackCardPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-feedback-card',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/feedback-card/feedback-card.html"*/'<div class="message-background" *ngIf="isShowRateCard">\n  <div class="message-header">\n    <ion-row justify-content-end>\n      <button float-right ion-button clear icon-only color="grey" (click)="hideCard()">\n        <ion-icon name="close"></ion-icon>\n      </button>\n    </ion-row>\n  </div>\n  <div class="message-content">\n    <ion-row class="title-container">\n      <div class="message-icon"><img src="assets/img/help-question-blue.svg" /></div>\n      <div class="message-title" translate>Feedback</div>\n    </ion-row>\n    <div class="message-body">{{feedbackCardTitle}}</div>\n    <ion-list class="bp-list">\n      <ion-row class="icons-row">\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(1)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 1}" src="assets/img/disappointed-face.svg" />\n          </ion-icon>\n        </ion-col>\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(2)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 2}" src="assets/img/satisfied-face.svg" />\n          </ion-icon>\n        </ion-col>\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(3)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 3}" src="assets/img/happy-face.svg" />\n          </ion-icon>\n        </ion-col>\n      </ion-row>\n    </ion-list>\n    <div *ngIf="button_title">\n      <div class="line-divider"></div>\n      <span class="message-button" (click)="goFeedbackFlow()">{{button_title}}</span>\n    </div>\n  </div>\n</div>\n<div class="message-background message-background--survey" *ngIf="!isShowRateCard && surveyCardShown">\n  <div class="message-header">\n    <ion-row justify-content-end>\n      <button float-right ion-button clear icon-only color="grey" (click)="hideSurvey()">\n        <ion-icon name="close"></ion-icon>\n      </button>\n    </ion-row>\n  </div>\n  <div class="message-content">\n    <ion-row class="title-container">\n      <div class="message-icon"><img src="assets/img/icon-heart-pink.svg" /></div>\n      <div class="message-title" translate>Help TKCoin improve</div>\n    </ion-row>\n    <div class="message-body">Take a 2 minute survey to help us learn how we can improve your experience.</div>\n    <div>\n      <div class="line-divider"></div>\n      <span class="message-button" (click)="takeSurvey()">Take the survey</span>\n    </div>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/feedback-card/feedback-card.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [app["a" /* AppProvider */],
        ionic_angular["m" /* NavController */],
        logger_logger["a" /* Logger */],
        persistence["b" /* PersistenceProvider */],
        analytics["a" /* AnalyticsProvider */],
        core_es5["f" /* TranslateService */],
        replace_parameters["a" /* ReplaceParametersProvider */],
        external_link["a" /* ExternalLinkProvider */]])
], feedback_card_FeedbackCardPage);

//# sourceMappingURL=feedback-card.js.map
// CONCATENATED MODULE: ./src/pages/includes/gravatar/gravatar.ts


let GravatarPage = class GravatarPage {
    constructor() { }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], GravatarPage.prototype, "email", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], GravatarPage.prototype, "name", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Number)
], GravatarPage.prototype, "height", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Number)
], GravatarPage.prototype, "width", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], GravatarPage.prototype, "coin", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], GravatarPage.prototype, "network", void 0);
GravatarPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'gravatar',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/gravatar/gravatar.html"*/'<div class="gravatar">\n  <img class="gravatar-img" alt="{{ name }}" height="{{ height }}" width="{{ width }}" src="assets/img/contact-placeholder.svg">\n  <coin-icon class="gravatar-coin" [coin]="coin" [network]="network"></coin-icon>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/gravatar/gravatar.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [])
], GravatarPage);

//# sourceMappingURL=gravatar.js.map
// EXTERNAL MODULE: ./src/providers/address-book/address-book.ts
var address_book = __webpack_require__(164);

// EXTERNAL MODULE: ./src/providers/address/address.ts
var address = __webpack_require__(97);

// CONCATENATED MODULE: ./src/pages/includes/multiple-outputs/multiple-outputs.ts




// Providers




let multiple_outputs_MultipleOutputsPage = class MultipleOutputsPage {
    constructor(addressBookProvider, addressProvider, logger, translate, walletProvider) {
        this.addressBookProvider = addressBookProvider;
        this.addressProvider = addressProvider;
        this.logger = logger;
        this.translate = translate;
        this.walletProvider = walletProvider;
        this.openBlockChainEvent = new core["EventEmitter"]();
        this.showMultiplesOutputs = false;
    }
    set tx(tx) {
        this._tx = tx;
        this._misunderstoodOutputsMsg = tx.misunderstoodOutputs
            ? this.translate.instant('There are some misunderstood outputs, please view on blockchain.')
            : undefined;
        this.tx.outputs.forEach(output => {
            const outputAddr = output.toAddress ? output.toAddress : output.address;
            this.coin = this._tx.coin
                ? this._tx.coin
                : this.addressProvider.getCoinAndNetwork(outputAddr, this._tx.network)
                    .coin;
            const addressToShow = this.walletProvider.getAddressView(this.coin, this._tx.network, outputAddr);
            output.addressToShow =
                addressToShow == 'false' ? 'Unparsed address' : addressToShow;
        });
        this.contact();
    }
    get tx() {
        return this._tx;
    }
    get misunderstoodOutputsMsg() {
        return this._misunderstoodOutputsMsg;
    }
    viewOnBlockchain() {
        this.openBlockChainEvent.next();
    }
    contact() {
        const addr = this._tx.toAddress;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                const name = lodash["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", Object)
], multiple_outputs_MultipleOutputsPage.prototype, "openBlockChainEvent", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], multiple_outputs_MultipleOutputsPage.prototype, "tx", null);
multiple_outputs_MultipleOutputsPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-multiple-outputs',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/multiple-outputs/multiple-outputs.html"*/'<ion-item>\n  <ion-label>\n    <div class="summary-item">\n      <span translate>Sending to</span>\n    </div>\n  </ion-label>\n  <ion-note item-end>\n    <div *ngIf="tx.misunderstoodOutputs" class="summary-item-detail">\n      <span translate>Multiple recipients</span>\n    </div>\n    <div class="payment-proposal-to" *ngIf="!tx.hasMultiplesOutputs && !tx.misunderstoodOutputs">\n      <div class="background-content" copy-to-clipboard="{{ tx.outputs[0].addressToShow ? tx.outputs[0].addressToShow : tx.outputs[0].address }}">\n        <img class="coin-img" *ngIf="tx.hasMultiplesOutputs || (!tx.hasMultiplesOutputs && tx.customData?.service != \'debitcard\') || true" src="assets/img/currencies/{{tx.coin}}.svg" [ngClass]="{\'testnet\': tx.network === \'testnet\'}" alt="Coin" />\n        <img *ngIf="!tx.hasMultiplesOutputs && tx.customData?.service == \'debitcard\'" src="assets/img/icon-card.svg" class="debit-card">\n\n        <span *ngIf="!contactName">{{ (tx.outputs[0].addressToShow ? tx.outputs[0].addressToShow : tx.outputs[0].address) | shortenedAddress}}</span>\n        <span class="ellipsis" *ngIf="contactName">{{ contactName }}</span>\n      </div>\n    </div>\n\n    <ion-row align-items-center class="wallet" *ngIf="tx.hasMultiplesOutputs && !tx.misunderstoodOutputs" (click)="showMultiplesOutputs = !showMultiplesOutputs">\n      <ion-col>\n        <ion-icon item-start>\n          <img class="coin-img" src="assets/img/icon-{{tx.coin}}-small.svg" alt="Coin" />\n        </ion-icon>\n      </ion-col>\n      <ion-col>\n        <span class="note-container ellipsis" translate>Multiple recipients </span>\n      </ion-col>\n      <ion-col>\n        <span>({{tx.recipientCount}}):</span>\n      </ion-col>\n      <ion-col>\n        <button ion-button clear color="grey" icon-only item-end>\n          <ion-icon *ngIf="showMultiplesOutputs" name="ios-arrow-up-outline"></ion-icon>\n          <ion-icon *ngIf="!showMultiplesOutputs" name="ios-arrow-down-outline"></ion-icon>\n        </button>\n      </ion-col>\n    </ion-row>\n  </ion-note>\n\n</ion-item>\n\n<div *ngIf="tx.hasMultiplesOutputs && showMultiplesOutputs">\n  <ion-item *ngFor="let output of tx.outputs" copy-to-clipboard="{{output.toAddress ? output.toAddress : output.address}}">\n    <ion-note class="secondary-note" item-right text-end>\n      <span>{{output.addressToShow || output.toAddress || output.address}}</span>\n      <span>{{output.amountStr}}\n        <span *ngIf="output.alternativeAmountStr">({{output.alternativeAmountStr}})</span>\n      </span>\n      <p class="output-note" *ngIf="output.message">\n        <span class="ellipsis">{{output.message}}</span>\n      </p>\n    </ion-note>\n  </ion-item>\n</div>\n\n<ion-item *ngIf="tx.misunderstoodOutputs">\n<div>\n    <a class="misunderstood-msg" (click)="viewOnBlockchain()">\n      {{misunderstoodOutputsMsg}}\n    </a>\n</div>\n</ion-item>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/multiple-outputs/multiple-outputs.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [address_book["a" /* AddressBookProvider */],
        address["a" /* AddressProvider */],
        logger_logger["a" /* Logger */],
        core_es5["f" /* TranslateService */],
        wallet_wallet["a" /* WalletProvider */]])
], multiple_outputs_MultipleOutputsPage);

//# sourceMappingURL=multiple-outputs.js.map
// CONCATENATED MODULE: ./src/pages/includes/txp/txp.ts






let txp_TxpPage = class TxpPage {
    constructor(timeProvider, modalCtrl, navCtrl) {
        this.timeProvider = timeProvider;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
    }
    set tx(tx) {
        this._tx = tx;
    }
    get tx() {
        return this._tx;
    }
    set addressbook(addressbook) {
        this._addressbook = addressbook;
    }
    get addressbook() {
        return this._addressbook;
    }
    set noOpenModal(noOpenModal) {
        this._noOpenModal = noOpenModal;
    }
    get noOpenModal() {
        return this._noOpenModal;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    openTxpModal(txp) {
        if (this._noOpenModal)
            return;
        const modal = this.modalCtrl.create(txp_details_TxpDetailsPage, { tx: txp }, { showBackdrop: false, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(opts => {
            if (opts && opts.multisigContractAddress) {
                this.navCtrl.push(confirm_confirm["a" /* ConfirmPage */], opts);
            }
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], txp_TxpPage.prototype, "tx", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], txp_TxpPage.prototype, "addressbook", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], txp_TxpPage.prototype, "noOpenModal", null);
txp_TxpPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-txp',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/txp/txp.html"*/'<button ion-item class="proposal-container" (click)="openTxpModal(tx)">\n  <div *ngIf="!tx.merchant" class="proposal-title">\n    <span *ngIf="tx.message">{{tx.message}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && addressbook[tx.toAddress]">{{addressbook[tx.toAddress].name || addressbook[tx.toAddress]}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && !addressbook[tx.toAddress]" translate>Sending</span>\n  </div>\n  <div class="proposal-subtitle">\n    <span *ngIf="tx.merchant" class="item-subtitle">\n      <span *ngIf="tx.merchant.pr.ca">\n        <ion-icon class="fi-lock"></ion-icon>{{tx.merchant.domain}}\n      </span>\n      <span *ngIf="!tx.merchant.pr.ca">\n        <ion-icon class="fion-icon-unlock"></ion-icon>{{tx.merchant.domain}}\n      </span>\n    </span>\n    <div class="item-subtitle">\n      <span *ngIf="tx.creatorName">\n        <span translate>Created by</span>\n        <span>{{tx.creatorName}}</span>\n      </span>\n    </div>\n  </div>\n\n  <ion-note item-right>\n    <div class="amount">\n      <span *ngIf="tx.action == \'sent\'"></span>\n      <span *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n      <span *ngIf="tx.action != \'invalid\'">{{tx.amountStr}}</span>\n    </div>\n    <div class="date">\n      <time *ngIf="tx.createdOn && createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amTimeAgo}}</time>\n      <time *ngIf="tx.createdOn && !createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amDateFormat:\'MMM D, YYYY\'}}</time>\n    </div>\n  </ion-note>\n</button>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/txp/txp.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [time["a" /* TimeProvider */],
        ionic_angular["l" /* ModalController */],
        ionic_angular["m" /* NavController */]])
], txp_TxpPage);

//# sourceMappingURL=txp.js.map
// EXTERNAL MODULE: ./src/pages/cards/cards.ts
var cards_cards = __webpack_require__(975);

// EXTERNAL MODULE: ./src/pages/home/home.ts
var home = __webpack_require__(976);

// EXTERNAL MODULE: ./src/pages/scan/scan.ts
var scan = __webpack_require__(129);

// EXTERNAL MODULE: ./src/pages/send/send.ts
var send = __webpack_require__(1025);

// EXTERNAL MODULE: ./src/pages/settings/settings.ts
var settings = __webpack_require__(506);

// EXTERNAL MODULE: ./src/pages/wallets/wallets.ts
var wallets = __webpack_require__(1022);

// EXTERNAL MODULE: ./src/pages/wallets/proposals-notifications/proposals-notifications.ts
var proposals_notifications = __webpack_require__(516);

// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(5);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// EXTERNAL MODULE: ./src/pipes/format-currency.ts
var format_currency = __webpack_require__(504);

// EXTERNAL MODULE: ./node_modules/apexcharts/dist/apexcharts.common.js
var apexcharts_common = __webpack_require__(2009);
var apexcharts_common_default = /*#__PURE__*/__webpack_require__.n(apexcharts_common);

// CONCATENATED MODULE: ./src/components/chart-component/chart-component.ts



let chart_component_ChartComponent = class ChartComponent {
    ngOnInit() {
        setTimeout(() => {
            this.createElement();
        }, 0);
    }
    ngOnChanges(_changes) {
        setTimeout(() => {
            this.createElement();
        }, 0);
    }
    createElement() {
        const options = {};
        if (this.annotations) {
            options.annotations = this.annotations;
        }
        if (this.chart) {
            options.chart = this.chart;
        }
        if (this.colors) {
            options.colors = this.colors;
        }
        if (this.dataLabels) {
            options.dataLabels = this.dataLabels;
        }
        if (this.series) {
            options.series = this.series;
        }
        if (this.stroke) {
            options.stroke = this.stroke;
        }
        if (this.labels) {
            options.labels = this.labels;
        }
        if (this.legend) {
            options.legend = this.legend;
        }
        if (this.fill) {
            options.fill = this.fill;
        }
        if (this.tooltip) {
            options.tooltip = this.tooltip;
        }
        if (this.plotOptions) {
            options.plotOptions = this.plotOptions;
        }
        if (this.responsive) {
            options.responsive = this.responsive;
        }
        if (this.markers) {
            options.markers = this.markers;
        }
        if (this.xaxis) {
            options.xaxis = this.xaxis;
        }
        if (this.yaxis) {
            options.yaxis = this.yaxis;
        }
        if (this.grid) {
            options.grid = this.grid;
        }
        if (this.states) {
            options.states = this.states;
        }
        if (this.title) {
            options.title = this.title;
        }
        if (this.subtitle) {
            options.subtitle = this.subtitle;
        }
        if (this.theme) {
            options.theme = this.theme;
        }
        if (this.chartObj) {
            this.chartObj.destroy();
        }
        this.chartObj = new apexcharts_common_default.a(this.chartElement.nativeElement, options);
        this.render();
    }
    render() {
        return this.chartObj.render();
    }
    updateOptions(options, redrawPaths, animate, updateSyncedCharts) {
        return this.chartObj.updateOptions(options, redrawPaths, animate, updateSyncedCharts);
    }
    updateSeries(newSeries, animate) {
        this.chartObj.updateSeries(newSeries, animate);
    }
    toggleSeries(seriesName) {
        this.chartObj.toggleSeries(seriesName);
    }
    addXaxisAnnotation(options, pushToMemory, context) {
        this.chartObj.addXaxisAnnotation(options, pushToMemory, context);
    }
    addYaxisAnnotation(options, pushToMemory, context) {
        this.chartObj.addYaxisAnnotation(options, pushToMemory, context);
    }
    addPointAnnotation(options, pushToMemory, context) {
        this.chartObj.addPointAnnotation(options, pushToMemory, context);
    }
    addText(options, pushToMemory, context) {
        this.chartObj.addText(options, pushToMemory, context);
    }
    dataURI() {
        return this.chartObj.dataURI();
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "chart", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "annotations", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Array)
], chart_component_ChartComponent.prototype, "colors", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "dataLabels", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "series", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "stroke", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Array)
], chart_component_ChartComponent.prototype, "labels", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "legend", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "fill", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "tooltip", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "plotOptions", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "responsive", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "markers", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "xaxis", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "yaxis", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "grid", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "states", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "title", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "subtitle", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], chart_component_ChartComponent.prototype, "theme", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('chart'),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], chart_component_ChartComponent.prototype, "chartElement", void 0);
chart_component_ChartComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'apx-chart',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/chart-component/chart-component.html"*/'<div #chart></div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/chart-component/chart-component.html"*/
    })
], chart_component_ChartComponent);

//# sourceMappingURL=chart-component.js.map
// CONCATENATED MODULE: ./src/components/price-chart/price-chart.ts



let price_chart_PriceChart = class PriceChart {
    constructor() {
        this.priceChange = new core["EventEmitter"]();
        this.loading = false;
    }
    initChartData(params) {
        const { data, color } = params;
        this.rates = data;
        const eventEmitter = this.priceChange;
        this.chartOptions = {
            series: [
                {
                    name: '',
                    data: this.rates
                }
            ],
            chart: {
                type: 'line',
                stacked: false,
                height: 350,
                toolbar: {
                    show: false
                },
                animations: {
                    enabled: false
                },
                events: {
                    mouseMove(_event, _chart, options) {
                        const data = options.config.series[0].data;
                        const index = options.dataPointIndex;
                        if (data && data[index] && data[index][1]) {
                            eventEmitter.emit({
                                date: data[index][0],
                                price: data[index][1]
                            });
                        }
                    }
                }
            },
            dataLabels: {
                enabled: false
            },
            markers: {
                size: 0,
                hover: {
                    size: 0
                }
            },
            tooltip: {
                followCursor: true,
                shared: false,
                x: {
                    show: false
                }
            },
            grid: {
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                },
                show: false,
                xaxis: {
                    lines: {
                        show: false
                    }
                },
                yaxis: {
                    lines: {
                        show: false
                    }
                }
            },
            xaxis: {
                labels: {
                    show: false
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                }
            },
            yaxis: {
                show: false,
                labels: {
                    show: false
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                }
            },
            stroke: {
                colors: [color],
                curve: 'straight',
                width: 2
            },
            theme: {
                monochrome: {
                    enabled: true,
                    color
                }
            }
        };
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('chart'),
    tslib_es6["__metadata"]("design:type", chart_component_ChartComponent)
], price_chart_PriceChart.prototype, "chart", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", Object)
], price_chart_PriceChart.prototype, "priceChange", void 0);
price_chart_PriceChart = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'price-chart',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/price-chart/price-chart.html"*/'<div class="container">\n  <ion-spinner *ngIf="loading"></ion-spinner>\n  <apx-chart\n    *ngIf="rates"\n    #chart\n    [series]="chartOptions.series"\n    [chart]="chartOptions.chart"\n    [dataLabels]="chartOptions.dataLabels"\n    [markers]="chartOptions.markers"\n    [tooltip]="chartOptions.tooltip"\n    [grid]="chartOptions.grid"\n    [xaxis]="chartOptions.xaxis"\n    [yaxis]="chartOptions.yaxis"\n    [stroke]="chartOptions.stroke"\n    [theme]="chartOptions.theme"\n  ></apx-chart>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/price-chart/price-chart.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [])
], price_chart_PriceChart);

//# sourceMappingURL=price-chart.js.map
// EXTERNAL MODULE: ./src/providers/rate/rate.ts
var rate = __webpack_require__(78);

// CONCATENATED MODULE: ./src/pages/home/price-page/price-page.ts







// Pages

// Providers


let price_page_PricePage = class PricePage {
    constructor(navCtrl, navParams, rateProvider, formatCurrencyPipe, configProvider, logger, simplexProvider, analyticsProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.rateProvider = rateProvider;
        this.formatCurrencyPipe = formatCurrencyPipe;
        this.configProvider = configProvider;
        this.logger = logger;
        this.simplexProvider = simplexProvider;
        this.analyticsProvider = analyticsProvider;
        this.activeOption = '1D';
        this.updateOptions = [
            { label: '1D', dateRange: rate["a" /* DateRanges */].Day },
            { label: '1W', dateRange: rate["a" /* DateRanges */].Week },
            { label: '1M', dateRange: rate["a" /* DateRanges */].Month }
        ];
        this.card = lodash["clone"](this.navParams.data.card);
        this.setFiatIsoCode();
    }
    ionViewDidLoad() {
        this.drawCanvas();
        // Let the canvas settle
        setTimeout(() => {
            this.getPrice(rate["a" /* DateRanges */].Day);
        }, 1000);
    }
    getPrice(dateRange) {
        this.canvas.loading = true;
        this.rateProvider.fetchHistoricalRates(this.fiatIsoCode, dateRange).then(response => {
            this.card.historicalRates = response[this.card.unitCode];
            if (this.card.historicalRates) {
                this.updateValues();
                this.setPrice();
                this.redrawCanvas();
            }
            else {
                // TODO FIX SHOW "no historical rates found!"
            }
        }, err => {
            this.logger.error('Error getting rates:', err);
        });
    }
    formatDate(date) {
        if (this.activeOption === '1Y') {
            return `${moment(date).format('MMM DD YYYY')}`;
        }
        else if (this.activeOption === '1M') {
            return `${moment(date).format('MMM DD hh A')}`;
        }
        else if (this.activeOption === '1W') {
            return `${moment(date).format('ddd hh:mm A')}`;
        }
        else {
            return `${moment(date).format('hh:mm A')}`;
        }
    }
    setPrice(points = {}) {
        const { date, price = this.card.currentPrice } = points;
        const displayDate = date
            ? this.formatDate(date)
            : this.card.unitCode.toUpperCase();
        const minPrice = this.card.historicalRates[this.card.historicalRates.length - 1].rate;
        this.card.totalBalanceChangeAmount = price - minPrice;
        this.card.totalBalanceChange =
            (this.card.totalBalanceChangeAmount * 100) / minPrice;
        const customPrecision = this.card.unitCode === 'xrp' || this.card.unitCode === 'doge' ? 4 : 2;
        document.getElementById('displayPrice').textContent = `${this.formatCurrencyPipe.transform(price, this.fiatIsoCode, customPrecision)}`;
        document.getElementById('displayDate').textContent = `${displayDate}`;
        document.getElementById('averagePriceAmount').textContent = `${this.formatCurrencyPipe.transform(this.card.totalBalanceChangeAmount, this.fiatIsoCode, customPrecision)}`;
        document.getElementById('averagePricePercent').textContent = `${this.formatCurrencyPipe.transform(this.card.totalBalanceChange, '%', 2)}`;
    }
    redrawCanvas() {
        this.canvas.loading = false;
        if (!this.canvas.chart)
            return;
        const data = this.card.historicalRates.map(rate => [rate.ts, rate.rate]);
        this.canvas.chart.updateOptions({
            chart: {
                animations: {
                    enabled: true
                }
            },
            series: [
                {
                    data
                }
            ],
            tooltip: {
                x: {
                    show: false
                }
            }
        }, false, true, true);
    }
    drawCanvas() {
        const dataSeries = this.card.historicalRates.map(historicalRate => [
            historicalRate.ts,
            historicalRate.rate
        ]);
        this.canvas.initChartData({
            data: dataSeries,
            color: this.card.backgroundColor
        });
    }
    updateChart(option) {
        const { label, dateRange } = option;
        this.activeOption = label;
        this.getPrice(dateRange);
    }
    updateValues() {
        this.card.currentPrice = this.card.historicalRates[0].rate;
        const minPrice = this.card.historicalRates[this.card.historicalRates.length - 1].rate;
        this.card.totalBalanceChangeAmount = this.card.currentPrice - minPrice;
        this.card.totalBalanceChange =
            (this.card.totalBalanceChangeAmount * 100) / minPrice;
    }
    setFiatIsoCode() {
        this.fiatCodes = this.simplexProvider.getSupportedFiatAltCurrencies();
        const { alternativeIsoCode } = this.configProvider.get().wallet.settings;
        this.fiatIsoCode = this.rateProvider.isAltCurrencyAvailable(alternativeIsoCode)
            ? alternativeIsoCode
            : 'USD';
        this.isFiatIsoCodeSupported = lodash["includes"](this.fiatCodes, this.fiatIsoCode);
    }
    goToAmountPage() {
        this.analyticsProvider.logEvent('buy_crypto_button_clicked', {
            from: 'priceChartsPage',
            coin: this.card.unitCode
        });
        this.navCtrl.push(amount["a" /* AmountPage */], {
            coin: this.card.unitCode,
            fromBuyCrypto: true,
            nextPage: 'CryptoOrderSummaryPage',
            currency: this.configProvider.get().wallet.settings.alternativeIsoCode
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('canvas'),
    tslib_es6["__metadata"]("design:type", price_chart_PriceChart)
], price_page_PricePage.prototype, "canvas", void 0);
price_page_PricePage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'price-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/home/price-page/price-page.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title size="large" class="bp-header card-title">{{ card.name | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="total-amount-container">\n    <div id="displayDate" class="section-header" translate></div>\n    <span id="displayPrice" class="total-amount-value"></span>\n    <span *ngIf="card.totalBalanceChange || card.totalBalanceChange === 0" [ngClass]="card.totalBalanceChange >= 0 ? \'possitive-avg percent\' : \'negative-avg percent\'">\n      <span id="averagePricePercent"><span *ngIf="card.totalBalanceChange > 0">+</span></span>\n    </span>\n\n    <div class="average-container">\n      <div *ngIf="card.totalBalanceChangeAmount || card.totalBalanceChangeAmount === 0" [ngClass]="card.totalBalanceChangeAmount >= 0 ? \'possitive-avg\' : \'negative-avg\'">\n        <span class="average" id="averagePriceAmount"><span *ngIf="card.totalBalanceChangeAmount > 0">+</span></span>\n      </div>\n    </div>\n  </div>\n\n  <price-chart #canvas (priceChange)="setPrice($event)" (touchend)="setPrice()" (mouseup)="setPrice()"></price-chart>\n</ion-content>\n\n<ion-footer no-border>\n  <ion-toolbar>\n    <span class="labels">\n      <div *ngFor="let option of updateOptions">\n        <ion-chip [ngClass]="{\'active\': activeOption === option.label, \'inactive\': activeOption !== option.label }" (click)="updateChart(option)">\n          <ion-label>{{ option.label }}</ion-label>\n        </ion-chip>\n      </div>\n    </span>\n    <!--TODO FIX REMOVE BUY BUTTON\n    <button ion-button class="button-standard" *ngIf="card.unitCode != \'xrp\'" (click)="goToAmountPage()">\n      Buy {{ card.name }}\n    </button>\n    -->\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/home/price-page/price-page.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        rate["b" /* RateProvider */],
        format_currency["a" /* FormatCurrencyPipe */],
        providers["s" /* ConfigProvider */],
        providers["W" /* Logger */],
        providers["_13" /* SimplexProvider */],
        providers["d" /* AnalyticsProvider */]])
], price_page_PricePage);

//# sourceMappingURL=price-page.js.map
// EXTERNAL MODULE: ./src/directives/animate/animate.ts
var animate = __webpack_require__(509);

// CONCATENATED MODULE: ./src/pages/pin/pin-dots/pin-dots.component.ts



let PinDots = class PinDots {
    constructor() {
        this.dotArray = new Array(4);
    }
    ngOnChanges(changes) {
        const pinChanges = changes.pin;
        if (!pinChanges) {
            return;
        }
        const currentValue = pinChanges.currentValue;
        const previousValue = pinChanges.previousValue;
        if (!currentValue.length || currentValue.length < previousValue.length) {
            return;
        }
        this.pulseDot(currentValue.length - 1);
    }
    isFilled(limit) {
        return this.pin && this.pin.length >= limit;
    }
    pulseDot(dotIndex) {
        const dot = this.dots.toArray()[dotIndex];
        dot.animate('pulse');
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], PinDots.prototype, "pin", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChildren"])(animate["a" /* Animate */]),
    tslib_es6["__metadata"]("design:type", core["QueryList"])
], PinDots.prototype, "dots", void 0);
PinDots = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'pin-dots',
        template: `
    <div
      *ngFor="let dot of dotArray; index as i"
      class="circle"
      [ngClass]="{ filled: isFilled(i + 1) }"
      animate
    ></div>
  `
    })
], PinDots);

//# sourceMappingURL=pin-dots.component.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js
var Observable = __webpack_require__(4);
var Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);

// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js
var Subject = __webpack_require__(50);
var Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);

// CONCATENATED MODULE: ./src/pages/pin/pin-pad/pin-pad.component.ts




let pin_pad_component_PinPad = class PinPad {
    constructor() {
        this.integersOnly = false;
        this.keystrokeSubject = new Subject["Subject"]();
        this.keystroke = this.keystrokeSubject.asObservable();
        this.buttonRows = [
            [
                {
                    value: '1',
                    letters: ''
                },
                {
                    value: '2',
                    letters: 'ABC'
                },
                {
                    value: '3',
                    letters: 'DEF'
                }
            ],
            [
                {
                    value: '4',
                    letters: 'GHI'
                },
                {
                    value: '5',
                    letters: 'JKL'
                },
                {
                    value: '6',
                    letters: 'MNO'
                }
            ],
            [
                {
                    value: '7',
                    letters: 'PQRS'
                },
                {
                    value: '8',
                    letters: 'TUV'
                },
                {
                    value: '9',
                    letters: 'WXYZ'
                }
            ],
            [
                {
                    value: '.',
                    letters: ''
                },
                {
                    value: '0',
                    letters: ''
                },
                {
                    value: 'delete',
                    letters: ''
                }
            ]
        ];
    }
    onKeystroke(value) {
        if (this.isValueDisabled(value)) {
            return;
        }
        this.keystrokeSubject.next(value);
    }
    isValueDisabled(value) {
        return value === '.' && this.integersOnly;
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], pin_pad_component_PinPad.prototype, "integersOnly", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], pin_pad_component_PinPad.prototype, "type", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", Observable["Observable"])
], pin_pad_component_PinPad.prototype, "keystroke", void 0);
pin_pad_component_PinPad = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'pin-pad',
        template: `
    <ion-row *ngFor="let row of buttonRows">
      <ion-col
        *ngFor="let button of row"
        (click)="onKeystroke(button.value)"
        [ngClass]="{ disabled: isValueDisabled(button.value) }"
        tappable
      >
        <div class="buttons-container" [ngSwitch]="button.value">
          <span *ngSwitchCase="'delete'">
            <img *ngIf="type === 'pin'" src="assets/img/tail-left.svg" />
            <img
              class="amount-delete"
              *ngIf="type === 'amount'"
              src="assets/img/icon-delete.svg"
            />
          </span>
          <span *ngSwitchCase="'.'">
            <span *ngIf="type === 'amount'">.</span>
          </span>
          <span *ngSwitchDefault>{{ button.value }}</span>
        </div>
        <div class="letters" *ngIf="type === 'pin'">{{ button.letters }}</div>
      </ion-col>
    </ion-row>
  `
    })
], pin_pad_component_PinPad);

//# sourceMappingURL=pin-pad.component.js.map
// CONCATENATED MODULE: ./src/pages/pin/pin.ts



const PIN_COMPONENTS = [pin_modal["a" /* PinModalPage */], PinDots, pin_pad_component_PinPad];
//# sourceMappingURL=pin.js.map
// EXTERNAL MODULE: ./src/pages/settings/about/session-log/session-log.ts
var session_log = __webpack_require__(996);

// EXTERNAL MODULE: ./src/pages/settings/addressbook/addressbook.ts
var addressbook = __webpack_require__(997);

// EXTERNAL MODULE: ./src/pages/settings/addressbook/view/view.ts
var view = __webpack_require__(998);

// EXTERNAL MODULE: ./src/pages/settings/advanced/advanced.ts
var advanced = __webpack_require__(999);

// EXTERNAL MODULE: ./src/pages/settings/alt-currency/alt-currency.ts
var alt_currency = __webpack_require__(1002);

// EXTERNAL MODULE: ./src/pages/settings/fee-policy/fee-policy.ts
var fee_policy = __webpack_require__(1003);

// EXTERNAL MODULE: ./src/pages/settings/language/language.ts
var language = __webpack_require__(1017);

// EXTERNAL MODULE: ./src/pages/settings/local-theme/local-theme.ts
var local_theme = __webpack_require__(1018);

// EXTERNAL MODULE: ./src/pages/settings/lock/lock.ts
var lock = __webpack_require__(1019);

// EXTERNAL MODULE: ./src/pages/settings/notifications/notifications.ts + 1 modules
var notifications = __webpack_require__(1020);

// EXTERNAL MODULE: ./src/pages/settings/share/share.ts
var share = __webpack_require__(512);

// EXTERNAL MODULE: ./src/pages/settings/tkcoin-id/tkcoin-id.ts
var tkcoin_id = __webpack_require__(1021);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/clear-encrypt-password/clear-encrypt-password.ts
var clear_encrypt_password = __webpack_require__(1013);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/extended-private-key/extended-private-key.ts
var extended_private_key = __webpack_require__(1014);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/key-delete/key-delete.ts
var key_delete = __webpack_require__(1015);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/key-name/key-name.ts
var key_name = __webpack_require__(1005);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/key-onboarding/key-onboarding.ts
var key_onboarding = __webpack_require__(389);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/key-qr-export/key-qr-export.ts
var key_qr_export = __webpack_require__(1016);

// EXTERNAL MODULE: ./src/pages/settings/key-settings/key-settings.ts
var key_settings = __webpack_require__(1004);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-delete/wallet-delete.ts
var wallet_delete = __webpack_require__(1006);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-name/wallet-name.ts
var wallet_name = __webpack_require__(1007);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings.ts
var wallet_settings = __webpack_require__(513);

// EXTERNAL MODULE: ./src/pages/settings/advanced/wallet-recover-page/wallet-mnemonic-recover-page/wallet-mnemonic-recover-page.ts
var wallet_mnemonic_recover_page = __webpack_require__(1001);

// EXTERNAL MODULE: ./src/pages/settings/advanced/wallet-recover-page/wallet-recover-page.ts
var wallet_recover_page = __webpack_require__(1000);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.ts
var all_addresses = __webpack_require__(1008);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.ts
var wallet_addresses = __webpack_require__(514);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-duplicate/wallet-duplicate.ts
var wallet_duplicate = __webpack_require__(1009);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.ts
var wallet_export = __webpack_require__(515);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.ts
var wallet_information = __webpack_require__(1010);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.ts
var wallet_service_url = __webpack_require__(1011);

// EXTERNAL MODULE: ./src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.ts
var wallet_transaction_history = __webpack_require__(1012);

// EXTERNAL MODULE: ./src/pages/add/create-eth-multisig/create-eth-multisig.ts + 1 modules
var create_eth_multisig = __webpack_require__(971);

// EXTERNAL MODULE: ./src/pages/send/multi-send/multi-send.ts
var multi_send = __webpack_require__(1027);

// EXTERNAL MODULE: ./src/pages/send/select-inputs/select-inputs.ts
var select_inputs = __webpack_require__(1026);

// EXTERNAL MODULE: ./src/pages/send/transfer-to-modal/transfer-to-modal.ts
var transfer_to_modal = __webpack_require__(520);

// CONCATENATED MODULE: ./src/pages/send/transfer-to/transfer-to.ts




// Providers








// Pages

let transfer_to_TransferToPage = class TransferToPage {
    constructor(currencyProvider, navCtrl, navParams, profileProvider, walletProvider, addressBookProvider, logger, platformProvider, popupProvider, addressProvider, viewCtrl, events) {
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.addressBookProvider = addressBookProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.addressProvider = addressProvider;
        this.viewCtrl = viewCtrl;
        this.events = events;
        this.search = '';
        this.wallets = {};
        this.hasWallets = {};
        this.walletList = {};
        this.contactsList = [];
        this.filteredContactsList = [];
        this.filteredWallets = [];
        this.walletsByKeys = [];
        this.filteredWalletsByKeys = [];
        this.updatingContactsList = false;
        this.itemTapped = false;
        this._delayTimeOut = 700;
        this.CONTACTS_SHOW_LIMIT = 10;
        this.currentContactsPage = 0;
        this.availableCoins = this.currencyProvider.getAvailableCoins();
        for (const coin of this.availableCoins) {
            this.wallets[coin] = this.profileProvider.getWallets({ coin });
            this.hasWallets[coin] = !lodash["isEmpty"](this.wallets[coin]);
        }
        this._delayTimeOut =
            this.platformProvider.isIOS || this.platformProvider.isAndroid
                ? 700
                : 100;
    }
    set wallet(wallet) {
        this._wallet = this.navParams.data.wallet
            ? this.navParams.data.wallet
            : wallet;
        for (const coin of this.availableCoins) {
            this.walletList[coin] = lodash["compact"](this.getWalletsList(coin));
        }
        this.walletsByKeys = lodash["values"](lodash["groupBy"](this.walletList[this._wallet.coin], 'keyId'));
        this.delayUpdateContactsList(this._delayTimeOut);
    }
    get wallet() {
        return this._wallet;
    }
    set searchInput(search) {
        this.search = search;
        this.processInput();
    }
    get searchInput() {
        return this.search;
    }
    set useAsModal(useAsModal) {
        this._useAsModal = useAsModal;
    }
    get useAsModal() {
        return this._useAsModal;
    }
    set fromWalletDetails(fromWalletDetails) {
        this._fromWalletDetails = fromWalletDetails;
    }
    get fromWalletDetails() {
        return this._fromWalletDetails;
    }
    set fromSelectInputs(fromSelectInputs) {
        this._fromSelectInputs = fromSelectInputs;
    }
    get fromSelectInputs() {
        return this._fromSelectInputs;
    }
    set fromMultiSend(fromMultiSend) {
        this._fromMultiSend = fromMultiSend;
    }
    get fromMultiSend() {
        return this._fromMultiSend;
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    getWalletsList(coin) {
        return this.hasWallets[coin]
            ? this.getRelevantWallets(this.wallets[coin])
            : [];
    }
    getRelevantWallets(rawWallets) {
        return rawWallets
            .map(wallet => this.flattenWallet(wallet))
            .filter(wallet => this.filterIrrelevantRecipients(wallet));
    }
    delayUpdateContactsList(delayTime = 700) {
        if (this.updatingContactsList)
            return;
        this.updatingContactsList = true;
        setTimeout(() => {
            this.updateContactsList();
            this.updatingContactsList = false;
        }, delayTime || 700);
    }
    updateContactsList() {
        this.addressBookProvider.list().then(ab => {
            this.hasContacts = lodash["isEmpty"](ab) ? false : true;
            if (!this.hasContacts)
                return;
            let contactsList = [];
            lodash["each"](ab, (v, k) => {
                const addrData = this.addressProvider.getCoinAndNetwork(k);
                contactsList.push({
                    name: lodash["isObject"](v) ? v.name : v,
                    address: k,
                    network: addrData.network,
                    email: lodash["isObject"](v) ? v.email : null,
                    recipientType: 'contact',
                    coin: addrData.coin,
                    getAddress: () => Promise.resolve(k),
                    destinationTag: v.tag
                });
            });
            contactsList = lodash["orderBy"](contactsList, 'name');
            this.contactsList = contactsList.filter(c => this.filterIrrelevantRecipients(c));
            let shortContactsList = lodash["clone"](this.contactsList.slice(0, (this.currentContactsPage + 1) * this.CONTACTS_SHOW_LIMIT));
            this.filteredContactsList = lodash["clone"](shortContactsList);
            this.contactsShowMore =
                this.contactsList.length > shortContactsList.length;
        });
    }
    flattenWallet(wallet) {
        return {
            walletId: wallet.credentials.walletId,
            color: wallet.color,
            name: wallet.name,
            recipientType: 'wallet',
            coin: wallet.coin,
            network: wallet.network,
            m: wallet.credentials.m,
            n: wallet.credentials.n,
            keyId: wallet.keyId,
            walletGroupName: wallet.walletGroupName,
            isComplete: () => wallet.isComplete(),
            needsBackup: wallet.needsBackup,
            getAddress: () => this.walletProvider.getAddress(wallet, false)
        };
    }
    filterIrrelevantRecipients(recipient) {
        return this._wallet
            ? this._wallet.coin === recipient.coin &&
                this._wallet.network === recipient.network &&
                this._wallet.id !== recipient.walletId
            : true;
    }
    showMore() {
        this.currentContactsPage++;
        this.updateContactsList();
    }
    processInput() {
        if (this.search && this.search.trim() != '') {
            this.searchWallets();
            this.searchContacts();
            this.hasContactsOrWallets =
                this.filteredContactsList.length === 0 &&
                    this.filteredWallets.length === 0
                    ? false
                    : true;
        }
        else {
            this.delayUpdateContactsList(this._delayTimeOut);
            this.filteredWallets = [];
            this.filteredWalletsByKeys = [];
        }
    }
    searchWallets() {
        for (const coin of this.availableCoins) {
            if (this.hasWallets[coin] && this._wallet.coin === coin) {
                this.filteredWallets = this.walletList[coin].filter(wallet => {
                    return lodash["includes"](wallet.name.toLowerCase(), this.search.toLowerCase());
                });
                this.filteredWalletsByKeys = lodash["values"](lodash["groupBy"](this.filteredWallets, 'keyId'));
            }
        }
    }
    searchContacts() {
        this.filteredContactsList = lodash["filter"](this.contactsList, item => {
            let val = item.name;
            return lodash["includes"](val.toLowerCase(), this.search.toLowerCase());
        });
    }
    close(item) {
        this.itemTapped = true;
        item
            .getAddress()
            .then((addr) => {
            if (!addr) {
                // Error is already formated
                this.popupProvider.ionicAlert('Error - no address');
                return;
            }
            this.logger.debug('Got address:' + addr + ' | ' + item.name);
            if (this._fromSelectInputs) {
                const recipient = {
                    recipientType: item.recipientType,
                    toAddress: addr,
                    name: item.name,
                    email: item.email
                };
                this.events.publish('addRecipient', recipient);
                this.viewCtrl.dismiss();
            }
            else {
                this.navCtrl.push(amount["a" /* AmountPage */], {
                    walletId: this.navParams.data.wallet.id,
                    recipientType: item.recipientType,
                    amount: parseInt(this.navParams.data.amount, 10),
                    toAddress: addr,
                    name: item.name,
                    email: item.email,
                    color: item.color,
                    coin: item.coin,
                    network: item.network,
                    useAsModal: this._useAsModal,
                    fromWalletDetails: this._fromWalletDetails,
                    fromMultiSend: this._fromMultiSend,
                    destinationTag: item.destinationTag
                });
            }
        })
            .catch(err => {
            this.logger.error('Send: could not getAddress', err);
        });
        this.itemTapped = false;
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], transfer_to_TransferToPage.prototype, "wallet", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object),
    tslib_es6["__metadata"]("design:paramtypes", [Object])
], transfer_to_TransferToPage.prototype, "searchInput", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], transfer_to_TransferToPage.prototype, "useAsModal", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], transfer_to_TransferToPage.prototype, "fromWalletDetails", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], transfer_to_TransferToPage.prototype, "fromSelectInputs", null);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean),
    tslib_es6["__metadata"]("design:paramtypes", [Boolean])
], transfer_to_TransferToPage.prototype, "fromMultiSend", null);
transfer_to_TransferToPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-transfer-to',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/transfer-to/transfer-to.html"*/'<div class="wallets-container" *ngIf="filteredContactsList && filteredContactsList[0]">\n  <div class="section-header">\n    <ion-label class="key-name">\n      <span translate>Contacts</span>\n    </ion-label>\n  </div>\n  <div class="line-divider"></div>\n  <ion-list no-lines class="bp-list" ng-class="{ \'disabled\':itemTapped}">\n    <button ion-item *ngFor="let item of filteredContactsList" (click)="close(item)">\n      <ion-icon class="item-img" item-start>\n        <gravatar [name]="item.name" [height]="40" [width]="40" [email]="item.email" [coin]="item.coin" [network]="item.network"></gravatar>\n      </ion-icon>\n      <div class="main-label">{{ item.name }}</div>\n    </button>\n  </ion-list>\n</div>\n\n<div *ngFor="let coin of availableCoins" ng-class="{ \'disabled\':itemTapped}">\n  <div class="wallets-container" *ngIf="walletList[coin] && walletList[coin][0]">\n    <div class="section-header">\n      <ion-label class="key-name">\n        <span>{{\'{coinName} Wallets\' | translate: { coinName: getCoinName(coin) } }}</span>\n      </ion-label>\n    </div>\n    <ion-list no-lines class="bp-list">\n      <div *ngFor="let walletsByKey of filteredWalletsByKeys[0] ? filteredWalletsByKeys : walletsByKeys">\n        <div class="key-divider" *ngIf="walletsByKey && walletsByKey[0]">\n          <ion-icon>\n            <img src="assets/img/settings-icons/icon-key.svg" width="15">\n          </ion-icon>\n          <span>{{ walletsByKey[0].walletGroupName }}</span>\n        </div>\n        <div *ngFor="let wallet of walletsByKey">\n          <wallet-item-content [wallet]="wallet" (click)="close(wallet)"></wallet-item-content>\n        </div>\n      </div>\n    </ion-list>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/transfer-to/transfer-to.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [currency["b" /* CurrencyProvider */],
        ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        profile_profile["a" /* ProfileProvider */],
        wallet_wallet["a" /* WalletProvider */],
        address_book["a" /* AddressBookProvider */],
        logger_logger["a" /* Logger */],
        platform_platform["a" /* PlatformProvider */],
        popup["a" /* PopupProvider */],
        address["a" /* AddressProvider */],
        ionic_angular["t" /* ViewController */],
        ionic_angular["f" /* Events */]])
], transfer_to_TransferToPage);

//# sourceMappingURL=transfer-to.js.map
// EXTERNAL MODULE: ./src/pages/receive/custom-amount/custom-amount.ts
var custom_amount = __webpack_require__(984);

// CONCATENATED MODULE: ./src/pages/templates/wide-header-page/wide-header-page.ts




let WideHeaderPage = class WideHeaderPage {
    constructor(platformProvider) {
        this.platformProvider = platformProvider;
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], WideHeaderPage.prototype, "headerColor", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], WideHeaderPage.prototype, "title", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], WideHeaderPage.prototype, "hideBackButton", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], WideHeaderPage.prototype, "hasSlideButton", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(ionic_angular["o" /* Navbar */]),
    tslib_es6["__metadata"]("design:type", ionic_angular["o" /* Navbar */])
], WideHeaderPage.prototype, "navBar", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(ionic_angular["e" /* Content */]),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], WideHeaderPage.prototype, "scrollArea", void 0);
WideHeaderPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'wide-header-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/templates/wide-header-page/wide-header-page.html"*/'<ion-header class="wide-header" [ngClass]="{\'cordova\': platformProvider.isCordova}">\n  <ion-navbar [navbar-bg]="headerColor" [hideBackButton]="hideBackButton">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{title}}\n      </div>\n    </ion-title>\n    <ng-content select="[left]"></ng-content>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n<ion-content no-bounce #scrollArea [ngClass]="{\'add-padding-bottom\': hasSlideButton, \'add-bottom-safe-area\': !hasSlideButton && platformProvider.isCordova}">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary class="ellipsis">\n          {{title}}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n    <ng-content select="[page-content]"></ng-content>\n  </div>\n</ion-content>\n<ion-footer>\n  <ng-content select="[footer-content]"></ng-content>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/templates/wide-header-page/wide-header-page.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [platform_platform["a" /* PlatformProvider */]])
], WideHeaderPage);

//# sourceMappingURL=wide-header-page.js.map
// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/buy-card/buy-card.ts
var buy_card = __webpack_require__(395);

// EXTERNAL MODULE: ./node_modules/rxjs/operators.js
var operators = __webpack_require__(133);
var operators_default = /*#__PURE__*/__webpack_require__.n(operators);

// EXTERNAL MODULE: ./src/providers/gift-card/gift-card.ts + 1 modules
var gift_card = __webpack_require__(89);

// EXTERNAL MODULE: ./src/providers/merchant/merchant.ts + 1 modules
var merchant_merchant = __webpack_require__(386);

// CONCATENATED MODULE: ./src/pages/merchant/merchant.ts





let merchant_MerchantPage = class MerchantPage {
    constructor(externalLinkProvider, navParams, themeProvider) {
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.themeProvider = themeProvider;
        this.getDiscountTextColor = merchant_merchant["c" /* getDiscountTextColor */];
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.merchant = this.navParams.get('merchant');
        });
    }
    goToMerchant() {
        const url = this.merchant.cta
            ? this.merchant.cta.link
            : this.merchant.domains[0];
        this.externalLinkProvider.open(url);
    }
};
merchant_MerchantPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'merchant-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/merchant/merchant.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{merchant.displayName}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="wrapper">\n    <div class="content">\n      <div class="cover"><img [src]="merchant.icon" /></div>\n      <div class="body">\n        <div class="body__title">{{merchant.displayName}}</div>\n        <div class="body__discount" *ngIf="merchant.discount"\n          [ngStyle]="{color: getDiscountTextColor(merchant, themeProvider.getCurrentAppTheme())}">\n          <gift-card-discount-text [merchant]="merchant" [discount]="merchant.discount"></gift-card-discount-text>\n        </div>\n        <div class="body__caption">{{merchant.caption}}</div>\n        <div class="section-divider"></div>\n        <div class="body__subtitle">Payment Instructions</div>\n        <div class="body__instructions">{{merchant.instructions}}</div>\n      </div>\n      <div class="footer">\n        <button ion-button class="button-standard button-primary" (click)="goToMerchant()">\n          <img src="assets/img/icon-chain-link.svg" />\n          <span *ngIf="!merchant.cta || !merchant.cta.displayText" [clamp]="1">Go to {{merchant.displayName}}</span>\n          <span *ngIf="merchant.cta && merchant.cta.displayText" [clamp]="1">{{merchant.cta.displayText}}</span>\n        </button>\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/merchant/merchant.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [providers["E" /* ExternalLinkProvider */],
        ionic_angular["n" /* NavParams */],
        providers["_22" /* ThemeProvider */]])
], merchant_MerchantPage);

//# sourceMappingURL=merchant.js.map
// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/card-catalog/card-catalog.ts












let card_catalog_CardCatalogPage = CardCatalogPage_1 = class CardCatalogPage extends WideHeaderPage {
    constructor(actionSheetProvider, externalLinkProvider, giftCardProvider, merchantProvider, platformProvider, navCtrl, navParams, themeProvider) {
        super(platformProvider);
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.giftCardProvider = giftCardProvider;
        this.merchantProvider = merchantProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.themeProvider = themeProvider;
        this.giftCardsOnly = false;
        this.searchQuery = '';
        this.searchQuerySubject = new Rx["Subject"]();
        this.visibleMerchants = [];
        this.getDiscountTextColor = merchant_merchant["c" /* getDiscountTextColor */];
        this.isCordova = false;
    }
    ngOnInit() {
        this.isCordova = this.platformProvider.isCordova;
        this.category = this.navParams.get('category');
        this.giftCardsOnly = this.navParams.get('giftCardsOnly');
        this.title = this.category
            ? this.category
            : this.giftCardsOnly
                ? 'Gift Cards'
                : 'Shop';
        this.searchQuerySubject.pipe(Object(operators["debounceTime"])(300)).subscribe(query => {
            this.searchQuery = query;
            this.updateCardList();
        });
        this.merchantProvider
            .getMerchants()
            .then((allMerchants) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const merchants = allMerchants.filter(merchant => this.giftCardsOnly ? merchant.giftCards.length : true);
            this.allMerchants = merchants;
            if (merchants.length < 10) {
                this.category = 'All';
            }
            this.categories = getUniqueCategoriesOrCurations(this.allMerchants, 'categories');
            this.curations = buildCurations(this.allMerchants);
            this.updateCardList();
        }))
            .catch(_ => {
            this.showError();
            return [];
        });
    }
    slideChanged(slides, index) {
        const activeSlideIndex = this.slides.toArray()[index].getActiveIndex();
        const visibleCards = slides[activeSlideIndex] || [];
        visibleCards
            .filter(merchant => merchant.giftCards.length)
            .map(merchant => merchant.giftCards[0])
            .filter(cardConfig => Object(gift_card["f" /* hasVisibleDiscount */])(cardConfig))
            .forEach(promotedCard => this.giftCardProvider.logEvent('presentedWithGiftCardPromo', this.giftCardProvider.getPromoEventParams(promotedCard, 'Shop Page Curation')));
    }
    getDiscount(merchant) {
        return Object(merchant_merchant["b" /* getDiscount */])(merchant);
    }
    ionViewDidEnter() {
        this.logGiftCardCatalogHomeView();
    }
    onSearch(query) {
        this.searchQuerySubject.next(query);
    }
    viewCategory(category) {
        this.navCtrl.push(CardCatalogPage_1, {
            category,
            giftCardsOnly: this.giftCardsOnly
        });
    }
    trackBy(record) {
        return record.name;
    }
    updateCardList() {
        this.visibleMerchants = this.allMerchants
            .filter(merchant => isMerchantInSearchResults(merchant, this.searchQuery))
            .filter(merchant => !this.category ||
            this.category === 'All' ||
            [
                ...merchant.categories.map(category => category.displayName),
                ...merchant.curations.map(curation => curation.displayName)
            ].includes(this.category));
    }
    viewMerchant(merchant) {
        return merchant.hasDirectIntegration
            ? this.navCtrl.push(merchant_MerchantPage, { merchant })
            : this.buyCard(merchant.giftCards[0]);
    }
    buyCard(cardConfig) {
        this.logGiftCardBrandView(cardConfig);
        this.navCtrl.push(buy_card["a" /* BuyCardPage */], { cardConfig });
        if (!!Object(gift_card["c" /* getPromo */])(cardConfig)) {
            this.logPromoClick(cardConfig);
        }
    }
    logGiftCardCatalogHomeView() {
        this.giftCardProvider.logEvent('giftcards_view_home', {});
    }
    logGiftCardBrandView(cardConfig) {
        this.giftCardProvider.logEvent('giftcards_view_brand', {
            brand: cardConfig.name
        });
        this.giftCardProvider.logEvent('view_item', {
            items: [
                {
                    brand: cardConfig.name,
                    category: 'giftCards'
                }
            ]
        });
    }
    logPromoClick(cardConfig) {
        this.giftCardProvider.logEvent('clickedGiftCardPromo', this.giftCardProvider.getPromoEventParams(cardConfig, this.category ? 'Gift Card List' : 'Shop Page Curation'));
    }
    launchExtension() {
        this.externalLinkProvider.open('https://tkcoin.org/extension/?launchExtension=true');
    }
    showError() {
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('gift-cards-unavailable');
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(() => this.navCtrl.pop());
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(WideHeaderPage),
    tslib_es6["__metadata"]("design:type", WideHeaderPage)
], card_catalog_CardCatalogPage.prototype, "wideHeaderPage", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChildren"])(ionic_angular["q" /* Slides */]),
    tslib_es6["__metadata"]("design:type", core["QueryList"])
], card_catalog_CardCatalogPage.prototype, "slides", void 0);
card_catalog_CardCatalogPage = CardCatalogPage_1 = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'card-catalog-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-catalog/card-catalog.html"*/'<ion-header class="wide-header" [ngClass]="{cordova: platformProvider.isCordova}">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{title}}\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea>\n  <div class="wrapper" [hidden]="platformProvider.isMacApp()">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary> {{title}} </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <search-bar *ngIf="!category || category === \'All\'" [scrollArea]="scrollArea"\n      (search)="onSearch($event.target.value)" placeholder="{{ \'Search for a brand\' | translate }}"></search-bar>\n\n    <div *ngIf="category && category !== \'All\'" class="section-divider"></div>\n\n    <div *ngIf="!category">\n      <div *ngIf="!searchQuery">\n        <div *ngFor="let curation of curations; let i = index">\n          <div class="category-header">\n            <div class="category-header__name">{{curation.displayName}}</div>\n            <div *ngIf="!isCordova && curation.slides.length > 1" tappable class="category-header__button"\n              (click)="viewCategory(curation.displayName)">\n              See All\n            </div>\n          </div>\n          <ion-slides *ngIf="isCordova && curation.slides.length > 1;" [spaceBetween]="isCordova ? -40 : 0"\n            class="curation" [ngClass]="{desktop: !isCordova}" (ionSlideDidChange)="slideChanged(curation.slides, i)">\n            <ion-slide *ngFor="let slide of curation.slides">\n              <card-list-item *ngFor="let merchant of slide" (click)="viewMerchant(merchant)" [merchant]="merchant">\n              </card-list-item>\n            </ion-slide>\n          </ion-slides>\n          <div *ngIf="!isCordova || curation.slides.length === 1">\n            <card-list-item *ngFor="let merchant of curation.slides[0]" (click)="viewMerchant(merchant)"\n              [merchant]="merchant">\n            </card-list-item>\n          </div>\n          <div class="section-divider"></div>\n        </div>\n\n        <div class="category-header" *ngIf="categories">\n          <div class="category-header__name">Categories</div>\n          <div tappable class="category-header__button" (click)="viewCategory(\'All\')">\n            See All Brands\n          </div>\n        </div>\n        <button *ngFor="let category of categories" ion-item class="category-item"\n          (click)="viewCategory(category.displayName)">\n          <ion-icon item-start> <img [src]="category.icon" /> </ion-icon>\n          {{category.displayName}}\n        </button>\n\n        <br />\n        <br />\n        <br />\n      </div>\n    </div>\n\n    <ion-list style="margin-bottom: 40px;" [virtualScroll]="visibleMerchants" [approxItemHeight]="\'87px\'"\n      [virtualTrackBy]="trackBy" [hidden]="searchQuery" *ngIf="category">\n      <button ion-item class="card-list-item" *virtualItem="let merchant" (click)="viewMerchant(merchant)">\n        <ion-icon item-start>\n          <img-loader *ngIf="!merchant || !merchant.hasDirectIntegration" class="card-list-item__icon"\n            [src]="merchant?.icon" [fallbackAsPlaceholder]="true" [fallbackUrl]="giftCardProvider.fallbackIcon">\n          </img-loader>\n          <div *ngIf="merchant && merchant.hasDirectIntegration" class="card-list-item__icon">\n            <img [src]="merchant.icon" />\n          </div>\n        </ion-icon>\n        <ion-label>\n          <div>\n            <div class="card-list-item__label ellipsis">\n              {{ merchant.displayName }}\n            </div>\n            <div *ngIf="getDiscount(merchant)">\n              <ion-note class="card-list-item__note discount ellipsis"\n                [ngStyle]="{ color: getDiscountTextColor(merchant, themeProvider.getCurrentAppTheme()) }">\n                <gift-card-discount-text [merchant]="merchant" [discount]="getDiscount(merchant)">\n                </gift-card-discount-text>\n              </ion-note>\n            </div>\n            <div *ngIf="!getDiscount(merchant)">\n              <ion-note class="card-list-item__note ellipsis" *ngIf="!merchant.giftCards.length">\n                {{ merchant.caption }}\n              </ion-note>\n              <ion-note class="card-list-item__note ellipsis"\n                *ngIf="merchant.giftCards[0] && !merchant.giftCards[0].supportedAmounts">\n                {{ merchant.giftCards[0].minAmount | formatCurrency:\n                  merchant.giftCards[0].currency:0 }}  {{\n                  merchant.giftCards[0].maxAmount | formatCurrency:\n                  merchant.giftCards[0].currency:0 }}\n              </ion-note>\n              <ion-note class="card-list-item__note ellipsis"\n                *ngIf="merchant.giftCards[0] && merchant.giftCards[0].supportedAmounts">\n                <span *ngFor="\n                      let amount of merchant.giftCards[0].supportedAmounts;\n                      let last = last\n                    ">\n                  {{ amount | formatCurrency:\n                    merchant.giftCards[0].currency:\'minimal\' }}<span *ngIf="!last">,</span>\n                </span>\n              </ion-note>\n            </div>\n          </div>\n        </ion-label>\n      </button>\n    </ion-list>\n\n    <div *ngIf="searchQuery && visibleMerchants.length">\n      <card-list-item *ngFor="let merchant of visibleMerchants" (click)="viewMerchant(merchant)" [merchant]="merchant">\n      </card-list-item>\n    </div>\n\n    <div class="no-results" [ngClass]="{\'has-keyboard\': platformProvider.isCordova}"\n      *ngIf="searchQuery && !visibleMerchants.length">\n      <div>\n        <div class="no-results__title">No Results</div>\n        <div class="no-results__subtitle">\n          Please try searching something else\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class="wrapper" [hidden]="!platformProvider.isMacApp()">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary> {{title}} </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <action-card-v4 *ngIf="platformProvider.isMacApp()" (click)="launchExtension()" tappable>\n      <div action-card-header>\n        <div class="home-gift-card-header" style="padding: 0;">\n          <div class="home-gift-card-image" style="margin-bottom: -6px;">\n            <img src="assets/img/gift-cards/extension-banner.png" style="max-height: unset;" />\n          </div>\n        </div>\n      </div>\n      <div action-card-title translate>Shop with Crypto</div>\n      <div action-card-body [clamp]="2">\n        Spend crypto at 150+ major brands.\n      </div>\n      <div action-card-button translate>Get on Chrome</div>\n    </action-card-v4>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-catalog/card-catalog.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [providers["a" /* ActionSheetProvider */],
        providers["E" /* ExternalLinkProvider */],
        gift_card["a" /* GiftCardProvider */],
        merchant_merchant["a" /* MerchantProvider */],
        providers["_3" /* PlatformProvider */],
        ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        providers["_22" /* ThemeProvider */]])
], card_catalog_CardCatalogPage);

function buildCurations(merchants) {
    const uniqueCurations = getUniqueCategoriesOrCurations(merchants, 'curations');
    return uniqueCurations.map(curation => ({
        displayName: curation.displayName,
        slides: merchants
            .filter(merchant => merchant.curations
            .map(merchantCuration => merchantCuration.displayName)
            .includes(curation.displayName))
            .sort((a, b) => a.curations.find(c => c.displayName === curation.displayName)
            .merchantIndex -
            b.curations.find(c => c.displayName === curation.displayName)
                .merchantIndex)
            .reduce((all, one, i) => {
            const ch = Math.floor(i / 3);
            all[ch] = [].concat(all[ch] || [], one);
            return all;
        }, [])
    }));
}
function isMerchantInSearchResults(m, search = '') {
    const merchantName = (m.displayName || m.name).toLowerCase();
    const query = search.toLowerCase();
    const matchableText = [
        merchantName,
        stripPunctuation(merchantName),
        ...m.tags
    ];
    return !search || matchableText.some(text => text.indexOf(query) > -1);
}
function stripPunctuation(text) {
    return text.replace(/[^\w\s]|_/g, '');
}
function getUniqueCategoriesOrCurations(merchants, field) {
    return lodash["uniqBy"](merchants
        .filter(merchant => merchant[field].length)
        .map(merchant => merchant[field])
        .reduce((allCurations, merchantCurations) => [
        ...allCurations,
        ...merchantCurations
    ], []), categoryOrCuration => categoryOrCuration.displayName).sort((a, b) => a.index - b.index);
}
var CardCatalogPage_1;
//# sourceMappingURL=card-catalog.js.map
// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/buy-card/card-description/card-description.ts



let card_description_CardDescriptionComponent = class CardDescriptionComponent {
    constructor() {
        this.hasPromotion = gift_card["e" /* hasPromotion */];
    }
    prepForMarkdown(markdown) {
        return markdown && markdown.replace(//gm, '-');
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], card_description_CardDescriptionComponent.prototype, "cardConfig", void 0);
card_description_CardDescriptionComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'card-description',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/buy-card/card-description/card-description.html"*/'<div [ngSwitch]="cardConfig.name">\n  <div *ngSwitchCase="\'Amazon.com\'">\n    <div translate>Only redeemable on www.amazon.com (USA website)</div>\n    <div translate>Amazon.com Gift Cards never expire and can be redeemed towards millions of items at www.amazon.com.</div>\n  </div>\n  <div *ngSwitchCase="\'Amazon.co.jp\'">\n    <div translate>Only redeemable on www.amazon.co.jp (Japan website)</div>\n    <div translate>Amazon.co.jp Gift Cards never expire and can be redeemed towards millions of items at www.amazon.co.jp.</div>\n  </div>\n  <div *ngSwitchCase="\'Mercado Livre\'">\n    <div translate>Only redeemable on Mercado Livre (Brazil)</div>\n    <div translate>\n      You can use your Mercado Livre gift cards on your Mercado Pago account for everyday expenses like utilities and metro rides.\n    </div>\n  </div>\n  <div *ngSwitchDefault externalize-links>\n    <div markdown [data]="prepForMarkdown(cardConfig.promotions[0].details)" class="card-description__promotion"\n      *ngIf="hasPromotion(cardConfig)"></div>\n    <div markdown [data]="prepForMarkdown(cardConfig.description)"></div>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/buy-card/card-description/card-description.html"*/
    })
], card_description_CardDescriptionComponent);

//# sourceMappingURL=card-description.js.map
// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/card-details/card-details.ts + 1 modules
var card_details = __webpack_require__(393);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/card-details/printable-card/printable-card.ts
var printable_card = __webpack_require__(982);

// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/card-details/redeem-instructions/redeem-instructions.ts


let RedeemInstructionsComponent = class RedeemInstructionsComponent {
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], RedeemInstructionsComponent.prototype, "cardConfig", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], RedeemInstructionsComponent.prototype, "params", void 0);
RedeemInstructionsComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'redeem-instructions',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-details/redeem-instructions/redeem-instructions.html"*/'<span [ngSwitch]="cardConfig.name">\n  <span *ngSwitchDefault>\n    <span *ngIf="cardConfig.redeemInstructions" markdown [data]="cardConfig.redeemInstructions" externalize-links></span>\n    <span *ngIf="!cardConfig.redeemInstructions">\n      {{\'Paste this code on {cardConfig.website}. This gift card cannot be recovered if your claim code is lost.\' |\n      translate:params }}</span>\n  </span>\n</span>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-details/redeem-instructions/redeem-instructions.html"*/
    })
], RedeemInstructionsComponent);

//# sourceMappingURL=redeem-instructions.js.map
// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/card-terms/card-terms.ts




let card_terms_CardTermsComponent = class CardTermsComponent {
    constructor(giftCardProvider) {
        this.giftCardProvider = giftCardProvider;
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.cardName);
            const terms = this.cardConfig.terms;
            this.cardTerms =
                terms &&
                    linkifyTerms(terms)
                        .replace('Terms and Conditions', '')
                        .replace(/\n/gm, '')
                        .replace(/\*/gm, '&ast;')
                        .replace(/[ ]{5}/gm, '');
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(lib["MarkdownComponent"]),
    tslib_es6["__metadata"]("design:type", lib["MarkdownComponent"])
], card_terms_CardTermsComponent.prototype, "markdown", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], card_terms_CardTermsComponent.prototype, "cardName", void 0);
card_terms_CardTermsComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'card-terms',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-terms/card-terms.html"*/'<markdown ngPreserveWhitespaces class="terms" [data]="cardTerms" externalize-links></markdown>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-terms/card-terms.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [gift_card["a" /* GiftCardProvider */]])
], card_terms_CardTermsComponent);

function linkifyUrl(url) {
    return `[${url}](https://${url})`;
}
function linkifyTerms(terms) {
    const urlRegex = /[\w\/\-\:]+\.[\w\/\-\:]+((\.[\w\/\-\:]+)?)+/gm;
    const allUrls = terms.match(urlRegex) || [];
    const urlsWithoutProtocol = allUrls.filter(m => m && !m.startsWith('http') && !m.startsWith('www.') && m.length > 3);
    const termsWithPlaceholders = urlsWithoutProtocol.reduce((newTerms, url, index) => newTerms.replace(url, getPlaceholder(index)), terms);
    const linkifiedTerms = urlsWithoutProtocol.reduce((newTerms, url, index) => newTerms.replace(getPlaceholder(index), linkifyUrl(url)), termsWithPlaceholders);
    return linkifiedTerms;
}
function getPlaceholder(index) {
    return `---${index}`;
}
//# sourceMappingURL=card-terms.js.map
// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/confirm-card-purchase/confirm-card-purchase.ts
var confirm_card_purchase = __webpack_require__(391);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/gift-card-settings/gift-card-settings.ts
var gift_card_settings = __webpack_require__(994);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/gift-cards-settings/gift-cards-settings.ts
var gift_cards_settings = __webpack_require__(993);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/timer.js
var timer = __webpack_require__(239);
var timer_default = /*#__PURE__*/__webpack_require__.n(timer);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/purchased-cards/purchased-cards.ts + 1 modules
var purchased_cards = __webpack_require__(394);

// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/home-gift-cards/gift-card-item/gift-card-item.ts




let gift_card_item_GiftCardItem = class GiftCardItem {
    constructor(giftCardProvider, renderer) {
        this.giftCardProvider = giftCardProvider;
        this.renderer = renderer;
        this.giftCards = [];
        this.action = new core["EventEmitter"]();
    }
    ngAfterViewInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.cardName && this.setBrandStyling();
            this.currentCards = this.giftCards.filter(g => !g.archived);
            this.currency = this.currentCards[0].currency;
            this.numCurrencies = getNumCurrencies(this.currentCards);
            this.totalBalance = this.currentCards.reduce((sum, card) => sum + card.amount, 0);
        });
    }
    performAction(action) {
        this.action.emit({
            cardName: this.cardName,
            action
        });
    }
    shouldShowTotalBalance() {
        return this.cardConfig && this.numCurrencies === 1 && this.totalBalance;
    }
    setBrandStyling() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.cardName);
            const isGradient = this.cardConfig.logoBackgroundColor.indexOf('gradient') > -1;
            const cssProperty = isGradient ? 'background-image' : 'background-color';
            this.renderer.setStyle(this.card.nativeElement, cssProperty, this.cardConfig.logoBackgroundColor);
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], gift_card_item_GiftCardItem.prototype, "cardName", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Array)
], gift_card_item_GiftCardItem.prototype, "giftCards", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", core["EventEmitter"])
], gift_card_item_GiftCardItem.prototype, "action", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('card'),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], gift_card_item_GiftCardItem.prototype, "card", void 0);
gift_card_item_GiftCardItem = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'gift-card-item',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/home-gift-cards/gift-card-item/gift-card-item.html"*/'<div class="card-item" [ngClass]="{ light: cardConfig?.logoBackgroundColor === \'#ffffff\' }">\n  <div class="card-container">\n    <div #card class="card" (click)="performAction(\'view\')" tappable>\n      <img-loader class="logo" [src]="cardConfig?.logo"></img-loader>\n      <span class="ellipsis" item-end>\n        <div class="funds ellipsis" *ngIf="shouldShowTotalBalance()">\n          {{ totalBalance | formatCurrency: currency: \'minimal\' }}\n        </div>\n      </span>\n    </div>\n  </div>\n  <div class="slit"></div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/home-gift-cards/gift-card-item/gift-card-item.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [gift_card["a" /* GiftCardProvider */],
        core["Renderer2"]])
], gift_card_item_GiftCardItem);

function getNumCurrencies(cards) {
    const currencies = cards.map(c => c.currency);
    const uniqueCurrencies = lodash["uniq"](currencies);
    return uniqueCurrencies.length;
}
//# sourceMappingURL=gift-card-item.js.map
// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/home-gift-cards/home-gift-cards.ts













let home_gift_cards_HomeGiftCards = class HomeGiftCards {
    constructor(actionSheetProvider, appProvider, externalLinkProvider, giftCardProvider, navCtrl, persistenceProvider, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.giftCardProvider = giftCardProvider;
        this.navCtrl = navCtrl;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.hideDiscount = false;
        this.primaryCatalogCurrency = 'usd';
        this.disableArchiveAnimation = true; // Removes flicker on iOS when returning to home tab
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.appName = this.appProvider.info.userVisibleName;
            yield this.initGiftCards();
            setTimeout(() => {
                this.ready = true;
            }, 50);
            const availableCards = yield this.giftCardProvider.getAvailableCards();
            this.primaryCatalogCurrency = getPrimaryCatalogCurrency(availableCards);
            this.hideDiscount = yield this.persistenceProvider.getHideGiftCardDiscountItem();
            yield Object(timer["timer"])(3000).toPromise();
            this.giftCardProvider.preloadImages();
        });
    }
    buyGiftCards() {
        this.navCtrl.push(card_catalog_CardCatalogPage, { giftCardsOnly: true });
    }
    buyCard(cardName) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const cardConfig = yield this.giftCardProvider.getCardConfig(cardName);
            this.navCtrl.push(buy_card["a" /* BuyCardPage */], { cardConfig });
        });
    }
    onGiftCardAction(event, purchasedCards) {
        event.action === 'view'
            ? this.viewGiftCards(event.cardName, purchasedCards)
            : this.showArchiveSheet(event);
    }
    launchExtension() {
        this.externalLinkProvider.open('https://tkcoin.org/extension/?launchExtension=true');
    }
    viewGiftCards(cardName, cards) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const activeCards = cards.filter(c => !c.archived);
            activeCards.length === 1
                ? this.navCtrl.push(card_details["a" /* CardDetailsPage */], { card: activeCards[0] })
                : this.navCtrl.push(purchased_cards["b" /* PurchasedCardsPage */], { cardName });
        });
    }
    showArchiveSheet(event) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const brandCards = this.activeBrands
                .find(brandCards => brandCards[0].name === event.cardName)
                .filter(card => !card.archived);
            const sheetName = brandCards.length === 1 ? 'archive-gift-card' : 'archive-all-gift-cards';
            const cardConfig = yield this.giftCardProvider.getCardConfig(brandCards[0].name);
            const archiveSheet = this.actionSheetProvider.createInfoSheet(sheetName, {
                brand: cardConfig.displayName
            });
            archiveSheet.present();
            archiveSheet.onDidDismiss((confirm) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                yield this.giftCardProvider.archiveAllCards(event.cardName);
            }));
        });
    }
    showHideDiscountItemSheet() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.slidingItem.close();
            const hideDiscountSheet = this.actionSheetProvider.createInfoSheet('hide-gift-card-discount-item');
            hideDiscountSheet.present();
            hideDiscountSheet.onDidDismiss((confirm) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                this.disableArchiveAnimation = false;
                this.hideDiscount = true;
                yield this.giftCardProvider.hideDiscountItem();
            }));
        });
    }
    hideArchivedBrands() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.disableArchiveAnimation = false;
            const purchasedBrands = yield this.giftCardProvider.getPurchasedBrands();
            const { activeCardNames } = yield this.getActiveGiftCards(purchasedBrands);
            const filteredBrands = this.activeBrands.filter(cards => activeCardNames.indexOf(cards[0].name) > -1);
            filteredBrands.length === this.activeBrands.length
                ? this.loadGiftCards()
                : (this.activeBrands = filteredBrands);
        });
    }
    initGiftCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.loadGiftCards(true);
            this.giftCardProvider.cardUpdates$
                .pipe(Object(operators["debounceTime"])(300))
                .subscribe(card => card.archived ? this.hideArchivedBrands() : this.loadGiftCards());
        });
    }
    getActiveGiftCards(purchasedBrands) {
        const activeCards = purchasedBrands.filter(cards => cards.filter(c => !c.archived).length);
        const activeCardNames = activeCards.map(cards => cards[0].name);
        return { activeCards, activeCardNames };
    }
    updatePendingGiftCards(purchasedBrands) {
        const allCards = purchasedBrands.reduce((allCards, brandCards) => [...allCards, ...brandCards], []);
        this.giftCardProvider.updatePendingGiftCards(allCards);
    }
    loadGiftCards(isInitialLoad = false) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.disableArchiveAnimation = true;
            const activeCards = isInitialLoad
                ? this.activeCards
                : yield this.giftCardProvider.getActiveCards();
            const activeBrands = this.groupCardsByBrand(activeCards);
            this.updatePendingGiftCards(activeBrands);
            this.activeBrands = activeBrands;
        });
    }
    groupCardsByBrand(cards) {
        return cards
            .reduce((brands, c) => {
            const brandCards = brands.find(b => b[0].name === c.name);
            brandCards ? brandCards.push(c) : brands.push([c]);
            return brands;
        }, [])
            .sort((a, b) => Object(gift_card["g" /* sortByDisplayName */])(a[0], b[0]));
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Array)
], home_gift_cards_HomeGiftCards.prototype, "activeCards", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])('scrollArea'),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], home_gift_cards_HomeGiftCards.prototype, "scrollArea", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(ionic_angular["j" /* ItemSliding */]),
    tslib_es6["__metadata"]("design:type", ionic_angular["j" /* ItemSliding */])
], home_gift_cards_HomeGiftCards.prototype, "slidingItem", void 0);
home_gift_cards_HomeGiftCards = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'gift-cards',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/home-gift-cards/home-gift-cards.html"*/'<div *ngIf="ready" @fade>\n  <div class="section-header" *ngIf="activeCards?.length" translate>\n    Gift Cards\n  </div>\n  <gift-card-item *ngFor="let brandCards of activeBrands" class="sliding-container" [cardName]="brandCards[0].name"\n    [giftCards]="brandCards" (action)="onGiftCardAction($event, brandCards)" [@archiveAnimation]></gift-card-item>\n\n  <div class="add-button-wrapper--center" *ngIf="activeBrands?.length && !platformProvider.isMacApp()"\n    [@archiveAnimation]>\n    <add-button (click)="buyGiftCards()" tappable>\n      <div add-button-text translate>Buy Gift Card</div>\n    </add-button>\n  </div>\n\n  <action-card-v4 *ngIf="!activeBrands?.length && !platformProvider.isMacApp()" (click)="buyGiftCards()" tappable>\n    <div action-card-header>\n      <div class="home-gift-card-header">\n        <div class="home-gift-card-image">\n          <img *ngIf="primaryCatalogCurrency === \'usd\' && platformProvider.isMacApp()"\n            src="assets/img/gift-cards/mac-gift-cards.png">\n          <img *ngIf="primaryCatalogCurrency !== \'usd\' || !platformProvider.isMacApp()"\n            src="assets/img/gift-cards/gift-cards-{{primaryCatalogCurrency}}.png" />\n        </div>\n      </div>\n    </div>\n    <div action-card-title translate>Buy Gift Cards</div>\n    <div action-card-body [clamp]="2">\n      Buy gift cards for major brands using cryptocurrency.\n    </div>\n    <div action-card-button translate>Get Started</div>\n  </action-card-v4>\n\n  <action-card-v4 *ngIf="platformProvider.isMacApp()" (click)="launchExtension()" tappable>\n    <div action-card-header>\n      <div class="home-gift-card-header" style="padding: 0;">\n        <div class="home-gift-card-image" style="margin-bottom: -6px;">\n          <img src="assets/img/gift-cards/extension-banner.png" style="max-height: unset;" />\n        </div>\n      </div>\n    </div>\n    <div action-card-title translate>Buy Gift Cards</div>\n    <div action-card-body [clamp]="2">\n      Purchase & spend store credit instantly.\n    </div>\n    <div action-card-button translate>Get on Chrome</div>\n  </action-card-v4>\n\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/home-gift-cards/home-gift-cards.html"*/,
        animations: [
            Object(esm5_animations["l" /* trigger */])('archiveAnimation', [
                Object(esm5_animations["k" /* transition */])(':leave', [
                    Object(esm5_animations["j" /* style */])({
                        opacity: 1
                    }),
                    Object(esm5_animations["e" /* animate */])('400ms 0ms ease', Object(esm5_animations["j" /* style */])({
                        opacity: 0,
                        marginTop: '-88px',
                        transform: 'translate3d(0, 88px, 0)'
                    }))
                ])
            ]),
            Object(esm5_animations["l" /* trigger */])('preventInitialChildAnimations', [
                Object(esm5_animations["k" /* transition */])(':enter', [Object(esm5_animations["g" /* query */])(':enter', [], { optional: true })])
            ]),
            Object(esm5_animations["l" /* trigger */])('fade', [
                Object(esm5_animations["k" /* transition */])(':enter', [
                    Object(esm5_animations["j" /* style */])({
                        transform: 'translateY(5px)',
                        opacity: 0
                    }),
                    Object(esm5_animations["e" /* animate */])('200ms')
                ])
            ])
        ]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [providers["a" /* ActionSheetProvider */],
        providers["f" /* AppProvider */],
        providers["E" /* ExternalLinkProvider */],
        gift_card["a" /* GiftCardProvider */],
        ionic_angular["m" /* NavController */],
        providers["_2" /* PersistenceProvider */],
        providers["_3" /* PlatformProvider */]])
], home_gift_cards_HomeGiftCards);

function getPrimaryCatalogCurrency(availableCards) {
    const homeLogoCollageSupportedCurrencies = ['cad', 'eur', 'gbp', 'usd'];
    const firstBrandCurrency = availableCards[0] && availableCards[0].currency.toLowerCase();
    return homeLogoCollageSupportedCurrencies.indexOf(firstBrandCurrency) > -1
        ? firstBrandCurrency
        : 'usd';
}
const HOME_GIFT_CARD_COMPONENTS = [home_gift_cards_HomeGiftCards, gift_card_item_GiftCardItem];
//# sourceMappingURL=home-gift-cards.js.map
// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/phone/phone.ts
var phone = __webpack_require__(983);

// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/gift-cards.ts












const GIFT_CARD_PAGES = [
    buy_card["a" /* BuyCardPage */],
    card_description_CardDescriptionComponent,
    card_details["a" /* CardDetailsPage */],
    card_terms_CardTermsComponent,
    confirm_card_purchase["a" /* ConfirmCardPurchasePage */],
    gift_card_settings["a" /* GiftCardSettingsPage */],
    gift_cards_settings["a" /* GiftCardsSettingsPage */],
    ...HOME_GIFT_CARD_COMPONENTS,
    phone["a" /* PhonePage */],
    printable_card["a" /* PrintableCardComponent */],
    ...purchased_cards["a" /* PURCHASED_CARDS_PAGE_COMPONENTS */],
    RedeemInstructionsComponent
];
//# sourceMappingURL=gift-cards.js.map
// CONCATENATED MODULE: ./src/pages/pages.ts
/* Pages */



































// Integrations: Invoice

// Integrations: Changelly



// Integrations: Coinbase





// Integrations: Simplex


// Integrations: Wyre


// Integrations: Wallet Connect

// Integrations: TKCoinCard





// Integrations: TKCoinCard - Phases
// Phase 1

/*Includes */







/* Tabs */






/* Home */


/* Settings */
















/* Wallet Group Settings */







/* Wallet Settings */





/* Wallet Advanced Settings */







/* Send */







/* Receive */





const PAGES = [
    add_add["a" /* AddPage */],
    add_wallet["a" /* AddWalletPage */],
    amount["a" /* AmountPage */],
    addressbook["a" /* AddressbookPage */],
    add["a" /* AddressbookAddPage */],
    view["a" /* AddressbookViewPage */],
    about["a" /* AboutPage */],
    advanced["a" /* AdvancedPage */],
    all_addresses["a" /* AllAddressesPage */],
    alt_currency["a" /* AltCurrencyPage */],
    tkcoin_card_home_TKCoinCardHome,
    tkcoin_card_intro["a" /* TKCoinCardIntroPage */],
    tkcoin_card_tkcoin_card["a" /* TKCoinCardPage */],
    tkcoin_settings["a" /* TKCoinSettingsPage */],
    tkcoin_card_topup["a" /* TKCoinCardTopUpPage */],
    tkcoin_id["a" /* TKCoinIdPage */],
    card_catalog_CardCatalogPage,
    changelly_details["a" /* ChangellyDetailsPage */],
    changelly["a" /* ChangellyPage */],
    changelly_terms["a" /* ChangellyTermsPage */],
    create_wallet["a" /* CreateWalletPage */],
    create_new_wallet_CreateNewWalletPage,
    coinbase_account["a" /* CoinbaseAccountPage */],
    coinbase["a" /* CoinbasePage */],
    coinbase_tx_details["a" /* CoinbaseTxDetailsPage */],
    coinbase_withdraw["a" /* CoinbaseWithdrawPage */],
    copayers["a" /* CopayersPage */],
    country_selector["a" /* CountrySelectorPage */],
    crypto_payment_method["a" /* CryptoPaymentMethodPage */],
    crypto_order_summary["a" /* CryptoOrderSummaryPage */],
    crypto_offers["a" /* CryptoOffersPage */],
    crypto_coin_selector["a" /* CryptoCoinSelectorPage */],
    crypto_settings["a" /* CryptoSettingsPage */],
    exchange_checkout["a" /* ExchangeCheckoutPage */],
    exchange_crypto["a" /* ExchangeCryptoPage */],
    exchange_crypto_settings["a" /* ExchangeCryptoSettingsPage */],
    select_inputs["a" /* SelectInputsPage */],
    feedback_card_FeedbackCardPage,
    share["a" /* SharePage */],
    import_wallet["a" /* ImportWalletPage */],
    join_wallet["a" /* JoinWalletPage */],
    backup_game["a" /* BackupGamePage */],
    backup_key["a" /* BackupKeyPage */],
    create_eth_multisig["a" /* CreateEthMultisigPage */],
    confirm_confirm["a" /* ConfirmPage */],
    multi_send["a" /* MultiSendPage */],
    transfer_to_modal["a" /* TransferToModalPage */],
    transfer_to_TransferToPage,
    custom_amount["a" /* CustomAmountPage */],
    disclaimer["a" /* DisclaimerPage */],
    add_funds["a" /* AddFundsPage */],
    feature_education_FeatureEducationPage,
    lock_method_LockMethodPage,
    recovery_key["a" /* RecoveryKeyPage */],
    collect_email_CollectEmailPage,
    ...GIFT_CARD_PAGES,
    GravatarPage,
    FingerprintModalPage,
    home["a" /* HomePage */],
    cards_cards["a" /* CardsPage */],
    wallets["a" /* WalletsPage */],
    language["a" /* LanguagePage */],
    lock["a" /* LockPage */],
    merchant_MerchantPage,
    multiple_outputs_MultipleOutputsPage,
    paper_wallet["a" /* PaperWalletPage */],
    ...PIN_COMPONENTS,
    price_page_PricePage,
    proposals_notifications["a" /* ProposalsNotificationsPage */],
    scan["a" /* ScanPage */],
    send["a" /* SendPage */],
    settings["a" /* SettingsPage */],
    select_currency["a" /* SelectCurrencyPage */],
    select_invoice["a" /* SelectInvoicePage */],
    coinbase_settings["a" /* CoinbaseSettingsPage */],
    simplex["a" /* SimplexPage */],
    simplex_details["a" /* SimplexDetailsPage */],
    wyre["a" /* WyrePage */],
    wyre_details["a" /* WyreDetailsPage */],
    notifications["a" /* NotificationsPage */],
    fee_policy["a" /* FeePolicyPage */],
    search_tx_modal["a" /* SearchTxModalPage */],
    session_log["a" /* SessionLogPage */],
    send_feedback["a" /* SendFeedbackPage */],
    finish["a" /* FinishModalPage */],
    tabs["a" /* TabsPage */],
    txp_details_TxpDetailsPage,
    tx_details["a" /* TxDetailsModal */],
    txp_TxpPage,
    wallet_settings["a" /* WalletSettingsPage */],
    wallet_delete["a" /* WalletDeletePage */],
    wallet_name["a" /* WalletNamePage */],
    wallet_information["a" /* WalletInformationPage */],
    wallet_addresses["a" /* WalletAddressesPage */],
    wallet_export["a" /* WalletExportPage */],
    wallet_service_url["a" /* WalletServiceUrlPage */],
    wallet_transaction_history["a" /* WalletTransactionHistoryPage */],
    wallet_duplicate["a" /* WalletDuplicatePage */],
    extended_private_key["a" /* ExtendedPrivateKeyPage */],
    clear_encrypt_password["a" /* ClearEncryptPasswordPage */],
    key_delete["a" /* KeyDeletePage */],
    key_qr_export["a" /* KeyQrExportPage */],
    key_settings["a" /* KeySettingsPage */],
    key_name["a" /* KeyNamePage */],
    key_onboarding["a" /* KeyOnboardingPage */],
    wallet_connect["a" /* WalletConnectPage */],
    wallet_details["a" /* WalletDetailsPage */],
    wallet_recover_page["a" /* WalletRecoverPage */],
    wallet_mnemonic_recover_page["a" /* WalletMnemonicRecoverPage */],
    wallet_balance["a" /* WalletBalanceModal */],
    WideHeaderPage,
    CardItemPage,
    coin_selector["a" /* CoinSelectorPage */],
    slide_to_accept_SlideToAcceptPage,
    local_theme["a" /* LocalThemePage */],
    new_feature["a" /* NewFeaturePage */],
    // Phases: card pages
    phase_one_intro_page_PhaseOneCardIntro
];
//# sourceMappingURL=pages.js.map
// CONCATENATED MODULE: ./src/pipes/fiatToUnit.ts





let FiatToUnitPipe = class FiatToUnitPipe {
    constructor(configProvider, rateProvider, txFormatProvider) {
        this.configProvider = configProvider;
        this.rateProvider = rateProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin, alternative) {
        alternative = alternative
            ? alternative
            : this.walletSettings.alternativeIsoCode;
        let amount_ = this.rateProvider.fromFiat(amount, alternative, coin);
        return this.txFormatProvider.formatAmountStr(coin, amount_, true);
    }
};
FiatToUnitPipe = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'fiatToUnit',
        pure: false
    }),
    tslib_es6["__metadata"]("design:paramtypes", [config_config["a" /* ConfigProvider */],
        rate["b" /* RateProvider */],
        tx_format["a" /* TxFormatProvider */]])
], FiatToUnitPipe);

//# sourceMappingURL=fiatToUnit.js.map
// CONCATENATED MODULE: ./src/pipes/keys.ts
/*
 * Example use
 *  Simple: *ngFor="let item of giftCards | keys"
 *	With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */


let KeysPipe = class KeysPipe {
    transform(value, orderBy) {
        let keys = [];
        for (let key in value) {
            keys.push({
                key,
                value: value[key],
                order: orderBy ? value[key][orderBy] : null
            });
        }
        return keys;
    }
};
KeysPipe = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'keys'
    })
], KeysPipe);

//# sourceMappingURL=keys.js.map
// CONCATENATED MODULE: ./src/pipes/order-by.ts
/*
 * Example use
 *		Basic Array of single type: *ngFor="#todo of todoService.todos | orderBy : '-'"
 *		Multidimensional Array Sort on single column: *ngFor="#todo of todoService.todos | orderBy : ['-status']"
 *		Multidimensional Array Sort on multiple columns: *ngFor="#todo of todoService.todos | orderBy : ['status', '-title']"
 *    With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */


let OrderByPipe = OrderByPipe_1 = class OrderByPipe {
    static _orderByComparator(a, b) {
        if (isNaN(parseFloat(a)) ||
            !isFinite(a) ||
            isNaN(parseFloat(b)) ||
            !isFinite(b)) {
            // Isn't a number so lowercase the string to properly compare
            if (a.toLowerCase() < b.toLowerCase())
                return -1;
            if (a.toLowerCase() > b.toLowerCase())
                return 1;
        }
        else {
            // Parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b))
                return -1;
            if (parseFloat(a) > parseFloat(b))
                return 1;
        }
        return 0; // equal each other
    }
    transform(input, [config = '+']) {
        if (!Array.isArray(input))
            return input;
        if (!Array.isArray(config) ||
            (Array.isArray(config) && config.length == 1)) {
            var propertyToCheck = !Array.isArray(config) ? config : config[0];
            var desc = propertyToCheck.substr(0, 1) == '-';
            // Basic array
            if (!propertyToCheck ||
                propertyToCheck == '-' ||
                propertyToCheck == '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                var property = propertyToCheck.substr(0, 1) == '+' ||
                    propertyToCheck.substr(0, 1) == '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort((a, b) => {
                    if (a[property] && b[property]) {
                        return !desc
                            ? OrderByPipe_1._orderByComparator(a[property], b[property])
                            : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                    }
                    else if (a.value[property] && b.value[property]) {
                        return !desc
                            ? OrderByPipe_1._orderByComparator(a.value[property], b.value[property])
                            : -OrderByPipe_1._orderByComparator(a.value[property], b.value[property]);
                    }
                    else
                        return 0;
                });
            }
        }
        else {
            // Loop over property of the array in order and sort
            return input.sort((a, b) => {
                for (var i = 0; i < config.length; i++) {
                    let comparison = 0;
                    var desc = config[i].substr(0, 1) == '-';
                    var property = config[i].substr(0, 1) == '+' || config[i].substr(0, 1) == '-'
                        ? config[i].substr(1)
                        : config[i];
                    if (a[property] && b[property]) {
                        comparison = !desc
                            ? OrderByPipe_1._orderByComparator(a[property], b[property])
                            : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                    }
                    else if (a.value[property] && b.value[property]) {
                        comparison = !desc
                            ? OrderByPipe_1._orderByComparator(a.value[property], b.value[property])
                            : -OrderByPipe_1._orderByComparator(a.value[property], b.value[property]);
                    }
                    // Don't return 0 yet in case of needing to sort by next property
                    if (comparison != 0)
                        return comparison;
                }
                return 0; // equal each other
            });
        }
    }
};
OrderByPipe = OrderByPipe_1 = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'orderBy',
        pure: false
    })
], OrderByPipe);

var OrderByPipe_1;
//# sourceMappingURL=order-by.js.map
// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js
var common = __webpack_require__(131);

// CONCATENATED MODULE: ./src/pipes/satToFiat.ts





let SatToFiatPipe = class SatToFiatPipe {
    constructor(configProvider, rateProvider, decimalPipe) {
        this.configProvider = configProvider;
        this.rateProvider = rateProvider;
        this.decimalPipe = decimalPipe;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin) {
        let amount_ = this.rateProvider.toFiat(amount, this.walletSettings.alternativeIsoCode, coin.toLowerCase());
        return (this.decimalPipe.transform(amount_ || 0, '1.2-2') +
            ' ' +
            this.walletSettings.alternativeIsoCode);
    }
};
SatToFiatPipe = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'satToFiat',
        pure: false
    }),
    tslib_es6["__metadata"]("design:paramtypes", [config_config["a" /* ConfigProvider */],
        rate["b" /* RateProvider */],
        common["d" /* DecimalPipe */]])
], SatToFiatPipe);

//# sourceMappingURL=satToFiat.js.map
// CONCATENATED MODULE: ./src/pipes/satToUnit.ts



let SatToUnitPipe = class SatToUnitPipe {
    constructor(txFormatProvider) {
        this.txFormatProvider = txFormatProvider;
    }
    transform(amount, coin) {
        return this.txFormatProvider.formatAmountStr(coin, amount);
    }
};
SatToUnitPipe = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'satToUnit',
        pure: false
    }),
    tslib_es6["__metadata"]("design:paramtypes", [tx_format["a" /* TxFormatProvider */]])
], SatToUnitPipe);

//# sourceMappingURL=satToUnit.js.map
// EXTERNAL MODULE: ./src/providers/incoming-data/incoming-data.ts
var incoming_data = __webpack_require__(126);

// CONCATENATED MODULE: ./src/pipes/shortened-address.ts



let ShortenedAddressPipe = class ShortenedAddressPipe {
    constructor(incomingDataProvider) {
        this.incomingDataProvider = incomingDataProvider;
    }
    transform(address) {
        if (!address || address === '')
            return '...';
        const addr = this.incomingDataProvider.extractAddress(address);
        if (addr && addr.length > 4) {
            const first4Numbers = addr.substr(0, 4);
            const last4Numbers = addr.substr(addr.length - 4, addr.length);
            const result = first4Numbers + '...' + last4Numbers;
            return result;
        }
        else {
            return '...';
        }
    }
};
ShortenedAddressPipe = tslib_es6["__decorate"]([
    Object(core["Pipe"])({
        name: 'shortenedAddress',
        pure: false
    }),
    tslib_es6["__metadata"]("design:paramtypes", [incoming_data["a" /* IncomingDataProvider */]])
], ShortenedAddressPipe);

//# sourceMappingURL=shortened-address.js.map
// EXTERNAL MODULE: ./node_modules/@ionic-native/clipboard/index.js
var clipboard = __webpack_require__(320);

// EXTERNAL MODULE: ./src/providers/clipboard/clipboard.ts
var clipboard_clipboard = __webpack_require__(230);

// CONCATENATED MODULE: ./src/directives/copy-to-clipboard/copy-to-clipboard.ts





// providers




let CopyToClipboard = class CopyToClipboard {
    constructor(dom, clipboard, platform, logger, translate, actionSheetProvider, clipboardProvider) {
        this.clipboard = clipboard;
        this.platform = platform;
        this.logger = logger;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.clipboardProvider = clipboardProvider;
        this.dom = dom;
    }
    copyBrowser() {
        let textarea = this.dom.createElement('textarea');
        this.dom.body.appendChild(textarea);
        textarea.value = this.value;
        textarea.select();
        this.dom.execCommand('copy');
        this.dom.body.removeChild(textarea);
    }
    copy() {
        if (!this.value)
            return;
        try {
            this.clipboardProvider.copy(this.value);
        }
        catch (e) {
            if (e)
                this.logger.warn(e.message);
            this.copyBrowser();
        }
        if (this.hideToast)
            return;
        const infoSheet = this.actionSheetProvider.createInfoSheet('copy-to-clipboard', { msg: this.value });
        infoSheet.present();
    }
};
CopyToClipboard = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[copy-to-clipboard]',
        inputs: ['value: copy-to-clipboard', 'hideToast: hide-toast'],
        host: {
            '(click)': 'copy()'
        }
    }),
    tslib_es6["__param"](0, Object(core["Inject"])(platform_browser["b" /* DOCUMENT */])),
    tslib_es6["__metadata"]("design:paramtypes", [Document,
        clipboard["a" /* Clipboard */],
        platform_platform["a" /* PlatformProvider */],
        logger_logger["a" /* Logger */],
        core_es5["f" /* TranslateService */],
        action_sheet["a" /* ActionSheetProvider */],
        clipboard_clipboard["a" /* ClipboardProvider */]])
], CopyToClipboard);

//# sourceMappingURL=copy-to-clipboard.js.map
// CONCATENATED MODULE: ./src/directives/externalize-links/externalize-links.ts




let externalize_links_ExternalizeLinks = class ExternalizeLinks {
    constructor(element, externalLinkProvider) {
        this.element = element;
        this.externalLinkProvider = externalLinkProvider;
    }
    ngAfterViewInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield Rx["Observable"].timer(500).toPromise();
            this.getAllLinks().forEach(aTag => aTag.addEventListener('click', this.handleClick.bind(this)));
        });
    }
    ngOnDestroy() {
        this.getAllLinks().forEach(aTag => {
            aTag.removeEventListener('click', this.handleClick.bind(this));
        });
    }
    getAllLinks() {
        return this.element.nativeElement.querySelectorAll('a');
    }
    handleClick(event) {
        event.preventDefault();
        this.openExternalLink(event.srcElement.href);
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
externalize_links_ExternalizeLinks = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[externalize-links]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"],
        providers["E" /* ExternalLinkProvider */]])
], externalize_links_ExternalizeLinks);

//# sourceMappingURL=externalize-links.js.map
// EXTERNAL MODULE: ./src/providers/theme/theme.ts
var theme = __webpack_require__(56);

// CONCATENATED MODULE: ./src/directives/fixed-scroll-bg-color/fixed-scroll-bg-color.ts



/*
Sometimes the user can overshoot when scrolling, which can cause gaps to appear between
elements if colors are not properly set on the fixed and scroll containers to match the colors
of surrounding elements. This directive sets the proper bg-color on the fixed and scroll containers
to create the illusion of smooth, fluid, and connected elements.
*/
let FixedScrollBgColor = class FixedScrollBgColor {
    constructor(element, themeProvider) {
        this.element = element;
        this.themeProvider = themeProvider;
        this.bottomColor = this.themeProvider.getThemeInfo().fixedScrollBgColor;
    }
    ngOnChanges() {
        this.setFixedAndScrollContentBgColor(this.color);
    }
    setFixedAndScrollContentBgColor(color) {
        const scrollContent = this.element.nativeElement.getElementsByClassName('scroll-content')[0];
        const fixedContent = this.element.nativeElement.getElementsByClassName('fixed-content')[0];
        const wrapperContent = this.element.nativeElement.getElementsByClassName('wrapper')[0];
        const linearGradient = `linear-gradient(to bottom, ${this.color}, ${this.color} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%)`;
        if (color) {
            scrollContent.style.setProperty('background-image', linearGradient);
            fixedContent.style.setProperty('background-image', linearGradient);
            if (wrapperContent && wrapperContent.style) {
                wrapperContent.style.setProperty('background', this.bottomColor);
                wrapperContent.style.setProperty('min-height', '100%');
            }
        }
        else {
            scrollContent.style.removeProperty('background-image');
            fixedContent.style.removeProperty('background-image');
            if (wrapperContent && wrapperContent.style) {
                wrapperContent.style.removeProperty('background');
                wrapperContent.style.removeProperty('min-height');
            }
        }
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('fixed-scroll-bg-color'),
    tslib_es6["__metadata"]("design:type", String)
], FixedScrollBgColor.prototype, "color", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], FixedScrollBgColor.prototype, "bottomColor", void 0);
FixedScrollBgColor = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[fixed-scroll-bg-color]',
        host: { class: 'fixed-scroll-bg-color' }
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"],
        theme["a" /* ThemeProvider */]])
], FixedScrollBgColor);

//# sourceMappingURL=fixed-scroll-bg-color.js.map
// CONCATENATED MODULE: ./src/directives/ion-content-background-color/ion-content-background-color.ts



let IonContentBackgroundColor = class IonContentBackgroundColor {
    constructor(element, app) {
        this.element = element;
        this.app = app;
    }
    ngOnChanges() {
        this.setContentBackgroundColor(this.color);
    }
    setContentBackgroundColor(color) {
        const ionContent = this.element.nativeElement.getElementsByClassName('fixed-content')[0];
        if (color)
            ionContent.style.setProperty('background-color', color);
        else {
            const color = this.app.info.nameCase == 'Copay' ? '#192c3a' : '#2a3f90';
            ionContent.style.setProperty('background-color', color);
        }
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('ion-content-background-color'),
    tslib_es6["__metadata"]("design:type", String)
], IonContentBackgroundColor.prototype, "color", void 0);
IonContentBackgroundColor = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[ion-content-background-color]',
        host: { class: 'ion-content-background-color' }
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"], app["a" /* AppProvider */]])
], IonContentBackgroundColor);

//# sourceMappingURL=ion-content-background-color.js.map
// EXTERNAL MODULE: ./node_modules/text-mask-core/dist/textMaskCore.js
var textMaskCore = __webpack_require__(2010);
var textMaskCore_default = /*#__PURE__*/__webpack_require__.n(textMaskCore);

// CONCATENATED MODULE: ./src/directives/ion-mask/ion-mask.ts






let ion_mask_IonMask = class IonMask {
    constructor(ionInput) {
        this.ionInput = ionInput;
        this.mask = [];
        this.clearInputListeners = new Rx["Subject"]();
    }
    ngOnInit() {
        this.configureInput();
    }
    ngOnChanges() {
        this.clearInputListeners.next();
        if (this.mask)
            this.configureInput();
    }
    ngOnDestroy() {
        this.clearInputListeners.next();
    }
    configureInput() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const input = yield this.ionInput.getNativeElement();
            const maskedInput = Object(textMaskCore["createTextMaskInputElement"])({
                inputElement: input,
                mask: this.mask,
                guide: false
            });
            maskedInput.update(this.ionInput.value);
            this.ionInput.value = input.value;
            this.ionInput.ionChange
                .pipe(Object(operators["takeUntil"])(this.clearInputListeners))
                .subscribe((event) => {
                const { value } = event;
                maskedInput.update(value);
                this.ionInput.value = input.value;
            });
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('ionMask'),
    tslib_es6["__metadata"]("design:type", Array)
], ion_mask_IonMask.prototype, "mask", void 0);
ion_mask_IonMask = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[ionMask]',
        providers: [ionic_angular["r" /* TextInput */]]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["r" /* TextInput */]])
], ion_mask_IonMask);

//# sourceMappingURL=ion-mask.js.map
// EXTERNAL MODULE: ./node_modules/ionic-angular/gestures/gesture.js + 1 modules
var gesture = __webpack_require__(538);

// CONCATENATED MODULE: ./src/directives/long-press/long-press.ts



let long_press_LongPress = class LongPress {
    constructor(el) {
        this.longPress = new core["EventEmitter"]();
        this.el = el.nativeElement;
    }
    ngOnInit() {
        this.pressGesture = new gesture["a" /* Gesture */](this.el, {
            recognizers: [[Hammer.Press, { time: 1000 }]]
        });
        this.pressGesture.listen();
        this.pressGesture.on('press', e => {
            this.longPress.emit(e);
        });
    }
    ngOnDestroy() {
        this.pressGesture.destroy();
    }
};
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", core["EventEmitter"])
], long_press_LongPress.prototype, "longPress", void 0);
long_press_LongPress = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[longPress]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"]])
], long_press_LongPress);

//# sourceMappingURL=long-press.js.map
// CONCATENATED MODULE: ./src/directives/navbar-bg/navbar-bg.ts


/*
Ionic does not currently appear to provide an API to set the navbar background
to an arbitrary color. This directive enables this functionality.
*/
let NavbarBg = class NavbarBg {
    constructor(element) {
        this.element = element;
    }
    ngOnChanges() {
        this.setNewNavbarColor(this.color);
    }
    setNewNavbarColor(color) {
        const toolbarBg = this.element.nativeElement.getElementsByClassName('toolbar-background')[0];
        color
            ? toolbarBg.style.setProperty('background', color, 'important')
            : toolbarBg.style.removeProperty('background');
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('navbar-bg'),
    tslib_es6["__metadata"]("design:type", String)
], NavbarBg.prototype, "color", void 0);
NavbarBg = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[navbar-bg]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"]])
], NavbarBg);

//# sourceMappingURL=navbar-bg.js.map
// CONCATENATED MODULE: ./src/directives/no-low-fee/no-low-fee.ts




// Provider


let NoLowFee = class NoLowFee {
    constructor(configProvider, elem, logger, navCtrl, popupProvider) {
        this.configProvider = configProvider;
        this.elem = elem;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger.debug('NoLowFee Directive initialized');
        this.configWallet = this.configProvider.get().wallet;
    }
    noLowFee() {
        if (this.configWallet.settings.feeLevel &&
            this.configWallet.settings.feeLevel.match(/conomy/)) {
            this.logger.debug('Economy Fee setting... disabling link:' +
                this.elem.nativeElement.innerText);
            this.popupProvider
                .ionicAlert('Low Fee Error', 'Please change your Bitcoin Network Fee Policy setting to Normal or higher to use this service')
                .then(() => {
                this.navCtrl.pop();
            });
        }
    }
};
NoLowFee = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[no-low-fee]',
        host: {
            '(click)': 'noLowFee()'
        }
    }),
    tslib_es6["__metadata"]("design:paramtypes", [config_config["a" /* ConfigProvider */],
        core["ElementRef"],
        logger_logger["a" /* Logger */],
        ionic_angular["m" /* NavController */],
        popup["a" /* PopupProvider */]])
], NoLowFee);

//# sourceMappingURL=no-low-fee.js.map
// CONCATENATED MODULE: ./src/directives/reveal-at-scroll-pos/reveal-at-scroll-pos.ts



let RevealAtScrollPosition = class RevealAtScrollPosition {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.scrollPositionOfLastStyleUpdate = 0;
        this.animationDistance = 28;
    }
    ngAfterViewInit() {
        this.setInitialStyles();
        this.scrollArea.ionScroll.subscribe(event => this.shouldUpdateStyling(event.scrollTop) &&
            this.updateStyling(event.scrollTop));
    }
    shouldUpdateStyling(scrollTop) {
        return (scrollTop < this.scrollThreshold ||
            (scrollTop > this.scrollThreshold &&
                this.scrollPositionOfLastStyleUpdate < this.scrollThreshold));
    }
    setInitialStyles() {
        this.setOpacity(0);
        this.renderer.addClass(this.element.nativeElement, 'ellipsis');
    }
    updateStyling(scrollTop) {
        const opacity = this.getOpacity(scrollTop);
        const translateX = this.getTranslation(scrollTop);
        this.setOpacity(opacity);
        this.setTransform(translateX);
        this.scrollPositionOfLastStyleUpdate = scrollTop;
    }
    setOpacity(opacity) {
        this.renderer.setStyle(this.element.nativeElement, 'opacity', opacity.toFixed(3));
    }
    setTransform(translateX) {
        this.renderer.setStyle(this.element.nativeElement, 'transform', `translateX(${translateX}px)`);
    }
    getOpacity(scrollTop) {
        const finalOpacity = 1;
        const fadeStartPosition = this.scrollThreshold - this.animationDistance;
        const m = finalOpacity / (this.scrollThreshold - fadeStartPosition);
        const opacity = m * (scrollTop - this.scrollThreshold) + finalOpacity;
        return opacity;
    }
    getTranslation(scrollTop) {
        /*
        point-slope-form
        y-y1 = m(x-x1)
        y = m(x-x1) + y1
          where m = (y2 - y1) / (x2 - x1)
    
        initialTranslateX = -10
        finalTranslateX = 0
        p1 = (scrollThreshold, finalTranslateX)
        p2 = (animationStartPos, initialTranslateX)
        */
        const initialTranslateX = -10;
        const finalTranslateX = 0;
        const animationStartPos = this.scrollThreshold - this.animationDistance;
        const m = (initialTranslateX - finalTranslateX) /
            (animationStartPos - this.scrollThreshold);
        const translateX = m * (scrollTop - this.scrollThreshold) + 0;
        return translateX > 0 ? 0 : translateX;
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('reveal-at-scroll-pos'),
    tslib_es6["__metadata"]("design:type", Number)
], RevealAtScrollPosition.prototype, "scrollThreshold", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])('scrollArea'),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], RevealAtScrollPosition.prototype, "scrollArea", void 0);
RevealAtScrollPosition = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[reveal-at-scroll-pos]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"], core["Renderer2"]])
], RevealAtScrollPosition);

//# sourceMappingURL=reveal-at-scroll-pos.js.map
// CONCATENATED MODULE: ./src/directives/scrolled-into-view/scrolled-into-view.ts



let scrolled_into_view_ScrolledIntoView = class ScrolledIntoView {
    constructor(elm) {
        this.elm = elm;
        this.inView = false;
        this.viewEnter = new core["EventEmitter"]();
    }
    ngAfterViewInit() {
        this.checkIfElementInView();
        this.scrollArea.ionScroll.subscribe(() => this.checkIfElementInView());
    }
    checkIfElementInView() {
        const scanButtonAreaHeight = 70;
        const { scrollTop, contentHeight } = this.scrollArea;
        const { offsetTop, offsetHeight } = this.elm.nativeElement;
        if (scrollTop + contentHeight - scanButtonAreaHeight >
            offsetTop + offsetHeight) {
            if (this.inView)
                return;
            this.viewEnter.emit(true);
            this.inView = true;
        }
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])('scrollArea'),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], scrolled_into_view_ScrolledIntoView.prototype, "scrollArea", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", core["EventEmitter"])
], scrolled_into_view_ScrolledIntoView.prototype, "viewEnter", void 0);
scrolled_into_view_ScrolledIntoView = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[scrolled-into-view]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"]])
], scrolled_into_view_ScrolledIntoView);

//# sourceMappingURL=scrolled-into-view.js.map
// CONCATENATED MODULE: ./src/pages/templates/wide-header-page/wide-header-bar-button.ts



let WideHeaderBarButton = class WideHeaderBarButton {
    constructor(element, platformProvider, renderer) {
        this.element = element;
        this.platformProvider = platformProvider;
        this.renderer = renderer;
        this.platformName = 'md';
        this.platformName = this.platformProvider.isIOS ? 'ios' : 'md';
    }
    ngAfterViewInit() {
        const cssClasses = [
            'bar-button',
            `bar-button-${this.platformName}`,
            'bar-button-default',
            `bar-button-default-${this.platformName}`
        ];
        cssClasses.forEach(c => this.addClass(c));
    }
    addClass(cssClass) {
        this.renderer.addClass(this.element.nativeElement, cssClass);
    }
};
WideHeaderBarButton = tslib_es6["__decorate"]([
    Object(core["Directive"])({
        selector: '[wide-header-bar-button]'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"],
        providers["_3" /* PlatformProvider */],
        core["Renderer2"]])
], WideHeaderBarButton);

//# sourceMappingURL=wide-header-bar-button.js.map
// CONCATENATED MODULE: ./src/components/action-card-v4/action-card-v4.ts


let ActionCardV4Component = class ActionCardV4Component {
};
ActionCardV4Component = tslib_es6["__decorate"]([
    Object(core["Component"])({
        host: { class: 'card' },
        selector: 'action-card-v4',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-card-v4/action-card-v4.html"*/'<div class="action-card__header">\n  <ng-content select="[action-card-header]"></ng-content>\n</div>\n<div class="action-card__content">\n  <div class="action-card__title">\n    <ng-content select="[action-card-title]"></ng-content>\n  </div>\n  <div class="action-card__body">\n    <ng-content select="[action-card-body]"></ng-content>\n    <div class="cta">\n      <ng-content select="[action-card-button]"></ng-content>\n    </div>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-card-v4/action-card-v4.html"*/
    })
], ActionCardV4Component);

//# sourceMappingURL=action-card-v4.js.map
// CONCATENATED MODULE: ./src/components/action-card/action-card.ts


let ActionCardComponent = class ActionCardComponent {
};
ActionCardComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        host: { class: 'card' },
        selector: 'action-card',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-card/action-card.html"*/'<div class="action-card__header">\n  <ng-content select="[action-card-header]"></ng-content>\n</div>\n<div class="action-card__content">\n  <div class="action-card__title">\n    <ng-content select="[action-card-title]"></ng-content>\n  </div>\n  <div class="action-card__body">\n    <ng-content select="[action-card-body]"></ng-content>\n  </div>\n  <div action-card-button class="action-card__cta">\n    <ng-content select="[action-card-button]"></ng-content>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-card/action-card.html"*/
    })
], ActionCardComponent);

//# sourceMappingURL=action-card.js.map
// EXTERNAL MODULE: ./src/components/action-sheet/action-sheet.ts
var action_sheet_action_sheet = __webpack_require__(927);

// EXTERNAL MODULE: ./src/components/choose-fee-level/choose-fee-level.ts
var choose_fee_level = __webpack_require__(797);

// EXTERNAL MODULE: ./src/components/email-component/email-component.ts
var email_component = __webpack_require__(928);

// EXTERNAL MODULE: ./src/components/encrypt-password/encrypt-password.ts
var encrypt_password = __webpack_require__(929);

// EXTERNAL MODULE: ./src/components/incoming-data-menu/incoming-data-menu.ts
var incoming_data_menu = __webpack_require__(931);

// EXTERNAL MODULE: ./src/components/info-sheet/info-sheet.ts
var info_sheet = __webpack_require__(286);

// EXTERNAL MODULE: ./src/components/memo-component/memo-component.ts
var memo_component = __webpack_require__(932);

// EXTERNAL MODULE: ./src/components/miner-fee-warning/miner-fee-warning.ts
var miner_fee_warning = __webpack_require__(933);

// EXTERNAL MODULE: ./src/components/needs-backup/needs-backup.ts
var needs_backup = __webpack_require__(934);

// EXTERNAL MODULE: ./src/components/options-sheet/options-sheet.ts
var options_sheet = __webpack_require__(935);

// EXTERNAL MODULE: ./src/components/phone-sheet/phone-sheet.ts
var phone_sheet = __webpack_require__(936);

// EXTERNAL MODULE: ./src/components/wallet-receive/wallet-receive.ts
var wallet_receive = __webpack_require__(939);

// EXTERNAL MODULE: ./src/components/wallet-selector/wallet-selector.ts
var wallet_selector = __webpack_require__(940);

// EXTERNAL MODULE: ./src/components/wallet-tab-options/wallet-tab-options.ts
var wallet_tab_options = __webpack_require__(941);

// CONCATENATED MODULE: ./src/components/action-sheets.ts














const ACTION_SHEET_COMPONENTS = [
    action_sheet_action_sheet["a" /* ActionSheetComponent */],
    info_sheet["a" /* INFO_SHEET_COMPONENTS */],
    options_sheet["a" /* OptionsSheetComponent */],
    incoming_data_menu["a" /* IncomingDataMenuComponent */],
    memo_component["a" /* MemoComponent */],
    needs_backup["a" /* NeedsBackupComponent */],
    wallet_selector["a" /* WalletSelectorComponent */],
    wallet_receive["a" /* WalletReceiveComponent */],
    choose_fee_level["a" /* ChooseFeeLevelComponent */],
    email_component["a" /* EmailComponent */],
    phone_sheet["a" /* PhoneSheet */],
    wallet_tab_options["a" /* WalletTabOptionsComponent */],
    encrypt_password["a" /* EncryptPasswordComponent */],
    miner_fee_warning["a" /* MinerFeeWarningComponent */]
];
//# sourceMappingURL=action-sheets.js.map
// CONCATENATED MODULE: ./src/components/add-button/add-button.ts


let AddButtonComponent = class AddButtonComponent {
};
AddButtonComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        host: { class: 'add-button' },
        selector: 'add-button',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/add-button/add-button.html"*/'<div class="add-button__icon"><img src="assets/img/plus-gray.svg" /></div>\n<div class="add-button__text">\n  <ng-content select="[add-button-text]"></ng-content>\n</div>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/add-button/add-button.html"*/
    })
], AddButtonComponent);

//# sourceMappingURL=add-button.js.map
// CONCATENATED MODULE: ./src/components/amount-picker/amount-picker.ts


let amount_picker_AmountPickerComponent = class AmountPickerComponent {
    constructor() {
        this.amountChange = new core["EventEmitter"]();
    }
    ngOnInit() {
        this.amountIndex = getMiddleIndex(this.supportedAmounts);
        this.getAmount() && this.amountChange.emit(this.getAmount());
    }
    getAmount() {
        return ((this.supportedAmounts && this.supportedAmounts[this.amountIndex]) || 0);
    }
    shouldShowButton(value) {
        return (this.supportedAmounts && this.supportedAmounts[this.amountIndex + value]);
    }
    changeAmount(indexValue) {
        this.amountIndex = this.amountIndex + indexValue;
        this.amountChange.emit(this.getAmount());
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], amount_picker_AmountPickerComponent.prototype, "currency", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Array)
], amount_picker_AmountPickerComponent.prototype, "supportedAmounts", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", core["EventEmitter"])
], amount_picker_AmountPickerComponent.prototype, "amountChange", void 0);
amount_picker_AmountPickerComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'amount-picker',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/amount-picker/amount-picker.html"*/'<div class="amount-picker__picker">\n  <div [ngClass]="{\'hidden\': !shouldShowButton(-1)}" class="amount-picker__button" (click)="changeAmount(-1)" tappable>\n    <img src="assets/img/icon-minus.svg">\n  </div>\n  <div class="amount-picker__amount">\n    <span *ngFor="let amount of supportedAmounts">\n      <span *ngIf="amount === getAmount()">{{amount | formatCurrency:currency:\'minimal\'}}</span>\n    </span>\n    <span *ngIf="!supportedAmounts">{{0 | formatCurrency:currency:0}}</span>\n  </div>\n  <div [ngClass]="{\'hidden\': !shouldShowButton(1)}" class="amount-picker__button" (click)="changeAmount(1)" tappable>\n    <img src="assets/img/icon-plus.svg">\n  </div>\n</div>\n<div class="amount-picker__values" *ngIf="supportedAmounts && supportedAmounts.length > 1">\n  <div>Purchase Amounts:</div>\n  <div><span class="amount-picker__values__value"\n      *ngFor="let amount of supportedAmounts; let last = last">{{amount | formatCurrency:currency:\'minimal\'}}<span\n        *ngIf="!last">,</span>\n    </span></div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/amount-picker/amount-picker.html"*/
    })
], amount_picker_AmountPickerComponent);

function getMiddleIndex(arr) {
    return arr && Math.floor(arr.length / 2);
}
//# sourceMappingURL=amount-picker.js.map
// CONCATENATED MODULE: ./src/components/balance-to-show/balance-to-show.ts


let BalanceToShowComponent = class BalanceToShowComponent {
    constructor() {
        this.resize = false;
    }
    set balance(value) {
        this._balance = value;
        this.processBalance(this._balance);
    }
    get balance() {
        return this._balance;
    }
    processBalance(balance) {
        if (!balance || balance === '')
            return;
        this.resize = Boolean(balance.length >= 18);
        if (balance.indexOf(' ') >= 0) {
            const spacePosition = balance.indexOf(' ');
            this.amount = balance.substr(0, spacePosition);
            this.unit = balance.substr(spacePosition, balance.length);
        }
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String),
    tslib_es6["__metadata"]("design:paramtypes", [String])
], BalanceToShowComponent.prototype, "balance", null);
BalanceToShowComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'balance-to-show',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/balance-to-show/balance-to-show.html"*/'<div class="flex" [ngClass]="{\'resizeAmountFont\': resize}">\n  <span class="amount">\n    {{ amount }}\n  </span>\n  <span class="unit">\n    {{ unit }}\n  </span>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/balance-to-show/balance-to-show.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [])
], BalanceToShowComponent);

//# sourceMappingURL=balance-to-show.js.map
// CONCATENATED MODULE: ./src/components/coin-icon/coin-icon.ts


let CoinIconComponent = class CoinIconComponent {
    constructor() { }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], CoinIconComponent.prototype, "coin", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], CoinIconComponent.prototype, "network", void 0);
CoinIconComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'coin-icon',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/coin-icon/coin-icon.html"*/'<ion-icon *ngIf="coin && coin !== \'default\'" class="item-img rectangle" [ngClass]="{ \n\'background_btc\': coin == \'btc\',\n\'background_edu\': coin == \'edu\',\n\'background_tik\': coin == \'tik\',\n\'background_bch\': coin == \'bch\',\n\'background_eth\': coin == \'eth\',\n\'background_xrp\': coin == \'xrp\',\n\'background_usdc\': coin == \'usdc\',\n\'background_pax\': coin == \'pax\',\n\'background_gusd\': coin == \'gusd\',\n\'background_busd\': coin == \'busd\',\n\'background_dai\': coin == \'dai\',\n\'background_wbtc\': coin == \'wbtc\',\n\'background_doge\': coin == \'doge\',\n\'testnet\': network === \'testnet\'\n}" item-start>\n  <img src="assets/img/currencies/{{coin}}.svg" />\n</ion-icon>\n\n<ion-icon *ngIf="coin ===\'default\'" name="logo-usd" color="success" class="item-img rectangle background_default" item-start></ion-icon>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/coin-icon/coin-icon.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [])
], CoinIconComponent);

//# sourceMappingURL=coin-icon.js.map
// CONCATENATED MODULE: ./src/components/exchange-rates/exchange-rates.ts







let exchange_rates_ExchangeRates = class ExchangeRates {
    constructor(navCtrl, currencyProvider, rateProvider, configProvider, logger, events) {
        this.navCtrl = navCtrl;
        this.currencyProvider = currencyProvider;
        this.rateProvider = rateProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.events = events;
        this.coins = [];
        const availableChains = this.currencyProvider.getAvailableChains();
        for (const coin of availableChains) {
            const { backgroundColor, gradientBackgroundColor } = this.currencyProvider.getTheme(coin);
            if (coin != 'edu' && coin != 'tik') {
                const card = {
                    unitCode: coin,
                    historicalRates: [],
                    currentPrice: 0,
                    totalBalanceChange: 0,
                    totalBalanceChangeAmount: 0,
                    backgroundColor,
                    gradientBackgroundColor,
                    name: this.currencyProvider.getCoinName(coin)
                };
                this.coins.push(card);
            }
        }
        this.getPrices();
        this.events.subscribe('Local/PriceUpdate', () => {
            this.getPrices();
        });
    }
    goToPricePage(card) {
        this.navCtrl.push(price_page_PricePage, { card });
    }
    getPrices() {
        this.setIsoCode();
        // TODO: Add a new endpoint in BWS that
        // provides JUST  the current prices and the delta.
        this.rateProvider
            .fetchHistoricalRates(this.fiatIsoCode, rate["a" /* DateRanges */].Day)
            .then(response => {
            lodash["forEach"](this.coins, (coin, index) => {
                if (response[coin.unitCode])
                    this.update(index, response[coin.unitCode]);
            });
                err => {
                this.logger.error('Error getting rates:', err);
            };
        });
    }
    update(i, values) {
        if (!values[0] || !lodash["last"](values)) {
            this.logger.warn('No exchange rate data');
            return;
        }
        const lastRate = lodash["last"](values).rate;
        this.coins[i].currentPrice = values[0].rate;
        this.coins[i].totalBalanceChangeAmount =
            this.coins[i].currentPrice - lastRate;
        this.coins[i].totalBalanceChange =
            (this.coins[i].totalBalanceChangeAmount * 100) / lastRate;
    }
    setIsoCode() {
        const alternativeIsoCode = this.configProvider.get().wallet.settings
            .alternativeIsoCode;
        this.isFiatIsoCodeSupported = this.rateProvider.isAltCurrencyAvailable(alternativeIsoCode);
        this.fiatIsoCode = this.isFiatIsoCodeSupported ? alternativeIsoCode : 'USD';
    }
    getDigitsInfo(coin) {
        switch (coin) {
            case 'xrp':
                return '1.4-4';
            case 'doge':
                return '1.4-4';
            default:
                return '1.2-2';
        }
    }
};
exchange_rates_ExchangeRates = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'exchange-rates',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/exchange-rates/exchange-rates.html"*/'<ion-list class="bp-list">\n  <div *ngFor="let coin of coins">\n    <button ion-item (click)="goToPricePage(coin)">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/currencies/{{coin.unitCode}}.svg">\n      </ion-icon>\n      <ion-label>\n        <div class="main-label">{{coin.name}}</div>\n        <div class="secondary-label">{{coin.unitCode | uppercase}}</div>\n      </ion-label>\n      <ion-note item-end>\n        <div class="main-note">\n          <span *ngIf="fiatIsoCode === \'USD\' && isFiatIsoCodeSupported">$</span>{{ coin.currentPrice | number: getDigitsInfo(coin.unitCode) }}\n          <span class="unit" *ngIf="fiatIsoCode !== \'USD\' && isFiatIsoCodeSupported">{{ fiatIsoCode }}</span>\n          <span class="unit" *ngIf="!isFiatIsoCodeSupported">USD</span>\n        </div>\n        <div class="average-container" [ngClass]="coin.totalBalanceChange > 0 ? \'possitive-avg\' : \'negative-avg\'">\n          <span class="average"><span *ngIf="coin.totalBalanceChange > 0">+</span>{{ coin.totalBalanceChange | number:\'1.2-2\' }}%</span>\n        </div>\n      </ion-note>\n    </button>\n  </div>\n</ion-list>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/exchange-rates/exchange-rates.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        providers["t" /* CurrencyProvider */],
        rate["b" /* RateProvider */],
        providers["s" /* ConfigProvider */],
        providers["W" /* Logger */],
        ionic_angular["f" /* Events */]])
], exchange_rates_ExchangeRates);

//# sourceMappingURL=exchange-rates.js.map
// CONCATENATED MODULE: ./src/components/expandable-header/expandable-header.ts



let ExpandableHeaderPrimaryComponent = class ExpandableHeaderPrimaryComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderPrimaryComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'expandable-header-primary',
        template: '<ng-content></ng-content>'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"]])
], ExpandableHeaderPrimaryComponent);

let ExpandableHeaderFooterComponent = class ExpandableHeaderFooterComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderFooterComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'expandable-header-footer',
        template: '<ng-content></ng-content>'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"]])
], ExpandableHeaderFooterComponent);

let ExpandableHeaderComponent = class ExpandableHeaderComponent {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * Determines how quickly the content fades out on scroll. The
         * greater the value, the quicker the fade.
         */
        this.fadeFactor = 2.5;
        this.disableFade = false;
    }
    ngOnInit() {
        if (this.disableFade) {
            return;
        }
        this.scrollArea.ionScroll.subscribe(event => event.domWrite(() => this.handleDomWrite(event.scrollTop)));
    }
    ngAfterViewInit() {
        this.headerHeight = this.element.nativeElement.offsetHeight;
    }
    handleDomWrite(scrollTop) {
        const newHeaderHeight = this.getNewHeaderHeight(scrollTop);
        newHeaderHeight > 0 && this.applyTransforms(scrollTop, newHeaderHeight);
    }
    applyTransforms(scrollTop, newHeaderHeight) {
        const transformations = this.computeTransformations(scrollTop, newHeaderHeight);
        this.transformContent(transformations);
    }
    getNewHeaderHeight(scrollTop) {
        const newHeaderHeight = this.headerHeight - scrollTop;
        return newHeaderHeight < 0 ? 0 : newHeaderHeight;
    }
    computeTransformations(scrollTop, newHeaderHeight) {
        const opacity = this.getScaleValue(newHeaderHeight, this.fadeFactor);
        const scale = this.getScaleValue(newHeaderHeight, 0.5);
        const translateY = scrollTop > 0 ? scrollTop / 1.5 : 0;
        return [opacity, scale, translateY];
    }
    getScaleValue(newHeaderHeight, exponent) {
        return (Math.pow(newHeaderHeight, exponent) /
            Math.pow(this.headerHeight, exponent));
    }
    transformContent(transformations) {
        const [opacity] = transformations;
        this.renderer.setStyle(this.primaryContent.element.nativeElement, 'opacity', `${opacity}`);
        this.renderer.setStyle(this.footerContent.element.nativeElement, 'opacity', `${opacity}`);
    }
};
tslib_es6["__decorate"]([
    Object(core["ContentChild"])(ExpandableHeaderPrimaryComponent),
    tslib_es6["__metadata"]("design:type", ExpandableHeaderPrimaryComponent)
], ExpandableHeaderComponent.prototype, "primaryContent", void 0);
tslib_es6["__decorate"]([
    Object(core["ContentChild"])(ExpandableHeaderFooterComponent),
    tslib_es6["__metadata"]("design:type", ExpandableHeaderFooterComponent)
], ExpandableHeaderComponent.prototype, "footerContent", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])('scrollArea'),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], ExpandableHeaderComponent.prototype, "scrollArea", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Number)
], ExpandableHeaderComponent.prototype, "fadeFactor", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], ExpandableHeaderComponent.prototype, "disableFade", void 0);
ExpandableHeaderComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'expandable-header',
        template: '<ng-content></ng-content>'
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"], core["Renderer2"]])
], ExpandableHeaderComponent);

const EXPANDABLE_HEADER_COMPONENTS = [
    ExpandableHeaderComponent,
    ExpandableHeaderFooterComponent,
    ExpandableHeaderPrimaryComponent
];
//# sourceMappingURL=expandable-header.js.map
// CONCATENATED MODULE: ./src/components/gift-card-discount-text/gift-card-discount-text.ts


let GiftCardDiscountText = class GiftCardDiscountText {
    constructor() {
        this.showConcisePercentage = false;
        this.numberOnly = false;
        this.math = Math;
    }
    ngOnInit() {
        const cardConfig = (this.merchant &&
            this.merchant.giftCards[0] &&
            this.merchant.giftCards[0]) ||
            this.cardConfig;
        this.currency =
            this.discount.currency || (cardConfig && cardConfig.currency);
    }
    shouldShowConcisePercentage(discount) {
        return this.showConcisePercentage && discount.amount >= 1;
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], GiftCardDiscountText.prototype, "discount", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], GiftCardDiscountText.prototype, "cardConfig", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], GiftCardDiscountText.prototype, "merchant", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], GiftCardDiscountText.prototype, "showConcisePercentage", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Boolean)
], GiftCardDiscountText.prototype, "numberOnly", void 0);
GiftCardDiscountText = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'gift-card-discount-text',
        template: `
    <span *ngIf="discount.type === 'flatrate'">{{
      discount.amount | formatCurrency: currency:'minimal'
    }}</span>
    <span *ngIf="discount.type === 'percentage'">
      <span *ngIf="shouldShowConcisePercentage(discount)"
        >{{ math.floor(discount.amount) }}%</span
      >
      <span *ngIf="!shouldShowConcisePercentage(discount)"
        >{{ discount.amount }}%</span
      >
    </span>
    <span
      *ngIf="!numberOnly && ['flatrate', 'percentage'].includes(discount.type)"
      >Off Every Purchase</span
    >
    <span *ngIf="discount.type === 'custom'">{{
      discount.value || 'Discount Available'
    }}</span>
  `
    }),
    tslib_es6["__metadata"]("design:paramtypes", [])
], GiftCardDiscountText);

//# sourceMappingURL=gift-card-discount-text.js.map
// EXTERNAL MODULE: ./src/components/info-sheet/info-sheet-template.ts
var info_sheet_template = __webpack_require__(930);

// CONCATENATED MODULE: ./src/components/label-tip/label-tip.ts



let LabelTip = class LabelTip {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    ngOnChanges() {
        this.renderer.addClass(this.element.nativeElement, this.type);
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], LabelTip.prototype, "type", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], LabelTip.prototype, "header", void 0);
LabelTip = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'label-tip',
        template: `
    <div class="label-header" *ngIf="header !== 'no-header'">
      <img
        *ngIf="type === 'info'"
        class="label-header__icon"
        src="assets/img/icon-info-blue.svg"
      />
      <img
        *ngIf="type === 'warn'"
        class="label-header__icon"
        src="assets/img/icon-warning-circled.svg"
      />
      <img
        *ngIf="type === 'danger'"
        class="label-header__icon"
        src="assets/img/icon-danger.svg"
      />
      <ng-content select="[label-tip-title]"></ng-content>
    </div>
    <div
      [ngClass]="{
        blue: type === 'info',
        yellow: type == 'warn',
        red: type == 'danger'
      }"
    >
      <ng-content select="[label-tip-body]"></ng-content>
    </div>
  `
    }),
    tslib_es6["__metadata"]("design:paramtypes", [core["ElementRef"], core["Renderer2"]])
], LabelTip);

//# sourceMappingURL=label-tip.js.map
// CONCATENATED MODULE: ./src/components/search-bar/search-bar.ts





let search_bar_SearchBarComponent = class SearchBarComponent {
    constructor() {
        this.search = new core["EventEmitter"]();
        this.debouncer = new Rx["Subject"]();
    }
    ngOnInit() {
        this.debouncer
            .pipe(Object(operators["debounceTime"])(200))
            .subscribe(value => this.search.emit(value));
        this.scrollArea &&
            this.scrollArea.ionScroll.subscribe(() => {
                const activeElement = document.activeElement;
                activeElement && activeElement.blur && activeElement.blur();
            });
    }
    onSearch($event) {
        this.debouncer.next($event);
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], search_bar_SearchBarComponent.prototype, "placeholder", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", ionic_angular["e" /* Content */])
], search_bar_SearchBarComponent.prototype, "scrollArea", void 0);
tslib_es6["__decorate"]([
    Object(core["Output"])(),
    tslib_es6["__metadata"]("design:type", core["EventEmitter"])
], search_bar_SearchBarComponent.prototype, "search", void 0);
search_bar_SearchBarComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        host: { class: 'search-bar' },
        selector: 'search-bar',
        template: `
    <ion-input
      [placeholder]="placeholder"
      (input)="onSearch($event)"
    ></ion-input>
  `
    })
], search_bar_SearchBarComponent);

//# sourceMappingURL=search-bar.js.map
// CONCATENATED MODULE: ./src/components/wallet-item-content/wallet-item-content.ts


let WalletItemContent = class WalletItemContent {
    getBalance(wallet, currency) {
        const lastKnownBalance = this.getLastKownBalance(wallet, currency);
        if (currency === 'XRP') {
            const availableBalanceStr = wallet.cachedStatus &&
                wallet.cachedStatus.availableBalanceStr &&
                wallet.cachedStatus.availableBalanceStr.replace(` ${currency}`, '');
            return availableBalanceStr || lastKnownBalance;
        }
        else {
            const totalBalanceStr = wallet.cachedStatus &&
                wallet.cachedStatus.totalBalanceStr &&
                wallet.cachedStatus.totalBalanceStr.replace(` ${currency}`, '');
            // New created wallet does not have "lastkKnownBalance"
            if (totalBalanceStr == '0.00' &&
                (lastKnownBalance == '0.00' || !lastKnownBalance))
                return '0';
            return totalBalanceStr || lastKnownBalance;
        }
    }
    getAlternativeBalance(wallet, currency) {
        if (currency === 'XRP') {
            const availableAlternative = wallet.cachedStatus && wallet.cachedStatus.availableBalanceAlternative;
            return availableAlternative;
        }
        else {
            const totalBalanceAlternative = wallet.cachedStatus && wallet.cachedStatus.totalBalanceAlternative;
            if (totalBalanceAlternative == '0.00')
                return '0';
            return totalBalanceAlternative;
        }
    }
    getLastKownBalance(wallet, currency) {
        return (wallet.lastKnownBalance &&
            wallet.lastKnownBalance.replace(` ${currency}`, ''));
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], WalletItemContent.prototype, "wallet", void 0);
WalletItemContent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'wallet-item-content',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-item-content/wallet-item-content.html"*/'<ion-item [ngClass]="{\'wallet-disabled\': !wallet?.isComplete() || wallet?.needsBackup}">\n  <coin-icon [coin]="wallet.coin" [network]="wallet.network" item-left></coin-icon>\n  <ion-label>\n    <div class="main-label">{{ wallet?.name }}</div>\n    <div *ngIf="wallet?.credentials?.n > 1 || (!wallet?.credentials?.n && wallet?.n > 1) || !wallet?.isComplete() || (wallet?.isComplete() && wallet?.needsBackup)" class="secondary-label">\n      <span *ngIf="wallet?.credentials?.n > 1">({{ wallet?.credentials?.m }}/{{ wallet?.credentials?.n }})</span>\n      <span *ngIf="!wallet?.credentials?.n && wallet?.n > 1">({{ wallet?.m }}/{{ wallet?.n }})</span>\n      <span *ngIf="!wallet?.isComplete()"> - <span class="wallet-warning">{{ \'Incomplete\' | translate }}</span></span>\n      <span *ngIf="wallet?.isComplete() && wallet?.needsBackup" class="wallet-warning backup-msg"> {{\'Needs Backup\' | translate}}</span>\n    </div>\n  </ion-label>\n  <ion-note item-end>\n    <div>\n      <div *ngIf="!wallet?.balanceHidden">\n        <div class="main-note">{{ getBalance(wallet, wallet?.coin.toUpperCase()) }}</div>\n        <div class="secondary-note" *ngIf="wallet?.cachedStatus">\n          {{ getAlternativeBalance(wallet, wallet?.coin.toUpperCase()) }}\n          {{ wallet?.cachedStatus.alternativeIsoCode }}\n        </div>\n      </div>\n    </div>\n    <div *ngIf="wallet?.balanceHidden">\n      [<span translate>Hidden</span>]\n    </div>\n  </ion-note>\n</ion-item>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-item-content/wallet-item-content.html"*/
    })
], WalletItemContent);

//# sourceMappingURL=wallet-item-content.js.map
// CONCATENATED MODULE: ./src/components/components.ts
















const COMPONENTS = [
    ActionCardComponent,
    ActionCardV4Component,
    ACTION_SHEET_COMPONENTS,
    AddButtonComponent,
    AdvertisingComponent,
    amount_picker_AmountPickerComponent,
    EXPANDABLE_HEADER_COMPONENTS,
    GiftCardDiscountText,
    LabelTip,
    WalletItemContent,
    search_bar_SearchBarComponent,
    exchange_rates_ExchangeRates,
    CoinIconComponent,
    BalanceToShowComponent,
    chart_component_ChartComponent,
    price_chart_PriceChart
];
//# sourceMappingURL=components.js.map
// EXTERNAL MODULE: ./src/providers/language-loader/language-loader.ts
var language_loader = __webpack_require__(950);

// CONCATENATED MODULE: ./src/providers/providers.module.ts




let ProvidersModule = class ProvidersModule {
};
ProvidersModule = tslib_es6["__decorate"]([
    Object(core["NgModule"])({
        providers: [
            providers["a" /* ActionSheetProvider */],
            providers["c" /* AddressProvider */],
            providers["b" /* AddressBookProvider */],
            providers["d" /* AnalyticsProvider */],
            providers["g" /* AppleWalletNg */],
            providers["h" /* AppleWalletProvider */],
            providers["f" /* AppProvider */],
            providers["e" /* AppIdentityProvider */],
            providers["i" /* BackupProvider */],
            providers["_20" /* TKCoinProvider */],
            providers["_18" /* TKCoinCardProvider */],
            providers["_19" /* TKCoinIdProvider */],
            providers["_17" /* TKCoinAccountProvider */],
            providers["j" /* BuyCryptoProvider */],
            providers["l" /* BwcProvider */],
            providers["k" /* BwcErrorProvider */],
            providers["n" /* ChangellyProvider */],
            providers["r" /* ConfettiProvider */],
            providers["s" /* ConfigProvider */],
            providers["q" /* CoinbaseProvider */],
            providers["o" /* Clipboard */],
            providers["p" /* ClipboardProvider */],
            providers["t" /* CurrencyProvider */],
            providers["u" /* DerivationPathHelperProvider */],
            providers["v" /* Device */],
            providers["w" /* DirectoryProvider */],
            providers["x" /* DomProvider */],
            providers["y" /* DownloadProvider */],
            providers["z" /* DynamicLinksProvider */],
            providers["C" /* ErrorsProvider */],
            providers["D" /* ExchangeCryptoProvider */],
            providers["E" /* ExternalLinkProvider */],
            providers["H" /* FeedbackProvider */],
            providers["F" /* FCMNG */],
            providers["M" /* HomeIntegrationsProvider */],
            providers["Z" /* NewFeatureData */],
            providers["N" /* IABCardProvider */],
            providers["O" /* InAppBrowserProvider */],
            providers["G" /* FeeProvider */],
            providers["K" /* FingerprintAIO */],
            providers["L" /* GiftCardProvider */],
            providers["P" /* IncomingDataProvider */],
            providers["Q" /* InvoiceProvider */],
            providers["R" /* KeyProvider */],
            providers["S" /* LanguageLoader */],
            providers["T" /* LanguageProvider */],
            providers["U" /* LaunchReview */],
            providers["V" /* LocationProvider */],
            providers["W" /* Logger */],
            providers["X" /* LogsProvider */],
            providers["A" /* ElectronProvider */],
            providers["Y" /* MerchantProvider */],
            providers["_0" /* OnGoingProcessProvider */],
            providers["_1" /* PayproProvider */],
            providers["_3" /* PlatformProvider */],
            providers["_5" /* ProfileProvider */],
            providers["_4" /* PopupProvider */],
            providers["_7" /* QRScanner */],
            providers["_6" /* PushNotificationsProvider */],
            providers["_8" /* RateProvider */],
            providers["_10" /* ReplaceParametersProvider */],
            providers["_9" /* ReleaseProvider */],
            providers["_13" /* SimplexProvider */],
            providers["_16" /* StatusBar */],
            providers["_15" /* SplashScreen */],
            providers["_11" /* ScanProvider */],
            providers["_12" /* ScreenOrientation */],
            providers["_14" /* SocialSharing */],
            providers["_21" /* TabProvider */],
            providers["_24" /* Toast */],
            providers["_29" /* Vibration */],
            providers["_22" /* ThemeProvider */],
            providers["_23" /* TimeProvider */],
            providers["_25" /* TouchIdProvider */],
            providers["_26" /* TxConfirmNotificationProvider */],
            providers["J" /* FilterProvider */],
            providers["_27" /* TxFormatProvider */],
            providers["_28" /* UserAgent */],
            providers["_31" /* WalletProvider */],
            providers["_30" /* WalletConnectProvider */],
            providers["_32" /* WyreProvider */],
            providers["B" /* EmailNotificationsProvider */],
            common["d" /* DecimalPipe */],
            providers["_2" /* PersistenceProvider */],
            providers["I" /* File */],
            providers["m" /* CardPhasesProvider */]
        ]
    })
], ProvidersModule);

//# sourceMappingURL=providers.module.js.map
// CONCATENATED MODULE: ./src/app/app.module.ts









/* Modules */




/* Copay App */



/* Pipes */







/* Directives */












/* Components */

/* Providers */


function translateParserFactory() {
    return new InterpolatedTranslateParser();
}
class InterpolatedTranslateParser extends core_es5["b" /* TranslateDefaultParser */] {
    constructor() {
        super(...arguments);
        this.templateMatcher = /{\s?([^{}\s]*)\s?}/g;
    }
}
class MyMissingTranslationHandler {
    constructor() {
        this.parser = translateParserFactory();
    }
    handle(params) {
        return this.parser.interpolate(params.key, params.interpolateParams);
    }
}
let AppModule = class AppModule {
    constructor(config) {
        this.config = config;
    }
};
AppModule = tslib_es6["__decorate"]([
    Object(core["NgModule"])({
        declarations: [
            app_component_CopayApp,
            ...PAGES,
            ...COMPONENTS,
            /* Directives */
            CopyToClipboard,
            externalize_links_ExternalizeLinks,
            FixedScrollBgColor,
            IonContentBackgroundColor,
            ion_mask_IonMask,
            long_press_LongPress,
            NavbarBg,
            NoLowFee,
            animate["a" /* Animate */],
            RevealAtScrollPosition,
            scrolled_into_view_ScrolledIntoView,
            WideHeaderBarButton,
            /* Pipes */
            FiatToUnitPipe,
            format_currency["a" /* FormatCurrencyPipe */],
            KeysPipe,
            SatToUnitPipe,
            SatToFiatPipe,
            OrderByPipe,
            ShortenedAddressPipe
        ],
        imports: [
            ionic_angular["i" /* IonicModule */].forRoot(app_component_CopayApp, {
                animate: environments["a" /* default */].enableAnimations,
                tabsHideOnSubPages: true,
                scrollPadding: false,
                tabsPlacement: 'bottom',
                backButtonIcon: 'arrow-round-back',
                backButtonText: ''
            }, {
                links: []
            }),
            ngx_text_overflow_clamp_dist["a" /* NgxTextOverflowClampModule */],
            dist["c" /* IonicImageLoader */].forRoot(),
            platform_browser["a" /* BrowserModule */],
            animations["a" /* BrowserAnimationsModule */],
            esm5_http["b" /* HttpClientModule */],
            lib["MarkdownModule"].forRoot(),
            angular2_moment["MomentModule"],
            ngx_barcode["a" /* NgxBarcodeModule */],
            ngx_qrcode2["a" /* NgxQRCodeModule */],
            ProvidersModule,
            core_es5["d" /* TranslateModule */].forRoot({
                parser: { provide: core_es5["e" /* TranslateParser */], useFactory: translateParserFactory },
                missingTranslationHandler: {
                    provide: core_es5["a" /* MissingTranslationHandler */],
                    useClass: MyMissingTranslationHandler
                },
                loader: {
                    provide: core_es5["c" /* TranslateLoader */],
                    useClass: language_loader["a" /* LanguageLoader */]
                }
            })
        ],
        bootstrap: [ionic_angular["g" /* IonicApp */]],
        entryComponents: [app_component_CopayApp, ...PAGES, ...COMPONENTS],
        providers: [
            {
                provide: core["ErrorHandler"],
                useClass: ionic_angular["h" /* IonicErrorHandler */]
            },
            format_currency["a" /* FormatCurrencyPipe */]
        ],
        schemas: [core["CUSTOM_ELEMENTS_SCHEMA"]]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["d" /* Config */]])
], AppModule);

//# sourceMappingURL=app.module.js.map
// EXTERNAL MODULE: ./node_modules/qr-code-component-ng/dist/loader/index.js + 2 modules
var loader = __webpack_require__(2011);

// CONCATENATED MODULE: ./src/app/main.ts

// tslint:disable-next-line:no-submodule-imports


// Note: loader import location set using "esmLoaderPath" within the output target confg
// tslint:disable-next-line:no-submodule-imports

Object(platform_browser_dynamic["a" /* platformBrowserDynamic */])().bootstrapModule(AppModule);
Object(loader["a" /* defineCustomElements */])(window);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 104:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(858);

module.exports.Interpreter = __webpack_require__(1495);


/***/ }),

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(75);
var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);

var Signature = function Signature(r, s) {
  if (!(this instanceof Signature)) {
    return new Signature(r, s);
  }
  if (r instanceof BN) {
    this.set({
      r: r,
      s: s
    });
  } else if (r) {
    var obj = r;
    this.set(obj);
  }
};

/* jshint maxcomplexity: 7 */
Signature.prototype.set = function(obj) {
  this.r = obj.r || this.r || undefined;
  this.s = obj.s || this.s || undefined;

  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]
  this.compressed = typeof obj.compressed !== 'undefined' ?
    obj.compressed : this.compressed; //whether the recovered pubkey is compressed
  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;
  return this;
};

Signature.fromCompact = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');

  var sig = new Signature();

  var compressed = true;
  var i = buf.slice(0, 1)[0] - 27 - 4;
  if (i < 0) {
    compressed = false;
    i = i + 4;
  }

  var b2 = buf.slice(1, 33);
  var b3 = buf.slice(33, 65);

  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));
  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));
  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));

  sig.compressed = compressed;
  sig.i = i;
  sig.r = BN.fromBuffer(b2);
  sig.s = BN.fromBuffer(b3);

  return sig;
};

Signature.fromDER = Signature.fromBuffer = function(buf, strict) {
  var obj = Signature.parseDER(buf, strict);
  var sig = new Signature();

  sig.r = obj.r;
  sig.s = obj.s;

  return sig;
};

// The format used in a tx
Signature.fromTxFormat = function(buf) {
  var nhashtype = buf.readUInt8(buf.length - 1);
  var derbuf = buf.slice(0, buf.length - 1);
  var sig = new Signature.fromDER(derbuf, false);
  sig.nhashtype = nhashtype;
  return sig;
};

Signature.fromString = function(str) {
  var buf = Buffer.from(str, 'hex');
  return Signature.fromDER(buf);
};


/**
 * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.
 */
Signature.parseDER = function(buf, strict) {
  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));
  if (_.isUndefined(strict)) {
    strict = true;
  }

  var header = buf[0];
  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));

  var length = buf[1];
  var buflength = buf.slice(2).length;
  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));

  length = length < buflength ? length : buflength;

  var rheader = buf[2 + 0];
  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));

  var rlength = buf[2 + 1];
  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
  var r = BN.fromBuffer(rbuf);
  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;
  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));

  var sheader = buf[2 + 2 + rlength + 0];
  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));

  var slength = buf[2 + 2 + rlength + 1];
  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
  var s = BN.fromBuffer(sbuf);
  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;
  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));

  var sumlength = 2 + 2 + rlength + 2 + slength;
  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));

  var obj = {
    header: header,
    length: length,
    rheader: rheader,
    rlength: rlength,
    rneg: rneg,
    rbuf: rbuf,
    r: r,
    sheader: sheader,
    slength: slength,
    sneg: sneg,
    sbuf: sbuf,
    s: s
  };

  return obj;
};


Signature.prototype.toCompact = function(i, compressed) {
  i = typeof i === 'number' ? i : this.i;
  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;

  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
    throw new Error('i must be equal to 0, 1, 2, or 3');
  }

  var val = i + 27 + 4;
  if (compressed === false) {
    val = val - 4;
  }
  var b1 = Buffer.from([val]);
  var b2 = this.r.toBuffer({
    size: 32
  });
  var b3 = this.s.toBuffer({
    size: 32
  });
  return Buffer.concat([b1, b2, b3]);
};

Signature.prototype.toBuffer = Signature.prototype.toDER = function() {
  var rnbuf = this.r.toBuffer();
  var snbuf = this.s.toBuffer();

  var rneg = rnbuf[0] & 0x80 ? true : false;
  var sneg = snbuf[0] & 0x80 ? true : false;

  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;
  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;

  var rlength = rbuf.length;
  var slength = sbuf.length;
  var length = 2 + rlength + 2 + slength;
  var rheader = 0x02;
  var sheader = 0x02;
  var header = 0x30;

  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);
  return der;
};

Signature.prototype.toString = function() {
  var buf = this.toDER();
  return buf.toString('hex');
};

/**
 * This function is translated from bitcoind's IsDERSignature and is used in
 * the script interpreter.  This "DER" format actually includes an extra byte,
 * the nhashtype, at the end. It is really the tx format, not DER format.
 *
 * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
 * Where R and S are not negative (their first byte has its highest bit not set), and not
 * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
 * in which case a single 0 byte is necessary and even required).
 *
 * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
 */
Signature.isTxDER = function(buf) {
  if (buf.length < 9) {
    //  Non-canonical signature: too short
    return false;
  }
  if (buf.length > 73) {
    // Non-canonical signature: too long
    return false;
  }
  if (buf[0] !== 0x30) {
    //  Non-canonical signature: wrong type
    return false;
  }
  if (buf[1] !== buf.length - 3) {
    //  Non-canonical signature: wrong length marker
    return false;
  }
  var nLenR = buf[3];
  if (5 + nLenR >= buf.length) {
    //  Non-canonical signature: S length misplaced
    return false;
  }
  var nLenS = buf[5 + nLenR];
  if ((nLenR + nLenS + 7) !== buf.length) {
    //  Non-canonical signature: R+S length mismatch
    return false;
  }

  var R = buf.slice(4);
  if (buf[4 - 2] !== 0x02) {
    //  Non-canonical signature: R value type mismatch
    return false;
  }
  if (nLenR === 0) {
    //  Non-canonical signature: R length is zero
    return false;
  }
  if (R[0] & 0x80) {
    //  Non-canonical signature: R value negative
    return false;
  }
  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {
    //  Non-canonical signature: R value excessively padded
    return false;
  }

  var S = buf.slice(6 + nLenR);
  if (buf[6 + nLenR - 2] !== 0x02) {
    //  Non-canonical signature: S value type mismatch
    return false;
  }
  if (nLenS === 0) {
    //  Non-canonical signature: S length is zero
    return false;
  }
  if (S[0] & 0x80) {
    //  Non-canonical signature: S value negative
    return false;
  }
  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {
    //  Non-canonical signature: S value excessively padded
    return false;
  }
  return true;
};

/**
 * Compares to bitcoind's IsLowDERSignature
 * See also ECDSA signature algorithm which enforces this.
 * See also BIP 62, "low S values in signatures"
 */
Signature.prototype.hasLowS = function() {
  if (this.s.lt(new BN(1)) ||
    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {
    return false;
  }
  return true;
};

/**
 * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.
 * Translated from bitcoind's IsDefinedHashtypeSignature
 */
Signature.prototype.hasDefinedHashtype = function() {
  if (!JSUtil.isNaturalNumber(this.nhashtype)) {
    return false;
  }
  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit
  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;
  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {
    return false;
  }
  return true;
};

Signature.prototype.toTxFormat = function() {
  var derbuf = this.toDER();
  var buf = Buffer.alloc(1);
  buf.writeUInt8(this.nhashtype, 0);
  return Buffer.concat([derbuf, buf]);
};

Signature.SIGHASH_ALL = 0x01;
Signature.SIGHASH_NONE = 0x02;
Signature.SIGHASH_SINGLE = 0x03;
Signature.SIGHASH_ANYONECANPAY = 0x80;

module.exports = Signature;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(863);

module.exports.Interpreter = __webpack_require__(1508);


/***/ }),

/***/ 1060:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1062:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 626,
	"./af.js": 626,
	"./ar": 627,
	"./ar-dz": 628,
	"./ar-dz.js": 628,
	"./ar-kw": 629,
	"./ar-kw.js": 629,
	"./ar-ly": 630,
	"./ar-ly.js": 630,
	"./ar-ma": 631,
	"./ar-ma.js": 631,
	"./ar-sa": 632,
	"./ar-sa.js": 632,
	"./ar-tn": 633,
	"./ar-tn.js": 633,
	"./ar.js": 627,
	"./az": 634,
	"./az.js": 634,
	"./be": 635,
	"./be.js": 635,
	"./bg": 636,
	"./bg.js": 636,
	"./bm": 637,
	"./bm.js": 637,
	"./bn": 638,
	"./bn.js": 638,
	"./bo": 639,
	"./bo.js": 639,
	"./br": 640,
	"./br.js": 640,
	"./bs": 641,
	"./bs.js": 641,
	"./ca": 642,
	"./ca.js": 642,
	"./cs": 643,
	"./cs.js": 643,
	"./cv": 644,
	"./cv.js": 644,
	"./cy": 645,
	"./cy.js": 645,
	"./da": 646,
	"./da.js": 646,
	"./de": 647,
	"./de-at": 648,
	"./de-at.js": 648,
	"./de-ch": 649,
	"./de-ch.js": 649,
	"./de.js": 647,
	"./dv": 650,
	"./dv.js": 650,
	"./el": 651,
	"./el.js": 651,
	"./en-au": 652,
	"./en-au.js": 652,
	"./en-ca": 653,
	"./en-ca.js": 653,
	"./en-gb": 654,
	"./en-gb.js": 654,
	"./en-ie": 655,
	"./en-ie.js": 655,
	"./en-il": 656,
	"./en-il.js": 656,
	"./en-in": 657,
	"./en-in.js": 657,
	"./en-nz": 658,
	"./en-nz.js": 658,
	"./en-sg": 659,
	"./en-sg.js": 659,
	"./eo": 660,
	"./eo.js": 660,
	"./es": 661,
	"./es-do": 662,
	"./es-do.js": 662,
	"./es-us": 663,
	"./es-us.js": 663,
	"./es.js": 661,
	"./et": 664,
	"./et.js": 664,
	"./eu": 665,
	"./eu.js": 665,
	"./fa": 666,
	"./fa.js": 666,
	"./fi": 667,
	"./fi.js": 667,
	"./fil": 668,
	"./fil.js": 668,
	"./fo": 669,
	"./fo.js": 669,
	"./fr": 670,
	"./fr-ca": 671,
	"./fr-ca.js": 671,
	"./fr-ch": 672,
	"./fr-ch.js": 672,
	"./fr.js": 670,
	"./fy": 673,
	"./fy.js": 673,
	"./ga": 674,
	"./ga.js": 674,
	"./gd": 675,
	"./gd.js": 675,
	"./gl": 676,
	"./gl.js": 676,
	"./gom-deva": 677,
	"./gom-deva.js": 677,
	"./gom-latn": 678,
	"./gom-latn.js": 678,
	"./gu": 679,
	"./gu.js": 679,
	"./he": 680,
	"./he.js": 680,
	"./hi": 681,
	"./hi.js": 681,
	"./hr": 682,
	"./hr.js": 682,
	"./hu": 683,
	"./hu.js": 683,
	"./hy-am": 684,
	"./hy-am.js": 684,
	"./id": 685,
	"./id.js": 685,
	"./is": 686,
	"./is.js": 686,
	"./it": 687,
	"./it-ch": 688,
	"./it-ch.js": 688,
	"./it.js": 687,
	"./ja": 689,
	"./ja.js": 689,
	"./jv": 690,
	"./jv.js": 690,
	"./ka": 691,
	"./ka.js": 691,
	"./kk": 692,
	"./kk.js": 692,
	"./km": 693,
	"./km.js": 693,
	"./kn": 694,
	"./kn.js": 694,
	"./ko": 695,
	"./ko.js": 695,
	"./ku": 696,
	"./ku.js": 696,
	"./ky": 697,
	"./ky.js": 697,
	"./lb": 698,
	"./lb.js": 698,
	"./lo": 699,
	"./lo.js": 699,
	"./lt": 700,
	"./lt.js": 700,
	"./lv": 701,
	"./lv.js": 701,
	"./me": 702,
	"./me.js": 702,
	"./mi": 703,
	"./mi.js": 703,
	"./mk": 704,
	"./mk.js": 704,
	"./ml": 705,
	"./ml.js": 705,
	"./mn": 706,
	"./mn.js": 706,
	"./mr": 707,
	"./mr.js": 707,
	"./ms": 708,
	"./ms-my": 709,
	"./ms-my.js": 709,
	"./ms.js": 708,
	"./mt": 710,
	"./mt.js": 710,
	"./my": 711,
	"./my.js": 711,
	"./nb": 712,
	"./nb.js": 712,
	"./ne": 713,
	"./ne.js": 713,
	"./nl": 714,
	"./nl-be": 715,
	"./nl-be.js": 715,
	"./nl.js": 714,
	"./nn": 716,
	"./nn.js": 716,
	"./oc-lnc": 717,
	"./oc-lnc.js": 717,
	"./pa-in": 718,
	"./pa-in.js": 718,
	"./pl": 719,
	"./pl.js": 719,
	"./pt": 720,
	"./pt-br": 721,
	"./pt-br.js": 721,
	"./pt.js": 720,
	"./ro": 722,
	"./ro.js": 722,
	"./ru": 723,
	"./ru.js": 723,
	"./sd": 724,
	"./sd.js": 724,
	"./se": 725,
	"./se.js": 725,
	"./si": 726,
	"./si.js": 726,
	"./sk": 727,
	"./sk.js": 727,
	"./sl": 728,
	"./sl.js": 728,
	"./sq": 729,
	"./sq.js": 729,
	"./sr": 730,
	"./sr-cyrl": 731,
	"./sr-cyrl.js": 731,
	"./sr.js": 730,
	"./ss": 732,
	"./ss.js": 732,
	"./sv": 733,
	"./sv.js": 733,
	"./sw": 734,
	"./sw.js": 734,
	"./ta": 735,
	"./ta.js": 735,
	"./te": 736,
	"./te.js": 736,
	"./tet": 737,
	"./tet.js": 737,
	"./tg": 738,
	"./tg.js": 738,
	"./th": 739,
	"./th.js": 739,
	"./tk": 740,
	"./tk.js": 740,
	"./tl-ph": 741,
	"./tl-ph.js": 741,
	"./tlh": 742,
	"./tlh.js": 742,
	"./tr": 743,
	"./tr.js": 743,
	"./tzl": 744,
	"./tzl.js": 744,
	"./tzm": 745,
	"./tzm-latn": 746,
	"./tzm-latn.js": 746,
	"./tzm.js": 745,
	"./ug-cn": 747,
	"./ug-cn.js": 747,
	"./uk": 748,
	"./uk.js": 748,
	"./ur": 749,
	"./ur.js": 749,
	"./uz": 750,
	"./uz-latn": 751,
	"./uz-latn.js": 751,
	"./uz.js": 750,
	"./vi": 752,
	"./vi.js": 752,
	"./x-pseudo": 753,
	"./x-pseudo.js": 753,
	"./yo": 754,
	"./yo.js": 754,
	"./zh-cn": 755,
	"./zh-cn.js": 755,
	"./zh-hk": 756,
	"./zh-hk.js": 756,
	"./zh-mo": 757,
	"./zh-mo.js": 757,
	"./zh-tw": 758,
	"./zh-tw.js": 758
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 1062;

/***/ }),

/***/ 107:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet__ = __webpack_require__(927);



class ActionSheetParent {
    present(params = {
            maxHeight: '90vh',
            minHeight: 'unset'
        }) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            return this.actionSheet.present(this.componentRef, params);
        });
    }
    dismiss(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.actionSheet.dismiss(data);
        });
    }
    onDidDismiss(func) {
        this.dismissFunction = func;
        this.actionSheet.dismissFunction = func;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ActionSheetParent;

__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2__action_sheet__["a" /* ActionSheetComponent */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_2__action_sheet__["a" /* ActionSheetComponent */])
], ActionSheetParent.prototype, "actionSheet", void 0);
//# sourceMappingURL=action-sheet-parent.js.map

/***/ }),

/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);






let ConfigProvider = class ConfigProvider {
    constructor(currencyProvider, logger, persistence) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.persistence = persistence;
        this.logger.debug('ConfigProvider initialized');
        this.configDefault = {
            // wallet limits
            limits: {
                totalCopayers: 6,
                mPlusN: 100
            },
            // wallet default config
            wallet: {
                requiredCopayers: 2,
                totalCopayers: 3,
                spendUnconfirmed: false,
                reconnectDelay: 5000,
                idleDurationMin: 4,
                settings: {
                    unitName: 'EDU',
                    unitToSatoshi: 100000000,
                    unitDecimals: 8,
                    unitCode: 'edu',
                    alternativeName: 'Peso argentino',
                    alternativeIsoCode: 'ARS',
                    defaultLanguage: '',
                    feeLevel: 'normal'
                }
            },
            // Bitcore wallet service URL
            bws: {
                url: 'https://bws.tkcoin.org/bws/api' // Uncomment and replace w/ http://localhost:3232/bws/api for testing
            },
            // TODO FIX Check what is useful
            adPubKey: {
                pubkey: '022fd3864dcba0c5177a0b76a94143ac26dcf4cf32ce7bb3d42a1cecae4102e105'
            },
            download: {
                tkcoin: {
                    url: '',
                },
                copay: {
                    url: '',
                }
            },
            rateApp: {
                tkcoin: {
                    ios: '',
                    android: '',
                    wp: ''
                },
                copay: {
                    ios: '',
                    android: '',
                    wp: ''
                }
            },
            lock: {
                method: null,
                value: null,
                bannedUntil: null
            },
            // External services
            showIntegration: {
                coinbase: true,
                debitcard: true,
                amazon: true,
                mercadolibre: true,
                shapeshift: true,
                buycrypto: true,
                exchangecrypto: true,
                giftcards: true,
                walletConnect: true
            },
            pushNotifications: {
                enabled: true
            },
            desktopNotifications: {
                enabled: true
            },
            confirmedTxsNotifications: {
                enabled: true
            },
            productsUpdates: {
                enabled: true
            },
            offersAndPromotions: {
                enabled: true
            },
            emailNotifications: {
                enabled: false,
                email: ''
            },
            log: {
                weight: 3
            },
            blockExplorerUrl: this.currencyProvider.getBlockExplorerUrls(),
            blockExplorerUrlTestnet: this.currencyProvider.getBlockExplorerUrlsTestnet(),
            allowMultiplePrimaryWallets: false,
            legacyQrCode: {
                show: false
            },
            theme: {
                enabled: true,
                system: true,
                name: 'light'
            },
            totalBalance: {
                show: true
            }
        };
    }
    load() {
        return new Promise(resolve => {
            this.persistence
                .getConfig()
                .then((config) => {
                if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](config)) {
                    this.logger.debug('Using Custom Configuration');
                    this.configCache = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](config);
                    this.backwardCompatibility();
                }
                else {
                    this.logger.debug('Using Default Configurartion');
                    this.configCache = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](this.configDefault);
                }
                this.logImportantConfig(this.configCache);
                resolve();
            })
                .catch(err => {
                this.logger.error(err.message);
                this.logger.error('There was an error reading the app config. It was reseted to default values');
                this.configCache = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](this.configDefault);
                this.reset(); // remove local config
                resolve();
            });
        });
    }
    logImportantConfig(config) {
        const spendUnconfirmed = config.wallet.spendUnconfirmed;
        const lockMethod = config && config.lock ? config.lock.method : null;
        this.logger.debug('Config | spendUnconfirmed: ' +
            spendUnconfirmed +
            ' - lockMethod: ' +
            lockMethod);
    }
    /**
     * @param newOpts object or string (JSON)
     */
    set(newOpts) {
        const config = __WEBPACK_IMPORTED_MODULE_5_lodash__["cloneDeep"](this.configDefault);
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](newOpts)) {
            newOpts = JSON.parse(newOpts);
        }
        __WEBPACK_IMPORTED_MODULE_5_lodash__["merge"](config, this.configCache, newOpts);
        this.configCache = config;
        this.persistence.storeConfig(this.configCache).then(() => {
            this.logger.info('Config saved');
        });
    }
    removeBwsFor(walletid) {
        const config = __WEBPACK_IMPORTED_MODULE_5_lodash__["cloneDeep"](this.configCache);
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](walletid) && config.bwsFor && config.bwsFor[walletid]) {
            try {
                delete config.bwsFor[walletid];
                this.logger.debug(`Removed bwsFor ${walletid}`);
                this.configCache = config;
                this.persistence.storeConfig(this.configCache).then(() => {
                    this.logger.info('Config saved');
                });
            }
            catch (_a) { }
        }
    }
    get() {
        return this.configCache;
    }
    getDefaults() {
        return this.configDefault;
    }
    backwardCompatibility() {
        this.logger.debug('Config: setting backwardCompatibility');
        // these ifs are to avoid migration problems
        if (this.configCache.bws) {
            this.configCache.bws = this.configDefault.bws;
        }
        if (!this.configCache.wallet) {
            this.configCache.wallet = this.configDefault.wallet;
        }
        if (!this.configCache.wallet.settings.unitCode) {
            this.configCache.wallet.settings.unitCode = this.configDefault.wallet.settings.unitCode;
        }
        if (!this.configCache.showIntegration) {
            this.configCache.showIntegration = this.configDefault.showIntegration;
        }
        else {
            if (this.configCache.showIntegration.giftcards !== false) {
                this.configCache.showIntegration.giftcards = this.configDefault.showIntegration.giftcards;
            }
            if (this.configCache.showIntegration.buycrypto !== false) {
                this.configCache.showIntegration.buycrypto = this.configDefault.showIntegration.buycrypto;
            }
            if (this.configCache.showIntegration.exchangecrypto !== false) {
                this.configCache.showIntegration.exchangecrypto = this.configDefault.showIntegration.exchangecrypto;
            }
            if (this.configCache.showIntegration.coinbase !== false) {
                this.configCache.showIntegration.coinbase = this.configDefault.showIntegration.coinbase;
            }
        }
        if (!this.configCache.pushNotifications) {
            this.configCache.pushNotifications = this.configDefault.pushNotifications;
        }
        if (!this.configCache.desktopNotifications) {
            this.configCache.desktopNotifications = this.configDefault.desktopNotifications;
        }
        if (!this.configCache.emailNotifications) {
            this.configCache.emailNotifications = this.configDefault.emailNotifications;
        }
        if (!this.configCache.lock) {
            this.configCache.lock = this.configDefault.lock;
        }
        if (!this.configCache.confirmedTxsNotifications) {
            this.configCache.confirmedTxsNotifications = this.configDefault.confirmedTxsNotifications;
        }
        if (this.configCache.wallet.settings.unitCode == 'bit') {
            // Convert to BTC. Bits will be disabled
            this.configCache.wallet.settings.unitName = this.configDefault.wallet.settings.unitName;
            this.configCache.wallet.settings.unitToSatoshi = this.configDefault.wallet.settings.unitToSatoshi;
            this.configCache.wallet.settings.unitDecimals = this.configDefault.wallet.settings.unitDecimals;
            this.configCache.wallet.settings.unitCode = this.configDefault.wallet.settings.unitCode;
        }
        if (!this.configCache.theme ||
            (this.configCache.theme && !this.configCache.theme.enabled)) {
            this.configCache.theme = this.configDefault.theme;
        }
        if (!this.configCache.totalBalance) {
            this.configCache.totalBalance = this.configDefault.totalBalance;
        }
        if (!this.configCache.legacyQrCode) {
            this.configCache.legacyQrCode = this.configDefault.legacyQrCode;
        }
    }
    reset() {
        this.persistence.clearConfig();
    }
};
ConfigProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__persistence_persistence__["b" /* PersistenceProvider */]])
], ConfigProvider);

//# sourceMappingURL=config.js.map

/***/ }),

/***/ 115:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

function format(message, args) {
  return message
    .replace('{0}', args[0])
    .replace('{1}', args[1])
    .replace('{2}', args[2]);
}
var traverseNode = function(parent, errorDefinition) {
  var NodeError = function() {
    if (_.isString(errorDefinition.message)) {
      this.message = format(errorDefinition.message, arguments);
    } else if (_.isFunction(errorDefinition.message)) {
      this.message = errorDefinition.message.apply(null, arguments);
    } else {
      throw new Error('Invalid error definition for ' + errorDefinition.name);
    }
    this.stack = this.message + '\n' + (new Error()).stack;
  };
  NodeError.prototype = Object.create(parent.prototype);
  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
  parent[errorDefinition.name] = NodeError;
  if (errorDefinition.errors) {
    childDefinitions(NodeError, errorDefinition.errors);
  }
  return NodeError;
};

/* jshint latedef: false */
var childDefinitions = function(parent, childDefinitions) {
  _.each(childDefinitions, function(childDefinition) {
    traverseNode(parent, childDefinition);
  });
};
/* jshint latedef: true */

var traverseRoot = function(parent, errorsDefinition) {
  childDefinitions(parent, errorsDefinition);
  return parent;
};


var bitcore = {};
bitcore.Error = function() {
  this.message = 'Internal error';
  this.stack = this.message + '\n' + (new Error()).stack;
};
bitcore.Error.prototype = Object.create(Error.prototype);
bitcore.Error.prototype.name = 'bitcore.Error';


var data = __webpack_require__(1493);
traverseRoot(bitcore.Error, data);

module.exports = bitcore.Error;

module.exports.extend = function(spec) {
  return traverseNode(bitcore.Error, spec);
};


/***/ }),

/***/ 116:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

function format(message, args) {
  return message
    .replace('{0}', args[0])
    .replace('{1}', args[1])
    .replace('{2}', args[2]);
}
var traverseNode = function(parent, errorDefinition) {
  var NodeError = function() {
    if (_.isString(errorDefinition.message)) {
      this.message = format(errorDefinition.message, arguments);
    } else if (_.isFunction(errorDefinition.message)) {
      this.message = errorDefinition.message.apply(null, arguments);
    } else {
      throw new Error('Invalid error definition for ' + errorDefinition.name);
    }
    this.stack = this.message + '\n' + (new Error()).stack;
  };
  NodeError.prototype = Object.create(parent.prototype);
  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
  parent[errorDefinition.name] = NodeError;
  if (errorDefinition.errors) {
    childDefinitions(NodeError, errorDefinition.errors);
  }
  return NodeError;
};

/* jshint latedef: false */
var childDefinitions = function(parent, childDefinitions) {
  _.each(childDefinitions, function(childDefinition) {
    traverseNode(parent, childDefinition);
  });
};
/* jshint latedef: true */

var traverseRoot = function(parent, errorsDefinition) {
  childDefinitions(parent, errorsDefinition);
  return parent;
};


var bitcore = {};
bitcore.Error = function() {
  this.message = 'Internal error';
  this.stack = this.message + '\n' + (new Error()).stack;
};
bitcore.Error.prototype = Object.create(Error.prototype);
bitcore.Error.prototype.name = 'bitcore.Error';


var data = __webpack_require__(1506);
traverseRoot(bitcore.Error, data);

module.exports = bitcore.Error;

module.exports.extend = function(spec) {
  return traverseNode(bitcore.Error, spec);
};


/***/ }),

/***/ 119:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplaceParametersProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/*
 * Example of use:
 * let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr: amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
 */



let ReplaceParametersProvider = class ReplaceParametersProvider {
    constructor() { }
    replace(stringToReplace, params) {
        let processedParams = [];
        for (let key in params) {
            processedParams.push({ key, value: params[key] });
        }
        processedParams.forEach(param => {
            stringToReplace = __WEBPACK_IMPORTED_MODULE_2_lodash__["replace"](stringToReplace, new RegExp('{{' + param.key + '}}', 'g'), param.value);
            stringToReplace = __WEBPACK_IMPORTED_MODULE_2_lodash__["replace"](stringToReplace, new RegExp('{{ ' + param.key + ' }}', 'g'), param.value);
        });
        return stringToReplace;
    }
};
ReplaceParametersProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], ReplaceParametersProvider);

//# sourceMappingURL=replace-parameters.js.map

/***/ }),

/***/ 126:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__in_app_browser_card__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__tkcoin_id_tkcoin_id__ = __webpack_require__(380);





// providers













let IncomingDataProvider = class IncomingDataProvider {
    constructor(actionSheetProvider, events, bwcProvider, currencyProvider, externalLinkProvider, payproProvider, logger, analyticsProvider, appProvider, translate, profileProvider, onGoingProcessProvider, iabCardProvider, persistenceProvider, tkcoinIdProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.events = events;
        this.bwcProvider = bwcProvider;
        this.currencyProvider = currencyProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.payproProvider = payproProvider;
        this.logger = logger;
        this.analyticsProvider = analyticsProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.profileProvider = profileProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.iabCardProvider = iabCardProvider;
        this.persistenceProvider = persistenceProvider;
        this.tkcoinIdProvider = tkcoinIdProvider;
        this.logger.debug('IncomingDataProvider initialized');
        this.events.subscribe('unlockInvoice', paymentUrl => this.handleUnlock(paymentUrl));
    }
    showMenu(data) {
        const dataMenu = this.actionSheetProvider.createIncomingDataMenu({ data });
        dataMenu.present();
        dataMenu.onDidDismiss(data => this.finishIncomingData(data));
    }
    finishIncomingData(data) {
        let nextView = {};
        if (data) {
            const stateParams = {
                addressbookEntry: data.redirTo == 'AddressbookAddPage' ? data.value : null,
                toAddress: data.redirTo == 'AmountPage' ? data.value : null,
                coin: data.coin ? data.coin : 'btc',
                privateKey: data.redirTo == 'PaperWalletPage' ? data.value : null
            };
            nextView = {
                name: data.redirTo,
                params: stateParams
            };
        }
        this.incomingDataRedir(nextView);
    }
    isValidPayPro(data) {
        data = this.sanitizeUri(data);
        return !!/^(bitcoin|bitcoincash|bchtest|ethereum|ripple|dogecoin)?:\?r=[\w+]/.exec(data);
    }
    isValidBitPayInvoice(data) {
        return !!/^https:\/\/(www.)?(test.|staging.)?bitpay.org\/i\/\w+/.exec(data);
    }
    isValidBitPayUri(data) {
        data = this.sanitizeUri(data);
        if (!(data && data.indexOf('bitpay:') === 0))
            return false;
        const address = this.extractAddress(data);
        if (!address)
            return false;
        let params = new URLSearchParams(data.replace(`bitpay:${address}`, ''));
        const coin = params.get('coin');
        if (!coin)
            return false;
        return true;
    }
    isValidBitcoinUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcore().URI.isValid(data);
    }
    isValidEducoinUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcoreEdu().URI.isValid(data);
    }
    isValidTKCoinUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcoreTik().URI.isValid(data);
    }
    isValidBitcoinCashUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcoreCash().URI.isValid(data);
    }
    isValidEthereumUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getCore().Validation.validateUri('ETH', data);
    }
    isValidRippleUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getCore().Validation.validateUri('XRP', data);
    }
    isValidDogecoinUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcoreDoge().URI.isValid(data);
    }
    isValidWalletConnectUri(data) {
        return !!/^(wc)?:/.exec(data);
    }
    isValidBitcoinCashUriWithLegacyAddress(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider
            .getBitcore()
            .URI.isValid(data.replace(/^(bitcoincash:|bchtest:)/, 'bitcoin:'));
    }
    isValidPlainUrl(data) {
        if (this.isValidBitPayInvoice(data)) {
            return false;
        }
        data = this.sanitizeUri(data);
        return !!/^https?:\/\//.test(data);
    }
    isValidBitcoinAddress(data) {
        return !!(this.bwcProvider.getBitcore().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcore().Address.isValid(data, 'testnet'));
    }
    isValidEducoinAddress(data) {
        return !!(this.bwcProvider.getBitcoreEdu().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreEdu().Address.isValid(data, 'testnet'));
    }
    isValidTKCoinAddress(data) {
        return !!(this.bwcProvider.getBitcoreTik().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreTik().Address.isValid(data, 'testnet'));
    }
    isValidBitcoinCashLegacyAddress(data) {
        return !!(this.bwcProvider.getBitcore().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcore().Address.isValid(data, 'testnet'));
    }
    isValidBitcoinCashAddress(data) {
        return !!(this.bwcProvider.getBitcoreCash().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreCash().Address.isValid(data, 'testnet'));
    }
    isValidEthereumAddress(data) {
        return !!this.bwcProvider
            .getCore()
            .Validation.validateAddress('ETH', 'livenet', data);
    }
    isValidRippleAddress(data) {
        return !!this.bwcProvider
            .getCore()
            .Validation.validateAddress('XRP', 'livenet', data);
    }
    isValidDogecoinAddress(data) {
        return !!(this.bwcProvider.getBitcoreDoge().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreDoge().Address.isValid(data, 'testnet'));
    }
    isValidCoinbaseUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf(this.appProvider.info.name + '://coinbase') === 0);
    }
    isValidSimplexUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf(this.appProvider.info.name + '://simplex') === 0);
    }
    isValidWyreUri(data) {
        data = this.sanitizeUri(data);
        return !!(data &&
            (data.indexOf(this.appProvider.info.name + '://wyre') === 0 ||
                data.indexOf(this.appProvider.info.name + '://wyreError') === 0));
    }
    isValidInvoiceUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf(this.appProvider.info.name + '://invoice') === 0);
    }
    isValidBitPayCardUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf('bitpay://bitpay') === 0);
    }
    isValidBitPayRedirLink(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf('bitpay://landing') === 0);
    }
    isValidBitPayDynamicLink(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf('com.bitpay.wallet://google/link') === 0);
    }
    isValidJoinCode(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.match(/^copay:[0-9A-HJ-NP-Za-km-z]{70,80}$/));
    }
    isValidJoinLegacyCode(data) {
        return !!(data && data.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/));
    }
    isValidPrivateKey(data) {
        return !!(data &&
            (data.substring(0, 2) == '6P' || this.checkPrivateKey(data)));
    }
    isValidImportPrivateKey(data) {
        return !!(data &&
            (data.substring(0, 2) == '1|' ||
                data.substring(0, 2) == '2|' ||
                data.substring(0, 2) == '3|'));
    }
    handlePrivateKey(data, redirParams) {
        this.logger.debug('Incoming-data: private key');
        this.showMenu({
            data,
            type: 'privateKey',
            fromHomeCard: redirParams ? redirParams.fromHomeCard : false
        });
    }
    handlePayProNonBackwardsCompatible(data) {
        this.logger.debug('Incoming-data: Payment Protocol with non-backwards-compatible request');
        const url = this.getPayProUrl(data);
        this.handleBitPayInvoice(url);
    }
    handleBitPayInvoice(invoiceUrl) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.debug('Incoming-data: Handling bitpay invoice');
            try {
                const disableLoader = true;
                const payProOptions = yield this.payproProvider.getPayProOptions(invoiceUrl);
                const selected = payProOptions.paymentOptions.filter(option => option.selected);
                if (selected.length === 1) {
                    // Confirm Page - selectedTransactionCurrency set to selected
                    const [{ currency }] = selected;
                    return this.goToPayPro(invoiceUrl, currency.toLowerCase(), payProOptions, disableLoader);
                }
                else {
                    // Select Invoice Currency - No selectedTransactionCurrency set
                    let hasWallets = {};
                    let availableWallets = [];
                    for (const option of payProOptions.paymentOptions) {
                        const fundedWallets = this.profileProvider.getWallets({
                            coin: option.currency.toLowerCase(),
                            network: option.network,
                            minAmount: option.estimatedAmount
                        });
                        if (fundedWallets.length === 0) {
                            option.disabled = true;
                        }
                        else {
                            hasWallets[option.currency.toLowerCase()] = fundedWallets.length;
                            availableWallets.push(option);
                        }
                    }
                    if (availableWallets.length === 1) {
                        // Only one available wallet with balance
                        const [{ currency }] = availableWallets;
                        return this.goToPayPro(invoiceUrl, currency.toLowerCase(), payProOptions, disableLoader);
                    }
                    const stateParams = {
                        payProOptions,
                        hasWallets
                    };
                    let nextView = {
                        name: 'SelectInvoicePage',
                        params: stateParams
                    };
                    this.incomingDataRedir(nextView);
                }
            }
            catch (err) {
                this.onGoingProcessProvider.clear();
                this.events.publish('incomingDataError', err);
                this.logger.error(err);
            }
        });
    }
    handleDynamicLink(deepLink) {
        this.logger.debug('Incoming-data: Dynamic Link ' + deepLink);
        this.persistenceProvider.setDynamicLink(deepLink);
    }
    handleBitPayUri(data, redirParams) {
        this.logger.debug('Incoming-data: BitPay URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const address = this.extractAddress(data);
        let params = new URLSearchParams(data.replace(`bitpay:${address}`, ''));
        let amount = params.get('amount') || amountFromRedirParams;
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */][params.get('coin').toUpperCase()];
        const message = params.get('message');
        const requiredFeeParam = params.get('gasPrice');
        if (amount) {
            const { unitToSatoshi } = this.currencyProvider.getPrecision(coin);
            amount = parseInt((Number(amount) * unitToSatoshi).toFixed(0), 10).toString();
            this.goSend(address, amount, message, coin, requiredFeeParam);
        }
        else {
            this.goToAmountPage(address, coin);
        }
    }
    handleBitcoinUri(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].BTC;
        let parsed = this.bwcProvider.getBitcore().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    handleEducoinUri(data, redirParams) {
        this.logger.debug('Incoming-data: Educoin URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].EDU;
        let parsed = this.bwcProvider.getBitcoreEdu().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    handleTKCoinUri(data, redirParams) {
        this.logger.debug('Incoming-data: TKCoin URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].TIK;
        let parsed = this.bwcProvider.getBitcoreTik().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    handleBitcoinCashUri(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin Cash URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].BCH;
        let parsed = this.bwcProvider.getBitcoreCash().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        // keep address in original format
        if (parsed.address && data.indexOf(address) < 0) {
            address = parsed.address.toCashAddress();
        }
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    handleEthereumUri(data, redirParams) {
        this.logger.debug('Incoming-data: Ethereum URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].ETH;
        const value = /[\?\&]value=(\d+([\,\.]\d+)?)/i;
        const gasPrice = /[\?\&]gasPrice=(\d+([\,\.]\d+)?)/i;
        let parsedAmount;
        let requiredFeeParam;
        if (value.exec(data)) {
            parsedAmount = value.exec(data)[1];
        }
        if (gasPrice.exec(data)) {
            requiredFeeParam = gasPrice.exec(data)[1];
        }
        const address = this.extractAddress(data);
        const message = '';
        const amount = parsedAmount || amountFromRedirParams;
        if (amount) {
            this.goSend(address, amount, message, coin, requiredFeeParam);
        }
        else {
            this.handleEthereumAddress(address, redirParams);
        }
    }
    handleRippleUri(data, redirParams) {
        this.logger.debug('Incoming-data: Ripple URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].XRP;
        const amountParam = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
        const tagParam = /[\?\&]dt=(\d+([\,\.]\d+)?)/i;
        let parsedAmount;
        let destinationTag;
        let requiredFeeRate;
        if (amountParam.exec(data)) {
            const { unitToSatoshi } = this.currencyProvider.getPrecision(coin);
            parsedAmount = (Number(amountParam.exec(data)[1]) * unitToSatoshi).toString();
        }
        if (tagParam.exec(data)) {
            destinationTag = tagParam.exec(data)[1];
        }
        const address = this.extractAddress(data);
        const message = '';
        const amount = parsedAmount || amountFromRedirParams;
        if (amount) {
            this.goSend(address, amount, message, coin, requiredFeeRate, destinationTag);
        }
        else {
            this.handleRippleAddress(address, redirParams);
        }
    }
    handleDogecoinUri(data, redirParams) {
        this.logger.debug('Incoming-data: Dogecoin URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].DOGE;
        let parsed = this.bwcProvider.getBitcoreDoge().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    handleWalletConnectUri(uri) {
        // Disable Wallet Connect
        if (!this.appProvider.info._enabledExtensions.walletConnect) {
            this.logger.warn('Wallet Connect has been disabled for this build');
            return;
        }
        let stateParams = {
            uri
        };
        let nextView = {
            name: 'WalletConnectPage',
            params: stateParams
        };
        this.analyticsProvider.logEvent('wallet_connect_camera_scan_attempt', {});
        this.incomingDataRedir(nextView);
    }
    handleBitcoinCashUriLegacyAddress(data) {
        this.logger.debug('Incoming-data: Bitcoin Cash URI with legacy address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].BCH;
        let parsed = this.bwcProvider
            .getBitcore()
            .URI(data.replace(/^(bitcoincash:|bchtest:)/, 'bitcoin:'));
        let oldAddr = parsed.address ? parsed.address.toString() : '';
        if (!oldAddr)
            this.logger.error('Could not parse Bitcoin Cash legacy address');
        let a = this.bwcProvider.getBitcore().Address(oldAddr).toObject();
        let address = this.bwcProvider
            .getBitcoreCash()
            .Address.fromObject(a)
            .toString();
        let message = parsed.message;
        let amount = parsed.amount ? parsed.amount : '';
        // Translate address
        this.logger.warn('Legacy Bitcoin Address translated to: ' + address);
        if (parsed.r) {
            const payProUrl = this.getPayProUrl(parsed.r);
            this.goToPayPro(payProUrl, coin);
        }
        else
            this.goSend(address, amount, message, coin);
    }
    // Deprecated
    handlePlainUrl(data) {
        this.logger.debug('Incoming-data: Plain URL', data);
        // No process Plain URL anymore
        // data = this.sanitizeUri(data);
        // this.showMenu({
        //  data,
        //  type: 'url'
        // });
    }
    handlePlainBitcoinAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].BTC;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'bitcoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handlePlainEducoinAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Educoin plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].EDU;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'educoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handlePlainTKCoinAddress(data, redirParams) {
        this.logger.debug('Incoming-data: TKCoin plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].TIK;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'tkcoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handlePlainBitcoinCashAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin Cash plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].BCH;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'bitcoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handleEthereumAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Ethereum address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].ETH;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'ethereumAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handleRippleAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Ripple address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].XRP;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'rippleAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handlePlainDogecoinAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Dogecoin plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_9__currency_currency__["a" /* Coin */].DOGE;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'dogecoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    goToImportByPrivateKey(data) {
        this.logger.debug('Incoming-data (redirect): QR code export feature');
        let stateParams = { code: data };
        let nextView = {
            name: 'ImportWalletPage',
            params: stateParams
        };
        this.incomingDataRedir(nextView);
    }
    goToJoinWallet(data) {
        this.logger.debug('Incoming-data (redirect): Code to join to a wallet');
        let nextView, stateParams;
        const opts = {
            showHidden: true,
            canAddNewAccount: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        const nrKeys = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](__WEBPACK_IMPORTED_MODULE_4_lodash__["groupBy"](wallets, 'keyId')).length;
        if (nrKeys === 0) {
            stateParams = { url: data };
            nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
        }
        else if (nrKeys != 1) {
            stateParams = { url: data, isJoin: true };
            nextView = {
                name: 'AddWalletPage',
                params: stateParams
            };
        }
        else if (nrKeys === 1) {
            stateParams = { keyId: wallets[0].credentials.keyId, url: data };
            nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
        }
        if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            this.incomingDataRedir(nextView);
        }
        else {
            this.logger.error('Incoming-data: Invalid code to join to a wallet');
        }
    }
    // private goToBitPayCard(data: string): void {
    //   this.logger.debug('Incoming-data (redirect): BitPay Card URL');
    //
    //   // Disable BitPay Card
    //   if (!this.appProvider.info._enabledExtensions.debitcard) {
    //     this.logger.warn('BitPay Card has been disabled for this build');
    //     return;
    //   }
    //
    //   let secret = this.getParameterByName('secret', data);
    //   let email = this.getParameterByName('email', data);
    //   let otp = this.getParameterByName('otp', data);
    //   let reason = this.getParameterByName('r', data);
    //   switch (reason) {
    //     default:
    //     case '0':
    //       /* For BitPay card binding */
    //       let stateParams = { secret, email, otp };
    //       let nextView = {
    //         name: 'BitPayCardIntroPage',
    //         params: stateParams
    //       };
    //       this.incomingDataRedir(nextView);
    //       break;
    //   }
    // }
    goToBitPayRedir(data) {
        this.logger.debug('Incoming-data (redirect): BitPay Redir');
        const redir = data.replace('bitpay://landing/', '');
        switch (redir) {
            default:
            case 'card':
                // Disable BitPay Card
                if (!this.appProvider.info._enabledExtensions.debitcard) {
                    this.logger.warn('BitPay Card has been disabled for this build');
                    return;
                }
                const nextView = {
                    name: 'PhaseOneCardIntro'
                };
                this.incomingDataRedir(nextView);
                break;
        }
    }
    goToCoinbase(data) {
        this.logger.debug('Incoming-data (redirect): Coinbase URL');
        let code = this.getParameterByName('code', data);
        let stateParams = { code };
        let nextView = {
            name: 'CoinbasePage',
            params: stateParams
        };
        this.incomingDataRedir(nextView);
    }
    goToSimplex(data) {
        this.logger.debug('Incoming-data (redirect): Simplex URL: ' + data);
        const res = data.replace(new RegExp('&amp;', 'g'), '&');
        const success = this.getParameterByName('success', res);
        const paymentId = this.getParameterByName('paymentId', res);
        const quoteId = this.getParameterByName('quoteId', res);
        const userId = this.getParameterByName('userId', res);
        const stateParams = { success, paymentId, quoteId, userId };
        const nextView = {
            name: 'SimplexPage',
            params: stateParams
        };
        this.incomingDataRedir(nextView);
    }
    goToWyre(data) {
        this.logger.debug('Incoming-data (redirect): Wyre URL: ' + data);
        if (data.indexOf(this.appProvider.info.name + '://wyreError') >= 0) {
            const infoSheet = this.actionSheetProvider.createInfoSheet('wyre-error');
            infoSheet.present();
            infoSheet.onDidDismiss(option => {
                if (option) {
                    this.openExternalLink('https://wyre-support.zendesk.com/hc/en-us/requests/new');
                }
            });
            return;
        }
        if (data === this.appProvider.info.name + '://wyre')
            return;
        const res = data.replace(new RegExp('&amp;', 'g'), '&');
        const transferId = this.getParameterByName('transferId', res);
        const walletId = this.getParameterByName('walletId', res);
        const owner = this.getParameterByName('owner', res);
        const orderId = this.getParameterByName('id', res);
        const accountId = this.getParameterByName('accountId', res);
        const dest = this.getParameterByName('dest', res);
        const destAmount = this.getParameterByName('destAmount', res);
        const destCurrency = this.getParameterByName('destCurrency', res);
        const purchaseAmount = this.getParameterByName('purchaseAmount', res);
        const sourceAmount = this.getParameterByName('sourceAmount', res);
        const sourceCurrency = this.getParameterByName('sourceCurrency', res);
        const status = this.getParameterByName('status', res);
        const createdAt = this.getParameterByName('createdAt', res);
        const paymentMethodName = this.getParameterByName('paymentMethodName', res);
        const blockchainNetworkTx = this.getParameterByName('blockchainNetworkTx', res);
        if (!orderId) {
            this.logger.debug('No orderId present. Do not redir');
            return;
        }
        const stateParams = {
            transferId,
            walletId,
            owner,
            orderId,
            accountId,
            dest,
            destAmount,
            destCurrency,
            purchaseAmount,
            sourceAmount,
            sourceCurrency,
            status,
            createdAt,
            paymentMethodName,
            blockchainNetworkTx
        };
        const nextView = {
            name: 'WyrePage',
            params: stateParams
        };
        this.incomingDataRedir(nextView);
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    goToInvoice(data) {
        this.logger.debug('Incoming-data (redirect): Invoice URL');
        const invoiceUrl = this.getParameterByName('url', data);
        this.redir(invoiceUrl);
    }
    openIAB(message) {
        this.iabCardProvider.hasFirstView().then(() => {
            this.iabCardProvider.show();
            this.iabCardProvider.sendMessage({
                message
            });
        });
    }
    redir(data, redirParams) {
        if (redirParams && redirParams.activePage)
            this.activePage = redirParams.activePage;
        //  Handling of a bitpay invoice url
        if (this.isValidBitPayInvoice(data)) {
            this.handleBitPayInvoice(data);
            return true;
        }
        else if (data.includes('unlock')) {
            this.handleUnlock(data);
            return true;
            // Payment Protocol
        }
        else if (this.isValidPayPro(data)) {
            this.handlePayProNonBackwardsCompatible(data);
            return true;
            // Bitcoin  URI
        }
        else if (this.isValidBitcoinUri(data)) {
            this.handleBitcoinUri(data, redirParams);
            return true;
            // Educoin URI
        }
        else if (this.isValidEducoinUri(data)) {
            this.handleEducoinUri(data, redirParams);
            return true;
            // TKCoin URI
        }
        else if (this.isValidTKCoinUri(data)) {
            this.handleTKCoinUri(data, redirParams);
            return true;
            // Bitcoin Cash URI
        }
        else if (this.isValidBitcoinCashUri(data)) {
            this.handleBitcoinCashUri(data, redirParams);
            return true;
            // Ethereum URI
        }
        else if (this.isValidEthereumUri(data)) {
            this.handleEthereumUri(data, redirParams);
            return true;
            // Ripple URI
        }
        else if (this.isValidRippleUri(data)) {
            this.handleRippleUri(data, redirParams);
            return true;
            // Dogecoin URI
        }
        else if (this.isValidDogecoinUri(data)) {
            this.handleDogecoinUri(data, redirParams);
            return true;
            // Wallet Connect URI
        }
        else if (this.isValidWalletConnectUri(data)) {
            this.handleWalletConnectUri(data);
            return true;
            // Bitcoin Cash URI using Bitcoin Core legacy address
        }
        else if (this.isValidBitcoinCashUriWithLegacyAddress(data)) {
            this.handleBitcoinCashUriLegacyAddress(data);
            return true;
            // Plain URL
        }
        else if (this.isValidPlainUrl(data)) {
            this.handlePlainUrl(data);
            return true;
            // Plain Address (Bitcoin)
        }
        else if (this.isValidBitcoinAddress(data)) {
            this.handlePlainBitcoinAddress(data, redirParams);
            return true;
            // Plain Address (Educoin)
        }
        else if (this.isValidEducoinAddress(data)) {
            this.handlePlainEducoinAddress(data, redirParams);
            return true;
            // Plain Address (TKCoin)
        }
        else if (this.isValidTKCoinAddress(data)) {
            this.handlePlainTKCoinAddress(data, redirParams);
            return true;
            // Plain Address (Bitcoin Cash)
        }
        else if (this.isValidBitcoinCashAddress(data)) {
            this.handlePlainBitcoinCashAddress(data, redirParams);
            return true;
            // Address (Ethereum)
        }
        else if (this.isValidEthereumAddress(data)) {
            this.handleEthereumAddress(data, redirParams);
            return true;
            // Address (Ripple)
        }
        else if (this.isValidRippleAddress(data)) {
            this.handleRippleAddress(data, redirParams);
            return true;
            // Plain Address (Doge)
        }
        else if (this.isValidDogecoinAddress(data)) {
            this.handlePlainDogecoinAddress(data, redirParams);
            return true;
            // Coinbase
        }
        else if (this.isValidCoinbaseUri(data)) {
            this.goToCoinbase(data);
            return true;
            // Simplex
        }
        else if (this.isValidSimplexUri(data)) {
            this.goToSimplex(data);
            return true;
            // Wyre
        }
        else if (this.isValidWyreUri(data)) {
            this.goToWyre(data);
            return true;
            // Invoice Intent
        }
        else if (this.isValidInvoiceUri(data)) {
            this.goToInvoice(data);
            return true;
            // BitPay Redir Link
        }
        else if (this.isValidBitPayRedirLink(data)) {
            this.goToBitPayRedir(data);
            return true;
            // BitPayCard Authentication
        }
        else if (this.isValidBitPayCardUri(data)) {
            // this.goToBitPayCard(data);
            return true;
            // BitPay URI
        }
        else if (this.isValidBitPayUri(data)) {
            this.handleBitPayUri(data);
            return true;
            // Join
        }
        else if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            this.goToJoinWallet(data);
            return true;
            // Check Private Key
        }
        else if (this.isValidPrivateKey(data)) {
            this.handlePrivateKey(data, redirParams);
            return true;
            // Import Private Key
        }
        else if (this.isValidImportPrivateKey(data)) {
            this.goToImportByPrivateKey(data);
            return true;
        }
        else if (data.includes('wallet-card')) {
            const event = data.split('wallet-card/')[1];
            const [switchExp, payload] = (event || '').split('?');
            /*
             *
             * handler for wallet-card events
             *
             * leaving this as a switch in case events become complex and require wallet side and iab actions
             *
             * */
            switch (switchExp) {
                case 'pairing':
                    const secret = payload.split('=')[1].split('&')[0];
                    const params = {
                        secret,
                        withNotification: true
                    };
                    if (payload.includes('&code=')) {
                        params['code'] = payload.split('&code=')[1];
                    }
                    if (payload.includes('dashboardRedirect')) {
                        params['dashboardRedirect'] = true;
                    }
                    this.iabCardProvider.pairing({ data: { params } });
                    // this param is set if pairing for the first time after an order
                    if (payload.includes('fb=orderComplete')) {
                        this.persistenceProvider.getNetwork().then(network => {
                            if (network === 'livenet') {
                                this.analyticsProvider.logEvent('Card_application_Success', {});
                            }
                        });
                    }
                    break;
                case 'order-now':
                    this.persistenceProvider.setCardExperimentFlag('enabled');
                    this.events.publish('experimentUpdateStart');
                    setTimeout(() => {
                        this.events.publish('experimentUpdateComplete');
                    }, 300);
                    break;
                case 'email-verified':
                    this.openIAB('emailVerified');
                    break;
                case 'get-started':
                    this.openIAB('orderCard');
                    break;
                case 'retry':
                    this.openIAB('retry');
                    break;
                case 'debit-card-order':
                    this.openIAB('debitCardOrder');
                    this.persistenceProvider.setCardExperimentFlag('enabled');
                    this.events.publish('experimentUpdateStart');
                    setTimeout(() => {
                        this.events.publish('experimentUpdateComplete');
                    }, 300);
            }
            return true;
            // Anything else
        }
        else if (this.isValidBitPayDynamicLink(data)) {
            const deepLink = this.getParameterByName('deep_link_id', data);
            this.handleDynamicLink(deepLink);
            return true;
        }
        else {
            if (redirParams && redirParams.activePage === 'ScanPage') {
                this.logger.debug('Incoming-data: Plain text');
                this.showMenu({
                    data,
                    type: 'text'
                });
                return true;
            }
            else {
                this.logger.warn('Incoming-data: Unknown information');
                return false;
            }
        }
    }
    parseData(data) {
        if (!data)
            return;
        if (this.isValidBitPayInvoice(data)) {
            return {
                data,
                type: 'InvoiceUri',
                title: 'Invoice URL'
            };
        }
        else if (this.isValidPayPro(data)) {
            return {
                data,
                type: 'PayPro',
                title: 'Payment URL'
            };
            // Bitcoin URI
        }
        else if (this.isValidBitcoinUri(data)) {
            return {
                data,
                type: 'BitcoinUri',
                title: 'Bitcoin URI'
            };
            // Educoin URI
        }
        else if (this.isValidEducoinUri(data)) {
            return {
                data,
                type: 'EducoinUri',
                title: 'Educoin URI'
            };
            // TKCoin URI
        }
        else if (this.isValidTKCoinUri(data)) {
            return {
                data,
                type: 'TKCoinUri',
                title: 'TKCoin URI'
            };
            // Bitcoin Cash URI
        }
        else if (this.isValidBitcoinCashUri(data)) {
            return {
                data,
                type: 'BitcoinCashUri',
                title: 'Bitcoin Cash URI'
            };
            // Ethereum URI
        }
        else if (this.isValidEthereumUri(data)) {
            return {
                data,
                type: 'EthereumUri',
                title: 'Ethereum URI'
            };
            // Ripple URI
        }
        else if (this.isValidRippleUri(data)) {
            return {
                data,
                type: 'RippleUri',
                title: 'Ripple URI'
            };
            // Dogecoin URI
        }
        else if (this.isValidDogecoinUri(data)) {
            return {
                data,
                type: 'DogecoinUri',
                title: 'Dogecoin URI'
            };
            // Wallet Connect URI
        }
        else if (this.isValidWalletConnectUri(data)) {
            return {
                data,
                type: 'WalletConnectUri',
                title: 'WalletConnect URI'
            };
            // Bitcoin Cash URI using Bitcoin Core legacy address
        }
        else if (this.isValidBitcoinCashUriWithLegacyAddress(data)) {
            return {
                data,
                type: 'BitcoinCashUri',
                title: 'Bitcoin Cash URI'
            };
            // Plain URL
        }
        else if (this.isValidPlainUrl(data)) {
            return {
                data,
                type: 'PlainUrl',
                title: 'Plain URL'
            };
            // Plain Address (Bitcoin)
        }
        else if (this.isValidBitcoinAddress(data)) {
            return {
                data,
                type: 'BitcoinAddress',
                title: this.translate.instant('Bitcoin Address')
            };
            // Plain Address (Educoin)
        }
        else if (this.isValidEducoinAddress(data)) {
            return {
                data,
                type: 'EducoinAddress',
                title: this.translate.instant('Educoin Address')
            };
            // Plain Address (TKCoin)
        }
        else if (this.isValidTKCoinAddress(data)) {
            return {
                data,
                type: 'TKCoinAddress',
                title: this.translate.instant('TKCoin Address')
            };
            // Plain Address (Bitcoin Cash)
        }
        else if (this.isValidBitcoinCashAddress(data)) {
            return {
                data,
                type: 'BitcoinCashAddress',
                title: this.translate.instant('Bitcoin Cash Address')
            };
            // Plain Address (Ethereum)
        }
        else if (this.isValidEthereumAddress(data)) {
            return {
                data,
                type: 'EthereumAddress',
                title: this.translate.instant('Ethereum Address')
            };
            // Plain Address (Ripple)
        }
        else if (this.isValidRippleAddress(data)) {
            return {
                data,
                type: 'RippleAddress',
                title: this.translate.instant('XRP Address')
            };
            // Plain Address (Dogecoin)
        }
        else if (this.isValidDogecoinAddress(data)) {
            return {
                data,
                type: 'DogecoinAddress',
                title: this.translate.instant('Doge Address')
            };
            // Coinbase
        }
        else if (this.isValidCoinbaseUri(data)) {
            return {
                data,
                type: 'Coinbase',
                title: 'Coinbase URI'
            };
            // BitPayCard Authentication
        }
        else if (this.isValidBitPayCardUri(data)) {
            return {
                data,
                type: 'BitPayCard',
                title: 'BitPay Card URI'
            };
            // BitPay  URI
        }
        else if (this.isValidBitPayUri(data)) {
            return {
                data,
                type: 'BitPayUri',
                title: 'BitPay URI'
            };
            // Join
        }
        else if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            return {
                data,
                type: 'JoinWallet',
                title: this.translate.instant('Invitation Code')
            };
            // Check Private Key
        }
        else if (this.isValidPrivateKey(data)) {
            return {
                data,
                type: 'PrivateKey',
                title: this.translate.instant('Private Key')
            };
            // Import Private Key
        }
        else if (this.isValidImportPrivateKey(data)) {
            return {
                data,
                type: 'ImportPrivateKey',
                title: this.translate.instant('Import Words')
            };
            // Anything else
        }
        else {
            return;
        }
    }
    extractAddress(data) {
        const address = data.replace(/^[a-z]+:/i, '').replace(/\?.*/, '');
        const params = /([\?\&]+[a-z]+=(\d+([\,\.]\d+)?))+/i;
        return address.replace(params, '');
    }
    sanitizeUri(data) {
        // Fixes when a region uses comma to separate decimals
        let regex = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
        let match = regex.exec(data);
        if (!match || match.length === 0) {
            return data;
        }
        let value = match[0].replace(',', '.');
        let newUri = data.replace(regex, value);
        // mobile devices, uris like copay://xxx
        newUri.replace('://', ':');
        return newUri;
    }
    getPayProUrl(data) {
        return decodeURIComponent(data.replace(/(bitcoin|bitcoincash|ethereum|ripple|dogecoin)?:\?r=/, ''));
    }
    getParameterByName(name, url) {
        if (!url)
            return undefined;
        name = name.replace(/[\[\]]/g, '\\$&');
        let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);
        if (!results)
            return null;
        if (!results[2])
            return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }
    checkPrivateKey(privateKey) {
        // Check if it is a Transaction id to prevent errors
        let isPK = this.checkRegex(privateKey);
        if (!isPK)
            return false;
        try {
            this.bwcProvider.getBitcore().PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    checkRegex(data) {
        let PKregex = new RegExp(/^[5KL][1-9A-HJ-NP-Za-km-z]{50,51}$/);
        return !!PKregex.exec(data);
    }
    goSend(addr, amount, message, coin, requiredFeeRate, destinationTag) {
        if (amount) {
            let stateParams = {
                amount,
                toAddress: addr,
                description: message,
                coin,
                requiredFeeRate,
                destinationTag
            };
            let nextView = {
                name: 'ConfirmPage',
                params: stateParams
            };
            this.incomingDataRedir(nextView);
        }
        else {
            let stateParams = {
                toAddress: addr,
                description: message,
                coin
            };
            let nextView = {
                name: 'AmountPage',
                params: stateParams
            };
            this.incomingDataRedir(nextView);
        }
    }
    goToAmountPage(toAddress, coin) {
        let stateParams = {
            toAddress,
            coin
        };
        let nextView = {
            name: 'AmountPage',
            params: stateParams
        };
        this.incomingDataRedir(nextView);
    }
    goToPayPro(url, coin, payProOptions, disableLoader, activePage) {
        if (activePage)
            this.activePage = activePage;
        this.payproProvider
            .getPayProDetails({ paymentUrl: url, coin, disableLoader })
            .then(details => {
            this.onGoingProcessProvider.clear();
            this.handlePayPro(details, payProOptions, url, coin);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.events.publish('incomingDataError', err);
            this.logger.error(err);
        });
    }
    handlePayPro(payProDetails, payProOptions, url, coin) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!payProDetails) {
                this.logger.error('No wallets available');
                const error = this.translate.instant('No wallets available');
                this.events.publish('incomingDataError', error);
                return;
            }
            let invoiceID;
            let requiredFeeRate;
            if (payProDetails.requiredFeeRate) {
                requiredFeeRate = !this.currencyProvider.isUtxoCoin(coin)
                    ? payProDetails.requiredFeeRate
                    : Math.ceil(payProDetails.requiredFeeRate * 1000);
            }
            try {
                const { memo, network } = payProDetails;
                if (!payProOptions) {
                    payProOptions = yield this.payproProvider.getPayProOptions(url);
                }
                const paymentOptions = payProOptions.paymentOptions;
                const { estimatedAmount, minerFee } = paymentOptions.find(option => option.currency.toLowerCase() === coin);
                const instructions = payProDetails.instructions[0];
                const { outputs, toAddress, data } = instructions;
                if (coin === 'xrp' && outputs) {
                    invoiceID = outputs[0].invoiceID;
                }
                const stateParams = {
                    amount: estimatedAmount,
                    toAddress,
                    description: memo,
                    data,
                    invoiceID,
                    paypro: payProDetails,
                    coin,
                    network,
                    payProUrl: url,
                    requiredFeeRate,
                    minerFee // needed for payments with Coinbase accounts
                };
                const nextView = {
                    name: 'ConfirmPage',
                    params: stateParams
                };
                this.incomingDataRedir(nextView);
            }
            catch (err) {
                this.events.publish('incomingDataError', err);
                this.logger.error(err);
            }
        });
    }
    incomingDataRedir(nextView) {
        if (this.activePage === 'SendPage') {
            this.events.publish('SendPageRedir', nextView);
        }
        else {
            this.events.publish('IncomingDataRedir', nextView);
        }
    }
    handleUnlock(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                const url = data.split('?')[1];
                const invoiceId = url.split('i/')[1];
                const result = yield this.tkcoinIdProvider.unlockInvoice(invoiceId);
                switch (result) {
                    case 'unlockSuccess':
                        yield this.handleBitPayInvoice(`unlock:?${url}`);
                        break;
                    // call IAB and attempt pairing
                    case 'pairingRequired':
                        const authRequiredInfoSheet = this.actionSheetProvider.createInfoSheet('auth-required');
                        yield authRequiredInfoSheet.present();
                        authRequiredInfoSheet.onDidDismiss(() => {
                            this.iabCardProvider.show();
                            setTimeout(() => {
                                this.iabCardProvider.sendMessage({
                                    message: 'pairingOnly',
                                    payload: { paymentUrl: data }
                                }, () => { });
                            }, 100);
                        });
                        break;
                    // needs verification - send to bitpay id verify
                    case 'userShopperNotFound':
                    case 'tierNotMet':
                        const verificationRequiredInfoSheet = this.actionSheetProvider.createInfoSheet('auth-required');
                        yield verificationRequiredInfoSheet.present();
                        verificationRequiredInfoSheet.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                            const host = url.includes('test')
                                ? 'test.tkcoin.org'
                                : 'tkcoin.org';
                            yield this.externalLinkProvider.open(`https://${host}/id/verify?context=unlockv&id=${invoiceId}`);
                        }));
                }
            }
            catch (err) {
                this.logger.error(err);
                yield this.actionSheetProvider
                    .createInfoSheet('default-error', {
                    msg: this.translate.instant('Uh oh something went wrong! Please try again later.'),
                    title: this.translate.instant('Error')
                })
                    .present();
            }
        });
    }
};
IncomingDataProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_9__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_10__external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_14__paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_12__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_16__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_13__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_11__in_app_browser_card__["a" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_15__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_17__tkcoin_id_tkcoin_id__["a" /* TKCoinIdProvider */]])
], IncomingDataProvider);

//# sourceMappingURL=incoming-data.js.map

/***/ }),

/***/ 129:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__environments__ = __webpack_require__(170);




// providers







let ScanPage = class ScanPage {
    constructor(navCtrl, scanProvider, platformProvider, incomingDataProvider, events, logger, translate, navParams, platform, errorsProvider, bwcErrorProvider) {
        this.navCtrl = navCtrl;
        this.scanProvider = scanProvider;
        this.platformProvider = platformProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.events = events;
        this.logger = logger;
        this.translate = translate;
        this.navParams = navParams;
        this.platform = platform;
        this.errorsProvider = errorsProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.incomingDataErrorHandler = err => {
            this.showErrorInfoSheet(err);
        };
        this.scannerServiceInitializedHandler = () => {
            this.logger.debug('Scanner initialization finished, reinitializing scan view...');
            this._refreshScanView();
        };
        this.isCameraSelected = false;
        this.browserScanEnabled = false;
        this.canEnableLight = true;
        this.canChangeCamera = true;
        this.scannerStates = {
            unauthorized: 'unauthorized',
            denied: 'denied',
            unavailable: 'unavailable',
            loading: 'loading',
            visible: 'visible'
        };
        this.scannerIsAvailable = true;
        this.scannerHasPermission = false;
        this.scannerIsDenied = false;
        this.scannerIsRestricted = false;
        this.canOpenSettings = false;
        this.isCordova = this.platformProvider.isCordova;
        this.tabBarElement = document.querySelector('.tabbar.show-tabbar');
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ScanPage');
        this.navCtrl.swipeBackEnabled = false;
        this.canGoBack = this.navCtrl.canGoBack();
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
        this.events.unsubscribe('incomingDataError', this.incomingDataErrorHandler);
        this.events.unsubscribe('scannerServiceInitialized', this.scannerServiceInitializedHandler);
        this.cameraToggleActive = false;
        this.lightActive = false;
        this.scanProvider.frontCameraEnabled = false;
        this.scanProvider.deactivate();
        this.unregisterBackButtonAction && this.unregisterBackButtonAction();
        this.tabBarElement.style.display = 'flex';
    }
    ionViewWillEnter() {
        this.initializeBackButtonHandler();
        this.fromAddressbook = this.navParams.data.fromAddressbook;
        this.fromImport = this.navParams.data.fromImport;
        this.fromJoin = this.navParams.data.fromJoin;
        this.fromSend = this.navParams.data.fromSend;
        this.fromMultiSend = this.navParams.data.fromMultiSend;
        this.fromSelectInputs = this.navParams.data.fromSelectInputs;
        this.fromEthMultisig = this.navParams.data.fromEthMultisig;
        this.fromConfirm = this.navParams.data.fromConfirm;
        this.fromWalletConnect = this.navParams.data.fromWalletConnect;
        if (this.canGoBack && this.tabBarElement)
            this.tabBarElement.style.display = 'none';
        if (!__WEBPACK_IMPORTED_MODULE_10__environments__["a" /* default */].activateScanner) {
            this.logger.debug('Scanner page: env.activateScanner = false');
            return;
        }
        this.events.subscribe('incomingDataError', this.incomingDataErrorHandler);
        // try initializing and refreshing status any time the view is entered
        if (this.scannerHasPermission) {
            this.logger.debug('scannerHasPermission: true');
            this.activate();
        }
        else {
            this.logger.debug('scannerHasPermission: false');
            if (!this.scanProvider.isInitialized()) {
                this.logger.debug('Scanner trying to initialize');
                this.scanProvider.gentleInitialize().then(() => {
                    this.authorize();
                });
            }
            else {
                this.authorize();
            }
        }
        this.events.subscribe('scannerServiceInitialized', this.scannerServiceInitializedHandler);
    }
    showErrorInfoSheet(error, title) {
        let infoSheetTitle = title ? title : this.translate.instant('Error');
        this.errorsProvider.showDefaultError(this.bwcErrorProvider.msg(error), infoSheetTitle, () => {
            this.activate();
        });
    }
    initializeBackButtonHandler() {
        // This event is only used within Cordova apps running on Android and
        // Windows platforms. This event is not fired on iOS since iOS doesn't come with a hardware back button
        this.unregisterBackButtonAction = this.platform.registerBackButtonAction(() => {
            this.closeCam();
        });
    }
    updateCapabilities() {
        let capabilities = this.scanProvider.getCapabilities();
        this.scannerIsAvailable = capabilities.isAvailable;
        this.scannerHasPermission = capabilities.hasPermission;
        this.scannerIsDenied = capabilities.isDenied;
        this.scannerIsRestricted = capabilities.isRestricted;
        this.canEnableLight = capabilities.canEnableLight;
        this.canChangeCamera = capabilities.canChangeCamera;
        this.canOpenSettings = capabilities.canOpenSettings;
    }
    handleCapabilities() {
        // always update the view
        if (!this.scanProvider.isInitialized()) {
            this.currentState = this.scannerStates.loading;
        }
        else if (!this.scannerIsAvailable) {
            this.currentState = this.scannerStates.unavailable;
        }
        else if (this.scannerIsDenied) {
            this.currentState = this.scannerStates.denied;
        }
        else if (this.scannerIsRestricted) {
            this.currentState = this.scannerStates.denied;
        }
        else if (!this.scannerHasPermission) {
            this.currentState = this.scannerStates.unauthorized;
        }
        this.logger.debug('Scan view state set to: ' + this.currentState);
    }
    _refreshScanView() {
        this.updateCapabilities();
        this.handleCapabilities();
        if (this.scannerHasPermission) {
            this.activate();
        }
    }
    activate() {
        this.scanProvider
            .activate()
            .then(() => {
            this.logger.info('Scanner activated, setting to visible...');
            this.updateCapabilities();
            this.handleCapabilities();
            this.currentState = this.scannerStates.visible;
            // resume preview if paused
            this.scanProvider.resumePreview();
            this.scanProvider.scan().then((contents) => {
                this.scanProvider.pausePreview();
                this.handleSuccessfulScan(contents.toLowerCase());
            });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    handleSuccessfulScan(contents) {
        if (this.canGoBack)
            this.navCtrl.pop({ animate: false });
        if (this.fromAddressbook) {
            this.events.publish('Local/AddressScan', { value: contents });
        }
        else if (this.fromImport) {
            this.events.publish('Local/BackupScan', { value: contents });
        }
        else if (this.fromJoin) {
            this.events.publish('Local/JoinScan', { value: contents });
        }
        else if (this.fromSend) {
            this.events.publish('Local/AddressScan', { value: contents });
        }
        else if (this.fromMultiSend) {
            this.events.publish('Local/AddressScanMultiSend', { value: contents });
        }
        else if (this.fromSelectInputs) {
            this.events.publish('Local/AddressScanSelectInputs', { value: contents });
        }
        else if (this.fromEthMultisig) {
            this.events.publish('Local/AddressScanEthMultisig', { value: contents });
        }
        else if (this.fromConfirm) {
            this.events.publish('Local/TagScan', { value: contents });
        }
        else if (this.fromWalletConnect) {
            this.events.publish('Local/UriScan', { value: contents });
        }
        else {
            this.navCtrl.parent.select(1); // Workaround to avoid keep camera active
            const redirParms = { activePage: 'ScanPage' };
            this.incomingDataProvider.redir(contents, redirParms);
        }
    }
    authorize() {
        this.scanProvider.initialize().then(() => {
            this._refreshScanView();
        });
    }
    attemptToReactivate() {
        this.scanProvider.reinitialize();
    }
    openSettings() {
        this.scanProvider.openSettings();
    }
    toggleLight() {
        this.scanProvider
            .toggleLight()
            .then(resp => {
            this.lightActive = resp;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + JSON.stringify(error));
        });
    }
    toggleCamera() {
        this.scanProvider
            .toggleCamera()
            .then(resp => {
            this.cameraToggleActive = resp;
            this.lightActive = false;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + JSON.stringify(error));
        });
    }
    closeCam() {
        this.navCtrl.pop({ animate: false });
    }
};
ScanPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-scan',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/scan/scan.html"*/'<ion-header no-border *ngIf="canGoBack">\n  <ion-navbar hideBackButton transparent>\n    <ion-buttons left>\n      <button class="close-container disable-hover" (click)="closeCam()" ion-button>\n        <ion-icon ios="md-close" md="md-close" color="light"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content *ngIf="!isCordova">\n  <div class="not-supported">\n    <span>\n      Camera not supported\n    </span>\n  </div>\n</ion-content>\n\n<ion-content *ngIf="isCordova" class="back-transparent" no-bounce>\n  <div class="page-scan-has-problems" *ngIf="(currentState == scannerStates.unauthorized || currentState == scannerStates.denied || currentState == scannerStates.unavailable)">\n    <div class="header-container">\n      <div>\n        <div class="header" padding>\n          <div class="image-container">\n            <img src="assets/img/ico-receive.svg" />\n          </div>\n          <div class="title" padding translate>Scan QR Codes</div>\n        </div>\n        <div class="subtitle" translate>You can scan bitcoin addresses, payment requests, paper wallets, and more.</div>\n      </div>\n    </div>\n    <div class="body">\n      <div padding>\n        <div *ngIf="currentState == scannerStates.unauthorized" translate>Enable the camera to get started.</div>\n        <div *ngIf="currentState == scannerStates.denied" translate>Enable camera access in your device settings to get started.</div>\n        <div *ngIf="currentState == scannerStates.unavailable" translate>Please connect a camera to get started.</div>\n      </div>\n      <div>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unauthorized" (click)="authorize()">\n          {{\'Allow camera access\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.denied && canOpenSettings" (click)="openSettings()">\n          {{\'Open settings\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unavailable" (click)="attemptToReactivate()">\n          {{\'Retry camera\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n  <div class="page-scan-loading-camera" *ngIf="currentState == scannerStates.loading"></div>\n  <div class="page-scan-camera-ready" *ngIf="currentState == scannerStates.visible">\n    <div class="guides">\n      <img class="svg qr-scan-guides" src="assets/img/tkcoin-wallet-qr-scan-guides.svg">\n    </div>\n    <div class="scanner-controls">\n      <span *ngIf="canEnableLight" class="icon-flash" [ngClass]="{\'active\': lightActive}" (click)="toggleLight()"></span>\n      <span *ngIf="canChangeCamera" class="icon-camera-toggle" [ngClass]="{\'active\': cameraToggleActive}" (click)="toggleCamera()"></span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/scan/scan.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__["a" /* ScanProvider */]]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__["a" /* ScanProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_5__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], ScanPage);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 13:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlatformProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);





let PlatformProvider = class PlatformProvider {
    constructor(platform, logger, device) {
        this.platform = platform;
        this.logger = logger;
        this.device = device;
        let ua = navigator ? navigator.userAgent : null;
        if (!ua) {
            this.logger.info('Could not determine navigator. Using fixed string');
            ua = 'dummy user-agent';
        }
        // Fixes IOS WebKit UA
        ua = ua.replace(/\(\d+\)$/, '');
        this.isAndroid = this.platform.is('android');
        this.isIOS = this.platform.is('ios');
        this.ua = ua;
        this.isCordova = this.platform.is('cordova');
        this.isElectron = this.isElectronPlatform();
        this.isMobile = this.platform.is('mobile');
        this.isDevel = !this.isMobile && !this.isElectron;
        this.isMac = this.isMacApp();
        this.isWindows = this.isWindowsApp();
        this.isLinux = this.isLinuxApp();
        this.logger.debug('PlatformProvider initialized');
    }
    getPlatform() {
        return this.isAndroid
            ? 'android'
            : this.isIOS
                ? 'ios'
                : this.isCordova
                    ? 'cordova'
                    : this.isMac
                        ? 'macintosh'
                        : this.isWindows
                            ? 'windows'
                            : this.isLinux
                                ? 'linux'
                                : this.isMobile
                                    ? 'mobile'
                                    : undefined;
    }
    getBrowserName() {
        let userAgent = window.navigator.userAgent;
        let browsers = {
            chrome: /chrome/i,
            safari: /safari/i,
            firefox: /firefox/i,
            ie: /internet explorer/i
        };
        for (let key in browsers) {
            if (browsers[key].test(userAgent)) {
                return key;
            }
        }
        return 'unknown';
    }
    getUserAgent() {
        return window.navigator.userAgent;
    }
    isMacApp() {
        return (this.isElectronPlatform() &&
            this.getUserAgent().toLowerCase().includes('macintosh'));
    }
    isWindowsApp() {
        return (this.isElectronPlatform() &&
            this.getUserAgent().toLowerCase().includes('windows'));
    }
    isLinuxApp() {
        return (this.isElectronPlatform() &&
            this.getUserAgent().toLowerCase().includes('linux'));
    }
    isElectronPlatform() {
        const userAgent = navigator && navigator.userAgent
            ? navigator.userAgent.toLowerCase()
            : null;
        if (userAgent && userAgent.indexOf('electron/') > -1) {
            return true;
        }
        else {
            return false;
        }
    }
    getOS() {
        let OS = {
            OSName: '',
            extension: ''
        };
        if (this.isElectron) {
            if (navigator.appVersion.indexOf('Win') != -1) {
                OS.OSName = 'Windows';
                OS.extension = '.exe';
            }
            if (navigator.appVersion.indexOf('Mac') != -1) {
                OS.OSName = 'MacOS';
                OS.extension = '.dmg';
            }
            if (navigator.appVersion.indexOf('Linux') != -1) {
                OS.OSName = 'Linux';
                OS.extension = '-linux.zip';
            }
        }
        return OS;
    }
    getDeviceInfo() {
        let info;
        if (this.isElectron) {
            info = ' (' + navigator.appVersion + ')';
        }
        else {
            info =
                ' (' +
                    this.device.platform +
                    ' ' +
                    this.device.version +
                    ' - ' +
                    this.device.model +
                    ')';
        }
        return info;
    }
};
PlatformProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a" /* Device */]])
], PlatformProvider);

//# sourceMappingURL=platform.js.map

/***/ }),

/***/ 1386:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(73);
var Point = __webpack_require__(216);
var Hash = __webpack_require__(74);
var JSUtil = __webpack_require__(59);
var Network = __webpack_require__(199);
var _ = __webpack_require__(1);
var $ = __webpack_require__(35);

/**
 * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.
 *
 * There are two internal properties, `network` and `compressed`, that deal with importing
 * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}
 *
 * @example
 * ```javascript
 * // instantiate from a private key
 * var key = PublicKey(privateKey, true);
 *
 * // export to as a DER hex encoded string
 * var exported = key.toString();
 *
 * // import the public key
 * var imported = PublicKey.fromString(exported);
 * ```
 *
 * @param {string} data - The encoded data in various formats
 * @param {Object} extra - additional options
 * @param {Network=} extra.network - Which network should the address for this public key be for
 * @param {String=} extra.compressed - If the public key is compressed
 * @returns {PublicKey} A new valid instance of an PublicKey
 * @constructor
 */
function PublicKey(data, extra) {

  if (!(this instanceof PublicKey)) {
    return new PublicKey(data, extra);
  }

  $.checkArgument(data, 'First argument is required, please include public key data.');

  if (data instanceof PublicKey) {
    // Return copy, but as it's an immutable object, return same argument
    return data;
  }
  extra = extra || {};

  var info = this._classifyArgs(data, extra);

  // validation
  info.point.validate();

  JSUtil.defineImmutable(this, {
    point: info.point,
    compressed: info.compressed,
    network: info.network || Network.defaultNetwork
  });

  return this;
};

/**
 * Internal function to differentiate between arguments passed to the constructor
 * @param {*} data
 * @param {Object} extra
 */
PublicKey.prototype._classifyArgs = function(data, extra) {
  /* jshint maxcomplexity: 10 */
  var info = {
    compressed: _.isUndefined(extra.compressed) || extra.compressed
  };

  // detect type of data
  if (data instanceof Point) {
    info.point = data;
  } else if (data.x && data.y) {
    info = PublicKey._transformObject(data);
  } else if (typeof(data) === 'string') {
    info = PublicKey._transformDER(Buffer.from(data, 'hex'));
  } else if (PublicKey._isBuffer(data)) {
    info = PublicKey._transformDER(data);
  } else if (PublicKey._isPrivateKey(data)) {
    info = PublicKey._transformPrivateKey(data);
  } else {
    throw new TypeError('First argument is an unrecognized data format.');
  }
  if (!info.network) {
    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);
  }
  return info;
};

/**
 * Internal function to detect if an object is a {@link PrivateKey}
 *
 * @param {*} param - object to test
 * @returns {boolean}
 * @private
 */
PublicKey._isPrivateKey = function(param) {
  var PrivateKey = __webpack_require__(266);
  return param instanceof PrivateKey;
};

/**
 * Internal function to detect if an object is a Buffer
 *
 * @param {*} param - object to test
 * @returns {boolean}
 * @private
 */
PublicKey._isBuffer = function(param) {
  return (param instanceof Buffer) || (param instanceof Uint8Array);
};

/**
 * Internal function to transform a private key into a public key point
 *
 * @param {PrivateKey} privkey - An instance of PrivateKey
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformPrivateKey = function(privkey) {
  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
  var info = {};
  info.point = Point.getG().mul(privkey.bn);
  info.compressed = privkey.compressed;
  info.network = privkey.network;
  return info;
};

/**
 * Internal function to transform DER into a public key point
 *
 * @param {Buffer} buf - An hex encoded buffer
 * @param {bool=} strict - if set to false, will loosen some conditions
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformDER = function(buf, strict) {
  /* jshint maxstatements: 30 */
  /* jshint maxcomplexity: 12 */
  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');
  var info = {};

  strict = _.isUndefined(strict) ? true : strict;

  var x;
  var y;
  var xbuf;
  var ybuf;

  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {
    xbuf = buf.slice(1, 33);
    ybuf = buf.slice(33, 65);
    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
      throw new TypeError('Length of x and y must be 32 bytes');
    }
    x = new BN(xbuf);
    y = new BN(ybuf);
    info.point = new Point(x, y);
    info.compressed = false;
  } else if (buf[0] === 0x03) {
    xbuf = buf.slice(1);
    x = new BN(xbuf);
    info = PublicKey._transformX(true, x);
    info.compressed = true;
  } else if (buf[0] === 0x02) {
    xbuf = buf.slice(1);
    x = new BN(xbuf);
    info = PublicKey._transformX(false, x);
    info.compressed = true;
  } else {
    throw new TypeError('Invalid DER format public key');
  }
  return info;
};

/**
 * Internal function to transform X into a public key point
 *
 * @param {Boolean} odd - If the point is above or below the x axis
 * @param {Point} x - The x point
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformX = function(odd, x) {
  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');
  var info = {};
  info.point = Point.fromX(odd, x);
  return info;
};

/**
 * Internal function to transform a JSON into a public key point
 *
 * @param {String|Object} json - a JSON string or plain object
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformObject = function(json) {
  var x = new BN(json.x, 'hex');
  var y = new BN(json.y, 'hex');
  var point = new Point(x, y);
  return new PublicKey(point, {
    compressed: json.compressed
  });
};

/**
 * Instantiate a PublicKey from a PrivateKey
 *
 * @param {PrivateKey} privkey - An instance of PrivateKey
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromPrivateKey = function(privkey) {
  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
  var info = PublicKey._transformPrivateKey(privkey);
  return new PublicKey(info.point, {
    compressed: info.compressed,
    network: info.network
  });
};

/**
 * Instantiate a PublicKey from a Buffer
 * @param {Buffer} buf - A DER hex buffer
 * @param {bool=} strict - if set to false, will loosen some conditions
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {
  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');
  var info = PublicKey._transformDER(buf, strict);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Instantiate a PublicKey from a Point
 *
 * @param {Point} point - A Point instance
 * @param {boolean=} compressed - whether to store this public key as compressed format
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromPoint = function(point, compressed) {
  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');
  return new PublicKey(point, {
    compressed: compressed
  });
};

/**
 * Instantiate a PublicKey from a DER hex encoded string
 *
 * @param {string} str - A DER hex string
 * @param {String=} encoding - The type of string encoding
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromString = function(str, encoding) {
  var buf = Buffer.from(str, encoding || 'hex');
  var info = PublicKey._transformDER(buf);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Instantiate a PublicKey from an X Point
 *
 * @param {Boolean} odd - If the point is above or below the x axis
 * @param {Point} x - The x point
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromX = function(odd, x) {
  var info = PublicKey._transformX(odd, x);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Check if there would be any errors when initializing a PublicKey
 *
 * @param {string} data - The encoded data in various formats
 * @returns {null|Error} An error if exists
 */
PublicKey.getValidationError = function(data) {
  var error;
  try {
    /* jshint nonew: false */
    new PublicKey(data);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Check if the parameters are valid
 *
 * @param {string} data - The encoded data in various formats
 * @returns {Boolean} If the public key would be valid
 */
PublicKey.isValid = function(data) {
  return !PublicKey.getValidationError(data);
};

/**
 * @returns {Object} A plain object of the PublicKey
 */
PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {
  return {
    x: this.point.getX().toString('hex', 2),
    y: this.point.getY().toString('hex', 2),
    compressed: this.compressed
  };
};

/**
 * Will output the PublicKey to a DER Buffer
 *
 * @returns {Buffer} A DER hex encoded buffer
 */
PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {
  var x = this.point.getX();
  var y = this.point.getY();

  var xbuf = x.toBuffer({
    size: 32
  });
  var ybuf = y.toBuffer({
    size: 32
  });

  var prefix;
  if (!this.compressed) {
    prefix = Buffer.from([0x04]);
    return Buffer.concat([prefix, xbuf, ybuf]);
  } else {
    var odd = ybuf[ybuf.length - 1] % 2;
    if (odd) {
      prefix = Buffer.from([0x03]);
    } else {
      prefix = Buffer.from([0x02]);
    }
    return Buffer.concat([prefix, xbuf]);
  }
};

/**
 * Will return a sha256 + ripemd160 hash of the serialized public key
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141
 * @returns {Buffer}
 */
PublicKey.prototype._getID = function _getID() {
  return Hash.sha256ripemd160(this.toBuffer());
};

/**
 * Will return an address for the public key
 *
 * @param {String|Network=} network - Which network should the address be for
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Address} An address generated from the public key
 */
PublicKey.prototype.toAddress = function(network, type) {
  var Address = __webpack_require__(140);
  return Address.fromPublicKey(this, network || this.network, type);
};

/**
 * Will output the PublicKey to a DER encoded hex string
 *
 * @returns {string} A DER hex encoded string
 */
PublicKey.prototype.toString = function() {
  return this.toDER().toString('hex');
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Public key
 */
PublicKey.prototype.inspect = function() {
  return '<PublicKey: ' + this.toString() +
    (this.compressed ? '' : ', uncompressed') + '>';
};


module.exports = PublicKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1390:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var errors = __webpack_require__(115);
var Base58Check = __webpack_require__(267);
var Bech32 = __webpack_require__(1494);
var Networks = __webpack_require__(199);
var Hash = __webpack_require__(74);
var JSUtil = __webpack_require__(59);
var PublicKey = __webpack_require__(139);

/**
 * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,
 * or an instance of {@link PublicKey} or {@link Script}.
 *
 * This is an immutable class, and if the first parameter provided to this constructor is an
 * `Address` instance, the same argument will be returned.
 *
 * An address has two key properties: `network` and `type`. The type is one of
 * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),
 * `Address.PayToScriptHash` (the string `'scripthash'`),
 * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),
 * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).
 * The network is an instance of {@link Network}.
 * You can quickly check whether an address is of a given kind by using the methods
 * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,
 * and `isPayToWitnessScriptHash`.
 *
 * @example
 * ```javascript
 * // validate that an input field is valid
 * var error = Address.getValidationError(input, 'testnet');
 * if (!error) {
 *   var address = Address(input, 'testnet');
 * } else {
 *   // invalid network or checksum (typo?)
 *   var message = error.messsage;
 * }
 *
 * // get an address from a public key
 * var address = Address(publicKey, 'testnet').toString();
 * ```
 *
 * @param {*} data - The encoded data in various formats
 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash or 'witnesspubkeyhash'
 * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 * @constructor
 */
function Address(data, network, type, multisigType) {
  /* jshint maxcomplexity: 12 */
  /* jshint maxstatements: 20 */

  if (!(this instanceof Address)) {
    return new Address(data, network, type);
  }

  if (_.isArray(data) && _.isNumber(network)) {
    return Address.createMultisig(data, network, type, false, multisigType);
  }

  if (data instanceof Address) {
    // Immutable instance
    return data;
  }

  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');

  if (network && !Networks.get(network)) {
    throw new TypeError('Second argument must be "livenet" or "testnet".');
  }

  if (type && (
    type !== Address.PayToPublicKeyHash
    && type !== Address.PayToScriptHash
    && type !== Address.PayToWitnessPublicKeyHash
    && type !== Address.PayToWitnessScriptHash)) {
    throw new TypeError('Third argument must be "pubkeyhash", "scripthash", "witnesspubkeyhash", or "witnessscripthash".');
  }

  var info = this._classifyArguments(data, network, type);

  // set defaults if not set
  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
  info.type = info.type || type || Address.PayToPublicKeyHash;

  JSUtil.defineImmutable(this, {
    hashBuffer: info.hashBuffer,
    network: info.network,
    type: info.type
  });

  return this;
}

/**
 * Internal function used to split different kinds of arguments of the constructor
 * @param {*} data - The encoded data in various formats
 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Object} An "info" object with "type", "network", and "hashBuffer"
 */
Address.prototype._classifyArguments = function(data, network, type) {
  /* jshint maxcomplexity: 10 */
  // transform and validate input data
  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {
    return Address._transformHash(data, network, type);
  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {
    return Address._transformBuffer(data, network, type);
  } else if (data instanceof PublicKey) {
    return Address._transformPublicKey(data, network, type);
  } else if (data instanceof Script) {
    return Address._transformScript(data, network);
  } else if (typeof(data) === 'string') {
    return Address._transformString(data, network, type);
  } else if (_.isObject(data)) {
    return Address._transformObject(data);
  } else {
    throw new TypeError('First argument is an unrecognized data format.');
  }
};

/** @static */
Address.PayToPublicKeyHash = 'pubkeyhash';
/** @static */
Address.PayToScriptHash = 'scripthash';
/** @static */
Address.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';
/** @static */
Address.PayToWitnessScriptHash = 'witnessscripthash';

/**
 * @param {Buffer} hash - An instance of a hash Buffer
 * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @param {Network=} network - the name of the network associated
 * @returns {Object} An object with keys: hashBuffer
 * @private
 */
Address._transformHash = function(hash, network, type) {
  var info = {};
  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {
    throw new TypeError('Address supplied is not a buffer.');
  }
  if (hash.length !== 20 && hash.length !== 32) {
    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');
  }
  info.hashBuffer = hash;
  info.network = Networks.get(network) || Networks.defaultNetwork;
  info.type = type;
  return info;
};

/**
 * Deserializes an address serialized through `Address#toObject()`
 * @param {Object} data
 * @param {string} data.hash - the hash that this address encodes
 * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @param {Network=} data.network - the name of the network associated
 * @return {Address}
 */
Address._transformObject = function(data) {
  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');
  $.checkArgument(data.type, 'Must provide a `type` property');
  return {
    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,
    network: Networks.get(data.network) || Networks.defaultNetwork,
    type: data.type
  };
};

/**
 * Internal function to discover the network and type based on the first data byte
 *
 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
 * @returns {Object} An object with keys: network and type
 * @private
 */
Address._classifyFromVersion = function(buffer) {
  var version = {};

  if (buffer.length > 21) {
    var info = Bech32.decode(buffer.toString('utf8'));
    if (info.version !== 0) {
      throw new TypeError('Only witness v0 addresses are supported.');
    }
    if (info.data.length === 20) {
      version.type = Address.PayToWitnessPublicKeyHash;
    } else if (info.data.length === 32) {
      version.type = Address.PayToWitnessScriptHash;
    } else {
      throw new TypeError('Witness data must be either 20 or 32 bytes.')
    }
    version.network = Networks.get(info.prefix, 'bech32prefix');
  } else {

    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');
    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');

    if (pubkeyhashNetwork) {
      version.network = pubkeyhashNetwork;
      version.type = Address.PayToPublicKeyHash;
    } else if (scripthashNetwork) {
      version.network = scripthashNetwork;
      version.type = Address.PayToScriptHash;
    }
  }

  return version;
};

/**
 * Internal function to transform a educoin address buffer
 *
 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
 * @param {string=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @returns {Object} An object with keys: hashBuffer, network and type
 * @private
 */
Address._transformBuffer = function(buffer, network, type) {
  /* jshint maxcomplexity: 9 */
  var info = {};
  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {
    throw new TypeError('Address supplied is not a buffer.');
  }

  if (buffer.length < 21) {
    throw new TypeError('Address buffer is incorrect length.');
  }

  var networkObj = Networks.get(network);
  var bufferVersion = Address._classifyFromVersion(buffer);

  if (network && !networkObj) {
    throw new TypeError('Unknown network');
  }

  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {
    throw new TypeError('Address has mismatched network type.');
  }

  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {
    throw new TypeError('Address has mismatched type.');
  }

  if (buffer.length > 21) {
    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;
  } else {
    info.hashBuffer = buffer.slice(1);
  }
  info.network = bufferVersion.network;
  info.type = bufferVersion.type;
  return info;
};

/**
 * Internal function to transform a {@link PublicKey}
 *
 * @param {PublicKey} pubkey - An instance of PublicKey
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Object} An object with keys: hashBuffer, type
 * @private
 */
Address._transformPublicKey = function(pubkey, network, type) {
  var info = {};
  if (!(pubkey instanceof PublicKey)) {
    throw new TypeError('Address must be an instance of PublicKey.');
  }
  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash) {
    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, or scripthash to transform public key.');
  }
  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {
    throw new TypeError('Witness addresses must use compressed public keys.');
  }
  if (type === Address.PayToScriptHash) {
    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());
  } else {
    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());
  }
  info.type = type || Address.PayToPublicKeyHash;
  return info;
};

/**
 * Internal function to transform a {@link Script} into a `info` object.
 *
 * @param {Script} script - An instance of Script
 * @returns {Object} An object with keys: hashBuffer, type
 * @private
 */
Address._transformScript = function(script, network) {
  $.checkArgument(script instanceof Script, 'script must be a Script instance');
  var info = script.getAddressInfo(network);
  if (!info) {
    throw new errors.Script.CantDeriveAddress(script);
  }
  return info;
};

/**
 * Creates a P2SH address from a set of public keys and a threshold.
 *
 * The addresses will be sorted lexicographically, as that is the trend in educoin.
 * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}
 * interface.
 *
 * @param {Array} publicKeys - a set of public keys to create an address
 * @param {number} threshold - the number of signatures needed to release the funds
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored
 * @return {Address}
 */
Address.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {
  network = network || publicKeys[0].network || Networks.defaultNetwork;
  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {
    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');
  }
  if (nestedWitness || type === Address.PayToWitnessScriptHash) {
    publicKeys = _.map(publicKeys, PublicKey);
    for (var i = 0; i < publicKeys.length; i++) {
      if (!publicKeys[i].compressed) {
        throw new TypeError('Witness addresses must use compressed public keys.');
      }
    }
  }
  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);
  if (nestedWitness) {
    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);
  }
  return Address.payingTo(redeemScript, network, type);
};

/**
 * Internal function to transform a educoin address string
 *
 * @param {string} data
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @returns {Object} An object with keys: hashBuffer, network and type
 * @private
 */
Address._transformString = function(data, network, type) {
  if (typeof(data) !== 'string') {
    throw new TypeError('data parameter supplied is not a string.');
  }

  if(data.length > 100) {
    throw new TypeError('address string is too long');
  }

  if (network && !Networks.get(network)) {
    throw new TypeError('Unknown network');
  }

  data = data.trim();

  try {
    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);
    return info;
  } catch (e) {
    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash) {
      throw e;
    }
  }

  var addressBuffer = Base58Check.decode(data);
  var info = Address._transformBuffer(addressBuffer, network, type);
  return info;
};

/**
 * Instantiate an address from a PublicKey instance
 *
 * @param {PublicKey} data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromPublicKey = function(data, network, type) {
  var info = Address._transformPublicKey(data, network, type);
  network = network || Networks.defaultNetwork;
  return new Address(info.hashBuffer, network, info.type);
};

/**
 * Instantiate an address from a ripemd160 public key hash
 *
 * @param {Buffer} hash - An instance of buffer of the hash
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromPublicKeyHash = function(hash, network) {
  var info = Address._transformHash(hash);
  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);
};

/**
 * Instantiate an address from a ripemd160 script hash
 *
 * @param {Buffer} hash - An instance of buffer of the hash
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromScriptHash = function(hash, network, type) {
  $.checkArgument(hash, 'hash parameter is required');
  var info = Address._transformHash(hash);
  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {
      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');
  }
  var type = type || Address.PayToScriptHash;
  return new Address(info.hashBuffer, network, type);
};

/**
 * Builds a p2sh address paying to script. This will hash the script and
 * use that to create the address.
 * If you want to extract an address associated with a script instead,
 * see {{Address#fromScript}}
 *
 * @param {Script} script - An instance of Script
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.payingTo = function(script, network, type) {
  $.checkArgument(script, 'script is required');
  $.checkArgument(script instanceof Script, 'script must be instance of Script');
  var hash;
  if (type === Address.PayToWitnessScriptHash) {
    hash = Hash.sha256(script.toBuffer());
  } else {
    hash = Hash.sha256ripemd160(script.toBuffer());
  }
  var type = type || Address.PayToScriptHash;
  return Address.fromScriptHash(hash, network, type);
};

/**
 * Extract address from a Script. The script must be of one
 * of the following types: p2pkh input, p2pkh output, p2sh input
 * or p2sh output.
 * This will analyze the script and extract address information from it.
 * If you want to transform any script to a p2sh Address paying
 * to that script's hash instead, use {{Address#payingTo}}
 *
 * @param {Script} script - An instance of Script
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromScript = function(script, network) {
  $.checkArgument(script instanceof Script, 'script must be a Script instance');
  var info = Address._transformScript(script, network);
  return new Address(info.hashBuffer, network, info.type);
};

/**
 * Instantiate an address from a buffer of the address
 *
 * @param {Buffer} buffer - An instance of buffer of the address
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromBuffer = function(buffer, network, type) {
  var info = Address._transformBuffer(buffer, network, type);
  return new Address(info.hashBuffer, info.network, info.type);
};

/**
 * Instantiate an address from an address string
 *
 * @param {string} str - An string of the educoin address
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromString = function(str, network, type) {
  var info = Address._transformString(str, network, type);
  return new Address(info.hashBuffer, info.network, info.type);
};

/**
 * Instantiate an address from an Object
 *
 * @param {string} json - An JSON string or Object with keys: hash, network and type
 * @returns {Address} A new valid instance of an Address
 */
Address.fromObject = function fromObject(obj) {
  $.checkState(
    JSUtil.isHexa(obj.hash),
    'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
  );
  var hashBuffer = Buffer.from(obj.hash, 'hex');
  return new Address(hashBuffer, obj.network, obj.type);
};

/**
 * Will return a validation error if exists
 *
 * @example
 * ```javascript
 * // a network mismatch error
 * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');
 * ```
 *
 * @param {string} data - The encoded data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - The type of address: 'script' or 'pubkey'
 * @returns {null|Error} The corresponding error message
 */
Address.getValidationError = function(data, network, type) {
  var error;
  try {
    /* jshint nonew: false */
    new Address(data, network, type);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Will return a boolean if an address is valid
 *
 * @example
 * ```javascript
 * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));
 * ```
 *
 * @param {string} data - The encoded data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - The type of address: 'script' or 'pubkey'
 * @returns {boolean} The corresponding error message
 */
Address.isValid = function(data, network, type) {
  return !Address.getValidationError(data, network, type);
};

/**
 * Returns true if an address is of pay to public key hash type
 * @return boolean
 */
Address.prototype.isPayToPublicKeyHash = function() {
  return this.type === Address.PayToPublicKeyHash;
};

/**
 * Returns true if an address is of pay to script hash type
 * @return boolean
 */
Address.prototype.isPayToScriptHash = function() {
  return this.type === Address.PayToScriptHash;
};

/**
 * Returns true if an address is of pay to witness public key hash type
 * @return boolean
 */
Address.prototype.isPayToWitnessPublicKeyHash = function() {
  return this.type === Address.PayToWitnessPublicKeyHash;
};

/**
 * Returns true if an address is of pay to witness script hash type
 * @return boolean
 */
Address.prototype.isPayToWitnessScriptHash = function() {
  return this.type === Address.PayToWitnessScriptHash;
};

/**
 * Will return a buffer representation of the address
 *
 * @returns {Buffer} Educoin address buffer
 */
Address.prototype.toBuffer = function() {
  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
    return Buffer.from(this.toString(), 'utf8')
  }
  var version = Buffer.from([this.network[this.type]]);
  return Buffer.concat([version, this.hashBuffer]);
};

/**
 * @returns {Object} A plain object with the address information
 */
Address.prototype.toObject = Address.prototype.toJSON = function toObject() {
  return {
    hash: this.hashBuffer.toString('hex'),
    type: this.type,
    network: this.network.toString()
  };
};

/**
 * Will return a the string representation of the address
 *
 * @returns {string} Educoin address
 */
Address.prototype.toString = function() {
  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
    var prefix = this.network.bech32prefix;
    var version = 0; // Only supporting segwit v0 for now
    return Bech32.encode(prefix, version, this.hashBuffer);
  }
  return Base58Check.encode(this.toBuffer());
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Educoin address
 */
Address.prototype.inspect = function() {
  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';
};

module.exports = Address;

var Script = __webpack_require__(104);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1407:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1409:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(75);
var Point = __webpack_require__(217);
var Hash = __webpack_require__(76);
var JSUtil = __webpack_require__(60);
var Network = __webpack_require__(200);
var _ = __webpack_require__(1);
var $ = __webpack_require__(36);

/**
 * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.
 *
 * There are two internal properties, `network` and `compressed`, that deal with importing
 * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}
 *
 * @example
 * ```javascript
 * // instantiate from a private key
 * var key = PublicKey(privateKey, true);
 *
 * // export to as a DER hex encoded string
 * var exported = key.toString();
 *
 * // import the public key
 * var imported = PublicKey.fromString(exported);
 * ```
 *
 * @param {string} data - The encoded data in various formats
 * @param {Object} extra - additional options
 * @param {Network=} extra.network - Which network should the address for this public key be for
 * @param {String=} extra.compressed - If the public key is compressed
 * @returns {PublicKey} A new valid instance of an PublicKey
 * @constructor
 */
function PublicKey(data, extra) {

  if (!(this instanceof PublicKey)) {
    return new PublicKey(data, extra);
  }

  $.checkArgument(data, 'First argument is required, please include public key data.');

  if (data instanceof PublicKey) {
    // Return copy, but as it's an immutable object, return same argument
    return data;
  }
  extra = extra || {};

  var info = this._classifyArgs(data, extra);

  // validation
  info.point.validate();

  JSUtil.defineImmutable(this, {
    point: info.point,
    compressed: info.compressed,
    network: info.network || Network.defaultNetwork
  });

  return this;
};

/**
 * Internal function to differentiate between arguments passed to the constructor
 * @param {*} data
 * @param {Object} extra
 */
PublicKey.prototype._classifyArgs = function(data, extra) {
  /* jshint maxcomplexity: 10 */
  var info = {
    compressed: _.isUndefined(extra.compressed) || extra.compressed
  };

  // detect type of data
  if (data instanceof Point) {
    info.point = data;
  } else if (data.x && data.y) {
    info = PublicKey._transformObject(data);
  } else if (typeof(data) === 'string') {
    info = PublicKey._transformDER(Buffer.from(data, 'hex'));
  } else if (PublicKey._isBuffer(data)) {
    info = PublicKey._transformDER(data);
  } else if (PublicKey._isPrivateKey(data)) {
    info = PublicKey._transformPrivateKey(data);
  } else {
    throw new TypeError('First argument is an unrecognized data format.');
  }
  if (!info.network) {
    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);
  }
  return info;
};

/**
 * Internal function to detect if an object is a {@link PrivateKey}
 *
 * @param {*} param - object to test
 * @returns {boolean}
 * @private
 */
PublicKey._isPrivateKey = function(param) {
  var PrivateKey = __webpack_require__(270);
  return param instanceof PrivateKey;
};

/**
 * Internal function to detect if an object is a Buffer
 *
 * @param {*} param - object to test
 * @returns {boolean}
 * @private
 */
PublicKey._isBuffer = function(param) {
  return (param instanceof Buffer) || (param instanceof Uint8Array);
};

/**
 * Internal function to transform a private key into a public key point
 *
 * @param {PrivateKey} privkey - An instance of PrivateKey
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformPrivateKey = function(privkey) {
  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
  var info = {};
  info.point = Point.getG().mul(privkey.bn);
  info.compressed = privkey.compressed;
  info.network = privkey.network;
  return info;
};

/**
 * Internal function to transform DER into a public key point
 *
 * @param {Buffer} buf - An hex encoded buffer
 * @param {bool=} strict - if set to false, will loosen some conditions
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformDER = function(buf, strict) {
  /* jshint maxstatements: 30 */
  /* jshint maxcomplexity: 12 */
  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');
  var info = {};

  strict = _.isUndefined(strict) ? true : strict;

  var x;
  var y;
  var xbuf;
  var ybuf;

  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {
    xbuf = buf.slice(1, 33);
    ybuf = buf.slice(33, 65);
    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
      throw new TypeError('Length of x and y must be 32 bytes');
    }
    x = new BN(xbuf);
    y = new BN(ybuf);
    info.point = new Point(x, y);
    info.compressed = false;
  } else if (buf[0] === 0x03) {
    xbuf = buf.slice(1);
    x = new BN(xbuf);
    info = PublicKey._transformX(true, x);
    info.compressed = true;
  } else if (buf[0] === 0x02) {
    xbuf = buf.slice(1);
    x = new BN(xbuf);
    info = PublicKey._transformX(false, x);
    info.compressed = true;
  } else {
    throw new TypeError('Invalid DER format public key');
  }
  return info;
};

/**
 * Internal function to transform X into a public key point
 *
 * @param {Boolean} odd - If the point is above or below the x axis
 * @param {Point} x - The x point
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformX = function(odd, x) {
  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');
  var info = {};
  info.point = Point.fromX(odd, x);
  return info;
};

/**
 * Internal function to transform a JSON into a public key point
 *
 * @param {String|Object} json - a JSON string or plain object
 * @returns {Object} An object with keys: point and compressed
 * @private
 */
PublicKey._transformObject = function(json) {
  var x = new BN(json.x, 'hex');
  var y = new BN(json.y, 'hex');
  var point = new Point(x, y);
  return new PublicKey(point, {
    compressed: json.compressed
  });
};

/**
 * Instantiate a PublicKey from a PrivateKey
 *
 * @param {PrivateKey} privkey - An instance of PrivateKey
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromPrivateKey = function(privkey) {
  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');
  var info = PublicKey._transformPrivateKey(privkey);
  return new PublicKey(info.point, {
    compressed: info.compressed,
    network: info.network
  });
};

/**
 * Instantiate a PublicKey from a Buffer
 * @param {Buffer} buf - A DER hex buffer
 * @param {bool=} strict - if set to false, will loosen some conditions
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {
  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');
  var info = PublicKey._transformDER(buf, strict);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Instantiate a PublicKey from a Point
 *
 * @param {Point} point - A Point instance
 * @param {boolean=} compressed - whether to store this public key as compressed format
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromPoint = function(point, compressed) {
  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');
  return new PublicKey(point, {
    compressed: compressed
  });
};

/**
 * Instantiate a PublicKey from a DER hex encoded string
 *
 * @param {string} str - A DER hex string
 * @param {String=} encoding - The type of string encoding
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromString = function(str, encoding) {
  var buf = Buffer.from(str, encoding || 'hex');
  var info = PublicKey._transformDER(buf);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Instantiate a PublicKey from an X Point
 *
 * @param {Boolean} odd - If the point is above or below the x axis
 * @param {Point} x - The x point
 * @returns {PublicKey} A new valid instance of PublicKey
 */
PublicKey.fromX = function(odd, x) {
  var info = PublicKey._transformX(odd, x);
  return new PublicKey(info.point, {
    compressed: info.compressed
  });
};

/**
 * Check if there would be any errors when initializing a PublicKey
 *
 * @param {string} data - The encoded data in various formats
 * @returns {null|Error} An error if exists
 */
PublicKey.getValidationError = function(data) {
  var error;
  try {
    /* jshint nonew: false */
    new PublicKey(data);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Check if the parameters are valid
 *
 * @param {string} data - The encoded data in various formats
 * @returns {Boolean} If the public key would be valid
 */
PublicKey.isValid = function(data) {
  return !PublicKey.getValidationError(data);
};

/**
 * @returns {Object} A plain object of the PublicKey
 */
PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {
  return {
    x: this.point.getX().toString('hex', 2),
    y: this.point.getY().toString('hex', 2),
    compressed: this.compressed
  };
};

/**
 * Will output the PublicKey to a DER Buffer
 *
 * @returns {Buffer} A DER hex encoded buffer
 */
PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {
  var x = this.point.getX();
  var y = this.point.getY();

  var xbuf = x.toBuffer({
    size: 32
  });
  var ybuf = y.toBuffer({
    size: 32
  });

  var prefix;
  if (!this.compressed) {
    prefix = Buffer.from([0x04]);
    return Buffer.concat([prefix, xbuf, ybuf]);
  } else {
    var odd = ybuf[ybuf.length - 1] % 2;
    if (odd) {
      prefix = Buffer.from([0x03]);
    } else {
      prefix = Buffer.from([0x02]);
    }
    return Buffer.concat([prefix, xbuf]);
  }
};

/**
 * Will return a sha256 + ripemd160 hash of the serialized public key
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141
 * @returns {Buffer}
 */
PublicKey.prototype._getID = function _getID() {
  return Hash.sha256ripemd160(this.toBuffer());
};

/**
 * Will return an address for the public key
 *
 * @param {String|Network=} network - Which network should the address be for
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Address} An address generated from the public key
 */
PublicKey.prototype.toAddress = function(network, type) {
  var Address = __webpack_require__(142);
  return Address.fromPublicKey(this, network || this.network, type);
};

/**
 * Will output the PublicKey to a DER encoded hex string
 *
 * @returns {string} A DER hex encoded string
 */
PublicKey.prototype.toString = function() {
  return this.toDER().toString('hex');
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Public key
 */
PublicKey.prototype.inspect = function() {
  return '<PublicKey: ' + this.toString() +
    (this.compressed ? '' : ', uncompressed') + '>';
};


module.exports = PublicKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var errors = __webpack_require__(116);
var Base58Check = __webpack_require__(271);
var Bech32 = __webpack_require__(1507);
var Networks = __webpack_require__(200);
var Hash = __webpack_require__(76);
var JSUtil = __webpack_require__(60);
var PublicKey = __webpack_require__(141);

/**
 * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,
 * or an instance of {@link PublicKey} or {@link Script}.
 *
 * This is an immutable class, and if the first parameter provided to this constructor is an
 * `Address` instance, the same argument will be returned.
 *
 * An address has two key properties: `network` and `type`. The type is one of
 * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),
 * `Address.PayToScriptHash` (the string `'scripthash'`),
 * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),
 * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).
 * The network is an instance of {@link Network}.
 * You can quickly check whether an address is of a given kind by using the methods
 * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,
 * and `isPayToWitnessScriptHash`.
 *
 * @example
 * ```javascript
 * // validate that an input field is valid
 * var error = Address.getValidationError(input, 'testnet');
 * if (!error) {
 *   var address = Address(input, 'testnet');
 * } else {
 *   // invalid network or checksum (typo?)
 *   var message = error.messsage;
 * }
 *
 * // get an address from a public key
 * var address = Address(publicKey, 'testnet').toString();
 * ```
 *
 * @param {*} data - The encoded data in various formats
 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash or 'witnesspubkeyhash'
 * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 * @constructor
 */
function Address(data, network, type, multisigType) {
  /* jshint maxcomplexity: 12 */
  /* jshint maxstatements: 20 */

  if (!(this instanceof Address)) {
    return new Address(data, network, type);
  }

  if (_.isArray(data) && _.isNumber(network)) {
    return Address.createMultisig(data, network, type, false, multisigType);
  }

  if (data instanceof Address) {
    // Immutable instance
    return data;
  }

  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');

  if (network && !Networks.get(network)) {
    throw new TypeError('Second argument must be "livenet" or "testnet".');
  }

  if (type && (
    type !== Address.PayToPublicKeyHash
    && type !== Address.PayToScriptHash
    && type !== Address.PayToWitnessPublicKeyHash
    && type !== Address.PayToWitnessScriptHash)) {
    throw new TypeError('Third argument must be "pubkeyhash", "scripthash", "witnesspubkeyhash", or "witnessscripthash".');
  }

  var info = this._classifyArguments(data, network, type);

  // set defaults if not set
  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
  info.type = info.type || type || Address.PayToPublicKeyHash;

  JSUtil.defineImmutable(this, {
    hashBuffer: info.hashBuffer,
    network: info.network,
    type: info.type
  });

  return this;
}

/**
 * Internal function used to split different kinds of arguments of the constructor
 * @param {*} data - The encoded data in various formats
 * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Object} An "info" object with "type", "network", and "hashBuffer"
 */
Address.prototype._classifyArguments = function(data, network, type) {
  /* jshint maxcomplexity: 10 */
  // transform and validate input data
  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {
    return Address._transformHash(data, network, type);
  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {
    return Address._transformBuffer(data, network, type);
  } else if (data instanceof PublicKey) {
    return Address._transformPublicKey(data, network, type);
  } else if (data instanceof Script) {
    return Address._transformScript(data, network);
  } else if (typeof(data) === 'string') {
    return Address._transformString(data, network, type);
  } else if (_.isObject(data)) {
    return Address._transformObject(data);
  } else {
    throw new TypeError('First argument is an unrecognized data format.');
  }
};

/** @static */
Address.PayToPublicKeyHash = 'pubkeyhash';
/** @static */
Address.PayToScriptHash = 'scripthash';
/** @static */
Address.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';
/** @static */
Address.PayToWitnessScriptHash = 'witnessscripthash';

/**
 * @param {Buffer} hash - An instance of a hash Buffer
 * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @param {Network=} network - the name of the network associated
 * @returns {Object} An object with keys: hashBuffer
 * @private
 */
Address._transformHash = function(hash, network, type) {
  var info = {};
  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {
    throw new TypeError('Address supplied is not a buffer.');
  }
  if (hash.length !== 20 && hash.length !== 32) {
    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');
  }
  info.hashBuffer = hash;
  info.network = Networks.get(network) || Networks.defaultNetwork;
  info.type = type;
  return info;
};

/**
 * Deserializes an address serialized through `Address#toObject()`
 * @param {Object} data
 * @param {string} data.hash - the hash that this address encodes
 * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @param {Network=} data.network - the name of the network associated
 * @return {Address}
 */
Address._transformObject = function(data) {
  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');
  $.checkArgument(data.type, 'Must provide a `type` property');
  return {
    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,
    network: Networks.get(data.network) || Networks.defaultNetwork,
    type: data.type
  };
};

/**
 * Internal function to discover the network and type based on the first data byte
 *
 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
 * @returns {Object} An object with keys: network and type
 * @private
 */
Address._classifyFromVersion = function(buffer) {
  var version = {};

  if (buffer.length > 21) {
    var info = Bech32.decode(buffer.toString('utf8'));
    if (info.version !== 0) {
      throw new TypeError('Only witness v0 addresses are supported.');
    }
    if (info.data.length === 20) {
      version.type = Address.PayToWitnessPublicKeyHash;
    } else if (info.data.length === 32) {
      version.type = Address.PayToWitnessScriptHash;
    } else {
      throw new TypeError('Witness data must be either 20 or 32 bytes.')
    }
    version.network = Networks.get(info.prefix, 'bech32prefix');
  } else {

    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');
    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');

    if (pubkeyhashNetwork) {
      version.network = pubkeyhashNetwork;
      version.type = Address.PayToPublicKeyHash;
    } else if (scripthashNetwork) {
      version.network = scripthashNetwork;
      version.type = Address.PayToScriptHash;
    }
  }

  return version;
};

/**
 * Internal function to transform a tkcoin address buffer
 *
 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
 * @param {string=} network - The network: 'livenet' or 'testnet'
 * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @returns {Object} An object with keys: hashBuffer, network and type
 * @private
 */
Address._transformBuffer = function(buffer, network, type) {
  /* jshint maxcomplexity: 9 */
  var info = {};
  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {
    throw new TypeError('Address supplied is not a buffer.');
  }

  if (buffer.length < 21) {
    throw new TypeError('Address buffer is incorrect length.');
  }

  var networkObj = Networks.get(network);
  var bufferVersion = Address._classifyFromVersion(buffer);

  if (network && !networkObj) {
    throw new TypeError('Unknown network');
  }

  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {
    throw new TypeError('Address has mismatched network type.');
  }

  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {
    throw new TypeError('Address has mismatched type.');
  }

  if (buffer.length > 21) {
    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;
  } else {
    info.hashBuffer = buffer.slice(1);
  }
  info.network = bufferVersion.network;
  info.type = bufferVersion.type;
  return info;
};

/**
 * Internal function to transform a {@link PublicKey}
 *
 * @param {PublicKey} pubkey - An instance of PublicKey
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Object} An object with keys: hashBuffer, type
 * @private
 */
Address._transformPublicKey = function(pubkey, network, type) {
  var info = {};
  if (!(pubkey instanceof PublicKey)) {
    throw new TypeError('Address must be an instance of PublicKey.');
  }
  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash) {
    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, or scripthash to transform public key.');
  }
  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {
    throw new TypeError('Witness addresses must use compressed public keys.');
  }
  if (type === Address.PayToScriptHash) {
    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());
  } else {
    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());
  }
  info.type = type || Address.PayToPublicKeyHash;
  return info;
};

/**
 * Internal function to transform a {@link Script} into a `info` object.
 *
 * @param {Script} script - An instance of Script
 * @returns {Object} An object with keys: hashBuffer, type
 * @private
 */
Address._transformScript = function(script, network) {
  $.checkArgument(script instanceof Script, 'script must be a Script instance');
  var info = script.getAddressInfo(network);
  if (!info) {
    throw new errors.Script.CantDeriveAddress(script);
  }
  return info;
};

/**
 * Creates a P2SH address from a set of public keys and a threshold.
 *
 * The addresses will be sorted lexicographically, as that is the trend in tkcoin.
 * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}
 * interface.
 *
 * @param {Array} publicKeys - a set of public keys to create an address
 * @param {number} threshold - the number of signatures needed to release the funds
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored
 * @return {Address}
 */
Address.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {
  network = network || publicKeys[0].network || Networks.defaultNetwork;
  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {
    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');
  }
  if (nestedWitness || type === Address.PayToWitnessScriptHash) {
    publicKeys = _.map(publicKeys, PublicKey);
    for (var i = 0; i < publicKeys.length; i++) {
      if (!publicKeys[i].compressed) {
        throw new TypeError('Witness addresses must use compressed public keys.');
      }
    }
  }
  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);
  if (nestedWitness) {
    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);
  }
  return Address.payingTo(redeemScript, network, type);
};

/**
 * Internal function to transform a tkcoin address string
 *
 * @param {string} data
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'
 * @returns {Object} An object with keys: hashBuffer, network and type
 * @private
 */
Address._transformString = function(data, network, type) {
  if (typeof(data) !== 'string') {
    throw new TypeError('data parameter supplied is not a string.');
  }

  if(data.length > 100) {
    throw new TypeError('address string is too long');
  }

  if (network && !Networks.get(network)) {
    throw new TypeError('Unknown network');
  }

  data = data.trim();

  try {
    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);
    return info;
  } catch (e) {
    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash) {
      throw e;
    }
  }

  var addressBuffer = Base58Check.decode(data);
  var info = Address._transformBuffer(addressBuffer, network, type);
  return info;
};

/**
 * Instantiate an address from a PublicKey instance
 *
 * @param {PublicKey} data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromPublicKey = function(data, network, type) {
  var info = Address._transformPublicKey(data, network, type);
  network = network || Networks.defaultNetwork;
  return new Address(info.hashBuffer, network, info.type);
};

/**
 * Instantiate an address from a ripemd160 public key hash
 *
 * @param {Buffer} hash - An instance of buffer of the hash
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromPublicKeyHash = function(hash, network) {
  var info = Address._transformHash(hash);
  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);
};

/**
 * Instantiate an address from a ripemd160 script hash
 *
 * @param {Buffer} hash - An instance of buffer of the hash
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromScriptHash = function(hash, network, type) {
  $.checkArgument(hash, 'hash parameter is required');
  var info = Address._transformHash(hash);
  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {
      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');
  }
  var type = type || Address.PayToScriptHash;
  return new Address(info.hashBuffer, network, type);
};

/**
 * Builds a p2sh address paying to script. This will hash the script and
 * use that to create the address.
 * If you want to extract an address associated with a script instead,
 * see {{Address#fromScript}}
 *
 * @param {Script} script - An instance of Script
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - Either 'scripthash' or 'witnessscripthash'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.payingTo = function(script, network, type) {
  $.checkArgument(script, 'script is required');
  $.checkArgument(script instanceof Script, 'script must be instance of Script');
  var hash;
  if (type === Address.PayToWitnessScriptHash) {
    hash = Hash.sha256(script.toBuffer());
  } else {
    hash = Hash.sha256ripemd160(script.toBuffer());
  }
  var type = type || Address.PayToScriptHash;
  return Address.fromScriptHash(hash, network, type);
};

/**
 * Extract address from a Script. The script must be of one
 * of the following types: p2pkh input, p2pkh output, p2sh input
 * or p2sh output.
 * This will analyze the script and extract address information from it.
 * If you want to transform any script to a p2sh Address paying
 * to that script's hash instead, use {{Address#payingTo}}
 *
 * @param {Script} script - An instance of Script
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromScript = function(script, network) {
  $.checkArgument(script instanceof Script, 'script must be a Script instance');
  var info = Address._transformScript(script, network);
  return new Address(info.hashBuffer, network, info.type);
};

/**
 * Instantiate an address from a buffer of the address
 *
 * @param {Buffer} buffer - An instance of buffer of the address
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromBuffer = function(buffer, network, type) {
  var info = Address._transformBuffer(buffer, network, type);
  return new Address(info.hashBuffer, info.network, info.type);
};

/**
 * Instantiate an address from an address string
 *
 * @param {string} str - An string of the tkcoin address
 * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string=} type - The type of address: 'script' or 'pubkey'
 * @returns {Address} A new valid and frozen instance of an Address
 */
Address.fromString = function(str, network, type) {
  var info = Address._transformString(str, network, type);
  return new Address(info.hashBuffer, info.network, info.type);
};

/**
 * Instantiate an address from an Object
 *
 * @param {string} json - An JSON string or Object with keys: hash, network and type
 * @returns {Address} A new valid instance of an Address
 */
Address.fromObject = function fromObject(obj) {
  $.checkState(
    JSUtil.isHexa(obj.hash),
    'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
  );
  var hashBuffer = Buffer.from(obj.hash, 'hex');
  return new Address(hashBuffer, obj.network, obj.type);
};

/**
 * Will return a validation error if exists
 *
 * @example
 * ```javascript
 * // a network mismatch error
 * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');
 * ```
 *
 * @param {string} data - The encoded data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - The type of address: 'script' or 'pubkey'
 * @returns {null|Error} The corresponding error message
 */
Address.getValidationError = function(data, network, type) {
  var error;
  try {
    /* jshint nonew: false */
    new Address(data, network, type);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Will return a boolean if an address is valid
 *
 * @example
 * ```javascript
 * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));
 * ```
 *
 * @param {string} data - The encoded data
 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
 * @param {string} type - The type of address: 'script' or 'pubkey'
 * @returns {boolean} The corresponding error message
 */
Address.isValid = function(data, network, type) {
  return !Address.getValidationError(data, network, type);
};

/**
 * Returns true if an address is of pay to public key hash type
 * @return boolean
 */
Address.prototype.isPayToPublicKeyHash = function() {
  return this.type === Address.PayToPublicKeyHash;
};

/**
 * Returns true if an address is of pay to script hash type
 * @return boolean
 */
Address.prototype.isPayToScriptHash = function() {
  return this.type === Address.PayToScriptHash;
};

/**
 * Returns true if an address is of pay to witness public key hash type
 * @return boolean
 */
Address.prototype.isPayToWitnessPublicKeyHash = function() {
  return this.type === Address.PayToWitnessPublicKeyHash;
};

/**
 * Returns true if an address is of pay to witness script hash type
 * @return boolean
 */
Address.prototype.isPayToWitnessScriptHash = function() {
  return this.type === Address.PayToWitnessScriptHash;
};

/**
 * Will return a buffer representation of the address
 *
 * @returns {Buffer} TKCoin address buffer
 */
Address.prototype.toBuffer = function() {
  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
    return Buffer.from(this.toString(), 'utf8')
  }
  var version = Buffer.from([this.network[this.type]]);
  return Buffer.concat([version, this.hashBuffer]);
};

/**
 * @returns {Object} A plain object with the address information
 */
Address.prototype.toObject = Address.prototype.toJSON = function toObject() {
  return {
    hash: this.hashBuffer.toString('hex'),
    type: this.type,
    network: this.network.toString()
  };
};

/**
 * Will return a the string representation of the address
 *
 * @returns {string} TKCoin address
 */
Address.prototype.toString = function() {
  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
    var prefix = this.network.bech32prefix;
    var version = 0; // Only supporting segwit v0 for now
    return Bech32.encode(prefix, version, this.hashBuffer);
  }
  return Base58Check.encode(this.toBuffer());
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} TKCoin address
 */
Address.prototype.inspect = function() {
  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';
};

module.exports = Address;

var Script = __webpack_require__(106);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 143:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PushNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fcm_ng__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fcm_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_fcm_ng__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_bitcore_wallet_client__ = __webpack_require__(798);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_bitcore_wallet_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_bitcore_wallet_client__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash__);








// providers







let PushNotificationsProvider = class PushNotificationsProvider {
    constructor(http, profileProvider, platformProvider, configProvider, logger, appProvider, bwcProvider, FCMPlugin, events, toastCtrl, translate) {
        this.http = http;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.FCMPlugin = FCMPlugin;
        this.events = events;
        this.toastCtrl = toastCtrl;
        this.translate = translate;
        this._token = null;
        this.toasts = [];
        this.logger.debug('PushNotificationsProvider initialized');
        this.isIOS = this.platformProvider.isIOS;
        this.isAndroid = this.platformProvider.isAndroid;
        this.usePushNotifications = this.platformProvider.isCordova;
    }
    init() {
        if (!this.usePushNotifications || this._token)
            return;
        this.configProvider.load().then(() => {
            const config = this.configProvider.get();
            if (!config.pushNotifications.enabled)
                return;
            this.logger.debug('Starting push notification registration...');
            // Keep in mind the function will return null if the token has not been established yet.
            this.FCMPlugin.getToken().then(token => {
                if (!token) {
                    setTimeout(() => {
                        this.init();
                    }, 5000);
                    return;
                }
                this.logger.debug('Get token for push notifications: ' + token);
                this._token = token;
                this.enable();
                this.handlePushNotifications();
                // enabling topics
                if (this.appProvider.info.name != 'copay' &&
                    config.offersAndPromotions.enabled)
                    this.subscribeToTopic('offersandpromotions');
                if (this.appProvider.info.name != 'copay' &&
                    config.productsUpdates.enabled)
                    this.subscribeToTopic('productsupdates');
                this.fcmInterval = setInterval(() => {
                    this.renewSubscription();
                }, 5 * 60 * 1000); // 5 min
            });
        });
    }
    renewSubscription() {
        const opts = {
            showHidden: false
        };
        const wallets = this.profileProvider.getWallets(opts);
        __WEBPACK_IMPORTED_MODULE_14_lodash__["forEach"](wallets, walletClient => {
            this._unsubscribe(walletClient);
        });
        setTimeout(() => {
            this.updateSubscription(wallets);
        }, 1000);
    }
    handlePushNotifications() {
        if (this.usePushNotifications) {
            this.FCMPlugin.onNotification().subscribe((data) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                if (!this._token)
                    return;
                this.logger.debug('New Event Push onNotification: ' + JSON.stringify(data));
                if (data.wasTapped) {
                    // Notification was received on device tray and tapped by the user.
                    if (data.redir) {
                        this.events.publish('IncomingDataRedir', { name: data.redir });
                    }
                    else if (data.takeover_url &&
                        data.takeover_image &&
                        data.takeover_sig) {
                        if (!this.verifySignature(data))
                            return;
                        this.events.publish('ShowAdvertising', data);
                    }
                    else {
                        this._openWallet(data);
                    }
                }
                else {
                    const wallet = this.findWallet(data.walletId, data.tokenAddress);
                    if (!wallet)
                        return;
                    this.newBwsEvent(data, wallet.credentials.walletId);
                    this.showToastNotification(data);
                }
            }));
        }
    }
    newBwsEvent(notification, walletId) {
        let id = walletId;
        if (notification.tokenAddress) {
            id = walletId + '-' + notification.tokenAddress.toLowerCase();
            this.logger.debug(`event for token wallet: ${id}`);
        }
        this.events.publish('bwsEvent', id, notification.notification_type, notification);
    }
    updateSubscription(walletClient) {
        if (!this._token) {
            this.logger.warn('Push notifications disabled for this device. Nothing to do here.');
            return;
        }
        if (!__WEBPACK_IMPORTED_MODULE_14_lodash__["isArray"](walletClient))
            walletClient = [walletClient];
        walletClient.forEach(w => {
            this._subscribe(w);
        });
    }
    enable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot set push notifications. Needs registration.');
            return;
        }
        const opts = {
            showHidden: false
        };
        const wallets = this.profileProvider.getWallets(opts);
        __WEBPACK_IMPORTED_MODULE_14_lodash__["forEach"](wallets, walletClient => {
            this._subscribe(walletClient);
        });
    }
    disable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot disable push notifications.');
            return;
        }
        // disabling topics
        this.unsubscribeFromTopic('offersandpromotions');
        this.unsubscribeFromTopic('productsupdates');
        const opts = {
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        __WEBPACK_IMPORTED_MODULE_14_lodash__["forEach"](wallets, walletClient => {
            this._unsubscribe(walletClient);
        });
        this._token = null;
        clearInterval(this.fcmInterval);
    }
    unsubscribe(walletClient) {
        if (!this._token)
            return;
        this._unsubscribe(walletClient);
    }
    subscribeToTopic(topic) {
        this.FCMPlugin.subscribeToTopic(topic);
    }
    unsubscribeFromTopic(topic) {
        this.FCMPlugin.unsubscribeFromTopic(topic);
    }
    _subscribe(walletClient) {
        const opts = {
            token: this._token,
            platform: this.isIOS ? 'ios' : this.isAndroid ? 'android' : null,
            packageName: this.appProvider.info.packageNameId,
            walletId: walletClient.credentials.walletId
        };
        walletClient.pushNotificationsSubscribe(opts, err => {
            if (err)
                this.logger.error(walletClient.name + ': Subscription Push Notifications error. ', err.message);
            else
                this.logger.debug(walletClient.name + ': Subscription Push Notifications success.');
        });
    }
    _unsubscribe(walletClient) {
        walletClient.pushNotificationsUnsubscribe(this._token, err => {
            if (err)
                this.logger.error(walletClient.name + ': Unsubscription Push Notifications error. ', err.message);
            else
                this.logger.debug(walletClient.name + ': Unsubscription Push Notifications Success.');
        });
    }
    _openWallet(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const walletIdHashed = data.walletId;
            const tokenAddress = data.tokenAddress;
            const multisigContractAddress = data.multisigContractAddress;
            if (!walletIdHashed)
                return;
            const wallet = this.findWallet(walletIdHashed, tokenAddress, multisigContractAddress);
            if (!wallet || this.openWalletId === wallet.credentials.walletId)
                return;
            this.openWalletId = wallet.credentials.walletId; // avoid opening the same wallet many times
            yield __WEBPACK_IMPORTED_MODULE_6_rxjs__["Observable"].timer(1000).toPromise(); // wait for subscription to OpenWallet event
            this.events.publish('OpenWallet', wallet);
        });
    }
    findWallet(walletIdHashed, tokenAddress, multisigContractAddress) {
        let walletIdHash;
        const sjcl = this.bwcProvider.getSJCL();
        const wallets = this.profileProvider.getWallets();
        const wallet = __WEBPACK_IMPORTED_MODULE_14_lodash__["find"](wallets, w => {
            if (tokenAddress || multisigContractAddress) {
                const walletId = w.credentials.walletId;
                const lastHyphenPosition = walletId.lastIndexOf('-');
                const walletIdWithoutTokenAddress = walletId.substring(0, lastHyphenPosition);
                walletIdHash = sjcl.hash.sha256.hash(walletIdWithoutTokenAddress);
            }
            else {
                walletIdHash = sjcl.hash.sha256.hash(w.credentials.walletId);
            }
            return __WEBPACK_IMPORTED_MODULE_14_lodash__["isEqual"](walletIdHashed, sjcl.codec.hex.fromBits(walletIdHash));
        });
        return wallet;
    }
    clearAllNotifications() {
        if (!this._token)
            return;
        this.FCMPlugin.clearAllNotifications();
    }
    verifySignature(data) {
        const pubKey = this.appProvider.info.marketingPublicKey;
        if (!pubKey)
            return false;
        const b = __WEBPACK_IMPORTED_MODULE_13_bitcore_wallet_client___default.a.Bitcore;
        const ECDSA = b.crypto.ECDSA;
        const Hash = b.crypto.Hash;
        const SEP = '::';
        const _takeover_url = data.takeover_url;
        const _takeover_image = data.takeover_image;
        const _takeover_sig = data.takeover_sig;
        const sigObj = b.crypto.Signature.fromString(_takeover_sig);
        const _hashbuf = Hash.sha256(Buffer.from(_takeover_url + SEP + _takeover_image));
        const verificationResult = ECDSA.verify(_hashbuf, sigObj, new b.PublicKey(pubKey), 'little');
        return verificationResult;
    }
    showToastNotification(data) {
        if (!data.body || data.notification_type === 'NewOutgoingTx')
            return;
        this.toasts.unshift(data);
        this.runToastQueue();
    }
    runToastQueue() {
        if (this.currentToast)
            return;
        this.toasts.some(data => {
            if (!data.showDone) {
                this.currentToast = this.toastCtrl.create({
                    message: `${data.title}\n${data.body}`,
                    duration: 5000,
                    position: 'top',
                    showCloseButton: true,
                    closeButtonText: this.translate.instant('Open Wallet'),
                    cssClass: 'toast-bg'
                });
                this.currentToast.onDidDismiss((_opt, role) => {
                    if (role === 'close')
                        this._openWallet(data);
                    this.currentToast = null;
                    this.runToastQueue();
                });
                this.currentToast.present();
                data.showDone = true;
                return true;
            }
            return false;
        });
    }
};
PushNotificationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_12__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_9__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4_fcm_ng__["FCMNG"],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["s" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], PushNotificationsProvider);

//# sourceMappingURL=push-notifications.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2).Buffer))

/***/ }),

/***/ 144:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_address_book_address_book__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_index__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_time_time__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pages_backup_backup_key_backup_key__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pages_exchange_crypto_exchange_crypto__ = __webpack_require__(517);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__pages_send_send__ = __webpack_require__(1025);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__pages_tx_details_tx_details__ = __webpack_require__(1028);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__pages_wallets_proposals_notifications_proposals_notifications__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__search_tx_modal_search_tx_modal__ = __webpack_require__(1029);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__wallet_balance_wallet_balance__ = __webpack_require__(1030);







// import env from '../../environments';
// providers


// import { BuyCryptoProvider } from '../../providers/buy-crypto/buy-crypto';




// import { ExchangeCryptoProvider } from '../../providers/exchange-crypto/exchange-crypto';








// pages









const HISTORY_SHOW_LIMIT = 10;
const MIN_UPDATE_TIME = 2000;
const TIMEOUT_FOR_REFRESHER = 1000;
let WalletDetailsPage = class WalletDetailsPage {
    constructor(currencyProvider, navParams, navCtrl, walletProvider, addressbookProvider, events, 
        // public giftCardProvider: GiftCardProvider,
        logger, timeProvider, translate, modalCtrl, externalLinkProvider, actionSheetProvider, platform, profileProvider, viewCtrl, platformProvider, socialSharing, bwcErrorProvider, errorsProvider, themeProvider, configProvider, analyticsProvider, 
        // TODO FIX BUY and EXCHANGE DISABLED/HIDDEN
        // private buyCryptoProvider: BuyCryptoProvider,
        // private exchangeCryptoProvider: ExchangeCryptoProvider,
        appProvider) {
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.walletProvider = walletProvider;
        this.addressbookProvider = addressbookProvider;
        this.events = events;
        this.logger = logger;
        this.timeProvider = timeProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.platform = platform;
        this.profileProvider = profileProvider;
        this.viewCtrl = viewCtrl;
        this.platformProvider = platformProvider;
        this.socialSharing = socialSharing;
        this.bwcErrorProvider = bwcErrorProvider;
        this.errorsProvider = errorsProvider;
        this.themeProvider = themeProvider;
        this.configProvider = configProvider;
        this.analyticsProvider = analyticsProvider;
        this.appProvider = appProvider;
        this.currentPage = 0;
        this.showBackupNeededMsg = true;
        this.history = [];
        this.groupedHistory = [];
        this.updatingTxHistoryProgress = 0;
        this.showBalanceButton = false;
        this.addressbook = {};
        this.txps = [];
        this.updateAll = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"]((opts) => {
            opts = opts || {};
            this.events.publish('Local/WalletFocus', {
                walletId: this.wallet.credentials.walletId,
                force: true
            });
        }, MIN_UPDATE_TIME, {
            leading: true
        });
        // no network //
        this.updateHistory = opts => {
            this.logger.debug('RECV Local/WalletHistoryUpdate @walletDetails', opts);
            if (opts.walletId != this.wallet.id)
                return;
            if (opts.finished) {
                this.updatingTxHistoryProgress = 0;
                this.updatingTxHistory = false;
                this.updateTxHistoryError = false;
                const hasTx = !!this.wallet.completeHistory[0];
                this.showNoTransactionsYetMsg = !hasTx;
                if (this.wallet.needsBackup && hasTx && this.showBackupNeededMsg)
                    this.openBackupModal();
                this.showHistory();
            }
            else {
                if (opts.error) {
                    this.updatingTxHistory = false;
                    this.updateTxHistoryError = true;
                    // show what we have.
                    this.showHistory();
                }
                else {
                    this.updatingTxHistory = true;
                    this.updatingTxHistoryProgress = opts.progress;
                    this.updateTxHistoryError = false;
                    // show what we have
                    this.showHistory();
                    // Hide prev history if long downlad is happending...
                    //  if (opts.progress > 5) {
                    //  this.history = null;
                    //  }
                }
            }
        };
        // no network //
        this.updateStatus = opts => {
            if (opts.walletId != this.wallet.id)
                return;
            this.logger.debug('RECV Local/WalletUpdate @walletDetails', opts);
            if (!opts.finished) {
                this.updatingStatus = true;
                return;
            }
            this.updatingStatus = false;
            if (!this.wallet.error) {
                this.logger.debug(' Updating wallet with amount ', this.wallet.cachedStatus.balance.totalAmount);
                let status = this.wallet.cachedStatus;
                this.setPendingTxps(status.pendingTxps);
                this.showBalanceButton = status.totalBalanceSat != status.spendableAmount;
                const minXrpBalance = 20000000; // 20 XRP * 1e6
                if (this.wallet.coin === 'xrp') {
                    this.showBalanceButton =
                        status.totalBalanceSat &&
                            status.totalBalanceSat != status.spendableAmount + minXrpBalance;
                }
                if (this.isUtxoCoin()) {
                    this.analyzeUtxos();
                }
                this.updateStatusError = null;
                this.walletNotRegistered = false;
            }
            else {
                this.showBalanceButton = false;
                let err = this.wallet.errorObj;
                if (err.name && err.name.match(/WALLET_NOT_FOUND/)) {
                    this.walletNotRegistered = true;
                }
                if (err === 'WALLET_NOT_REGISTERED') {
                    this.walletNotRegistered = true;
                }
                else {
                    this.updateStatusError = this.wallet.errorObj;
                }
            }
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.isCordova = this.platformProvider.isCordova;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        // this.supportedCards = this.giftCardProvider.getSupportedCardMap();
        this.useLegacyQrCode = this.configProvider.get().legacyQrCode.show;
        this.isDarkModeEnabled = this.themeProvider.isDarkModeEnabled();
        // TODO FIX BUY and EXCHANGE DISABLED/HIDDEN
        this.showBuyCrypto = false;
        this.showExchangeCrypto = false;
        /*
        this.showBuyCrypto =
          _.includes(
            this.buyCryptoProvider.exchangeCoinsSupported,
            this.wallet.coin
          ) &&
          (this.wallet.network == 'livenet' ||
            (this.wallet.network == 'testnet' && env.name == 'development'));
        this.showExchangeCrypto =
          _.includes(
            this.exchangeCryptoProvider.exchangeCoinsSupported,
            this.wallet.coin
          ) && this.wallet.network == 'livenet';
        */
        // Getting info from cache
        if (this.navParams.data.clearCache) {
            this.clearHistoryCache();
        }
        else {
            if (this.wallet.completeHistory)
                this.showHistory();
            else
                this.fetchTxHistory({
                    walletId: this.wallet.credentials.walletId,
                    force: true
                });
        }
        this.requiresMultipleSignatures = this.wallet.credentials.m > 1;
        this.addressbookProvider
            .list()
            .then(ab => {
            this.addressbook = ab;
        })
            .catch(err => {
            this.logger.error(err);
        });
        let defaults = this.configProvider.getDefaults();
        this.blockexplorerUrl = defaults.blockExplorerUrl[this.wallet.coin];
        this.blockexplorerUrlTestnet =
            defaults.blockExplorerUrlTestnet[this.wallet.coin];
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.updateStatus);
        this.events.subscribe('Local/WalletHistoryUpdate', this.updateHistory);
    }
    ionViewWillEnter() {
        this.backgroundColor = this.themeProvider.getThemeInfo().walletDetailsBackgroundStart;
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.profileProvider.setFastRefresh(this.wallet);
            this.subscribeEvents();
        });
        this.profileProvider.setFastRefresh(this.wallet);
        this.events.publish('Local/WalletFocus', {
            walletId: this.wallet.credentials.walletId
        });
        this.subscribeEvents();
    }
    ionViewWillLeave() {
        this.profileProvider.setSlowRefresh(this.wallet);
        this.events.unsubscribe('Local/WalletUpdate', this.updateStatus);
        this.events.unsubscribe('Local/WalletHistoryUpdate', this.updateHistory);
        this.onResumeSubscription.unsubscribe();
    }
    shouldShowZeroState() {
        return this.showNoTransactionsYetMsg && !this.updateStatusError;
    }
    shouldShowSpinner() {
        return ((this.updatingStatus || this.updatingTxHistory) &&
            !this.walletNotRegistered &&
            !this.updateStatusError &&
            !this.updateTxHistoryError);
    }
    fetchTxHistory(opts) {
        if (!opts.walletId) {
            this.logger.error('Error no walletId in update History');
            return;
        }
        const progressFn = ((_, newTxs) => {
            let args = {
                walletId: opts.walletId,
                finished: false,
                progress: newTxs
            };
            this.events.publish('Local/WalletHistoryUpdate', args);
        }).bind(this);
        // Fire a startup event, to allow UI to show the spinner
        this.events.publish('Local/WalletHistoryUpdate', {
            walletId: opts.walletId,
            finished: false
        });
        this.walletProvider
            .fetchTxHistory(this.wallet, progressFn, opts)
            .then(txHistory => {
            this.wallet.completeHistory = txHistory;
            this.events.publish('Local/WalletHistoryUpdate', {
                walletId: opts.walletId,
                finished: true
            });
        })
            .catch(err => {
            if (err != 'HISTORY_IN_PROGRESS') {
                this.logger.warn('WalletHistoryUpdate ERROR', err);
                this.events.publish('Local/WalletHistoryUpdate', {
                    walletId: opts.walletId,
                    finished: false,
                    error: err
                });
            }
        });
    }
    isUtxoCoin() {
        return this.currencyProvider.isUtxoCoin(this.wallet.coin);
    }
    clearHistoryCache() {
        this.history = [];
        this.currentPage = 0;
    }
    groupHistory(history) {
        return history.reduce((groups, tx, txInd) => {
            this.isFirstInGroup(txInd)
                ? groups.push([tx])
                : groups[groups.length - 1].push(tx);
            return groups;
        }, []);
    }
    showHistory(loading) {
        if (!this.wallet.completeHistory)
            return;
        this.history = this.wallet.completeHistory.slice(0, (this.currentPage + 1) * HISTORY_SHOW_LIMIT);
        this.zone.run(() => {
            this.groupedHistory = this.groupHistory(this.history);
        });
        if (loading)
            this.currentPage++;
    }
    setPendingTxps(txps) {
        this.txps = !txps ? [] : __WEBPACK_IMPORTED_MODULE_5_lodash__["sortBy"](txps, 'createdOn').reverse();
        this.txpsPending = [];
        this.txps.forEach(txp => {
            const action = __WEBPACK_IMPORTED_MODULE_5_lodash__["find"](txp.actions, {
                copayerId: txp.wallet.copayerId
            });
            if ((!action || action.type === 'failed') && txp.status == 'pending') {
                this.txpsPending.push(txp);
            }
            // For unsent transactions
            if (action && txp.status == 'accepted') {
                this.txpsPending.push(txp);
            }
        });
    }
    openProposalsNotificationsPage() {
        if (this.wallet.credentials.multisigEthInfo) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_26__pages_wallets_proposals_notifications_proposals_notifications__["a" /* ProposalsNotificationsPage */], {
                multisigContractAddress: this.wallet.credentials.multisigEthInfo
                    .multisigContractAddress
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_26__pages_wallets_proposals_notifications_proposals_notifications__["a" /* ProposalsNotificationsPage */], {
                walletId: this.wallet.id
            });
        }
    }
    toggleBalance() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    loadHistory(loading) {
        if (this.history &&
            this.wallet.completeHistory &&
            this.history.length === this.wallet.completeHistory.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.showHistory(true); // loading in true
            loading.complete();
        }, 300);
    }
    analyzeUtxos() {
        if (this.analyzeUtxosDone)
            return;
        this.walletProvider
            .getLowUtxos(this.wallet)
            .then(resp => {
            if (!resp)
                return;
            this.analyzeUtxosDone = true;
            this.lowUtxosWarning = !!resp.warning;
            // this.logger.debug('Low UTXOs warning: ', this.lowUtxosWarning);
        })
            .catch(err => {
            this.logger.warn('Analyze UTXOs: ', err);
        });
    }
    itemTapped(tx) {
        if (tx.hasUnconfirmedInputs) {
            const infoSheet = this.actionSheetProvider.createInfoSheet('unconfirmed-inputs');
            infoSheet.present();
            infoSheet.onDidDismiss(() => {
                this.goToTxDetails(tx);
            });
        }
        else if (tx.isRBF) {
            const infoSheet = this.actionSheetProvider.createInfoSheet('rbf-tx');
            infoSheet.present();
            infoSheet.onDidDismiss(option => {
                option ? this.speedUpTx(tx) : this.goToTxDetails(tx);
            });
        }
        else if (this.canSpeedUpTx(tx)) {
            const infoSheet = this.actionSheetProvider.createInfoSheet('speed-up-tx');
            infoSheet.present();
            infoSheet.onDidDismiss(option => {
                option ? this.speedUpTx(tx) : this.goToTxDetails(tx);
            });
        }
        else {
            this.goToTxDetails(tx);
        }
    }
    speedUpTx(tx) {
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            const data = {
                amount: 0,
                network: this.wallet.network,
                coin: this.wallet.coin,
                speedUpTx: true,
                toAddress: addr,
                walletId: this.wallet.credentials.walletId,
                fromWalletDetails: true,
                txid: tx.txid,
                recipientType: 'wallet',
                name: this.wallet.name
            };
            const nextView = {
                name: 'ConfirmPage',
                params: data
            };
            this.events.publish('IncomingDataRedir', nextView);
        });
    }
    goToTxDetails(tx) {
        const txDetailModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_25__pages_tx_details_tx_details__["a" /* TxDetailsModal */], {
            walletId: this.wallet.credentials.walletId,
            txid: tx.txid
        });
        txDetailModal.present();
    }
    openBackupModal() {
        this.showBackupNeededMsg = false;
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-needed-with-activity');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option)
                this.openBackup();
        });
    }
    openBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__pages_backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId: this.wallet.credentials.keyId
        });
    }
    openAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_24__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    getDate(txCreated) {
        const date = new Date(txCreated * 1000);
        return date;
    }
    trackByFn(index) {
        return index;
    }
    isFirstInGroup(index) {
        if (index === 0) {
            return true;
        }
        const curTx = this.history[index];
        const prevTx = this.history[index - 1];
        return !this.createdDuringSameMonth(curTx, prevTx);
    }
    createdDuringSameMonth(curTx, prevTx) {
        return this.timeProvider.withinSameMonth(curTx.time * 1000, prevTx.time * 1000);
    }
    isDateInCurrentMonth(date) {
        return this.timeProvider.isDateInCurrentMonth(date);
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    isUnconfirmed(tx) {
        return !tx.confirmations || tx.confirmations === 0;
    }
    canSpeedUpTx(tx) {
        if (this.wallet.coin !== 'btc')
            return false;
        const currentTime = __WEBPACK_IMPORTED_MODULE_6_moment__();
        const txTime = __WEBPACK_IMPORTED_MODULE_6_moment__(tx.time * 1000);
        // Can speed up the tx after 4 hours without confirming
        return (currentTime.diff(txTime, 'hours') >= 4 &&
            this.isUnconfirmed(tx) &&
            tx.action === 'received');
    }
    openBalanceDetails() {
        let walletBalanceModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_29__wallet_balance_wallet_balance__["a" /* WalletBalanceModal */], {
            status: this.wallet.cachedStatus
        });
        walletBalanceModal.present();
    }
    back() {
        this.navCtrl.pop();
    }
    openSearchModal() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_28__search_tx_modal_search_tx_modal__["a" /* SearchTxModalPage */], {
            addressbook: this.addressbook,
            completeHistory: this.wallet.completeHistory,
            wallet: this.wallet
        }, { showBackdrop: false, enableBackdropDismiss: true });
        modal.present();
        modal.onDidDismiss(data => {
            if (!data || !data.txid)
                return;
            this.goToTxDetails(data);
        });
    }
    openExternalLink(url) {
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    doRefresh(refresher) {
        this.updateAll({ force: true });
        setTimeout(() => {
            refresher.complete();
        }, TIMEOUT_FOR_REFRESHER);
    }
    close() {
        this.viewCtrl.dismiss();
    }
    goToReceivePage() {
        if (this.wallet && this.wallet.isComplete() && this.wallet.needsBackup) {
            const needsBackup = this.actionSheetProvider.createNeedsBackup();
            needsBackup.present();
            needsBackup.onDidDismiss(data => {
                if (data === 'goToBackup')
                    this.goToBackup();
            });
        }
        else {
            const params = {
                wallet: this.wallet
            };
            const receive = this.actionSheetProvider.createWalletReceive(params);
            receive.present();
            receive.onDidDismiss(data => {
                if (data)
                    this.showErrorInfoSheet(data);
            });
        }
    }
    goToSendPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_23__pages_send_send__["a" /* SendPage */], {
            wallet: this.wallet
        });
    }
    goToExchangeCryptoPage() {
        if (this.wallet && this.wallet.isComplete() && this.wallet.needsBackup) {
            const needsBackup = this.actionSheetProvider.createNeedsBackup();
            needsBackup.present();
            needsBackup.onDidDismiss(data => {
                if (data === 'goToBackup')
                    this.goToBackup();
            });
        }
        else {
            this.analyticsProvider.logEvent('exchange_crypto_button_clicked', {
                from: 'walletDetails',
                coin: this.wallet.coin
            });
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_22__pages_exchange_crypto_exchange_crypto__["a" /* ExchangeCryptoPage */], {
                walletId: this.wallet.id
            });
        }
    }
    goToBuyCryptoPage() {
        if (this.wallet && this.wallet.isComplete() && this.wallet.needsBackup) {
            const needsBackup = this.actionSheetProvider.createNeedsBackup();
            needsBackup.present();
            needsBackup.onDidDismiss(data => {
                if (data === 'goToBackup')
                    this.goToBackup();
            });
        }
        else {
            this.analyticsProvider.logEvent('buy_crypto_button_clicked', {
                from: 'walletDetails',
                coin: this.wallet.coin
            });
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_27__send_amount_amount__["a" /* AmountPage */], {
                coin: this.wallet.coin,
                fromBuyCrypto: true,
                nextPage: 'CryptoOrderSummaryPage',
                currency: this.configProvider.get().wallet.settings.alternativeIsoCode,
                walletId: this.wallet.id
            });
        }
    }
    showMoreOptions() {
        const showRequest = this.wallet && this.wallet.isComplete() && !this.wallet.needsBackup;
        const showShare = showRequest && this.isCordova;
        const optionsSheet = this.actionSheetProvider.createOptionsSheet('wallet-options', { showShare, showRequest });
        optionsSheet.present();
        optionsSheet.onDidDismiss(option => {
            if (option == 'request-amount')
                this.requestSpecificAmount();
            if (option == 'share-address')
                this.shareAddress();
        });
    }
    requestSpecificAmount() {
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_27__send_amount_amount__["a" /* AmountPage */], {
                toAddress: addr,
                id: this.wallet.credentials.walletId,
                recipientType: 'wallet',
                name: this.wallet.name,
                color: this.wallet.color,
                coin: this.wallet.coin,
                nextPage: 'CustomAmountPage',
                network: this.wallet.network
            });
        });
    }
    shareAddress() {
        if (!this.isCordova)
            return;
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            if (this.platformProvider.isAndroid)
                this.appProvider.skipLockModal = true;
            this.socialSharing.share(addr);
        });
    }
    showErrorInfoSheet(error) {
        const infoSheetTitle = this.translate.instant('Error');
        this.errorsProvider.showDefaultError(this.bwcErrorProvider.msg(error), infoSheetTitle);
    }
    goToBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__pages_backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId: this.wallet.credentials.keyId
        });
    }
    getBalance() {
        const lastKnownBalance = this.wallet.lastKnownBalance;
        if (this.wallet.coin === 'xrp') {
            const availableBalanceStr = this.wallet.cachedStatus &&
                this.wallet.cachedStatus.availableBalanceStr;
            return availableBalanceStr || lastKnownBalance;
        }
        else {
            const totalBalanceStr = this.wallet.cachedStatus && this.wallet.cachedStatus.totalBalanceStr;
            return totalBalanceStr || lastKnownBalance;
        }
    }
    getAlternativeBalance() {
        if (this.wallet.coin === 'xrp') {
            const availableAlternative = this.wallet.cachedStatus &&
                this.wallet.cachedStatus.availableBalanceAlternative;
            return availableAlternative;
        }
        else {
            const totalBalanceAlternative = this.wallet.cachedStatus &&
                this.wallet.cachedStatus.totalBalanceAlternative;
            return totalBalanceAlternative;
        }
    }
    viewOnBlockchain() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.wallet.coin !== 'eth' &&
                this.wallet.coin !== 'xrp' &&
                !this.currencyProvider.isERCToken(this.wallet.coin))
                return;
            const address = yield this.walletProvider.getAddress(this.wallet, false);
            let url;
            if (this.wallet.coin === 'xrp') {
                url =
                    this.wallet.credentials.network === 'livenet'
                        ? `https://${this.blockexplorerUrl}account/${address}`
                        : `https://${this.blockexplorerUrlTestnet}account/${address}`;
            }
            if (this.wallet.coin === 'eth') {
                url =
                    this.wallet.credentials.network === 'livenet'
                        ? `https://${this.blockexplorerUrl}address/${address}`
                        : `https://${this.blockexplorerUrlTestnet}address/${address}`;
            }
            if (this.currencyProvider.isERCToken(this.wallet.coin)) {
                url =
                    this.wallet.credentials.network === 'livenet'
                        ? `https://${this.blockexplorerUrl}address/${address}#tokentxns`
                        : `https://${this.blockexplorerUrlTestnet}address/${address}#tokentxns`;
            }
            let optIn = true;
            let title = null;
            let message = this.translate.instant('View History');
            let okText = this.translate.instant('Open');
            let cancelText = this.translate.instant('Go Back');
            this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
        });
    }
};
WalletDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/wallet-details.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="(expandableHeader.headerHeight - 200)" [scrollArea]="scrollArea">\n        {{wallet?.name}}\n      </div>\n    </ion-title>\n    <ion-buttons right class="settings-button">\n      <button class="option-button disable-hover" clear *ngIf="wallet?.isComplete() && !wallet?.needsBackup" (click)="showMoreOptions()" ion-button icon-only>\n        <ion-icon name="ios-more" md="ios-more"></ion-icon>\n      </button>\n      <button ion-button *ngIf="wallet && wallet?.completeHistory && wallet?.completeHistory.length > 4" class="search-button disable-hover" (click)="openSearchModal()">\n        <img src="assets/img/search.svg">\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce #scrollArea [fixed-scroll-bg-color]="backgroundColor">\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160" [ngStyle]="{\'background\': backgroundColor}">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea" #expandableHeader>\n      <expandable-header-primary class="balance-header">\n\n        <div *ngIf="wallet?.network == \'testnet\'" class="top-notification warning">\n          <a class="energized" (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/360004102011-What-is-testnet-How-do-I-avoid-testnet-Bitcoin-scams-\')">\n            {{\'Learn more about testnet blockchain\' | translate}}\n            <ion-icon name="arrow-forward"></ion-icon>\n          </a>\n        </div>\n\n        <div *ngIf="lowUtxosWarning && wallet?.network == \'livenet\'" class="top-notification warning">\n          <a class="energized" (click)="openAddresses()">\n            {{\'Spending this balance will need significant Bitcoin network fees\'|translate}}\n            <ion-icon name="arrow-forward"></ion-icon>\n          </a>\n        </div>\n\n        <div class="wallet-name">\n          {{wallet?.name}}\n        </div>\n\n        <div class="balance-content" (longPress)="toggleBalance()">\n          <div (tap)="updateAll(true)" *ngIf="!wallet?.balanceHidden && !wallet?.scanning && !walletNotRegistered && (wallet?.cachedStatus || wallet?.lastKnownBalance)">\n            <div class="balance-str">\n              <balance-to-show [balance]="getBalance()"></balance-to-show>\n              <img *ngIf="wallet.coin === \'xrp\'" width="21" (click)="openBalanceDetails()" src="assets/img/icon-info-blue.svg">\n            </div>\n            <div class="balance-alt-str" *ngIf="wallet?.cachedStatus && wallet?.cachedStatus.totalBalanceAlternative">\n              {{getAlternativeBalance()}} {{wallet?.cachedStatus.alternativeIsoCode}}\n            </div>\n          </div>\n\n          <div class="balance-hidden" *ngIf="!updateStatusError && wallet?.balanceHidden  && !wallet?.scanning">\n            <span class="title" translate>[Balance Hidden]</span>\n            <div translate>\n              Tap and hold to show\n            </div>\n          </div>\n        </div>\n\n        <div class="balance-scanning" *ngIf="!updateStatusError && wallet?.scanning">\n          <div>\n            <span class="title" translate>[Scanning Funds]</span>\n            <div translate>\n              Please wait...\n            </div>\n          </div>\n        </div>\n\n        <div class="balance-spendable" (click)="openBalanceDetails()" *ngIf="!wallet?.balanceHidden && !wallet?.scanning && !updateStatusError && showBalanceButton">\n          <ion-icon ios="ios-timer-outline" md="md-timer"></ion-icon>\n          <strong>\n            {{wallet?.cachedStatus.spendableBalanceStr}}\n          </strong>\n          &nbsp;\n          <span>\n            ({{wallet?.cachedStatus.spendableBalanceAlternative}} {{wallet?.cachedStatus.alternativeIsoCode}})\n          </span>\n          &rarr;\n        </div>\n\n        <div class="balance-error" *ngIf="updateStatusError">\n          <div>\n            <span ion-text color="warning">{{wallet?.error}}</span>\n          </div>\n        </div>\n\n        <div class="balance-error" *ngIf="walletNotRegistered">\n          <div translate>\n            This wallet is not registered at the given Bitcore Wallet Service (BWS). As an advice, you could delete the key, under settings and selecting the specific key, and then use the Backup to import the wallet again (under Home > Wallet Tab).\n          </div>\n        </div>\n      </expandable-header-primary>\n      <expandable-header-footer>\n        <div class="wallet-info" *ngIf="wallet">\n          <div class="left-buttons">\n            <img class="testnet" *ngIf="wallet?.network == \'testnet\'" src="assets/img/icon-wallet-testnet.svg">\n            <span class="square-border" *ngIf="wallet?.network == \'testnet\' && wallet?.coin == \'eth\'">\n              <span>KOVAN TESTNET</span>\n            </span>\n            <span class="square-border" *ngIf="wallet?.network == \'testnet\' && wallet?.coin != \'eth\'">\n              <span>TESTNET</span>\n            </span>\n            <img class="read-only" *ngIf="!wallet?.canSign" src="assets/img/settings-icons/icon-read-only.svg">\n            <span class="square-border" *ngIf="!wallet?.canSign">\n              <span>READ ONLY</span>\n            </span>\n            <span class="square-border" *ngIf="((wallet?.coin == \'btc\' || wallet?.coin == \'edu\' || wallet?.coin == \'tik\' ) && wallet?.isSegwit)">\n              <span>SEGWIT</span>\n            </span>\n            <span class="square-border" *ngIf="wallet?.cachedStatus && wallet?.cachedStatus.wallet && wallet?.cachedStatus.wallet?.singleAddress && isUtxoCoin()">\n              <span>AUDITABLE</span>\n            </span>\n            <span class="square-border" *ngIf="wallet?.usingCustomBWS">\n              <span>BWS</span>\n            </span>\n            <img class="encrypted" *ngIf="wallet?.isPrivKeyEncrypted" src="assets/img/icon-lock-black.svg">\n            <span class="square-border" *ngIf="wallet?.linkedEthWalletName">\n              <span>{{\'Linked to wallet: {linkedEthWalletName}\' | translate : {linkedEthWalletName: wallet?.linkedEthWalletName} }}</span>\n            </span>\n            <span class="square-border" *ngIf="wallet?.coin === \'xrp\' && wallet?.cachedStatus && wallet?.cachedStatus.lockedBalanceSat">\n              <span translate>ACTIVATED</span>\n            </span>\n            <span class="wallet-type" *ngIf="wallet?.credentials.n > 1">\n              <span>{{wallet?.m}}-{{wallet?.n}}</span>\n            </span>\n          </div>\n          <ion-spinner name="crescent" *ngIf="shouldShowSpinner()"></ion-spinner>\n        </div>\n        <div class="action-buttons" [ngClass]="{\'two-actions\': !showBuyCrypto && !showExchangeCrypto}">\n\n          <div class="action-btn" *ngIf="showBuyCrypto" (click)="goToBuyCryptoPage()">\n            <img [src]="themeProvider.currentAppTheme == \'dark\' ? \'assets/img/wallet-details/wd-buy-dm.svg\' : \'assets/img/wallet-details/wd-buy.svg\'" width="50">\n            <div class="ellipsis">{{ \'Buy\' | translate }}</div>\n          </div>\n\n          <div class="action-btn" *ngIf="showExchangeCrypto" (click)="goToExchangeCryptoPage()">\n            <img [src]="themeProvider.currentAppTheme == \'dark\' ? \'assets/img/wallet-details/wd-exchange-dm.svg\': \'assets/img/wallet-details/wd-exchange.svg\'" width="50">\n            <div class="ellipsis">{{ \'Exchange\' | translate }}</div>\n          </div>\n\n          <div class="action-btn" (click)="goToReceivePage()">\n            <img [src]="themeProvider.currentAppTheme == \'dark\' ? \'assets/img/wallet-details/wd-receive-dm.svg\' : \'assets/img/wallet-details/wd-receive.svg\'" width="50">\n            <div class="ellipsis">{{ \'Receive\' | translate }}</div>\n          </div>\n\n          <div class="action-btn" (click)="goToSendPage()">\n            <img [src]="themeProvider.currentAppTheme == \'dark\' ? \'assets/img/wallet-details/wd-send-dm.svg\' : \'assets/img/wallet-details/wd-send.svg\'" width="50">\n            <div class="ellipsis">{{ \'Send\' | translate }}</div>\n          </div>\n\n        </div>\n      </expandable-header-footer>\n    </expandable-header>\n\n    <ion-list *ngIf="wallet && wallet?.isComplete() && !walletNotRegistered && txps && txps[0]" class="tx-history">\n      <ion-item-divider *ngIf="wallet?.incorrectDerivation">\n        <span translate>\n          WARNING: Key derivation is not working on this device/wallet?. Actions cannot be performed on this wallet?.\n        </span>\n      </ion-item-divider>\n      <ion-item-divider class="tx-history-header tx-history-header--large">\n        <span *ngIf="requiresMultipleSignatures" translate>Pending Proposals</span>\n        <span *ngIf="!requiresMultipleSignatures" translate>Unsent transactions</span>\n        <button ion-button clear icon-only class="txps-badge" *ngIf="txps.length > 0" (click)="openProposalsNotificationsPage()">\n          <ion-badge>{{txps.length}}</ion-badge>\n        </button>\n      </ion-item-divider>\n      <div *ngFor="let txp of txpsPending;  let i=index">\n        <page-txp *ngIf="i<=2" [tx]="txp" [addressbook]="addressbook"></page-txp>\n      </div>\n      <ion-item *ngIf="wallet?.cachedStatus && wallet?.cachedStatus.lockedBalanceSat" class="locked-balance" (click)="openBalanceDetails()">\n        <span translate>Total Locked Balance</span>\n        <ion-note item-end>\n          <span class="total-locked-amount">{{wallet?.cachedStatus.lockedBalanceStr}}</span>\n          <div class="total-alt-locked-amount">{{wallet?.cachedStatus.lockedBalanceAlternative}}\n            {{wallet?.cachedStatus.alternativeIsoCode}}</div>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <!-- Transactions -->\n\n\n    <div class="prompt-user activity-fix white-card" *ngIf="shouldShowZeroState()">\n      <div class="title-icon larger-icon" *ngIf="!wallet?.credentials.multisigEthInfo">\n        <img *ngIf="wallet.coin === \'xrp\' && wallet.cachedStatus && !wallet.cachedStatus.lockedBalanceSat; else ghostTongue" width="42" src="assets/img/icon-warning-circled.svg" />\n        <ng-template #ghostTongue>\n          <img *ngIf="wallet.coin !== \'doge\'" src="assets/img/ghost-tongue-out.svg">\n          <img *ngIf="wallet.coin === \'doge\'" src="assets/img/sad-doge.svg">\n        </ng-template>\n      </div>\n      <div class="title-info">\n        <span translate *ngIf="wallet?.coin === \'xrp\' && wallet?.cachedStatus && !wallet?.cachedStatus.lockedBalanceSat; else ghostTown">XRP Minimum Balance</span>\n        <ng-template #ghostTown>\n          <span translate *ngIf="!wallet?.credentials.multisigEthInfo && wallet.coin !== \'doge\'">It\'s a ghost town in here</span>\n          <span translate *ngIf="!wallet?.credentials.multisigEthInfo && wallet.coin === \'doge\' ">A dog without funds is a sad dog</span>\n          <span translate *ngIf="wallet?.credentials.multisigEthInfo">Join more Copayers</span>\n        </ng-template>\n      </div>\n      <div class="subtitle-info">\n        <span translate *ngIf="wallet?.coin === \'xrp\' && wallet?.cachedStatus && !wallet?.cachedStatus.lockedBalanceSat; else noFunds">\n          The XRP ledger requires that all wallets maintain a minimum balance of 20 XRP. This non-refundable 20 XRP will remain permanently locked in your wallet. Please first deposit no less than 20 XRP to activate your wallet.\n        </span>\n        <ng-template #noFunds>\n          <span translate *ngIf="!wallet?.credentials.multisigEthInfo">\n            If you have funds stored on a website then you should move them into a secure wallet... like this one!\n          </span>\n          <span translate *ngIf="wallet?.credentials.multisigEthInfo">\n            Share this invitation with the Copayers who join this wallet.\n          </span>\n        </ng-template>\n      </div>\n      <div class="qr-container" *ngIf="wallet?.credentials.multisigEthInfo">\n        <bp-qr-code *ngIf="wallet?.credentials.multisigEthInfo.multisigContractAddress && !useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ wallet.credentials.multisigEthInfo.multisigContractAddress }}" contents="{{ wallet.credentials.multisigEthInfo.multisigContractAddress }}" mask-x-to-y-ratio="1">\n          <img [ngClass]="{\'testnet\': wallet.network === \'testnet\'}" src="assets/img/currencies/{{ wallet.coin }}.svg" slot="icon" />\n        </bp-qr-code>\n        <div *ngIf="wallet?.credentials.multisigEthInfo.multisigContractAddress && useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ wallet.credentials.multisigEthInfo.multisigContractAddress }}">\n          <ngx-qrcode hide-toast="true" qrc-value="{{ wallet.credentials.multisigEthInfo.multisigContractAddress }}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n        </div>\n      </div>\n    </div>\n\n    <div class="middle-message white-card" *ngIf="updateTxHistoryError" translate>\n      Could not update transaction history\n    </div>\n\n    <div class="middle-message white-card" *ngIf="updatingTxHistory && (!history[0] || updatingTxHistoryProgress>4)">\n      <span translate>Updating transaction history. Please stand by.</span>\n      <br>\n      <span translate *ngIf="updatingTxHistoryProgress>4">{{updatingTxHistoryProgress}} transactions downloaded</span>\n    </div>\n\n    <ion-list *ngIf="history && history[0]" class="tx-history">\n      <ion-item-group *ngFor="let group of groupedHistory; trackBy: trackByFn; let i = index;">\n\n        <ion-item-divider (click)="viewOnBlockchain()" sticky class="tx-history-header">\n          <span *ngIf="isDateInCurrentMonth(getDate(group[0].time))">{{ \'Recent\' | translate }} </span>\n          <span *ngIf="!isDateInCurrentMonth(getDate(group[0].time))">{{getDate(group[0].time) | amDateFormat:\'MMMM\'}}</span>\n        </ion-item-divider>\n\n        <div class="item-wrapper" *ngFor="let tx of group; trackBy: trackByFn; let i = index">\n\n          <button ion-item (click)="itemTapped(tx)" [ngClass]="{\'warning-background\': canSpeedUpTx(tx), \'danger-background\': tx.hasUnconfirmedInputs || tx.isRBF}">\n            <ion-icon class="item-img" item-start>\n              <div *ngIf="tx.confirmations <= 0">\n                <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n              </div>\n              <div *ngIf="tx.confirmations > 0">\n                <span *ngIf="tx.customData && tx.customData.service">\n                  <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'" width="40">\n                  <img class="icon-services" src="assets/img/exchange-crypto/changelly-icon.svg" *ngIf="tx.customData.service == \'changelly\'" width="40">\n                  <img-loader class="icon-services" *ngIf="tx.customData.service === \'amazon\'" src="https://tkcoin.org/gift-cards/assets/amazoncom/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                  <img-loader class="icon-services" *ngIf="tx.customData.service === \'mercadolibre\'" src="https://tkcoin.org/gift-cards/assets/mercadolivre/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                  <img-loader class="icon-services" *ngIf="tx.customData.service === \'coinbase\'" src="assets/img/coinbase/coinbase-icon.png" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                  <ng-container *ngIf="supportedCards | async as cardConfig">\n                    <img-loader class="icon-services" *ngIf="tx.customData.service === \'giftcards\'" [src]="cardConfig[tx.customData.giftCardName]?.icon" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                  </ng-container>\n                  <img class="icon-services" src="assets/img/tkcoin-card/icon-tkcoin.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n                </span>\n                <span *ngIf="tx.customData && tx.customData.toWalletName && !tx.customData.service">\n                  <img class="icon-services" src="assets/img/icon-wallet-reverse.svg" *ngIf="tx.action == \'sent\'" width="40">\n                </span>\n                <span *ngIf="!tx.customData || (tx.customData && !tx.customData.service && !tx.customData.toWalletName)">\n                  <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                </span>\n                <span>\n                  <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                  <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n                </span>\n              </div>\n            </ion-icon>\n\n            <div class="action" *ngIf="tx.confirmations <= 0 && !(tx.amount === 0 && wallet?.coin === \'eth\')">\n              <span *ngIf="(tx.action == \'sent\') && !(addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{\'Sending\'\n                    | translate}}\n              </span>\n              <span *ngIf="(tx.action == \'moved\') && !(addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{\'Moving\'\n                    | translate}}</span>\n              <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name\n                    || addressbook[tx.outputs[0].address]}}</span>\n              <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n            </div>\n\n            <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n              <span *ngIf="(!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address])">{{\'Received\'\n                    | translate}}</span>\n              <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n              <span *ngIf="(!tx.note || (tx.note && !tx.note.body)) && addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n              </span>\n            </div>\n\n            <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\' && !(tx.amount === 0 && wallet?.coin === \'eth\')">\n              <span *ngIf="(tx.message && (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)" translate>Sent</span>\n              <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)">{{\'Sent\'\n                    | translate}}</span>\n              <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (tx.customData && tx.customData.toWalletName)">\n                {{ \'Sent to {walletName}\' | translate: {walletName: tx.customData.toWalletName} }}\n              </span>\n              <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n              <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n              <span *ngIf="!tx.message && addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n              </span>\n            </div>\n\n            <div class="action" *ngIf="tx.amount === 0 && wallet?.coin === \'eth\'">\n              <span>{{\'Interaction with contract\' | translate}}</span>\n            </div>\n\n            <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n              <span *ngIf="(tx.message && (tx.note && !tx.note.body))" translate>Sent to self</span>\n              <span *ngIf="((!tx.note || (tx.note && !tx.note.body)) && !tx.message)" translate>Sent to self</span>\n              <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n              <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            </div>\n\n            <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n              <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n            </div>\n\n            <ion-note item-end text-end>\n              <div class="amount">\n                <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\' && !(tx.amount === 0 && wallet?.coin === \'eth\')">{{tx.amount |\n                      satToUnit: wallet?.coin}}</span>\n                <span *ngIf="tx.amount === 0 && wallet?.coin === \'eth\'">{{tx.fees | satToUnit: wallet?.coin}}</span>\n                <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n              </div>\n              <div class="date">\n                <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n                <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM\n                      D, YYYY\'}}</span>\n              </div>\n            </ion-note>\n          </button>\n        </div>\n      </ion-item-group>\n    </ion-list>\n\n    <ion-infinite-scroll (ionInfinite)="loadHistory($event)" *ngIf="!shouldShowZeroState()">\n      <ion-infinite-scroll-content></ion-infinite-scroll-content>\n    </ion-infinite-scroll>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallet-details/wallet-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_15__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_19__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_index__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_theme_theme__["a" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_index__["f" /* AppProvider */]])
], WalletDetailsPage);

//# sourceMappingURL=wallet-details.js.map

/***/ }),

/***/ 145:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FinishModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);





let FinishModalPage = class FinishModalPage {
    constructor(viewCtrl, navParams, translate) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.translate = translate;
        this.showLaunchRocket = false;
        this.showLandRocket = false;
        this.finishText =
            this.navParams.data.finishText || this.navParams.data.finishText == ''
                ? this.navParams.data.finishText
                : this.translate.instant('Payment Sent');
        this.finishComment = this.navParams.data.finishComment
            ? this.navParams.data.finishComment
            : '';
        this.cssClass = this.navParams.data.cssClass
            ? this.navParams.data.cssClass
            : 'success';
        if (this.navParams.get('autoDismiss')) {
            setTimeout(() => {
                this.viewCtrl.dismiss();
            }, 4000);
        }
        if (this.navParams.data.coin &&
            this.navParams.data.coin === 'doge' &&
            this.cssClass === 'success') {
            this.showLaunchRocket = true;
            setTimeout(() => {
                this.launchRocketPosition = 'launch';
            }, 2000);
        }
    }
    close() {
        this.viewCtrl.dismiss();
    }
    rocketLanding(newPosition) {
        if (this.launchRocketPosition) {
            this.showLaunchRocket = false;
            this.showLandRocket = true;
            this.landRocketPosition = newPosition;
        }
    }
};
FinishModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'page-finish',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/finish/finish.html"*/'<div class="container">\n  <div class="content" [ngClass]="{\'success\': cssClass == \'success\', \'warning\': cssClass == \'warning\', \'danger\': cssClass == \'danger\', \'primary\': cssClass == \'primary\', \'bg-none\': cssClass == \'bg-none\'}">\n    <div class="body">\n      <div class="body-img success-img" *ngIf="cssClass == \'primary\'"></div>\n      <img class="body-img" *ngIf="cssClass == \'success\'" src="assets/img/onboarding-success.svg">\n      <img class="body-img" *ngIf="cssClass == \'bg-none\'" src="assets/img/onboarding/success.svg">\n      <img class="body-img" *ngIf="(cssClass != \'success\' && cssClass != \'primary\' && cssClass != \'bg-none\')" src="assets/img/warning.svg">\n      <div class="body-text" [ngClass]="{\'bg-none\': cssClass == \'bg-none\'}">\n        {{finishText}}\n      </div>\n      <div class="body-comment">\n        {{finishComment}}\n      </div>\n    </div>\n  </div>\n  <div *ngIf="showLaunchRocket" class="rocket-container">\n    <img src="assets/img/rocket-doge.svg" class="rocket-img"\n    [@photoState]="launchRocketPosition"\n    (@photoState.done)="rocketLanding(\'land\')">\n  </div>\n  <div *ngIf="showLandRocket" class="rocket-container">\n    <img src="assets/img/rocket-sad-doge.svg" class="rocket-img"\n    [@photoState]="landRocketPosition">\n  </div>\n  <div class="footer" *ngIf="cssClass !== \'bg-none\'" (click)="close()" >\n    OK\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/finish/finish.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["l" /* trigger */])('photoState', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* state */])('launch', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({
                    overflow: 'hidden',
                    position: 'fixed',
                    'text-align': 'center',
                    top: '85%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)'
                })),
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* state */])('land', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({
                    overflow: 'hidden',
                    position: 'fixed',
                    'text-align': 'center',
                    top: '85%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)'
                })),
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["k" /* transition */])('* => launch', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('4000ms ease-out', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["f" /* keyframes */])([
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%,-50%)', offset: 0 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -49%)', offset: 0.2 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.24 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -49%)', offset: 0.26 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.28 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -49%)', offset: 0.3 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.32 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -51%)', offset: 0.34 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.36 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%,-300%)', offset: 1.0 })
                ]))),
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["k" /* transition */])('* => land', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('5000ms ease-out', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["f" /* keyframes */])([
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -250%)', offset: 0 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -49%)', offset: 0.7 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-49%, -50%)', offset: 0.74 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -49%)', offset: 0.76 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.78 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-49%, -49%)', offset: 0.8 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.82 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-49%, -50%)', offset: 0.84 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.86 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-49%, -50%)', offset: 0.88 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.9 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-51%, -50%)', offset: 0.92 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.94 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-51%, -50%)', offset: 0.96 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 0.98 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({ transform: 'translate(-50%, -50%)', offset: 1 })
                ])))
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], FinishModalPage);

//# sourceMappingURL=finish.js.map

/***/ }),

/***/ 148:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);




// providers



let FeeProvider = class FeeProvider {
    constructor(configProvider, logger, bwcProvider, translate) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.translate = translate;
        this.CACHE_TIME_TS = 60;
        this.cache = [
            {
                updateTs: 0,
                coin: '',
                network: 'livenet'
            }
        ];
        this.logger.debug('FeeProvider initialized');
    }
    getFeeOpts() {
        const feeOpts = {
            urgent: this.translate.instant('Urgent'),
            priority: this.translate.instant('Priority'),
            normal: this.translate.instant('Normal'),
            economy: this.translate.instant('Economy'),
            superEconomy: this.translate.instant('Super Economy'),
            custom: this.translate.instant('Custom')
        };
        return feeOpts;
    }
    getCoinCurrentFeeLevel(coin) {
        let feeLevel;
        switch (coin) {
            case 'bch':
                feeLevel = 'normal';
                break;
            case 'xrp':
                feeLevel = 'normal';
                break;
            default:
                feeLevel =
                    this.configProvider.get().wallet.settings.feeLevel || 'normal';
                break;
        }
        return feeLevel;
    }
    getCurrentFeeLevel() {
        return this.configProvider.get().wallet.settings.feeLevel || 'normal';
    }
    getFeeRate(coin, network, feeLevel) {
        return new Promise((resolve, reject) => {
            if (feeLevel == 'custom')
                return resolve();
            network = network || 'livenet';
            this.getFeeLevels(coin, network)
                .then(response => {
                let feeLevelRate;
                feeLevelRate = __WEBPACK_IMPORTED_MODULE_6_lodash__["find"](response.levels, o => {
                    return o.level == feeLevel;
                });
                if (!feeLevelRate || !feeLevelRate.feePerKb) {
                    let msg = this.translate.instant('Could not get dynamic fee for level:') +
                        ' ' +
                        feeLevel;
                    return reject(msg);
                }
                let feeRate = feeLevelRate.feePerKb;
                if (!response.fromCache)
                    this.logger.debug('Dynamic fee: ' +
                        feeLevel +
                        '/' +
                        network +
                        ' ' +
                        (feeLevelRate.feePerKb / 1000).toFixed() +
                        ' SAT/B');
                return resolve(feeRate);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getFeeLevels(coin, network) {
        return new Promise((resolve, reject) => {
            coin = coin || 'btc';
            const indexFound = this.cache.findIndex(fl => fl.coin == coin && fl.network == network);
            if (indexFound >= 0 &&
                this.cache[indexFound].updateTs > Date.now() - this.CACHE_TIME_TS * 1000) {
                return resolve({
                    levels: this.cache[indexFound].data,
                    fromCache: true
                });
            }
            let walletClient = this.bwcProvider.getClient(null, {});
            walletClient.getFeeLevels(coin, network, (errLivenet, feeLevels) => {
                if (errLivenet) {
                    return reject(this.translate.instant('Could not get dynamic fee'));
                }
                if (indexFound >= 0) {
                    this.cache[indexFound] = {
                        updateTs: Date.now(),
                        coin,
                        network,
                        data: feeLevels
                    };
                }
                else {
                    this.cache.push({
                        updateTs: Date.now(),
                        coin,
                        network,
                        data: feeLevels
                    });
                }
                return resolve({ levels: feeLevels });
            });
        });
    }
    getSpeedUpTxFee(network, txSize) {
        // Only for BTC
        return this.getFeeRate('btc', network, 'urgent').then(urgentFee => {
            // 250 bytes approx. is the minimum size of a tx with 1 input and 1 output
            const averageTxSize = 250;
            const fee = (urgentFee / 1000) * (txSize + averageTxSize);
            this.logger.debug('Fee needed to speed up the tx: ' + Number(fee.toFixed()));
            return Number(fee.toFixed());
        });
    }
};
FeeProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], FeeProvider);

//# sourceMappingURL=fee.js.map

/***/ }),

/***/ 1492:
/***/ (function(module, exports) {

module.exports = {"_args":[["bitcore-lib-edu@8.25.7","/Users/santiago/Documents/BTC/EducoinGenerator/wallet"]],"_from":"bitcore-lib-edu@8.25.7","_id":"bitcore-lib-edu@8.25.7","_inBundle":false,"_integrity":"sha512-eECXfaXkc6LSK3ZjOAsEvKXMMpbmWFJh+SaFFgWkyOs1py6LtXoUbjopDAuTyU4d1uIyGpUkZ+HHji+5QcXn/A==","_location":"/bitcore-lib-edu","_phantomChildren":{"base-x":"3.0.8"},"_requested":{"type":"version","registry":true,"raw":"bitcore-lib-edu@8.25.7","name":"bitcore-lib-edu","escapedName":"bitcore-lib-edu","rawSpec":"8.25.7","saveSpec":null,"fetchSpec":"8.25.7"},"_requiredBy":["/crypto-wallet-core"],"_resolved":"https://registry.npmjs.org/bitcore-lib-edu/-/bitcore-lib-edu-8.25.7.tgz","_spec":"8.25.7","_where":"/Users/santiago/Documents/BTC/EducoinGenerator/wallet","author":{"name":"TKCoin","email":"dev@tkcoin.org"},"browser":{"request":"browser-request"},"dependencies":{"bech32":"=1.1.3","bn.js":"=4.11.8","bs58":"^4.0.1","buffer-compare":"=1.1.1","elliptic":"^6.5.3","inherits":"=2.0.1","lodash":"^4.17.20"},"description":"A pure and powerful JavaScript Bitcoin library.","devDependencies":{"bitcore-build":"^8.25.7","brfs":"^2.0.1","chai":"^4.2.0","gulp":"^4.0.0","sinon":"^7.1.1"},"keywords":["educoin","transaction","address","p2p","ecies","cryptocurrency","blockchain","payment","bip21","bip32","bip37","bip69","bip70","multisig"],"license":"MIT","main":"index.js","name":"bitcore-lib-edu","repository":{"type":"git","url":"https://github.com/tkcoin/bitcore/tree/master/packages/bitcore-lib-edu"},"scripts":{"build":"gulp","coverage":"gulp coverage","pub":"npm run build && npm publish","test":"gulp --tasks && gulp test","test:ci":"npm run test"},"version":"8.25.7"}

/***/ }),

/***/ 1493:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var docsURL = 'http://bitcore.io/';

module.exports = [{
  name: 'InvalidB58Char',
  message: 'Invalid Base58 character: {0} in {1}'
}, {
  name: 'InvalidB58Checksum',
  message: 'Invalid Base58 checksum for {0}'
}, {
  name: 'InvalidNetwork',
  message: 'Invalid version for network: got {0}'
}, {
  name: 'InvalidState',
  message: 'Invalid state: {0}'
}, {
  name: 'NotImplemented',
  message: 'Function {0} was not implemented yet'
}, {
  name: 'InvalidNetworkArgument',
  message: 'Invalid network: must be "livenet" or "testnet", got {0}'
}, {
  name: 'InvalidArgument',
  message: function() {
    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +
      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');
  }
}, {
  name: 'AbstractMethodInvoked',
  message: 'Abstract Method Invocation: {0}'
}, {
  name: 'InvalidArgumentType',
  message: function() {
    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];
  }
}, {
  name: 'Unit',
  message: 'Internal Error on Unit {0}',
  errors: [{
    'name': 'UnknownCode',
    'message': 'Unrecognized unit code: {0}'
  }, {
    'name': 'InvalidRate',
    'message': 'Invalid exchange rate: {0}'
  }]
}, {
  name: 'MerkleBlock',
  message: 'Internal Error on MerkleBlock {0}',
  errors: [{
    'name': 'InvalidMerkleTree',
    'message': 'This MerkleBlock contain an invalid Merkle Tree'
  }]
}, {
  name: 'Transaction',
  message: 'Internal Error on Transaction {0}',
  errors: [{
    name: 'Input',
    message: 'Internal Error on Input {0}',
    errors: [{
      name: 'MissingScript',
      message: 'Need a script to create an input'
    }, {
      name: 'UnsupportedScript',
      message: 'Unsupported input script type: {0}'
    }, {
      name: 'MissingPreviousOutput',
      message: 'No previous output information.'
    }, {
      name: 'BlockHeightOutOfRange',
      message: 'Block Height can only be between 0 and 65535'
    } , {
      name: 'LockTimeRange',
      message: 'Seconds needs to be more that 0 and less that 33553920'
    }
    ]
  }, {
    name: 'NeedMoreInfo',
    message: '{0}'
  }, {
    name: 'InvalidSorting',
    message: 'The sorting function provided did not return the change output as one of the array elements'
  }, {
    name: 'InvalidOutputAmountSum',
    message: '{0}'
  }, {
    name: 'MissingSignatures',
    message: 'Some inputs have not been fully signed'
  }, {
    name: 'InvalidIndex',
    message: 'Invalid index: {0} is not between 0, {1}'
  }, {
    name: 'UnableToVerifySignature',
    message: 'Unable to verify signature: {0}'
  }, {
    name: 'DustOutputs',
    message: 'Dust amount detected in one output'
  }, {
    name: 'InvalidSatoshis',
    message: 'Output satoshis are invalid',
  }, {
    name: 'FeeError',
    message: 'Internal Error on Fee {0}',
    errors: [{
      name: 'TooSmall',
      message: 'Fee is too small: {0}',
    }, {
      name: 'TooLarge',
      message: 'Fee is too large: {0}',
    }, {
      name: 'Different',
      message: 'Unspent value is different from specified fee: {0}',
    }]
  }, {
    name: 'ChangeAddressMissing',
    message: 'Change address is missing'
  }, {
    name: 'BlockHeightTooHigh',
    message: 'Block Height can be at most 2^32 -1'
  }, {
    name: 'NLockTimeOutOfRange',
    message: 'Block Height can only be between 0 and 499 999 999'
  }, {
    name: 'LockTimeTooEarly',
    message: 'Lock Time can\'t be earlier than UNIX date 500 000 000'
  }]
}, {
  name: 'Script',
  message: 'Internal Error on Script {0}',
  errors: [{
    name: 'UnrecognizedAddress',
    message: 'Expected argument {0} to be an address'
  }, {
    name: 'CantDeriveAddress',
    message: 'Can\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'
  }, {
    name: 'InvalidBuffer',
    message: 'Invalid script buffer: can\'t parse valid script from given buffer {0}'
  }]
}, {
  name: 'HDPrivateKey',
  message: 'Internal Error on HDPrivateKey {0}',
  errors: [{
    name: 'InvalidDerivationArgument',
    message: 'Invalid derivation argument {0}, expected string, or number and boolean'
  }, {
    name: 'InvalidEntropyArgument',
    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',
    errors: [{
      name: 'TooMuchEntropy',
      message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
    }, {
      name: 'NotEnoughEntropy',
      message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
    }]
  }, {
    name: 'InvalidLength',
    message: 'Invalid length for xprivkey string in {0}'
  }, {
    name: 'InvalidPath',
    message: 'Invalid derivation path: {0}'
  }, {
    name: 'UnrecognizedArgument',
    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
  }]
}, {
  name: 'HDPublicKey',
  message: 'Internal Error on HDPublicKey {0}',
  errors: [{
    name: 'ArgumentIsPrivateExtended',
    message: 'Argument is an extended private key: {0}'
  }, {
    name: 'InvalidDerivationArgument',
    message: 'Invalid derivation argument: got {0}'
  }, {
    name: 'InvalidLength',
    message: 'Invalid length for xpubkey: got "{0}"'
  }, {
    name: 'InvalidPath',
    message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
  }, {
    name: 'InvalidIndexCantDeriveHardened',
    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'
  }, {
    name: 'MustSupplyArgument',
    message: 'Must supply an argument to create a HDPublicKey'
  }, {
    name: 'UnrecognizedArgument',
    message: 'Invalid argument for creation, must be string, json, buffer, or object'
  }]
}];


/***/ }),

/***/ 1494:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var bech32 = __webpack_require__(334);

var decode = function(str) {
  if (typeof str !== 'string') {
    throw new Error('Input should be a string');
  }
  var decoded = bech32.decode(str);
  return {
    prefix: decoded.prefix,
    data: Buffer.from(bech32.fromWords(decoded.words.slice(1))),
    version: decoded.words[0]
  };
};

var encode = function(prefix, version, data) {
	if (typeof prefix !== 'string') {
		throw new Error('Prefix should be a string');
	}
	if (typeof version !== 'number') {
		throw new Error('version should be a number');
	}
  var words = bech32.toWords(data);
  words.unshift(version);
	return bech32.encode(prefix, words);
}

module.exports = { decode: decode, encode: encode };

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1495:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);

var Script = __webpack_require__(858);
var Opcode = __webpack_require__(460);
var BN = __webpack_require__(73);
var Hash = __webpack_require__(74);
var Signature = __webpack_require__(103);
var PublicKey = __webpack_require__(139);

/**
 * Bitcoin transactions contain scripts. Each input has a script called the
 * scriptSig, and each output has a script called the scriptPubkey. To validate
 * an input, the input's script is concatenated with the referenced output script,
 * and the result is executed. If at the end of execution the stack contains a
 * "true" value, then the transaction is valid.
 *
 * The primary way to use this class is via the verify function.
 * e.g., Interpreter().verify( ... );
 */
var Interpreter = function Interpreter(obj) {
  if (!(this instanceof Interpreter)) {
    return new Interpreter(obj);
  }
  if (obj) {
    this.initialize();
    this.set(obj);
  } else {
    this.initialize();
  }
};

Interpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags) {

  var scriptPubKey = new Script();
  var stack = [];

  if (version === 0) {
    if (program.length === 32) {
      if (witness.length === 0) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';
        return false;
      }

      var scriptPubKeyBuffer = witness[witness.length - 1];
      scriptPubKey = new Script(scriptPubKeyBuffer);
      var hash = Hash.sha256(scriptPubKeyBuffer);
      if (hash.toString('hex') !== program.toString('hex')) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';
        return false;
      }

      stack = witness.slice(0, -1);
    } else if (program.length === 20) {
      if (witness.length !== 2) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';
        return false;
      }

      scriptPubKey.add(Opcode.OP_DUP);
      scriptPubKey.add(Opcode.OP_HASH160);
      scriptPubKey.add(program);
      scriptPubKey.add(Opcode.OP_EQUALVERIFY);
      scriptPubKey.add(Opcode.OP_CHECKSIG);

      stack = witness;

    } else {
      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';
      return false;
    }
  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {
    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';
    return false;
  } else {
    return true;
  }

  this.initialize();

  this.set({
    script: scriptPubKey,
    stack: stack,
    sigversion: 1,
    satoshis: satoshis,
    flags: flags,
  });

  if (!this.evaluate()) {
    return false;
  }

  if (this.stack.length !== 1) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';
    return false;
  }

  var buf = this.stack[this.stack.length - 1];
  if (!Interpreter.castToBool(buf)) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
    return false;
  }

  return true;
};



/**
 * Verifies a Script by executing it and returns true if it is valid.
 * This function needs to be provided with the scriptSig and the scriptPubkey
 * separately.
 * @param {Script} scriptSig - the script's first part (corresponding to the tx input)
 * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)
 * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used
 *    to check signature validity for some opcodes like OP_CHECKSIG)
 * @param {number} nin - index of the transaction input containing the scriptSig verified.
 * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants
 * @param {number} witness - array of witness data
 * @param {number} satoshis - number of satoshis created by this output
 *
 * Translated from bitcoind's VerifyScript
 */
Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {

  var Transaction = __webpack_require__(353);
  if (_.isUndefined(tx)) {
    tx = new Transaction();
  }
  if (_.isUndefined(nin)) {
    nin = 0;
  }
  if (_.isUndefined(flags)) {
    flags = 0;
  }
  if (_.isUndefined(witness)) {
    witness = null;
  }
  if (_.isUndefined(satoshis)) {
    satoshis = 0;
  }

  this.set({
    script: scriptSig,
    tx: tx,
    nin: nin,
    sigversion: 0,
    satoshis: 0,
    flags: flags
  });
  var stackCopy;

  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
    return false;
  }

  // evaluate scriptSig
  if (!this.evaluate()) {
    return false;
  }

  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
    stackCopy = this.stack.slice();
  }

  var stack = this.stack;
  this.initialize();
  this.set({
    script: scriptPubkey,
    stack: stack,
    tx: tx,
    nin: nin,
    flags: flags
  });

  // evaluate scriptPubkey
  if (!this.evaluate()) {
    return false;
  }

  if (this.stack.length === 0) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';
    return false;
  }

  var buf = this.stack[this.stack.length - 1];
  if (!Interpreter.castToBool(buf)) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
    return false;
  }

  var hadWitness = false;
  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
    var witnessValues = {};
    if (scriptPubkey.isWitnessProgram(witnessValues)) {
      hadWitness = true;
      if (scriptSig.toBuffer().length !== 0) {
        return false;
      }
      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {
        return false;
      }
    }
  }

  // Additional validation for spend-to-script-hash transactions:
  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {
    // scriptSig must be literals-only or validation fails
    if (!scriptSig.isPushOnly()) {
      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
      return false;
    }

    // stackCopy cannot be empty here, because if it was the
    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with
    // an empty stack and the EvalScript above would return false.
    if (stackCopy.length === 0) {
      throw new Error('internal error - stack copy empty');
    }

    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
    var redeemScript = Script.fromBuffer(redeemScriptSerialized);
    stackCopy.pop();

    this.initialize();
    this.set({
      script: redeemScript,
      stack: stackCopy,
      tx: tx,
      nin: nin,
      flags: flags
    });

    // evaluate redeemScript
    if (!this.evaluate()) {
      return false;
    }

    if (stackCopy.length === 0) {
      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';
      return false;
    }

    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';
      return false;
    }
    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
      var p2shWitnessValues = {};
      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {
        hadWitness = true;
        var redeemScriptPush = new Script();
        redeemScriptPush.add(redeemScript.toBuffer());
        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {
          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';
          return false;
        }

        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {
          return false;
        }
        // Bypass the cleanstack check at the end. The actual stack is obviously not clean
        // for witness programs.
        stack = [stack[0]];
      }
    }
  }

  // The CLEANSTACK check is only performed after potential P2SH evaluation,
  // as the non-P2SH evaluation of a P2SH script will obviously not result in
  // a clean stack (the P2SH inputs remain). The same holds for witness
  // evaluation.
  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {
      // Disallow CLEANSTACK without P2SH, as otherwise a switch
      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a
      // softfork (and P2SH should be one).
      if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0)
        throw 'flags & SCRIPT_VERIFY_P2SH';

      if (stackCopy.length != 1) {
        this.errstr = 'SCRIPT_ERR_CLEANSTACK';
        return false;
      }
  }

  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
    if (!hadWitness && witness.length > 0) {
      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';
      return false;
    }
  }

  return true;
};

module.exports = Interpreter;

Interpreter.prototype.initialize = function(obj) {
  this.stack = [];
  this.altstack = [];
  this.pc = 0;
  this.satoshis = 0;
  this.sigversion = 0;
  this.pbegincodehash = 0;
  this.nOpCount = 0;
  this.vfExec = [];
  this.errstr = '';
  this.flags = 0;
};

Interpreter.prototype.set = function(obj) {
  this.script = obj.script || this.script;
  this.tx = obj.tx || this.tx;
  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;
  this.stack = obj.stack || this.stack;
  this.altstack = obj.altack || this.altstack;
  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;
  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;
  this.sigversion = typeof obj.sigversion !== 'undefined' ? obj.sigversion : this.sigversion;
  this.satoshis = typeof obj.satoshis !== 'undefined' ? obj.satoshis : this.satoshis;
  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;
  this.vfExec = obj.vfExec || this.vfExec;
  this.errstr = obj.errstr || this.errstr;
  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;
};

Interpreter.true = Buffer.from([1]);
Interpreter.false = Buffer.from([]);

Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;

Interpreter.LOCKTIME_THRESHOLD = 500000000;
Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);

// flags taken from bitcoind
// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
Interpreter.SCRIPT_VERIFY_NONE = 0;

// Making v1-v16 witness program non-standard
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);

// Evaluate P2SH subscripts (softfork safe, BIP16).
Interpreter.SCRIPT_VERIFY_P2SH = (1 << 0);

// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
Interpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);

// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
Interpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);

// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
// (softfork safe, BIP62 rule 5).
Interpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);

// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
Interpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);

// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);

// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
// any other push causes the script to fail (BIP62 rule 3).
// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
// (softfork safe)
Interpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);

// Discourage use of NOPs reserved for upgrades (NOP1-10)
//
// Provided so that nodes can avoid accepting or mining transactions
// containing executed NOP's whose meaning may change after a soft-fork,
// thus rendering the script invalid; with this flag set executing
// discouraged NOPs fails the script. This verification flag will never be
// a mandatory flag applied to scripts in a block. NOPs that are not
// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);


// Require that only a single stack element remains after evaluation. This
// changes the success criterion from "At least one stack element must
// remain, and when interpreted as a boolean, it must be true" to "Exactly
// one stack element must remain, and when interpreted as a boolean, it must
// be true".
// (softfork safe, BIP62 rule 6)
// Note: CLEANSTACK should never be used without P2SH or WITNESS.
Interpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),

// CLTV See BIP65 for details.
Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);
Interpreter.SCRIPT_VERIFY_WITNESS = (1 << 10);
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 11);

// support CHECKSEQUENCEVERIFY opcode
//
// See BIP112 for details
Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);

//
// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly
// 0x01 or empty vector
//
Interpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);


// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
//
Interpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);

// Public keys in scripts must be compressed
//
Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);

// Do we accept signature using SIGHASH_FORKID
//
Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);

// Do we accept activate replay protection using a different fork id.
//
Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);

// Enable new opcodes.
//
Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = (1 << 18);



/* Below flags apply in the context of BIP 68*/
/**
 * If this flag set, CTxIn::nSequence is NOT interpreted as a relative
 * lock-time.
 */
Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);

/**
 * If CTxIn::nSequence encodes a relative lock-time and this flag is set,
 * the relative lock-time has units of 512 seconds, otherwise it specifies
 * blocks with a granularity of 1.
 */
Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);

/**
 * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to
 * extract that lock-time from the sequence field.
 */
Interpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;


Interpreter.castToBool = function(buf) {
  for (var i = 0; i < buf.length; i++) {
    if (buf[i] !== 0) {
      // can be negative zero
      if (i === buf.length - 1 && buf[i] === 0x80) {
        return false;
      }
      return true;
    }
  }
  return false;
};

/**
 * Translated from bitcoind's CheckSignatureEncoding
 */
Interpreter.prototype.checkSignatureEncoding = function(buf) {
  var sig;

    // Empty signature. Not strictly DER encoded, but allowed to provide a
    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG
    if (buf.length == 0) {
        return true;
    }

  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {
    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';
    return false;
  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
    sig = Signature.fromTxFormat(buf);
    if (!sig.hasLowS()) {
      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';
      return false;
    }
  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
    sig = Signature.fromTxFormat(buf);
    if (!sig.hasDefinedHashtype()) {
      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';
      return false;
    }
  }

  return true;
};

/**
 * Translated from bitcoind's CheckPubKeyEncoding
 */
Interpreter.prototype.checkPubkeyEncoding = function(buf) {
  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {
    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';
    return false;
  }

  // Only compressed keys are accepted in segwit
  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == 1 && !PublicKey.fromBuffer(buf).compressed) {
    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';
    return false;
  }

  return true;
};

/**
 * Based on bitcoind's EvalScript function, with the inner loop moved to
 * Interpreter.prototype.step()
 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
 */
Interpreter.prototype.evaluate = function() {
  if (this.script.toBuffer().length > 10000) {
    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';
    return false;
  }

  try {
    while (this.pc < this.script.chunks.length) {
      var fSuccess = this.step();
      if (!fSuccess) {
        return false;
      }
    }

    // Size limits
    if (this.stack.length + this.altstack.length > 1000) {
      this.errstr = 'SCRIPT_ERR_STACK_SIZE';
      return false;
    }
  } catch (e) {
    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;
    return false;
  }

  if (this.vfExec.length > 0) {
    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
    return false;
  }

  return true;
};

/**
 * Checks a locktime parameter with the transaction's locktime.
 * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,
 * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000
 *
 * See the corresponding code on bitcoin core:
 * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129
 *
 * @param {BN} nLockTime the locktime read from the script
 * @return {boolean} true if the transaction's locktime is less than or equal to
 *                   the transaction's locktime
 */
Interpreter.prototype.checkLockTime = function(nLockTime) {

  // We want to compare apples to apples, so fail the script
  // unless the type of nLockTime being tested is the same as
  // the nLockTime in the transaction.
  if (!(
    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||
    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))
  )) {
    return false;
  }

  // Now that we know we're comparing apples-to-apples, the
  // comparison is a simple numeric one.
  if (nLockTime.gt(new BN(this.tx.nLockTime))) {
    return false;
  }

  // Finally the nLockTime feature can be disabled and thus
  // CHECKLOCKTIMEVERIFY bypassed if every txin has been
  // finalized by setting nSequence to maxint. The
  // transaction would be allowed into the blockchain, making
  // the opcode ineffective.
  //
  // Testing if this vin is not final is sufficient to
  // prevent this condition. Alternatively we could test all
  // inputs, but testing just this input minimizes the data
  // required to prove correct CHECKLOCKTIMEVERIFY execution.
  if (!this.tx.inputs[this.nin].isFinal()) {
    return false;
  }

  return true;
}


/**
 * Checks a sequence parameter with the transaction's sequence.
 * @param {BN} nSequence the sequence read from the script
 * @return {boolean} true if the transaction's sequence is less than or equal to
 *                   the transaction's sequence 
 */
Interpreter.prototype.checkSequence = function(nSequence) {

    // Relative lock times are supported by comparing the passed in operand to
    // the sequence number of the input.
    var txToSequence = this.tx.inputs[this.nin].sequenceNumber;

    // Fail if the transaction's version number is not set high enough to
    // trigger BIP 68 rules.
    if (this.tx.version < 2) {
        return false;
    }

    // Sequence numbers with their most significant bit set are not consensus
    // constrained. Testing that the transaction's sequence number do not have
    // this bit set prevents using this property to get around a
    // CHECKSEQUENCEVERIFY check.
    if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
        return false;
    }

    // Mask off any bits that do not have consensus-enforced meaning before
    // doing the integer comparisons
    var nLockTimeMask =
        Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
    var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);
    var nSequenceMasked = nSequence.and(nLockTimeMask);

    // There are two kinds of nSequence: lock-by-blockheight and
    // lock-by-blocktime, distinguished by whether nSequenceMasked <
    // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
    //
    // We want to compare apples to apples, so fail the script unless the type
    // of nSequenceMasked being tested is the same as the nSequenceMasked in the
    // transaction.
    var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
    
    if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&
           nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||
          (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&
           nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {
        return false;
    }

    // Now that we know we're comparing apples-to-apples, the comparison is a
    // simple numeric one.
    if (nSequenceMasked.gt(txToSequenceMasked)) {
        return false;
    }
    return true;
  }

/** 
 * Based on the inner loop of bitcoind's EvalScript function
 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
 */
Interpreter.prototype.step = function() {
  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;

  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);
  var fExec = (this.vfExec.indexOf(false) === -1);
  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;
  var sig, pubkey;
  var fValue, fSuccess;

  // Read instruction
  var chunk = this.script.chunks[this.pc];
  this.pc++;
  var opcodenum = chunk.opcodenum;
  if (_.isUndefined(opcodenum)) {
    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';
    return false;
  }
  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
    return false;
  }

  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.
  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {
    this.errstr = 'SCRIPT_ERR_OP_COUNT';
    return false;
  }


  if (opcodenum === Opcode.OP_CAT ||
    opcodenum === Opcode.OP_SUBSTR ||
    opcodenum === Opcode.OP_LEFT ||
    opcodenum === Opcode.OP_RIGHT ||
    opcodenum === Opcode.OP_INVERT ||
    opcodenum === Opcode.OP_AND ||
    opcodenum === Opcode.OP_OR ||
    opcodenum === Opcode.OP_XOR ||
    opcodenum === Opcode.OP_2MUL ||
    opcodenum === Opcode.OP_2DIV ||
    opcodenum === Opcode.OP_MUL ||
    opcodenum === Opcode.OP_DIV ||
    opcodenum === Opcode.OP_MOD ||
    opcodenum === Opcode.OP_LSHIFT ||
    opcodenum === Opcode.OP_RSHIFT) {
    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';
    return false;
  }

  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {
    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
      this.errstr = 'SCRIPT_ERR_MINIMALDATA';
      return false;
    }
    if (!chunk.buf) {
      this.stack.push(Interpreter.false);
    } else if (chunk.len !== chunk.buf.length) {
      throw new Error('Length of push value not equal to length of data');
    } else {
      this.stack.push(chunk.buf);
    }
  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {
    switch (opcodenum) {
      // Push value
      case Opcode.OP_1NEGATE:
      case Opcode.OP_1:
      case Opcode.OP_2:
      case Opcode.OP_3:
      case Opcode.OP_4:
      case Opcode.OP_5:
      case Opcode.OP_6:
      case Opcode.OP_7:
      case Opcode.OP_8:
      case Opcode.OP_9:
      case Opcode.OP_10:
      case Opcode.OP_11:
      case Opcode.OP_12:
      case Opcode.OP_13:
      case Opcode.OP_14:
      case Opcode.OP_15:
      case Opcode.OP_16:
        {
          // ( -- value)
          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));
          n = opcodenum - (Opcode.OP_1 - 1);
          buf = new BN(n).toScriptNumBuffer();
          this.stack.push(buf);
          // The result of these opcodes should always be the minimal way to push the data
          // they push, so no need for a CheckMinimalPush here.
        }
        break;


        //
        // Control
        //
      case Opcode.OP_NOP:
        break;

      case Opcode.OP_NOP2:
      case Opcode.OP_CHECKLOCKTIMEVERIFY:

        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
          // not enabled; treat as a NOP2
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
          break;
        }

        if (this.stack.length < 1) {
          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
          return false;
        }

        // Note that elsewhere numeric opcodes are limited to
        // operands in the range -2**31+1 to 2**31-1, however it is
        // legal for opcodes to produce results exceeding that
        // range. This limitation is implemented by CScriptNum's
        // default 4-byte limit.
        //
        // If we kept to that limit we'd have a year 2038 problem,
        // even though the nLockTime field in transactions
        // themselves is uint32 which only becomes meaningless
        // after the year 2106.
        //
        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums, which are good until 2**39-1, well
        // beyond the 2**32-1 limit of the nLockTime field itself.
        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);

        // In the rare event that the argument may be < 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKLOCKTIMEVERIFY.
        if (nLockTime.lt(new BN(0))) {
          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
          return false;
        }

        // Actually compare the specified lock time with the transaction.
        if (!this.checkLockTime(nLockTime)) {
          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
          return false;
        }
        break;

      case Opcode.OP_NOP3:
      case Opcode.OP_CHECKSEQUENCEVERIFY:

        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
          // not enabled; treat as a NOP3
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
          break;
        }

        if (this.stack.length < 1) {
          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
          return false;
        }


        // nSequence, like nLockTime, is a 32-bit unsigned
        // integer field. See the comment in CHECKLOCKTIMEVERIFY
        // regarding 5-byte numeric operands.

        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);


        // In the rare event that the argument may be < 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKSEQUENCEVERIFY.
        if (nSequence.lt(new BN(0))) {
          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
          return false;
        }

        // To provide for future soft-fork extensibility, if the
        // operand has the disabled lock-time flag set,
        // CHECKSEQUENCEVERIFY behaves as a NOP.
        if ((nSequence &
          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {
          break;
        }

        // Actually compare the specified lock time with the transaction.
        if (!this.checkSequence(nSequence)) {
          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
          return false;
        }
        break;



      case Opcode.OP_NOP1:
      case Opcode.OP_NOP4:
      case Opcode.OP_NOP5:
      case Opcode.OP_NOP6:
      case Opcode.OP_NOP7:
      case Opcode.OP_NOP8:
      case Opcode.OP_NOP9:
      case Opcode.OP_NOP10:
        {
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
        }
        break;

      case Opcode.OP_IF:
      case Opcode.OP_NOTIF:
        {
          // <expression> if [statements] [else [statements]] endif
          // bool fValue = false;
          fValue = false;
          if (fExec) {
            if (this.stack.length < 1) {
              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
              return false;
            }

            buf = this.stack[this.stack.length - 1];

            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
              buf = this.stack[this.stack.length - 1];
              if (buf.length > 1) {
                this.errstr = 'SCRIPT_ERR_MINIMALIF';
                return false;
              }
              if (buf.length == 1 && buf[0]!=1) {
                this.errstr = 'SCRIPT_ERR_MINIMALIF';
                return false;
              }
            }
            fValue = Interpreter.castToBool(buf);
            if (opcodenum === Opcode.OP_NOTIF) {
              fValue = !fValue;
            }
            this.stack.pop();
          }
          this.vfExec.push(fValue);
        }
        break;

      case Opcode.OP_ELSE:
        {
          if (this.vfExec.length === 0) {
            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
            return false;
          }
          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
        }
        break;

      case Opcode.OP_ENDIF:
        {
          if (this.vfExec.length === 0) {
            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
            return false;
          }
          this.vfExec.pop();
        }
        break;

      case Opcode.OP_VERIFY:
        {
          // (true -- ) or
          // (false -- false) and return
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          fValue = Interpreter.castToBool(buf);
          if (fValue) {
            this.stack.pop();
          } else {
            this.errstr = 'SCRIPT_ERR_VERIFY';
            return false;
          }
        }
        break;

      case Opcode.OP_RETURN:
        {
          this.errstr = 'SCRIPT_ERR_OP_RETURN';
          return false;
        }
        break;


        //
        // Stack ops
        //
      case Opcode.OP_TOALTSTACK:
        {
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.altstack.push(this.stack.pop());
        }
        break;

      case Opcode.OP_FROMALTSTACK:
        {
          if (this.altstack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';
            return false;
          }
          this.stack.push(this.altstack.pop());
        }
        break;

      case Opcode.OP_2DROP:
        {
          // (x1 x2 -- )
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.pop();
          this.stack.pop();
        }
        break;

      case Opcode.OP_2DUP:
        {
          // (x1 x2 -- x1 x2 x1 x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 2];
          buf2 = this.stack[this.stack.length - 1];
          this.stack.push(buf1);
          this.stack.push(buf2);
        }
        break;

      case Opcode.OP_3DUP:
        {
          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 3];
          buf2 = this.stack[this.stack.length - 2];
          var buf3 = this.stack[this.stack.length - 1];
          this.stack.push(buf1);
          this.stack.push(buf2);
          this.stack.push(buf3);
        }
        break;

      case Opcode.OP_2OVER:
        {
          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
          if (this.stack.length < 4) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 4];
          buf2 = this.stack[this.stack.length - 3];
          this.stack.push(buf1);
          this.stack.push(buf2);
        }
        break;

      case Opcode.OP_2ROT:
        {
          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
          if (this.stack.length < 6) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          spliced = this.stack.splice(this.stack.length - 6, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
        }
        break;

      case Opcode.OP_2SWAP:
        {
          // (x1 x2 x3 x4 -- x3 x4 x1 x2)
          if (this.stack.length < 4) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          spliced = this.stack.splice(this.stack.length - 4, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
        }
        break;

      case Opcode.OP_IFDUP:
        {
          // (x - 0 | x x)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          fValue = Interpreter.castToBool(buf);
          if (fValue) {
            this.stack.push(buf);
          }
        }
        break;

      case Opcode.OP_DEPTH:
        {
          // -- stacksize
          buf = new BN(this.stack.length).toScriptNumBuffer();
          this.stack.push(buf);
        }
        break;

      case Opcode.OP_DROP:
        {
          // (x -- )
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.pop();
        }
        break;

      case Opcode.OP_DUP:
        {
          // (x -- x x)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.push(this.stack[this.stack.length - 1]);
        }
        break;

      case Opcode.OP_NIP:
        {
          // (x1 x2 -- x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.splice(this.stack.length - 2, 1);
        }
        break;

      case Opcode.OP_OVER:
        {
          // (x1 x2 -- x1 x2 x1)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.push(this.stack[this.stack.length - 2]);
        }
        break;

      case Opcode.OP_PICK:
      case Opcode.OP_ROLL:
        {
          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
          n = bn.toNumber();
          this.stack.pop();
          if (n < 0 || n >= this.stack.length) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - n - 1];
          if (opcodenum === Opcode.OP_ROLL) {
            this.stack.splice(this.stack.length - n - 1, 1);
          }
          this.stack.push(buf);
        }
        break;

      case Opcode.OP_ROT:
        {
          // (x1 x2 x3 -- x2 x3 x1)
          //  x2 x1 x3  after first swap
          //  x2 x3 x1  after second swap
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          x1 = this.stack[this.stack.length - 3];
          x2 = this.stack[this.stack.length - 2];
          var x3 = this.stack[this.stack.length - 1];
          this.stack[this.stack.length - 3] = x2;
          this.stack[this.stack.length - 2] = x3;
          this.stack[this.stack.length - 1] = x1;
        }
        break;

      case Opcode.OP_SWAP:
        {
          // (x1 x2 -- x2 x1)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          x1 = this.stack[this.stack.length - 2];
          x2 = this.stack[this.stack.length - 1];
          this.stack[this.stack.length - 2] = x2;
          this.stack[this.stack.length - 1] = x1;
        }
        break;

      case Opcode.OP_TUCK:
        {
          // (x1 x2 -- x2 x1 x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
        }
        break;


      case Opcode.OP_SIZE:
        {
          // (in -- in size)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn = new BN(this.stack[this.stack.length - 1].length);
          this.stack.push(bn.toScriptNumBuffer());
        }
        break;


        //
        // Bitwise logic
        //
      case Opcode.OP_EQUAL:
      case Opcode.OP_EQUALVERIFY:
        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL
        {
          // (x1 x2 - bool)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 2];
          buf2 = this.stack[this.stack.length - 1];
          var fEqual = buf1.toString('hex') === buf2.toString('hex');
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
          if (opcodenum === Opcode.OP_EQUALVERIFY) {
            if (fEqual) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';
              return false;
            }
          }
        }
        break;


        //
        // Numeric
        //
      case Opcode.OP_1ADD:
      case Opcode.OP_1SUB:
      case Opcode.OP_NEGATE:
      case Opcode.OP_ABS:
      case Opcode.OP_NOT:
      case Opcode.OP_0NOTEQUAL:
        {
          // (in -- out)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
          switch (opcodenum) {
            case Opcode.OP_1ADD:
              bn = bn.add(BN.One);
              break;
            case Opcode.OP_1SUB:
              bn = bn.sub(BN.One);
              break;
            case Opcode.OP_NEGATE:
              bn = bn.neg();
              break;
            case Opcode.OP_ABS:
              if (bn.cmp(BN.Zero) < 0) {
                bn = bn.neg();
              }
              break;
            case Opcode.OP_NOT:
              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);
              break;
            case Opcode.OP_0NOTEQUAL:
              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);
              break;
              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?
          }
          this.stack.pop();
          this.stack.push(bn.toScriptNumBuffer());
        }
        break;

      case Opcode.OP_ADD:
      case Opcode.OP_SUB:
      case Opcode.OP_BOOLAND:
      case Opcode.OP_BOOLOR:
      case Opcode.OP_NUMEQUAL:
      case Opcode.OP_NUMEQUALVERIFY:
      case Opcode.OP_NUMNOTEQUAL:
      case Opcode.OP_LESSTHAN:
      case Opcode.OP_GREATERTHAN:
      case Opcode.OP_LESSTHANOREQUAL:
      case Opcode.OP_GREATERTHANOREQUAL:
      case Opcode.OP_MIN:
      case Opcode.OP_MAX:
        {
          // (x1 x2 -- out)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
          bn = new BN(0);

          switch (opcodenum) {
            case Opcode.OP_ADD:
              bn = bn1.add(bn2);
              break;

            case Opcode.OP_SUB:
              bn = bn1.sub(bn2);
              break;

              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;
            case Opcode.OP_BOOLAND:
              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);
              break;
              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;
            case Opcode.OP_BOOLOR:
              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);
              break;
              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;
            case Opcode.OP_NUMEQUAL:
              bn = new BN((bn1.cmp(bn2) === 0) + 0);
              break;
              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;
            case Opcode.OP_NUMEQUALVERIFY:
              bn = new BN((bn1.cmp(bn2) === 0) + 0);
              break;
              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;
            case Opcode.OP_NUMNOTEQUAL:
              bn = new BN((bn1.cmp(bn2) !== 0) + 0);
              break;
              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;
            case Opcode.OP_LESSTHAN:
              bn = new BN((bn1.cmp(bn2) < 0) + 0);
              break;
              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;
            case Opcode.OP_GREATERTHAN:
              bn = new BN((bn1.cmp(bn2) > 0) + 0);
              break;
              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;
            case Opcode.OP_LESSTHANOREQUAL:
              bn = new BN((bn1.cmp(bn2) <= 0) + 0);
              break;
              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
            case Opcode.OP_GREATERTHANOREQUAL:
              bn = new BN((bn1.cmp(bn2) >= 0) + 0);
              break;
            case Opcode.OP_MIN:
              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);
              break;
            case Opcode.OP_MAX:
              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);
              break;
              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?
          }
          this.stack.pop();
          this.stack.pop();
          this.stack.push(bn.toScriptNumBuffer());

          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
            // if (CastToBool(stacktop(-1)))
            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';
              return false;
            }
          }
        }
        break;

      case Opcode.OP_WITHIN:
        {
          // (x min max -- out)
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
          //bool fValue = (bn2 <= bn1 && bn1 < bn3);
          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);
          this.stack.pop();
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fValue ? Interpreter.true : Interpreter.false);
        }
        break;


        //
        // Crypto
        //
      case Opcode.OP_RIPEMD160:
      case Opcode.OP_SHA1:
      case Opcode.OP_SHA256:
      case Opcode.OP_HASH160:
      case Opcode.OP_HASH256:
        {
          // (in -- hash)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||
          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);
          var bufHash;
          if (opcodenum === Opcode.OP_RIPEMD160) {
            bufHash = Hash.ripemd160(buf);
          } else if (opcodenum === Opcode.OP_SHA1) {
            bufHash = Hash.sha1(buf);
          } else if (opcodenum === Opcode.OP_SHA256) {
            bufHash = Hash.sha256(buf);
          } else if (opcodenum === Opcode.OP_HASH160) {
            bufHash = Hash.sha256ripemd160(buf);
          } else if (opcodenum === Opcode.OP_HASH256) {
            bufHash = Hash.sha256sha256(buf);
          }
          this.stack.pop();
          this.stack.push(bufHash);
        }
        break;

      case Opcode.OP_CODESEPARATOR:
        {
          // Hash starts after the code separator
          this.pbegincodehash = this.pc;
        }
        break;

      case Opcode.OP_CHECKSIG:
      case Opcode.OP_CHECKSIGVERIFY:
        {
          // (sig pubkey -- bool)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          bufSig = this.stack[this.stack.length - 2];
          bufPubkey = this.stack[this.stack.length - 1];
          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
            return false;
          }

          // Subset of script starting at the most recent codeseparator
          // CScript scriptCode(pbegincodehash, pend);
          subscript = new Script().set({
            chunks: this.script.chunks.slice(this.pbegincodehash)
          });

          // Drop the signature, since there's no way for a signature to sign itself
          var tmpScript = new Script().add(bufSig);
          subscript.findAndDelete(tmpScript);

          try {
            sig = Signature.fromTxFormat(bufSig);
            pubkey = PublicKey.fromBuffer(bufPubkey, false);
            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
          } catch (e) {
            //invalid sig or pubkey
            fSuccess = false;
          }

          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
            bufSig.length) {
            this.errstr = 'SCRIPT_ERR_NULLFAIL';
            return false;
          }

          this.stack.pop();
          this.stack.pop();

          // stack.push_back(fSuccess ? vchTrue : vchFalse);
          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';
              return false;
            }
          }
        }
        break;

      case Opcode.OP_CHECKMULTISIG:
      case Opcode.OP_CHECKMULTISIGVERIFY:
        {
          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)

          var i = 1;
          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
          if (nKeysCount < 0 || nKeysCount > 20) {
            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';
            return false;
          }
          this.nOpCount += nKeysCount;
          if (this.nOpCount > 201) {
            this.errstr = 'SCRIPT_ERR_OP_COUNT';
            return false;
          }
          // int ikey = ++i;
          var ikey = ++i;
          i += nKeysCount;

          // ikey2 is the position of last non-signature item in
          // the stack. Top stack item = 1. With
          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if
          // operation fails.
          var ikey2 = nKeysCount + 2;

          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
          if (nSigsCount < 0 || nSigsCount > nKeysCount) {
            this.errstr = 'SCRIPT_ERR_SIG_COUNT';
            return false;
          }
          // int isig = ++i;
          var isig = ++i;
          i += nSigsCount;
          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          // Subset of script starting at the most recent codeseparator
          subscript = new Script().set({
            chunks: this.script.chunks.slice(this.pbegincodehash)
          });

          // Drop the signatures, since there's no way for a signature to sign itself
          for (var k = 0; k < nSigsCount; k++) {
            bufSig = this.stack[this.stack.length - isig - k];
            subscript.findAndDelete(new Script().add(bufSig));
          }

          fSuccess = true;
          while (fSuccess && nSigsCount > 0) {
            // valtype& vchSig  = stacktop(-isig);
            bufSig = this.stack[this.stack.length - isig];
            // valtype& vchPubKey = stacktop(-ikey);
            bufPubkey = this.stack[this.stack.length - ikey];

            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
              return false;
            }

            var fOk;
            try {
              sig = Signature.fromTxFormat(bufSig);
              pubkey = PublicKey.fromBuffer(bufPubkey, false);
              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
            } catch (e) {
              //invalid sig or pubkey
              fOk = false;
            }

            if (fOk) {
              isig++;
              nSigsCount--;
            }
            ikey++;
            nKeysCount--;

            // If there are more signatures left than keys left,
            // then too many signatures have failed
            if (nSigsCount > nKeysCount) {
              fSuccess = false;
            }
          }


          // Clean up stack of actual arguments
          while (i-- > 1) {
            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
              !ikey2 && this.stack[this.stack.length - 1].length) {

              this.errstr = 'SCRIPT_ERR_NULLFAIL';
              return false;
            }

            if (ikey2 > 0) {
              ikey2--;
            }

            this.stack.pop();
          }

          // A bug causes CHECKMULTISIG to consume one extra argument
          // whose contents were not checked in any way.
          //
          // Unfortunately this is a potential source of mutability,
          // so optionally verify it is exactly equal to zero prior
          // to removing it from the stack.
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {
            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';
            return false;
          }
          this.stack.pop();

          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);

          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';
              return false;
            }
          }
        }
        break;

      default:
        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';
        return false;
    }
  }

  return true;
};


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1496:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(9);

var $ = __webpack_require__(35);
var BufferUtil = __webpack_require__(48);

var Input = __webpack_require__(268);
var Output = __webpack_require__(161);
var Sighash = __webpack_require__(181);
var Script = __webpack_require__(104);
var Signature = __webpack_require__(103);
var TransactionSignature = __webpack_require__(269);

/**
 * Represents a special kind of input of PayToPublicKey kind.
 * @constructor
 */
function PublicKeyInput() {
  Input.apply(this, arguments);
}
inherits(PublicKeyInput, Input);

/**
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
 * @param {number} index - the index of the input in the transaction input vector
 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
 * @param {String} signingMethod - method used to sign input - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Array} of objects that can be
 */
PublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  var publicKey = privateKey.toPublicKey();
  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {
    return [new TransactionSignature({
      publicKey: publicKey,
      prevTxId: this.prevTxId,
      outputIndex: this.outputIndex,
      inputIndex: index,
      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod),
      sigtype: sigtype
    })];
  }
  return [];
};

/**
 * Add the provided signature
 *
 * @param {Object} signature
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {number=} signature.sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {PublicKeyInput} this, for chaining
 */
PublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');
  this.setScript(Script.buildPublicKeyIn(
    signature.signature.toDER(),
    signature.sigtype
  ));
  return this;
};

/**
 * Clear the input's signature
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyInput.prototype.clearSignatures = function() {
  this.setScript(Script.empty());
  return this;
};

/**
 * Query whether the input is signed
 * @return {boolean}
 */
PublicKeyInput.prototype.isFullySigned = function() {
  return this.script.isPublicKeyIn();
};

PublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)

PublicKeyInput.prototype._estimateSize = function() {
  return PublicKeyInput.SCRIPT_MAX_SIZE;
};

module.exports = PublicKeyInput;


/***/ }),

/***/ 1497:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(9);

var $ = __webpack_require__(35);
var BufferUtil = __webpack_require__(48);

var Address = __webpack_require__(140);
var Hash = __webpack_require__(74);
var Input = __webpack_require__(268);
var Output = __webpack_require__(161);
var Sighash = __webpack_require__(181);
var SighashWitness = __webpack_require__(354);
var BufferWriter = __webpack_require__(93);
var BufferUtil = __webpack_require__(48);
var Script = __webpack_require__(104);
var Signature = __webpack_require__(103);
var TransactionSignature = __webpack_require__(269);

/**
 * Represents a special kind of input of PayToPublicKeyHash kind.
 * @constructor
 */
function PublicKeyHashInput() {
  Input.apply(this, arguments);
}
inherits(PublicKeyHashInput, Input);

PublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {
  if (!this.redeemScript) {
    var redeemScript = Script.buildWitnessV0Out(publicKey);
    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {
      var scriptSig = new Script();
      scriptSig.add(redeemScript.toBuffer());
      this.setScript(scriptSig);
      this.redeemScript = redeemScript;
    }
  }
  return this.redeemScript;
};

PublicKeyHashInput.prototype.getScriptCode = function(publicKey) {
  var writer = new BufferWriter();
  var script;
  if (this.output.script.isScriptHashOut()) {
    script = this.getRedeemScript(publicKey);
  } else {
    script = this.output.script;
  }
  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();
  writer.writeVarintNum(scriptBuffer.length);
  writer.write(scriptBuffer);
  return writer.toBuffer();
};

PublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {
  var scriptCode = this.getScriptCode(privateKey);
  var satoshisBuffer = this.getSatoshisBuffer();
  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);
};

/* jshint maxparams: 5 */
/**
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
 * @param {number} index - the index of the input in the transaction input vector
 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
 * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Array} of objects that can be
 */
PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var script;
  if (this.output.script.isScriptHashOut()) {
    script = this.getRedeemScript(privateKey.publicKey);
  } else {
    script = this.output.script;
  }

  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {
    var signature;
    if (script.isWitnessPublicKeyHashOut()) {
      var satoshisBuffer = this.getSatoshisBuffer();
      var scriptCode = this.getScriptCode(privateKey.publicKey);
      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
    } else {
      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod);
    }

    return [new TransactionSignature({
      publicKey: privateKey.publicKey,
      prevTxId: this.prevTxId,
      outputIndex: this.outputIndex,
      inputIndex: index,
      signature: signature,
      sigtype: sigtype
    })];
  }
  return [];
};
/* jshint maxparams: 3 */

/**
 * Add the provided signature
 *
 * @param {Object} signature
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {number=} signature.sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');

  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
    this.setWitnesses([
      BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]),
      signature.publicKey.toBuffer()
    ]);
  } else {
    this.setScript(Script.buildPublicKeyHashIn(
      signature.publicKey,
      signature.signature.toDER(),
      signature.sigtype
    ));
  }
  return this;
};

/**
 * Clear the input's signature
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyHashInput.prototype.clearSignatures = function() {
  this.setScript(Script.empty());
  this.setWitnesses([]);
  return this;
};

/**
 * Query whether the input is signed
 * @return {boolean}
 */
PublicKeyHashInput.prototype.isFullySigned = function() {
  return this.script.isPublicKeyHashIn() || this.hasWitnesses();
};

PublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signature.signature.nhashtype = signature.sigtype;
  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
    var scriptCode = this.getScriptCode();
    var satoshisBuffer = this.getSatoshisBuffer();
    return SighashWitness.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      scriptCode,
      satoshisBuffer,
      signingMethod
    );
  } else {
    return Sighash.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      this.output.script,
      signingMethod
    );
  }
};


PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)
PublicKeyHashInput.REDEEM_SCRIPT_SIZE = 22; // OP_0 (1) pubkeyhash (1 + 20)

PublicKeyHashInput.prototype._estimateSize = function() {
  var WITNESS_DISCOUNT = 4;
  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;
  if (this.output.script.isWitnessPublicKeyHashOut()) {
    return witnessSize;
  } else if (this.output.script.isScriptHashOut()) {
    return witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;
  } else {
    return PublicKeyHashInput.SCRIPT_MAX_SIZE;
  }
};

module.exports = PublicKeyHashInput;


/***/ }),

/***/ 1498:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var inherits = __webpack_require__(9);
var Transaction = __webpack_require__(461);
var Input = __webpack_require__(268);
var Output = __webpack_require__(161);
var $ = __webpack_require__(35);

var Script = __webpack_require__(104);
var Signature = __webpack_require__(103);
var Sighash = __webpack_require__(181);
var PublicKey = __webpack_require__(139);
var BufferUtil = __webpack_require__(48);
var TransactionSignature = __webpack_require__(269);

/**
 * @constructor
 */
function MultiSigInput(input, pubkeys, threshold, signatures, opts) {
  opts = opts || {};
  Input.apply(this, arguments);
  var self = this;
  pubkeys = pubkeys || input.publicKeys;
  threshold = threshold || input.threshold;
  signatures = signatures || input.signatures;
  if (opts.noSorting) {
    this.publicKeys = pubkeys
  } else  {
    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });
  }
  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
    'Provided public keys don\'t match to the provided output script');
  this.publicKeyIndex = {};
  _.each(this.publicKeys, function(publicKey, index) {
    self.publicKeyIndex[publicKey.toString()] = index;
  });
  this.threshold = threshold;
  // Empty array of signatures
  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
}
inherits(MultiSigInput, Input);

MultiSigInput.prototype.toObject = function() {
  var obj = Input.prototype.toObject.apply(this, arguments);
  obj.threshold = this.threshold;
  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });
  obj.signatures = this._serializeSignatures();
  return obj;
};

MultiSigInput.prototype._deserializeSignatures = function(signatures) {
  return _.map(signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return new TransactionSignature(signature);
  });
};

MultiSigInput.prototype._serializeSignatures = function() {
  return _.map(this.signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return signature.toObject();
  });
};

MultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var self = this;
  var results = [];
  _.each(this.publicKeys, function(publicKey) {
    if (publicKey.toString() === privateKey.publicKey.toString()) {
      results.push(new TransactionSignature({
        publicKey: privateKey.publicKey,
        prevTxId: self.prevTxId,
        outputIndex: self.outputIndex,
        inputIndex: index,
        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, signingMethod),
        sigtype: sigtype
      }));
    }
  });

  return results;
};

MultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], "Signature Undefined"),
    'Signature has no matching public key');
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature");
  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
  this._updateScript();
  return this;
};

MultiSigInput.prototype._updateScript = function() {
  this.setScript(Script.buildMultisigIn(
    this.publicKeys,
    this.threshold,
    this._createSignatures()
  ));
  return this;
};

MultiSigInput.prototype._createSignatures = function() {
  return _.map(
    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),
    // Future signature types may need refactor of toDER
    function(signature) {
      return BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]);
    }
  );
};

MultiSigInput.prototype.clearSignatures = function() {
  this.signatures = new Array(this.publicKeys.length);
  this._updateScript();
};

MultiSigInput.prototype.isFullySigned = function() {
  return this.countSignatures() === this.threshold;
};

MultiSigInput.prototype.countMissingSignatures = function() {
  return this.threshold - this.countSignatures();
};

MultiSigInput.prototype.countSignatures = function() {
  return _.reduce(this.signatures, function(sum, signature) {
    return sum + (!!signature);
  }, 0);
};

MultiSigInput.prototype.publicKeysWithoutSignature = function() {
  var self = this;
  return _.filter(this.publicKeys, function(publicKey) {
    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);
  });
};

MultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signature.signature.nhashtype = signature.sigtype;
  return Sighash.verify(
    transaction,
    signature.signature,
    signature.publicKey,
    signature.inputIndex,
    this.output.script,
    signingMethod
  );
};

/**
 *
 * @param {Buffer[]} signatures
 * @param {PublicKey[]} publicKeys
 * @param {Transaction} transaction
 * @param {Integer} inputIndex
 * @param {Input} input
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @returns {TransactionSignature[]}
 */
MultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {
  return publicKeys.map(function (pubKey) {
    var signatureMatch = null;
    signatures = signatures.filter(function (signatureBuffer) {
      if (signatureMatch) {
        return true;
      }

      var signature = new TransactionSignature({
        signature: Signature.fromTxFormat(signatureBuffer),
        publicKey: pubKey,
        prevTxId: input.prevTxId,
        outputIndex: input.outputIndex,
        inputIndex: inputIndex,
        sigtype: Signature.SIGHASH_ALL
      });

      signature.signature.nhashtype = signature.sigtype;
      var isMatch = Sighash.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          input.output.script,
          signingMethod
      );

      if (isMatch) {
        signatureMatch = signature;
        return false;
      }

      return true;
    });

    return signatureMatch ? signatureMatch : null;
  });
};

MultiSigInput.OPCODES_SIZE = 1; // 0
MultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)

MultiSigInput.prototype._estimateSize = function() {
  return MultiSigInput.OPCODES_SIZE +
    this.threshold * MultiSigInput.SIGNATURE_SIZE;
};

module.exports = MultiSigInput;


/***/ }),

/***/ 1499:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/* jshint maxparams:5 */

var _ = __webpack_require__(1);
var inherits = __webpack_require__(9);
var Input = __webpack_require__(268);
var Output = __webpack_require__(161);
var $ = __webpack_require__(35);

var Address = __webpack_require__(140);
var Script = __webpack_require__(104);
var Signature = __webpack_require__(103);
var Sighash = __webpack_require__(181);
var SighashWitness = __webpack_require__(354);
var BufferWriter = __webpack_require__(93);
var BufferUtil = __webpack_require__(48);
var TransactionSignature = __webpack_require__(269);

/**
 * @constructor
 */
function MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {
  /* jshint maxstatements:20 */
  opts = opts || {};
  Input.apply(this, arguments);
  var self = this;
  pubkeys = pubkeys || input.publicKeys;
  threshold = threshold || input.threshold;
  signatures = signatures || input.signatures;
  if (opts.noSorting) {
    this.publicKeys = pubkeys;
  } else  {
    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });
  }
  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);
  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);
  if (nested.equals(this.output.script)) {
    this.nestedWitness = false;
    this.type = Address.PayToWitnessScriptHash;
  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {
    this.nestedWitness = true;
    this.type = Address.PayToScriptHash;
  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {
    this.nestedWitness = false;
    this.type = Address.PayToScriptHash;
  } else {
    throw new Error('Provided public keys don\'t hash to the provided output');
  }

  if (this.nestedWitness) {
    var scriptSig = new Script();
    scriptSig.add(nested.toBuffer());
    this.setScript(scriptSig);
  }

  this.publicKeyIndex = {};
  _.each(this.publicKeys, function(publicKey, index) {
    self.publicKeyIndex[publicKey.toString()] = index;
  });
  this.threshold = threshold;
  // Empty array of signatures
  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
}
inherits(MultiSigScriptHashInput, Input);

MultiSigScriptHashInput.prototype.toObject = function() {
  var obj = Input.prototype.toObject.apply(this, arguments);
  obj.threshold = this.threshold;
  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });
  obj.signatures = this._serializeSignatures();
  return obj;
};

MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
  return _.map(signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return new TransactionSignature(signature);
  });
};

MultiSigScriptHashInput.prototype._serializeSignatures = function() {
  return _.map(this.signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return signature.toObject();
  });
};

MultiSigScriptHashInput.prototype.getScriptCode = function() {
  var writer = new BufferWriter();
  if (!this.redeemScript.hasCodeseparators()) {
    var redeemScriptBuffer = this.redeemScript.toBuffer();
    writer.writeVarintNum(redeemScriptBuffer.length);
    writer.write(redeemScriptBuffer);
  } else {
    throw new Error('@TODO');
  }
  return writer.toBuffer();
};

MultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {
  var self = this;
  var hash;
  if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {
    var scriptCode = self.getScriptCode();
    var satoshisBuffer = self.getSatoshisBuffer();
    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);
  } else  {
    hash = Sighash.sighash(transaction, sigtype, index, self.redeemScript);
  }
  return hash;
};

MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var self = this;
  var results = [];
  _.each(this.publicKeys, function(publicKey) {
    if (publicKey.toString() === privateKey.publicKey.toString()) {
      var signature;
      if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {
        var scriptCode = self.getScriptCode();
        var satoshisBuffer = self.getSatoshisBuffer();
        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
      } else  {
        signature = Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript, signingMethod);
      }
      results.push(new TransactionSignature({
        publicKey: privateKey.publicKey,
        prevTxId: self.prevTxId,
        outputIndex: self.outputIndex,
        inputIndex: index,
        signature: signature,
        sigtype: sigtype
      }));
    }
  });
  return results;
};

MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
                  'Signature has no matching public key');
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature!");
  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
  this._updateScript();
  return this;
};

MultiSigScriptHashInput.prototype._updateScript = function() {
  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {
    var stack = [
      Buffer.alloc(0),
    ];
    var signatures = this._createSignatures();
    for (var i = 0; i < signatures.length; i++) {
      stack.push(signatures[i]);
    }
    stack.push(this.redeemScript.toBuffer());
    this.setWitnesses(stack);
  } else {
    var scriptSig = Script.buildP2SHMultisigIn(
      this.publicKeys,
      this.threshold,
      this._createSignatures(),
      { cachedMultisig: this.redeemScript }
    );
    this.setScript(scriptSig);
  }
  return this;
};

MultiSigScriptHashInput.prototype._createSignatures = function() {
  return _.map(
    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),
    function(signature) {
      return BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]);
    }
  );
};

MultiSigScriptHashInput.prototype.clearSignatures = function() {
  this.signatures = new Array(this.publicKeys.length);
  this._updateScript();
};

MultiSigScriptHashInput.prototype.isFullySigned = function() {
  return this.countSignatures() === this.threshold;
};

MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
  return this.threshold - this.countSignatures();
};

MultiSigScriptHashInput.prototype.countSignatures = function() {
  return _.reduce(this.signatures, function(sum, signature) {
    return sum + (!!signature);
  }, 0);
};

MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
  var self = this;
  return _.filter(this.publicKeys, function(publicKey) {
    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);
  });
};

MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';
  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {
    signature.signature.nhashtype = signature.sigtype;
    var scriptCode = this.getScriptCode();
    var satoshisBuffer = this.getSatoshisBuffer();
    return SighashWitness.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      scriptCode,
      satoshisBuffer,
      signingMethod
    );
  } else {
    // FIXME: Refactor signature so this is not necessary
    signature.signature.nhashtype = signature.sigtype;
    return Sighash.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      this.redeemScript, 
      signingMethod
    );
  }
};

MultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG
MultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)
MultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)
MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)

MultiSigScriptHashInput.prototype._estimateSize = function() {
  var WITNESS_DISCOUNT = 4;
  var witnessSize = MultiSigScriptHashInput.OPCODES_SIZE +
    this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE +
    this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
  if (this.type === Address.PayToWitnessScriptHash) {
    return witnessSize / WITNESS_DISCOUNT;
  } else if (this.nestedWitness) {
    return witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;
  } else {
    return witnessSize;
  }
};

module.exports = MultiSigScriptHashInput;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1500:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BufferWriter = __webpack_require__(93);
var BufferReader = __webpack_require__(160);
var BN = __webpack_require__(73);

var Varint = function Varint(buf) {
  if (!(this instanceof Varint))
    return new Varint(buf);
  if (Buffer.isBuffer(buf)) {
    this.buf = buf;
  } else if (typeof buf === 'number') {
    var num = buf;
    this.fromNumber(num);
  } else if (buf instanceof BN) {
    var bn = buf;
    this.fromBN(bn);
  } else if (buf) {
    var obj = buf;
    this.set(obj);
  }
};

Varint.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf;
  return this;
};

Varint.prototype.fromString = function(str) {
  this.set({
    buf: Buffer.from(str, 'hex')
  });
  return this;
};

Varint.prototype.toString = function() {
  return this.buf.toString('hex');
};

Varint.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Varint.prototype.fromBufferReader = function(br) {
  this.buf = br.readVarintBuf();
  return this;
};

Varint.prototype.fromBN = function(bn) {
  this.buf = BufferWriter().writeVarintBN(bn).concat();
  return this;
};

Varint.prototype.fromNumber = function(num) {
  this.buf = BufferWriter().writeVarintNum(num).concat();
  return this;
};

Varint.prototype.toBuffer = function() {
  return this.buf;
};

Varint.prototype.toBN = function() {
  return BufferReader(this.buf).readVarintBN();
};

Varint.prototype.toNumber = function() {
  return BufferReader(this.buf).readVarintNum();
};

module.exports = Varint;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1501:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1502);

module.exports.BlockHeader = __webpack_require__(356);
module.exports.MerkleBlock = __webpack_require__(860);


/***/ }),

/***/ 1502:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BlockHeader = __webpack_require__(356);
var BN = __webpack_require__(73);
var BufferUtil = __webpack_require__(48);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var Hash = __webpack_require__(74);
var Transaction = __webpack_require__(353);
var $ = __webpack_require__(35);

/**
 * Instantiate a Block from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {Block}
 * @constructor
 */
function Block(arg) {
  if (!(this instanceof Block)) {
    return new Block(arg);
  }
  _.extend(this, Block._from(arg));
  return this;
}

// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14
Block.MAX_BLOCK_SIZE = 1000000;

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
Block._from = function _from(arg) {
  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = Block._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    info = Block._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for Block');
  }
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Object} - An object representing block data
 * @private
 */
Block._fromObject = function _fromObject(data) {
  var transactions = [];
  data.transactions.forEach(function(tx) {
    if (tx instanceof Transaction) {
      transactions.push(tx);
    } else {
      transactions.push(Transaction().fromObject(tx));
    }
  });
  var info = {
    header: BlockHeader.fromObject(data.header),
    transactions: transactions
  };
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
Block.fromObject = function fromObject(obj) {
  var info = Block._fromObject(obj);
  return new Block(info);
};

/**
 * @param {BufferReader} - Block data
 * @returns {Object} - An object representing the block data
 * @private
 */
Block._fromBufferReader = function _fromBufferReader(br) {
  var info = {};
  $.checkState(!br.finished(), 'No block data received');
  info.header = BlockHeader.fromBufferReader(br);
  var transactions = br.readVarintNum();
  info.transactions = [];
  for (var i = 0; i < transactions; i++) {
    info.transactions.push(Transaction().fromBufferReader(br));
  }
  return info;
};

/**
 * @param {BufferReader} - A buffer reader of the block
 * @returns {Block} - An instance of block
 */
Block.fromBufferReader = function fromBufferReader(br) {
  $.checkArgument(br, 'br is required');
  var info = Block._fromBufferReader(br);
  return new Block(info);
};

/**
 * @param {Buffer} - A buffer of the block
 * @returns {Block} - An instance of block
 */
Block.fromBuffer = function fromBuffer(buf) {
  return Block.fromBufferReader(new BufferReader(buf));
};

/**
 * @param {string} - str - A hex encoded string of the block
 * @returns {Block} - A hex encoded string of the block
 */
Block.fromString = function fromString(str) {
  var buf = Buffer.from(str, 'hex');
  return Block.fromBuffer(buf);
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {Block} - An instance of block
 */
Block.fromRawBlock = function fromRawBlock(data) {
  if (!BufferUtil.isBuffer(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader(data);
  br.pos = Block.Values.START_OF_BLOCK;
  var info = Block._fromBufferReader(br);
  return new Block(info);
};

/**
 * @returns {Object} - A plain object with the block properties
 */
Block.prototype.toObject = Block.prototype.toJSON = function toObject() {
  var transactions = [];
  this.transactions.forEach(function(tx) {
    transactions.push(tx.toObject());
  });
  return {
    header: this.header.toObject(),
    transactions: transactions
  };
};

/**
 * @returns {Buffer} - A buffer of the block
 */
Block.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @returns {string} - A hex encoded string of the block
 */
Block.prototype.toString = function toString() {
  return this.toBuffer().toString('hex');
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the Block
 */
Block.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.write(this.header.toBuffer());
  bw.writeVarintNum(this.transactions.length);
  for (var i = 0; i < this.transactions.length; i++) {
    this.transactions[i].toBufferWriter(bw);
  }
  return bw;
};

/**
 * Will iterate through each transaction and return an array of hashes
 * @returns {Array} - An array with transaction hashes
 */
Block.prototype.getTransactionHashes = function getTransactionHashes() {
  var hashes = [];
  if (this.transactions.length === 0) {
    return [Block.Values.NULL_HASH];
  }
  for (var t = 0; t < this.transactions.length; t++) {
    hashes.push(this.transactions[t]._getHash());
  }
  return hashes;
};

/**
 * Will build a merkle tree of all the transactions, ultimately arriving at
 * a single point, the merkle root.
 * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees
 * @returns {Array} - An array with each level of the tree after the other.
 */
Block.prototype.getMerkleTree = function getMerkleTree() {

  var tree = this.getTransactionHashes();

  var j = 0;
  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
    for (var i = 0; i < size; i += 2) {
      var i2 = Math.min(i + 1, size - 1);
      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
      tree.push(Hash.sha256sha256(buf));
    }
    j += size;
  }

  return tree;
};

/**
 * Calculates the merkleRoot from the transactions.
 * @returns {Buffer} - A buffer of the merkle root hash
 */
Block.prototype.getMerkleRoot = function getMerkleRoot() {
  var tree = this.getMerkleTree();
  return tree[tree.length - 1];
};

/**
 * Verifies that the transactions in the block match the header merkle root
 * @returns {Boolean} - If the merkle roots match
 */
Block.prototype.validMerkleRoot = function validMerkleRoot() {

  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');
  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');

  if (h.cmp(c) !== 0) {
    return false;
  }

  return true;
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
Block.prototype._getHash = function() {
  return this.header._getHash();
};

var idProperty = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function() {
    if (!this._id) {
      this._id = this.header.id;
    }
    return this._id;
  },
  set: _.noop
};
Object.defineProperty(Block.prototype, 'id', idProperty);
Object.defineProperty(Block.prototype, 'hash', idProperty);

/**
 * @returns {string} - A string formatted for the console
 */
Block.prototype.inspect = function inspect() {
  return '<Block ' + this.id + '>';
};

Block.Values = {
  START_OF_BLOCK: 8, // Start of block in raw block data
  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

module.exports = Block;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1503:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var PrivateKey = __webpack_require__(266);
var PublicKey = __webpack_require__(139);
var Address = __webpack_require__(140);
var BufferWriter = __webpack_require__(93);
var ECDSA = __webpack_require__(351);
var Signature = __webpack_require__(103);
var sha256sha256 = __webpack_require__(74).sha256sha256;
var JSUtil = __webpack_require__(59);
var $ = __webpack_require__(35);

function Message(message) {
  if (!(this instanceof Message)) {
    return new Message(message);
  }
  $.checkArgument(_.isString(message), 'First argument should be a string');
  this.message = message;

  return this;
}

Message.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\n');

Message.prototype.magicHash = function magicHash() {
  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);
  var messageBuffer = Buffer.from(this.message);
  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);
  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);
  var hash = sha256sha256(buf);
  return hash;
};

Message.prototype._sign = function _sign(privateKey) {
  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');
  var hash = this.magicHash();
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = hash;
  ecdsa.privkey = privateKey;
  ecdsa.pubkey = privateKey.toPublicKey();
  ecdsa.signRandomK();
  ecdsa.calci();
  return ecdsa.sig;
};

/**
 * Will sign a message with a given bitcoin private key.
 *
 * @param {PrivateKey} privateKey - An instance of PrivateKey
 * @returns {String} A base64 encoded compact signature
 */
Message.prototype.sign = function sign(privateKey) {
  var signature = this._sign(privateKey);
  return signature.toCompact().toString('base64');
};

Message.prototype._verify = function _verify(publicKey, signature) {
  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');
  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');
  var hash = this.magicHash();
  var verified = ECDSA.verify(hash, signature, publicKey);
  if (!verified) {
    this.error = 'The signature was invalid';
  }
  return verified;
};

/**
 * Will return a boolean of the signature is valid for a given bitcoin address.
 * If it isn't the specific reason is accessible via the "error" member.
 *
 * @param {Address|String} bitcoinAddress - A bitcoin address
 * @param {String} signatureString - A base64 encoded compact signature
 * @returns {Boolean}
 */
Message.prototype.verify = function verify(bitcoinAddress, signatureString) {
  $.checkArgument(bitcoinAddress);
  $.checkArgument(signatureString && _.isString(signatureString));

  if (_.isString(bitcoinAddress)) {
    bitcoinAddress = Address.fromString(bitcoinAddress);
  }
  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));

  // recover the public key
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = this.magicHash();
  ecdsa.sig = signature;
  var publicKey = ecdsa.toPublicKey();

  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);

  // check that the recovered address and specified address match
  if (bitcoinAddress.toString() !== signatureAddress.toString()) {
    this.error = 'The signature did not match the message digest';
    return false;
  }

  return this._verify(publicKey, signature);
};

/**
 * Will return a public key string if the provided signature and the message digest is correct
 * If it isn't the specific reason is accessible via the "error" member.
 *
 * @param {Address|String} bitcoinAddress - A bitcoin address
 * @param {String} signatureString - A base64 encoded compact signature
 * @returns {String}
 */
Message.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {
  $.checkArgument(bitcoinAddress);
  $.checkArgument(signatureString && _.isString(signatureString));

  if (_.isString(bitcoinAddress)) {
    bitcoinAddress = Address.fromString(bitcoinAddress);
  }
  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));

  // recover the public key
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = this.magicHash();
  ecdsa.sig = signature;
  var publicKey = ecdsa.toPublicKey();

  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);

  // check that the recovered address and specified address match
  if (bitcoinAddress.toString() !== signatureAddress.toString()) {
    this.error = 'The signature did not match the message digest';
  }

  return publicKey.toString();
};

/**
 * Instantiate a message from a message string
 *
 * @param {String} str - A string of the message
 * @returns {Message} A new instance of a Message
 */
Message.fromString = function(str) {
  return new Message(str);
};

/**
 * Instantiate a message from JSON
 *
 * @param {String} json - An JSON string or Object with keys: message
 * @returns {Message} A new instance of a Message
 */
Message.fromJSON = function fromJSON(json) {
  if (JSUtil.isValidJSON(json)) {
    json = JSON.parse(json);
  }
  return new Message(json.message);
};

/**
 * @returns {Object} A plain object with the message information
 */
Message.prototype.toObject = function toObject() {
  return {
    message: this.message
  };
};

/**
 * @returns {String} A JSON representation of the message information
 */
Message.prototype.toJSON = function toJSON() {
  return JSON.stringify(this.toObject());
};

/**
 * Will return a the string representation of the message
 *
 * @returns {String} Message
 */
Message.prototype.toString = function() {
  return this.message;
};

/**
 * Will return a string formatted for the console
 *
 * @returns {String} Message
 */
Message.prototype.inspect = function() {
  return '<Message: ' + this.toString() + '>';
};

module.exports = Message;

var Script = __webpack_require__(104);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1504:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var URL = __webpack_require__(81);

var Address = __webpack_require__(140);
var Unit = __webpack_require__(463);

/**
 * Bitcore URI
 *
 * Instantiate an URI from a educoin URI String or an Object. An URI instance
 * can be created with a educoin uri string or an object. All instances of
 * URI are valid, the static method isValid allows checking before instantiation.
 *
 * All standard parameters can be found as members of the class, the address
 * is represented using an {Address} instance and the amount is represented in
 * satoshis. Any other non-standard parameters can be found under the extra member.
 *
 * @example
 * ```javascript
 *
 * var uri = new URI('educoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');
 * console.log(uri.address, uri.amount);
 * ```
 *
 * @param {string|Object} data - A educoin URI string or an Object
 * @param {Array.<string>=} knownParams - Required non-standard params
 * @throws {TypeError} Invalid educoin address
 * @throws {TypeError} Invalid amount
 * @throws {Error} Unknown required argument
 * @returns {URI} A new valid and frozen instance of URI
 * @constructor
 */
var URI = function(data, knownParams) {
  if (!(this instanceof URI)) {
    return new URI(data, knownParams);
  }

  this.extras = {};
  this.knownParams = knownParams || [];
  this.address = this.network = this.amount = this.message = null;

  if (typeof(data) === 'string') {
    var params = URI.parse(data);
    if (params.amount) {
      params.amount = this._parseAmount(params.amount);
    }
    this._fromObject(params);
  } else if (typeof(data) === 'object') {
    this._fromObject(data);
  } else {
    throw new TypeError('Unrecognized data format.');
  }
};

/**
 * Instantiate a URI from a String
 *
 * @param {string} str - JSON string or object of the URI
 * @returns {URI} A new instance of a URI
 */
URI.fromString = function fromString(str) {
  if (typeof(str) !== 'string') {
    throw new TypeError('Expected a string');
  }
  return new URI(str);
};

/**
 * Instantiate a URI from an Object
 *
 * @param {Object} data - object of the URI
 * @returns {URI} A new instance of a URI
 */
URI.fromObject = function fromObject(json) {
  return new URI(json);
};

/**
 * Check if an educoin URI string is valid
 *
 * @example
 * ```javascript
 *
 * var valid = URI.isValid('educoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');
 * // true
 * ```
 *
 * @param {string|Object} data - A educoin URI string or an Object
 * @param {Array.<string>=} knownParams - Required non-standard params
 * @returns {boolean} Result of uri validation
 */
URI.isValid = function(arg, knownParams) {
  try {
    new URI(arg, knownParams);
  } catch (err) {
    return false;
  }
  return true;
};

/**
 * Convert a educoin URI string into a simple object.
 *
 * @param {string} uri - A educoin URI string
 * @throws {TypeError} Invalid educoin URI
 * @returns {Object} An object with the parsed params
 */
URI.parse = function(uri) {
  var info = URL.parse(uri, true);

  if (info.protocol !== 'educoin:') {
    throw new TypeError('Invalid educoin URI');
  }

  // workaround to host insensitiveness
  var group = /[^:]*:\/?\/?([^?]*)/.exec(uri);
  info.query.address = group && group[1] || undefined;

  return info.query;
};

URI.Members = ['address', 'amount', 'message', 'label', 'r'];

/**
 * Internal function to load the URI instance with an object.
 *
 * @param {Object} obj - Object with the information
 * @throws {TypeError} Invalid educoin address
 * @throws {TypeError} Invalid amount
 * @throws {Error} Unknown required argument
 */
URI.prototype._fromObject = function(obj) {
  /* jshint maxcomplexity: 10 */

  if (!Address.isValid(obj.address)) {
    throw new TypeError('Invalid educoin address');
  }

  this.address = new Address(obj.address);
  this.network = this.address.network;
  this.amount = obj.amount;

  for (var key in obj) {
    if (key === 'address' || key === 'amount') {
      continue;
    }

    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {
      throw Error('Unknown required argument ' + key);
    }

    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;
    destination[key] = obj[key];
  }
};

/**
 * Internal function to transform a EDU string amount into satoshis
 *
 * @param {string} amount - Amount EDU string
 * @throws {TypeError} Invalid amount
 * @returns {Object} Amount represented in satoshis
 */
URI.prototype._parseAmount = function(amount) {
  amount = Number(amount);
  if (isNaN(amount)) {
    throw new TypeError('Invalid amount');
  }
  return Unit.fromBTC(amount).toSatoshis();
};

URI.prototype.toObject = URI.prototype.toJSON = function toObject() {
  var json = {};
  for (var i = 0; i < URI.Members.length; i++) {
    var m = URI.Members[i];
    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {
      json[m] = this[m].toString();
    }
  }
  _.extend(json, this.extras);
  return json;
};

/**
 * Will return a the string representation of the URI
 *
 * @returns {string} Educoin URI string
 */
URI.prototype.toString = function() {
  var query = {};
  if (this.amount) {
    query.amount = Unit.fromSatoshis(this.amount).toEDU();
  }
  if (this.message) {
    query.message = this.message;
  }
  if (this.label) {
    query.label = this.label;
  }
  if (this.r) {
    query.r = this.r;
  }
  _.extend(query, this.extras);

  return URL.format({
    protocol: 'educoin:',
    host: this.address,
    query: query
  });
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Educoin URI
 */
URI.prototype.inspect = function() {
  return '<URI: ' + this.toString() + '>';
};

module.exports = URI;


/***/ }),

/***/ 1505:
/***/ (function(module, exports) {

module.exports = {"_args":[["bitcore-lib-tik@8.25.7","/Users/santiago/Documents/BTC/EducoinGenerator/wallet"]],"_from":"bitcore-lib-tik@8.25.7","_id":"bitcore-lib-tik@8.25.7","_inBundle":false,"_integrity":"sha512-eECXfaXkc6LSK3ZjOAsEvKXMMpbmWFJh+SaFFgWkyOs1py6LtXoUbjopDAuTyU4d1uIyGpUkZ+HHji+5QcXn/A==","_location":"/bitcore-lib-tik","_phantomChildren":{"base-x":"3.0.8"},"_requested":{"type":"version","registry":true,"raw":"bitcore-lib-tik@8.25.7","name":"bitcore-lib-tik","escapedName":"bitcore-lib-tik","rawSpec":"8.25.7","saveSpec":null,"fetchSpec":"8.25.7"},"_requiredBy":["/crypto-wallet-core"],"_resolved":"https://registry.npmjs.org/bitcore-lib-tik/-/bitcore-lib-tik-8.25.7.tgz","_spec":"8.25.7","_where":"/Users/santiago/Documents/BTC/EducoinGenerator/wallet","author":{"name":"TKCoin","email":"dev@tkcoin.org"},"browser":{"request":"browser-request"},"dependencies":{"bech32":"=1.1.3","bn.js":"=4.11.8","bs58":"^4.0.1","buffer-compare":"=1.1.1","elliptic":"^6.5.3","inherits":"=2.0.1","lodash":"^4.17.20"},"description":"A pure and powerful JavaScript Bitcoin library.","devDependencies":{"bitcore-build":"^8.25.7","brfs":"^2.0.1","chai":"^4.2.0","gulp":"^4.0.0","sinon":"^7.1.1"},"keywords":["tikcoin","transaction","address","p2p","ecies","cryptocurrency","blockchain","payment","bip21","bip32","bip37","bip69","bip70","multisig"],"license":"MIT","main":"index.js","name":"bitcore-lib-tik","repository":{"type":"git","url":"https://github.com/tkcoin/bitcore/tree/master/packages/bitcore-lib-tik"},"scripts":{"build":"gulp","coverage":"gulp coverage","pub":"npm run build && npm publish","test":"gulp --tasks && gulp test","test:ci":"npm run test"},"version":"8.25.7"}

/***/ }),

/***/ 1506:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var docsURL = 'http://bitcore.io/';

module.exports = [{
  name: 'InvalidB58Char',
  message: 'Invalid Base58 character: {0} in {1}'
}, {
  name: 'InvalidB58Checksum',
  message: 'Invalid Base58 checksum for {0}'
}, {
  name: 'InvalidNetwork',
  message: 'Invalid version for network: got {0}'
}, {
  name: 'InvalidState',
  message: 'Invalid state: {0}'
}, {
  name: 'NotImplemented',
  message: 'Function {0} was not implemented yet'
}, {
  name: 'InvalidNetworkArgument',
  message: 'Invalid network: must be "livenet" or "testnet", got {0}'
}, {
  name: 'InvalidArgument',
  message: function() {
    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +
      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');
  }
}, {
  name: 'AbstractMethodInvoked',
  message: 'Abstract Method Invocation: {0}'
}, {
  name: 'InvalidArgumentType',
  message: function() {
    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];
  }
}, {
  name: 'Unit',
  message: 'Internal Error on Unit {0}',
  errors: [{
    'name': 'UnknownCode',
    'message': 'Unrecognized unit code: {0}'
  }, {
    'name': 'InvalidRate',
    'message': 'Invalid exchange rate: {0}'
  }]
}, {
  name: 'MerkleBlock',
  message: 'Internal Error on MerkleBlock {0}',
  errors: [{
    'name': 'InvalidMerkleTree',
    'message': 'This MerkleBlock contain an invalid Merkle Tree'
  }]
}, {
  name: 'Transaction',
  message: 'Internal Error on Transaction {0}',
  errors: [{
    name: 'Input',
    message: 'Internal Error on Input {0}',
    errors: [{
      name: 'MissingScript',
      message: 'Need a script to create an input'
    }, {
      name: 'UnsupportedScript',
      message: 'Unsupported input script type: {0}'
    }, {
      name: 'MissingPreviousOutput',
      message: 'No previous output information.'
    }, {
      name: 'BlockHeightOutOfRange',
      message: 'Block Height can only be between 0 and 65535'
    } , {
      name: 'LockTimeRange',
      message: 'Seconds needs to be more that 0 and less that 33553920'
    }
    ]
  }, {
    name: 'NeedMoreInfo',
    message: '{0}'
  }, {
    name: 'InvalidSorting',
    message: 'The sorting function provided did not return the change output as one of the array elements'
  }, {
    name: 'InvalidOutputAmountSum',
    message: '{0}'
  }, {
    name: 'MissingSignatures',
    message: 'Some inputs have not been fully signed'
  }, {
    name: 'InvalidIndex',
    message: 'Invalid index: {0} is not between 0, {1}'
  }, {
    name: 'UnableToVerifySignature',
    message: 'Unable to verify signature: {0}'
  }, {
    name: 'DustOutputs',
    message: 'Dust amount detected in one output'
  }, {
    name: 'InvalidSatoshis',
    message: 'Output satoshis are invalid',
  }, {
    name: 'FeeError',
    message: 'Internal Error on Fee {0}',
    errors: [{
      name: 'TooSmall',
      message: 'Fee is too small: {0}',
    }, {
      name: 'TooLarge',
      message: 'Fee is too large: {0}',
    }, {
      name: 'Different',
      message: 'Unspent value is different from specified fee: {0}',
    }]
  }, {
    name: 'ChangeAddressMissing',
    message: 'Change address is missing'
  }, {
    name: 'BlockHeightTooHigh',
    message: 'Block Height can be at most 2^32 -1'
  }, {
    name: 'NLockTimeOutOfRange',
    message: 'Block Height can only be between 0 and 499 999 999'
  }, {
    name: 'LockTimeTooEarly',
    message: 'Lock Time can\'t be earlier than UNIX date 500 000 000'
  }]
}, {
  name: 'Script',
  message: 'Internal Error on Script {0}',
  errors: [{
    name: 'UnrecognizedAddress',
    message: 'Expected argument {0} to be an address'
  }, {
    name: 'CantDeriveAddress',
    message: 'Can\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'
  }, {
    name: 'InvalidBuffer',
    message: 'Invalid script buffer: can\'t parse valid script from given buffer {0}'
  }]
}, {
  name: 'HDPrivateKey',
  message: 'Internal Error on HDPrivateKey {0}',
  errors: [{
    name: 'InvalidDerivationArgument',
    message: 'Invalid derivation argument {0}, expected string, or number and boolean'
  }, {
    name: 'InvalidEntropyArgument',
    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',
    errors: [{
      name: 'TooMuchEntropy',
      message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
    }, {
      name: 'NotEnoughEntropy',
      message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
    }]
  }, {
    name: 'InvalidLength',
    message: 'Invalid length for xprivkey string in {0}'
  }, {
    name: 'InvalidPath',
    message: 'Invalid derivation path: {0}'
  }, {
    name: 'UnrecognizedArgument',
    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
  }]
}, {
  name: 'HDPublicKey',
  message: 'Internal Error on HDPublicKey {0}',
  errors: [{
    name: 'ArgumentIsPrivateExtended',
    message: 'Argument is an extended private key: {0}'
  }, {
    name: 'InvalidDerivationArgument',
    message: 'Invalid derivation argument: got {0}'
  }, {
    name: 'InvalidLength',
    message: 'Invalid length for xpubkey: got "{0}"'
  }, {
    name: 'InvalidPath',
    message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
  }, {
    name: 'InvalidIndexCantDeriveHardened',
    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'
  }, {
    name: 'MustSupplyArgument',
    message: 'Must supply an argument to create a HDPublicKey'
  }, {
    name: 'UnrecognizedArgument',
    message: 'Invalid argument for creation, must be string, json, buffer, or object'
  }]
}];


/***/ }),

/***/ 1507:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var bech32 = __webpack_require__(334);

var decode = function(str) {
  if (typeof str !== 'string') {
    throw new Error('Input should be a string');
  }
  var decoded = bech32.decode(str);
  return {
    prefix: decoded.prefix,
    data: Buffer.from(bech32.fromWords(decoded.words.slice(1))),
    version: decoded.words[0]
  };
};

var encode = function(prefix, version, data) {
	if (typeof prefix !== 'string') {
		throw new Error('Prefix should be a string');
	}
	if (typeof version !== 'number') {
		throw new Error('version should be a number');
	}
  var words = bech32.toWords(data);
  words.unshift(version);
	return bech32.encode(prefix, words);
}

module.exports = { decode: decode, encode: encode };

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1508:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);

var Script = __webpack_require__(863);
var Opcode = __webpack_require__(464);
var BN = __webpack_require__(75);
var Hash = __webpack_require__(76);
var Signature = __webpack_require__(105);
var PublicKey = __webpack_require__(141);

/**
 * Bitcoin transactions contain scripts. Each input has a script called the
 * scriptSig, and each output has a script called the scriptPubkey. To validate
 * an input, the input's script is concatenated with the referenced output script,
 * and the result is executed. If at the end of execution the stack contains a
 * "true" value, then the transaction is valid.
 *
 * The primary way to use this class is via the verify function.
 * e.g., Interpreter().verify( ... );
 */
var Interpreter = function Interpreter(obj) {
  if (!(this instanceof Interpreter)) {
    return new Interpreter(obj);
  }
  if (obj) {
    this.initialize();
    this.set(obj);
  } else {
    this.initialize();
  }
};

Interpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags) {

  var scriptPubKey = new Script();
  var stack = [];

  if (version === 0) {
    if (program.length === 32) {
      if (witness.length === 0) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';
        return false;
      }

      var scriptPubKeyBuffer = witness[witness.length - 1];
      scriptPubKey = new Script(scriptPubKeyBuffer);
      var hash = Hash.sha256(scriptPubKeyBuffer);
      if (hash.toString('hex') !== program.toString('hex')) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';
        return false;
      }

      stack = witness.slice(0, -1);
    } else if (program.length === 20) {
      if (witness.length !== 2) {
        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';
        return false;
      }

      scriptPubKey.add(Opcode.OP_DUP);
      scriptPubKey.add(Opcode.OP_HASH160);
      scriptPubKey.add(program);
      scriptPubKey.add(Opcode.OP_EQUALVERIFY);
      scriptPubKey.add(Opcode.OP_CHECKSIG);

      stack = witness;

    } else {
      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';
      return false;
    }
  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {
    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';
    return false;
  } else {
    return true;
  }

  this.initialize();

  this.set({
    script: scriptPubKey,
    stack: stack,
    sigversion: 1,
    satoshis: satoshis,
    flags: flags,
  });

  if (!this.evaluate()) {
    return false;
  }

  if (this.stack.length !== 1) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';
    return false;
  }

  var buf = this.stack[this.stack.length - 1];
  if (!Interpreter.castToBool(buf)) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
    return false;
  }

  return true;
};



/**
 * Verifies a Script by executing it and returns true if it is valid.
 * This function needs to be provided with the scriptSig and the scriptPubkey
 * separately.
 * @param {Script} scriptSig - the script's first part (corresponding to the tx input)
 * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)
 * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used
 *    to check signature validity for some opcodes like OP_CHECKSIG)
 * @param {number} nin - index of the transaction input containing the scriptSig verified.
 * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants
 * @param {number} witness - array of witness data
 * @param {number} satoshis - number of satoshis created by this output
 *
 * Translated from bitcoind's VerifyScript
 */
Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {

  var Transaction = __webpack_require__(360);
  if (_.isUndefined(tx)) {
    tx = new Transaction();
  }
  if (_.isUndefined(nin)) {
    nin = 0;
  }
  if (_.isUndefined(flags)) {
    flags = 0;
  }
  if (_.isUndefined(witness)) {
    witness = null;
  }
  if (_.isUndefined(satoshis)) {
    satoshis = 0;
  }

  this.set({
    script: scriptSig,
    tx: tx,
    nin: nin,
    sigversion: 0,
    satoshis: 0,
    flags: flags
  });
  var stackCopy;

  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
    return false;
  }

  // evaluate scriptSig
  if (!this.evaluate()) {
    return false;
  }

  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
    stackCopy = this.stack.slice();
  }

  var stack = this.stack;
  this.initialize();
  this.set({
    script: scriptPubkey,
    stack: stack,
    tx: tx,
    nin: nin,
    flags: flags
  });

  // evaluate scriptPubkey
  if (!this.evaluate()) {
    return false;
  }

  if (this.stack.length === 0) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';
    return false;
  }

  var buf = this.stack[this.stack.length - 1];
  if (!Interpreter.castToBool(buf)) {
    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
    return false;
  }

  var hadWitness = false;
  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
    var witnessValues = {};
    if (scriptPubkey.isWitnessProgram(witnessValues)) {
      hadWitness = true;
      if (scriptSig.toBuffer().length !== 0) {
        return false;
      }
      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {
        return false;
      }
    }
  }

  // Additional validation for spend-to-script-hash transactions:
  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {
    // scriptSig must be literals-only or validation fails
    if (!scriptSig.isPushOnly()) {
      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
      return false;
    }

    // stackCopy cannot be empty here, because if it was the
    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with
    // an empty stack and the EvalScript above would return false.
    if (stackCopy.length === 0) {
      throw new Error('internal error - stack copy empty');
    }

    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
    var redeemScript = Script.fromBuffer(redeemScriptSerialized);
    stackCopy.pop();

    this.initialize();
    this.set({
      script: redeemScript,
      stack: stackCopy,
      tx: tx,
      nin: nin,
      flags: flags
    });

    // evaluate redeemScript
    if (!this.evaluate()) {
      return false;
    }

    if (stackCopy.length === 0) {
      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';
      return false;
    }

    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';
      return false;
    }
    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
      var p2shWitnessValues = {};
      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {
        hadWitness = true;
        var redeemScriptPush = new Script();
        redeemScriptPush.add(redeemScript.toBuffer());
        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {
          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';
          return false;
        }

        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {
          return false;
        }
        // Bypass the cleanstack check at the end. The actual stack is obviously not clean
        // for witness programs.
        stack = [stack[0]];
      }
    }
  }

  // The CLEANSTACK check is only performed after potential P2SH evaluation,
  // as the non-P2SH evaluation of a P2SH script will obviously not result in
  // a clean stack (the P2SH inputs remain). The same holds for witness
  // evaluation.
  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {
      // Disallow CLEANSTACK without P2SH, as otherwise a switch
      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a
      // softfork (and P2SH should be one).
      if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0)
        throw 'flags & SCRIPT_VERIFY_P2SH';

      if (stackCopy.length != 1) {
        this.errstr = 'SCRIPT_ERR_CLEANSTACK';
        return false;
      }
  }

  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {
    if (!hadWitness && witness.length > 0) {
      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';
      return false;
    }
  }

  return true;
};

module.exports = Interpreter;

Interpreter.prototype.initialize = function(obj) {
  this.stack = [];
  this.altstack = [];
  this.pc = 0;
  this.satoshis = 0;
  this.sigversion = 0;
  this.pbegincodehash = 0;
  this.nOpCount = 0;
  this.vfExec = [];
  this.errstr = '';
  this.flags = 0;
};

Interpreter.prototype.set = function(obj) {
  this.script = obj.script || this.script;
  this.tx = obj.tx || this.tx;
  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;
  this.stack = obj.stack || this.stack;
  this.altstack = obj.altack || this.altstack;
  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;
  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;
  this.sigversion = typeof obj.sigversion !== 'undefined' ? obj.sigversion : this.sigversion;
  this.satoshis = typeof obj.satoshis !== 'undefined' ? obj.satoshis : this.satoshis;
  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;
  this.vfExec = obj.vfExec || this.vfExec;
  this.errstr = obj.errstr || this.errstr;
  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;
};

Interpreter.true = Buffer.from([1]);
Interpreter.false = Buffer.from([]);

Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;

Interpreter.LOCKTIME_THRESHOLD = 500000000;
Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);

// flags taken from bitcoind
// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
Interpreter.SCRIPT_VERIFY_NONE = 0;

// Making v1-v16 witness program non-standard
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);

// Evaluate P2SH subscripts (softfork safe, BIP16).
Interpreter.SCRIPT_VERIFY_P2SH = (1 << 0);

// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
Interpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);

// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
Interpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);

// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
// (softfork safe, BIP62 rule 5).
Interpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);

// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
Interpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);

// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);

// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
// any other push causes the script to fail (BIP62 rule 3).
// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
// (softfork safe)
Interpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);

// Discourage use of NOPs reserved for upgrades (NOP1-10)
//
// Provided so that nodes can avoid accepting or mining transactions
// containing executed NOP's whose meaning may change after a soft-fork,
// thus rendering the script invalid; with this flag set executing
// discouraged NOPs fails the script. This verification flag will never be
// a mandatory flag applied to scripts in a block. NOPs that are not
// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);


// Require that only a single stack element remains after evaluation. This
// changes the success criterion from "At least one stack element must
// remain, and when interpreted as a boolean, it must be true" to "Exactly
// one stack element must remain, and when interpreted as a boolean, it must
// be true".
// (softfork safe, BIP62 rule 6)
// Note: CLEANSTACK should never be used without P2SH or WITNESS.
Interpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),

// CLTV See BIP65 for details.
Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);
Interpreter.SCRIPT_VERIFY_WITNESS = (1 << 10);
Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 11);

// support CHECKSEQUENCEVERIFY opcode
//
// See BIP112 for details
Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);

//
// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly
// 0x01 or empty vector
//
Interpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);


// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
//
Interpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);

// Public keys in scripts must be compressed
//
Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);

// Do we accept signature using SIGHASH_FORKID
//
Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);

// Do we accept activate replay protection using a different fork id.
//
Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);

// Enable new opcodes.
//
Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = (1 << 18);



/* Below flags apply in the context of BIP 68*/
/**
 * If this flag set, CTxIn::nSequence is NOT interpreted as a relative
 * lock-time.
 */
Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);

/**
 * If CTxIn::nSequence encodes a relative lock-time and this flag is set,
 * the relative lock-time has units of 512 seconds, otherwise it specifies
 * blocks with a granularity of 1.
 */
Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);

/**
 * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to
 * extract that lock-time from the sequence field.
 */
Interpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;


Interpreter.castToBool = function(buf) {
  for (var i = 0; i < buf.length; i++) {
    if (buf[i] !== 0) {
      // can be negative zero
      if (i === buf.length - 1 && buf[i] === 0x80) {
        return false;
      }
      return true;
    }
  }
  return false;
};

/**
 * Translated from bitcoind's CheckSignatureEncoding
 */
Interpreter.prototype.checkSignatureEncoding = function(buf) {
  var sig;

    // Empty signature. Not strictly DER encoded, but allowed to provide a
    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG
    if (buf.length == 0) {
        return true;
    }

  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {
    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';
    return false;
  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
    sig = Signature.fromTxFormat(buf);
    if (!sig.hasLowS()) {
      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';
      return false;
    }
  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
    sig = Signature.fromTxFormat(buf);
    if (!sig.hasDefinedHashtype()) {
      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';
      return false;
    }
  }

  return true;
};

/**
 * Translated from bitcoind's CheckPubKeyEncoding
 */
Interpreter.prototype.checkPubkeyEncoding = function(buf) {
  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {
    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';
    return false;
  }

  // Only compressed keys are accepted in segwit
  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == 1 && !PublicKey.fromBuffer(buf).compressed) {
    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';
    return false;
  }

  return true;
};

/**
 * Based on bitcoind's EvalScript function, with the inner loop moved to
 * Interpreter.prototype.step()
 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
 */
Interpreter.prototype.evaluate = function() {
  if (this.script.toBuffer().length > 10000) {
    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';
    return false;
  }

  try {
    while (this.pc < this.script.chunks.length) {
      var fSuccess = this.step();
      if (!fSuccess) {
        return false;
      }
    }

    // Size limits
    if (this.stack.length + this.altstack.length > 1000) {
      this.errstr = 'SCRIPT_ERR_STACK_SIZE';
      return false;
    }
  } catch (e) {
    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;
    return false;
  }

  if (this.vfExec.length > 0) {
    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
    return false;
  }

  return true;
};

/**
 * Checks a locktime parameter with the transaction's locktime.
 * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,
 * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000
 *
 * See the corresponding code on bitcoin core:
 * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129
 *
 * @param {BN} nLockTime the locktime read from the script
 * @return {boolean} true if the transaction's locktime is less than or equal to
 *                   the transaction's locktime
 */
Interpreter.prototype.checkLockTime = function(nLockTime) {

  // We want to compare apples to apples, so fail the script
  // unless the type of nLockTime being tested is the same as
  // the nLockTime in the transaction.
  if (!(
    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||
    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))
  )) {
    return false;
  }

  // Now that we know we're comparing apples-to-apples, the
  // comparison is a simple numeric one.
  if (nLockTime.gt(new BN(this.tx.nLockTime))) {
    return false;
  }

  // Finally the nLockTime feature can be disabled and thus
  // CHECKLOCKTIMEVERIFY bypassed if every txin has been
  // finalized by setting nSequence to maxint. The
  // transaction would be allowed into the blockchain, making
  // the opcode ineffective.
  //
  // Testing if this vin is not final is sufficient to
  // prevent this condition. Alternatively we could test all
  // inputs, but testing just this input minimizes the data
  // required to prove correct CHECKLOCKTIMEVERIFY execution.
  if (!this.tx.inputs[this.nin].isFinal()) {
    return false;
  }

  return true;
}


/**
 * Checks a sequence parameter with the transaction's sequence.
 * @param {BN} nSequence the sequence read from the script
 * @return {boolean} true if the transaction's sequence is less than or equal to
 *                   the transaction's sequence 
 */
Interpreter.prototype.checkSequence = function(nSequence) {

    // Relative lock times are supported by comparing the passed in operand to
    // the sequence number of the input.
    var txToSequence = this.tx.inputs[this.nin].sequenceNumber;

    // Fail if the transaction's version number is not set high enough to
    // trigger BIP 68 rules.
    if (this.tx.version < 2) {
        return false;
    }

    // Sequence numbers with their most significant bit set are not consensus
    // constrained. Testing that the transaction's sequence number do not have
    // this bit set prevents using this property to get around a
    // CHECKSEQUENCEVERIFY check.
    if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
        return false;
    }

    // Mask off any bits that do not have consensus-enforced meaning before
    // doing the integer comparisons
    var nLockTimeMask =
        Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
    var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);
    var nSequenceMasked = nSequence.and(nLockTimeMask);

    // There are two kinds of nSequence: lock-by-blockheight and
    // lock-by-blocktime, distinguished by whether nSequenceMasked <
    // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
    //
    // We want to compare apples to apples, so fail the script unless the type
    // of nSequenceMasked being tested is the same as the nSequenceMasked in the
    // transaction.
    var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
    
    if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&
           nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||
          (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&
           nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {
        return false;
    }

    // Now that we know we're comparing apples-to-apples, the comparison is a
    // simple numeric one.
    if (nSequenceMasked.gt(txToSequenceMasked)) {
        return false;
    }
    return true;
  }

/** 
 * Based on the inner loop of bitcoind's EvalScript function
 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
 */
Interpreter.prototype.step = function() {
  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;

  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);
  var fExec = (this.vfExec.indexOf(false) === -1);
  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;
  var sig, pubkey;
  var fValue, fSuccess;

  // Read instruction
  var chunk = this.script.chunks[this.pc];
  this.pc++;
  var opcodenum = chunk.opcodenum;
  if (_.isUndefined(opcodenum)) {
    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';
    return false;
  }
  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
    return false;
  }

  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.
  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {
    this.errstr = 'SCRIPT_ERR_OP_COUNT';
    return false;
  }


  if (opcodenum === Opcode.OP_CAT ||
    opcodenum === Opcode.OP_SUBSTR ||
    opcodenum === Opcode.OP_LEFT ||
    opcodenum === Opcode.OP_RIGHT ||
    opcodenum === Opcode.OP_INVERT ||
    opcodenum === Opcode.OP_AND ||
    opcodenum === Opcode.OP_OR ||
    opcodenum === Opcode.OP_XOR ||
    opcodenum === Opcode.OP_2MUL ||
    opcodenum === Opcode.OP_2DIV ||
    opcodenum === Opcode.OP_MUL ||
    opcodenum === Opcode.OP_DIV ||
    opcodenum === Opcode.OP_MOD ||
    opcodenum === Opcode.OP_LSHIFT ||
    opcodenum === Opcode.OP_RSHIFT) {
    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';
    return false;
  }

  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {
    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
      this.errstr = 'SCRIPT_ERR_MINIMALDATA';
      return false;
    }
    if (!chunk.buf) {
      this.stack.push(Interpreter.false);
    } else if (chunk.len !== chunk.buf.length) {
      throw new Error('Length of push value not equal to length of data');
    } else {
      this.stack.push(chunk.buf);
    }
  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {
    switch (opcodenum) {
      // Push value
      case Opcode.OP_1NEGATE:
      case Opcode.OP_1:
      case Opcode.OP_2:
      case Opcode.OP_3:
      case Opcode.OP_4:
      case Opcode.OP_5:
      case Opcode.OP_6:
      case Opcode.OP_7:
      case Opcode.OP_8:
      case Opcode.OP_9:
      case Opcode.OP_10:
      case Opcode.OP_11:
      case Opcode.OP_12:
      case Opcode.OP_13:
      case Opcode.OP_14:
      case Opcode.OP_15:
      case Opcode.OP_16:
        {
          // ( -- value)
          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));
          n = opcodenum - (Opcode.OP_1 - 1);
          buf = new BN(n).toScriptNumBuffer();
          this.stack.push(buf);
          // The result of these opcodes should always be the minimal way to push the data
          // they push, so no need for a CheckMinimalPush here.
        }
        break;


        //
        // Control
        //
      case Opcode.OP_NOP:
        break;

      case Opcode.OP_NOP2:
      case Opcode.OP_CHECKLOCKTIMEVERIFY:

        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
          // not enabled; treat as a NOP2
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
          break;
        }

        if (this.stack.length < 1) {
          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
          return false;
        }

        // Note that elsewhere numeric opcodes are limited to
        // operands in the range -2**31+1 to 2**31-1, however it is
        // legal for opcodes to produce results exceeding that
        // range. This limitation is implemented by CScriptNum's
        // default 4-byte limit.
        //
        // If we kept to that limit we'd have a year 2038 problem,
        // even though the nLockTime field in transactions
        // themselves is uint32 which only becomes meaningless
        // after the year 2106.
        //
        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums, which are good until 2**39-1, well
        // beyond the 2**32-1 limit of the nLockTime field itself.
        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);

        // In the rare event that the argument may be < 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKLOCKTIMEVERIFY.
        if (nLockTime.lt(new BN(0))) {
          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
          return false;
        }

        // Actually compare the specified lock time with the transaction.
        if (!this.checkLockTime(nLockTime)) {
          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
          return false;
        }
        break;

      case Opcode.OP_NOP3:
      case Opcode.OP_CHECKSEQUENCEVERIFY:

        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
          // not enabled; treat as a NOP3
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
          break;
        }

        if (this.stack.length < 1) {
          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
          return false;
        }


        // nSequence, like nLockTime, is a 32-bit unsigned
        // integer field. See the comment in CHECKLOCKTIMEVERIFY
        // regarding 5-byte numeric operands.

        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);


        // In the rare event that the argument may be < 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKSEQUENCEVERIFY.
        if (nSequence.lt(new BN(0))) {
          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';
          return false;
        }

        // To provide for future soft-fork extensibility, if the
        // operand has the disabled lock-time flag set,
        // CHECKSEQUENCEVERIFY behaves as a NOP.
        if ((nSequence &
          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {
          break;
        }

        // Actually compare the specified lock time with the transaction.
        if (!this.checkSequence(nSequence)) {
          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';
          return false;
        }
        break;



      case Opcode.OP_NOP1:
      case Opcode.OP_NOP4:
      case Opcode.OP_NOP5:
      case Opcode.OP_NOP6:
      case Opcode.OP_NOP7:
      case Opcode.OP_NOP8:
      case Opcode.OP_NOP9:
      case Opcode.OP_NOP10:
        {
          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
            return false;
          }
        }
        break;

      case Opcode.OP_IF:
      case Opcode.OP_NOTIF:
        {
          // <expression> if [statements] [else [statements]] endif
          // bool fValue = false;
          fValue = false;
          if (fExec) {
            if (this.stack.length < 1) {
              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
              return false;
            }

            buf = this.stack[this.stack.length - 1];

            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
              buf = this.stack[this.stack.length - 1];
              if (buf.length > 1) {
                this.errstr = 'SCRIPT_ERR_MINIMALIF';
                return false;
              }
              if (buf.length == 1 && buf[0]!=1) {
                this.errstr = 'SCRIPT_ERR_MINIMALIF';
                return false;
              }
            }
            fValue = Interpreter.castToBool(buf);
            if (opcodenum === Opcode.OP_NOTIF) {
              fValue = !fValue;
            }
            this.stack.pop();
          }
          this.vfExec.push(fValue);
        }
        break;

      case Opcode.OP_ELSE:
        {
          if (this.vfExec.length === 0) {
            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
            return false;
          }
          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
        }
        break;

      case Opcode.OP_ENDIF:
        {
          if (this.vfExec.length === 0) {
            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
            return false;
          }
          this.vfExec.pop();
        }
        break;

      case Opcode.OP_VERIFY:
        {
          // (true -- ) or
          // (false -- false) and return
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          fValue = Interpreter.castToBool(buf);
          if (fValue) {
            this.stack.pop();
          } else {
            this.errstr = 'SCRIPT_ERR_VERIFY';
            return false;
          }
        }
        break;

      case Opcode.OP_RETURN:
        {
          this.errstr = 'SCRIPT_ERR_OP_RETURN';
          return false;
        }
        break;


        //
        // Stack ops
        //
      case Opcode.OP_TOALTSTACK:
        {
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.altstack.push(this.stack.pop());
        }
        break;

      case Opcode.OP_FROMALTSTACK:
        {
          if (this.altstack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';
            return false;
          }
          this.stack.push(this.altstack.pop());
        }
        break;

      case Opcode.OP_2DROP:
        {
          // (x1 x2 -- )
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.pop();
          this.stack.pop();
        }
        break;

      case Opcode.OP_2DUP:
        {
          // (x1 x2 -- x1 x2 x1 x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 2];
          buf2 = this.stack[this.stack.length - 1];
          this.stack.push(buf1);
          this.stack.push(buf2);
        }
        break;

      case Opcode.OP_3DUP:
        {
          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 3];
          buf2 = this.stack[this.stack.length - 2];
          var buf3 = this.stack[this.stack.length - 1];
          this.stack.push(buf1);
          this.stack.push(buf2);
          this.stack.push(buf3);
        }
        break;

      case Opcode.OP_2OVER:
        {
          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
          if (this.stack.length < 4) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 4];
          buf2 = this.stack[this.stack.length - 3];
          this.stack.push(buf1);
          this.stack.push(buf2);
        }
        break;

      case Opcode.OP_2ROT:
        {
          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
          if (this.stack.length < 6) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          spliced = this.stack.splice(this.stack.length - 6, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
        }
        break;

      case Opcode.OP_2SWAP:
        {
          // (x1 x2 x3 x4 -- x3 x4 x1 x2)
          if (this.stack.length < 4) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          spliced = this.stack.splice(this.stack.length - 4, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
        }
        break;

      case Opcode.OP_IFDUP:
        {
          // (x - 0 | x x)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          fValue = Interpreter.castToBool(buf);
          if (fValue) {
            this.stack.push(buf);
          }
        }
        break;

      case Opcode.OP_DEPTH:
        {
          // -- stacksize
          buf = new BN(this.stack.length).toScriptNumBuffer();
          this.stack.push(buf);
        }
        break;

      case Opcode.OP_DROP:
        {
          // (x -- )
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.pop();
        }
        break;

      case Opcode.OP_DUP:
        {
          // (x -- x x)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.push(this.stack[this.stack.length - 1]);
        }
        break;

      case Opcode.OP_NIP:
        {
          // (x1 x2 -- x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.splice(this.stack.length - 2, 1);
        }
        break;

      case Opcode.OP_OVER:
        {
          // (x1 x2 -- x1 x2 x1)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.push(this.stack[this.stack.length - 2]);
        }
        break;

      case Opcode.OP_PICK:
      case Opcode.OP_ROLL:
        {
          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
          n = bn.toNumber();
          this.stack.pop();
          if (n < 0 || n >= this.stack.length) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - n - 1];
          if (opcodenum === Opcode.OP_ROLL) {
            this.stack.splice(this.stack.length - n - 1, 1);
          }
          this.stack.push(buf);
        }
        break;

      case Opcode.OP_ROT:
        {
          // (x1 x2 x3 -- x2 x3 x1)
          //  x2 x1 x3  after first swap
          //  x2 x3 x1  after second swap
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          x1 = this.stack[this.stack.length - 3];
          x2 = this.stack[this.stack.length - 2];
          var x3 = this.stack[this.stack.length - 1];
          this.stack[this.stack.length - 3] = x2;
          this.stack[this.stack.length - 2] = x3;
          this.stack[this.stack.length - 1] = x1;
        }
        break;

      case Opcode.OP_SWAP:
        {
          // (x1 x2 -- x2 x1)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          x1 = this.stack[this.stack.length - 2];
          x2 = this.stack[this.stack.length - 1];
          this.stack[this.stack.length - 2] = x2;
          this.stack[this.stack.length - 1] = x1;
        }
        break;

      case Opcode.OP_TUCK:
        {
          // (x1 x2 -- x2 x1 x2)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
        }
        break;


      case Opcode.OP_SIZE:
        {
          // (in -- in size)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn = new BN(this.stack[this.stack.length - 1].length);
          this.stack.push(bn.toScriptNumBuffer());
        }
        break;


        //
        // Bitwise logic
        //
      case Opcode.OP_EQUAL:
      case Opcode.OP_EQUALVERIFY:
        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL
        {
          // (x1 x2 - bool)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf1 = this.stack[this.stack.length - 2];
          buf2 = this.stack[this.stack.length - 1];
          var fEqual = buf1.toString('hex') === buf2.toString('hex');
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
          if (opcodenum === Opcode.OP_EQUALVERIFY) {
            if (fEqual) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';
              return false;
            }
          }
        }
        break;


        //
        // Numeric
        //
      case Opcode.OP_1ADD:
      case Opcode.OP_1SUB:
      case Opcode.OP_NEGATE:
      case Opcode.OP_ABS:
      case Opcode.OP_NOT:
      case Opcode.OP_0NOTEQUAL:
        {
          // (in -- out)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
          switch (opcodenum) {
            case Opcode.OP_1ADD:
              bn = bn.add(BN.One);
              break;
            case Opcode.OP_1SUB:
              bn = bn.sub(BN.One);
              break;
            case Opcode.OP_NEGATE:
              bn = bn.neg();
              break;
            case Opcode.OP_ABS:
              if (bn.cmp(BN.Zero) < 0) {
                bn = bn.neg();
              }
              break;
            case Opcode.OP_NOT:
              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);
              break;
            case Opcode.OP_0NOTEQUAL:
              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);
              break;
              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?
          }
          this.stack.pop();
          this.stack.push(bn.toScriptNumBuffer());
        }
        break;

      case Opcode.OP_ADD:
      case Opcode.OP_SUB:
      case Opcode.OP_BOOLAND:
      case Opcode.OP_BOOLOR:
      case Opcode.OP_NUMEQUAL:
      case Opcode.OP_NUMEQUALVERIFY:
      case Opcode.OP_NUMNOTEQUAL:
      case Opcode.OP_LESSTHAN:
      case Opcode.OP_GREATERTHAN:
      case Opcode.OP_LESSTHANOREQUAL:
      case Opcode.OP_GREATERTHANOREQUAL:
      case Opcode.OP_MIN:
      case Opcode.OP_MAX:
        {
          // (x1 x2 -- out)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
          bn = new BN(0);

          switch (opcodenum) {
            case Opcode.OP_ADD:
              bn = bn1.add(bn2);
              break;

            case Opcode.OP_SUB:
              bn = bn1.sub(bn2);
              break;

              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;
            case Opcode.OP_BOOLAND:
              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);
              break;
              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;
            case Opcode.OP_BOOLOR:
              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);
              break;
              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;
            case Opcode.OP_NUMEQUAL:
              bn = new BN((bn1.cmp(bn2) === 0) + 0);
              break;
              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;
            case Opcode.OP_NUMEQUALVERIFY:
              bn = new BN((bn1.cmp(bn2) === 0) + 0);
              break;
              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;
            case Opcode.OP_NUMNOTEQUAL:
              bn = new BN((bn1.cmp(bn2) !== 0) + 0);
              break;
              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;
            case Opcode.OP_LESSTHAN:
              bn = new BN((bn1.cmp(bn2) < 0) + 0);
              break;
              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;
            case Opcode.OP_GREATERTHAN:
              bn = new BN((bn1.cmp(bn2) > 0) + 0);
              break;
              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;
            case Opcode.OP_LESSTHANOREQUAL:
              bn = new BN((bn1.cmp(bn2) <= 0) + 0);
              break;
              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
            case Opcode.OP_GREATERTHANOREQUAL:
              bn = new BN((bn1.cmp(bn2) >= 0) + 0);
              break;
            case Opcode.OP_MIN:
              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);
              break;
            case Opcode.OP_MAX:
              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);
              break;
              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?
          }
          this.stack.pop();
          this.stack.pop();
          this.stack.push(bn.toScriptNumBuffer());

          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
            // if (CastToBool(stacktop(-1)))
            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';
              return false;
            }
          }
        }
        break;

      case Opcode.OP_WITHIN:
        {
          // (x min max -- out)
          if (this.stack.length < 3) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
          //bool fValue = (bn2 <= bn1 && bn1 < bn3);
          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);
          this.stack.pop();
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fValue ? Interpreter.true : Interpreter.false);
        }
        break;


        //
        // Crypto
        //
      case Opcode.OP_RIPEMD160:
      case Opcode.OP_SHA1:
      case Opcode.OP_SHA256:
      case Opcode.OP_HASH160:
      case Opcode.OP_HASH256:
        {
          // (in -- hash)
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          buf = this.stack[this.stack.length - 1];
          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||
          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);
          var bufHash;
          if (opcodenum === Opcode.OP_RIPEMD160) {
            bufHash = Hash.ripemd160(buf);
          } else if (opcodenum === Opcode.OP_SHA1) {
            bufHash = Hash.sha1(buf);
          } else if (opcodenum === Opcode.OP_SHA256) {
            bufHash = Hash.sha256(buf);
          } else if (opcodenum === Opcode.OP_HASH160) {
            bufHash = Hash.sha256ripemd160(buf);
          } else if (opcodenum === Opcode.OP_HASH256) {
            bufHash = Hash.sha256sha256(buf);
          }
          this.stack.pop();
          this.stack.push(bufHash);
        }
        break;

      case Opcode.OP_CODESEPARATOR:
        {
          // Hash starts after the code separator
          this.pbegincodehash = this.pc;
        }
        break;

      case Opcode.OP_CHECKSIG:
      case Opcode.OP_CHECKSIGVERIFY:
        {
          // (sig pubkey -- bool)
          if (this.stack.length < 2) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          bufSig = this.stack[this.stack.length - 2];
          bufPubkey = this.stack[this.stack.length - 1];
          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
            return false;
          }

          // Subset of script starting at the most recent codeseparator
          // CScript scriptCode(pbegincodehash, pend);
          subscript = new Script().set({
            chunks: this.script.chunks.slice(this.pbegincodehash)
          });

          // Drop the signature, since there's no way for a signature to sign itself
          var tmpScript = new Script().add(bufSig);
          subscript.findAndDelete(tmpScript);

          try {
            sig = Signature.fromTxFormat(bufSig);
            pubkey = PublicKey.fromBuffer(bufPubkey, false);
            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
          } catch (e) {
            //invalid sig or pubkey
            fSuccess = false;
          }

          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
            bufSig.length) {
            this.errstr = 'SCRIPT_ERR_NULLFAIL';
            return false;
          }

          this.stack.pop();
          this.stack.pop();

          // stack.push_back(fSuccess ? vchTrue : vchFalse);
          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';
              return false;
            }
          }
        }
        break;

      case Opcode.OP_CHECKMULTISIG:
      case Opcode.OP_CHECKMULTISIGVERIFY:
        {
          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)

          var i = 1;
          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
          if (nKeysCount < 0 || nKeysCount > 20) {
            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';
            return false;
          }
          this.nOpCount += nKeysCount;
          if (this.nOpCount > 201) {
            this.errstr = 'SCRIPT_ERR_OP_COUNT';
            return false;
          }
          // int ikey = ++i;
          var ikey = ++i;
          i += nKeysCount;

          // ikey2 is the position of last non-signature item in
          // the stack. Top stack item = 1. With
          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if
          // operation fails.
          var ikey2 = nKeysCount + 2;

          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
          if (nSigsCount < 0 || nSigsCount > nKeysCount) {
            this.errstr = 'SCRIPT_ERR_SIG_COUNT';
            return false;
          }
          // int isig = ++i;
          var isig = ++i;
          i += nSigsCount;
          if (this.stack.length < i) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }

          // Subset of script starting at the most recent codeseparator
          subscript = new Script().set({
            chunks: this.script.chunks.slice(this.pbegincodehash)
          });

          // Drop the signatures, since there's no way for a signature to sign itself
          for (var k = 0; k < nSigsCount; k++) {
            bufSig = this.stack[this.stack.length - isig - k];
            subscript.findAndDelete(new Script().add(bufSig));
          }

          fSuccess = true;
          while (fSuccess && nSigsCount > 0) {
            // valtype& vchSig  = stacktop(-isig);
            bufSig = this.stack[this.stack.length - isig];
            // valtype& vchPubKey = stacktop(-ikey);
            bufPubkey = this.stack[this.stack.length - ikey];

            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
              return false;
            }

            var fOk;
            try {
              sig = Signature.fromTxFormat(bufSig);
              pubkey = PublicKey.fromBuffer(bufPubkey, false);
              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
            } catch (e) {
              //invalid sig or pubkey
              fOk = false;
            }

            if (fOk) {
              isig++;
              nSigsCount--;
            }
            ikey++;
            nKeysCount--;

            // If there are more signatures left than keys left,
            // then too many signatures have failed
            if (nSigsCount > nKeysCount) {
              fSuccess = false;
            }
          }


          // Clean up stack of actual arguments
          while (i-- > 1) {
            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&
              !ikey2 && this.stack[this.stack.length - 1].length) {

              this.errstr = 'SCRIPT_ERR_NULLFAIL';
              return false;
            }

            if (ikey2 > 0) {
              ikey2--;
            }

            this.stack.pop();
          }

          // A bug causes CHECKMULTISIG to consume one extra argument
          // whose contents were not checked in any way.
          //
          // Unfortunately this is a potential source of mutability,
          // so optionally verify it is exactly equal to zero prior
          // to removing it from the stack.
          if (this.stack.length < 1) {
            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
            return false;
          }
          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {
            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';
            return false;
          }
          this.stack.pop();

          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);

          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';
              return false;
            }
          }
        }
        break;

      default:
        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';
        return false;
    }
  }

  return true;
};


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1509:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(9);

var $ = __webpack_require__(36);
var BufferUtil = __webpack_require__(49);

var Input = __webpack_require__(272);
var Output = __webpack_require__(163);
var Sighash = __webpack_require__(182);
var Script = __webpack_require__(106);
var Signature = __webpack_require__(105);
var TransactionSignature = __webpack_require__(273);

/**
 * Represents a special kind of input of PayToPublicKey kind.
 * @constructor
 */
function PublicKeyInput() {
  Input.apply(this, arguments);
}
inherits(PublicKeyInput, Input);

/**
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
 * @param {number} index - the index of the input in the transaction input vector
 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
 * @param {String} signingMethod - method used to sign input - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Array} of objects that can be
 */
PublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  var publicKey = privateKey.toPublicKey();
  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {
    return [new TransactionSignature({
      publicKey: publicKey,
      prevTxId: this.prevTxId,
      outputIndex: this.outputIndex,
      inputIndex: index,
      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod),
      sigtype: sigtype
    })];
  }
  return [];
};

/**
 * Add the provided signature
 *
 * @param {Object} signature
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {number=} signature.sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {PublicKeyInput} this, for chaining
 */
PublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');
  this.setScript(Script.buildPublicKeyIn(
    signature.signature.toDER(),
    signature.sigtype
  ));
  return this;
};

/**
 * Clear the input's signature
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyInput.prototype.clearSignatures = function() {
  this.setScript(Script.empty());
  return this;
};

/**
 * Query whether the input is signed
 * @return {boolean}
 */
PublicKeyInput.prototype.isFullySigned = function() {
  return this.script.isPublicKeyIn();
};

PublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)

PublicKeyInput.prototype._estimateSize = function() {
  return PublicKeyInput.SCRIPT_MAX_SIZE;
};

module.exports = PublicKeyInput;


/***/ }),

/***/ 1510:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(9);

var $ = __webpack_require__(36);
var BufferUtil = __webpack_require__(49);

var Address = __webpack_require__(142);
var Hash = __webpack_require__(76);
var Input = __webpack_require__(272);
var Output = __webpack_require__(163);
var Sighash = __webpack_require__(182);
var SighashWitness = __webpack_require__(361);
var BufferWriter = __webpack_require__(94);
var BufferUtil = __webpack_require__(49);
var Script = __webpack_require__(106);
var Signature = __webpack_require__(105);
var TransactionSignature = __webpack_require__(273);

/**
 * Represents a special kind of input of PayToPublicKeyHash kind.
 * @constructor
 */
function PublicKeyHashInput() {
  Input.apply(this, arguments);
}
inherits(PublicKeyHashInput, Input);

PublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {
  if (!this.redeemScript) {
    var redeemScript = Script.buildWitnessV0Out(publicKey);
    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {
      var scriptSig = new Script();
      scriptSig.add(redeemScript.toBuffer());
      this.setScript(scriptSig);
      this.redeemScript = redeemScript;
    }
  }
  return this.redeemScript;
};

PublicKeyHashInput.prototype.getScriptCode = function(publicKey) {
  var writer = new BufferWriter();
  var script;
  if (this.output.script.isScriptHashOut()) {
    script = this.getRedeemScript(publicKey);
  } else {
    script = this.output.script;
  }
  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();
  writer.writeVarintNum(scriptBuffer.length);
  writer.write(scriptBuffer);
  return writer.toBuffer();
};

PublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {
  var scriptCode = this.getScriptCode(privateKey);
  var satoshisBuffer = this.getSatoshisBuffer();
  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);
};

/* jshint maxparams: 5 */
/**
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
 * @param {number} index - the index of the input in the transaction input vector
 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
 * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Array} of objects that can be
 */
PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var script;
  if (this.output.script.isScriptHashOut()) {
    script = this.getRedeemScript(privateKey.publicKey);
  } else {
    script = this.output.script;
  }

  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {
    var signature;
    if (script.isWitnessPublicKeyHashOut()) {
      var satoshisBuffer = this.getSatoshisBuffer();
      var scriptCode = this.getScriptCode(privateKey.publicKey);
      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
    } else {
      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod);
    }

    return [new TransactionSignature({
      publicKey: privateKey.publicKey,
      prevTxId: this.prevTxId,
      outputIndex: this.outputIndex,
      inputIndex: index,
      signature: signature,
      sigtype: sigtype
    })];
  }
  return [];
};
/* jshint maxparams: 3 */

/**
 * Add the provided signature
 *
 * @param {Object} signature
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {number=} signature.sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');

  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
    this.setWitnesses([
      BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]),
      signature.publicKey.toBuffer()
    ]);
  } else {
    this.setScript(Script.buildPublicKeyHashIn(
      signature.publicKey,
      signature.signature.toDER(),
      signature.sigtype
    ));
  }
  return this;
};

/**
 * Clear the input's signature
 * @return {PublicKeyHashInput} this, for chaining
 */
PublicKeyHashInput.prototype.clearSignatures = function() {
  this.setScript(Script.empty());
  this.setWitnesses([]);
  return this;
};

/**
 * Query whether the input is signed
 * @return {boolean}
 */
PublicKeyHashInput.prototype.isFullySigned = function() {
  return this.script.isPublicKeyHashIn() || this.hasWitnesses();
};

PublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signature.signature.nhashtype = signature.sigtype;
  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
    var scriptCode = this.getScriptCode();
    var satoshisBuffer = this.getSatoshisBuffer();
    return SighashWitness.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      scriptCode,
      satoshisBuffer,
      signingMethod
    );
  } else {
    return Sighash.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      this.output.script,
      signingMethod
    );
  }
};


PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)
PublicKeyHashInput.REDEEM_SCRIPT_SIZE = 22; // OP_0 (1) pubkeyhash (1 + 20)

PublicKeyHashInput.prototype._estimateSize = function() {
  var WITNESS_DISCOUNT = 4;
  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;
  if (this.output.script.isWitnessPublicKeyHashOut()) {
    return witnessSize;
  } else if (this.output.script.isScriptHashOut()) {
    return witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;
  } else {
    return PublicKeyHashInput.SCRIPT_MAX_SIZE;
  }
};

module.exports = PublicKeyHashInput;


/***/ }),

/***/ 1511:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var inherits = __webpack_require__(9);
var Transaction = __webpack_require__(465);
var Input = __webpack_require__(272);
var Output = __webpack_require__(163);
var $ = __webpack_require__(36);

var Script = __webpack_require__(106);
var Signature = __webpack_require__(105);
var Sighash = __webpack_require__(182);
var PublicKey = __webpack_require__(141);
var BufferUtil = __webpack_require__(49);
var TransactionSignature = __webpack_require__(273);

/**
 * @constructor
 */
function MultiSigInput(input, pubkeys, threshold, signatures, opts) {
  opts = opts || {};
  Input.apply(this, arguments);
  var self = this;
  pubkeys = pubkeys || input.publicKeys;
  threshold = threshold || input.threshold;
  signatures = signatures || input.signatures;
  if (opts.noSorting) {
    this.publicKeys = pubkeys
  } else  {
    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });
  }
  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
    'Provided public keys don\'t match to the provided output script');
  this.publicKeyIndex = {};
  _.each(this.publicKeys, function(publicKey, index) {
    self.publicKeyIndex[publicKey.toString()] = index;
  });
  this.threshold = threshold;
  // Empty array of signatures
  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
}
inherits(MultiSigInput, Input);

MultiSigInput.prototype.toObject = function() {
  var obj = Input.prototype.toObject.apply(this, arguments);
  obj.threshold = this.threshold;
  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });
  obj.signatures = this._serializeSignatures();
  return obj;
};

MultiSigInput.prototype._deserializeSignatures = function(signatures) {
  return _.map(signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return new TransactionSignature(signature);
  });
};

MultiSigInput.prototype._serializeSignatures = function() {
  return _.map(this.signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return signature.toObject();
  });
};

MultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var self = this;
  var results = [];
  _.each(this.publicKeys, function(publicKey) {
    if (publicKey.toString() === privateKey.publicKey.toString()) {
      results.push(new TransactionSignature({
        publicKey: privateKey.publicKey,
        prevTxId: self.prevTxId,
        outputIndex: self.outputIndex,
        inputIndex: index,
        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, signingMethod),
        sigtype: sigtype
      }));
    }
  });

  return results;
};

MultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], "Signature Undefined"),
    'Signature has no matching public key');
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature");
  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
  this._updateScript();
  return this;
};

MultiSigInput.prototype._updateScript = function() {
  this.setScript(Script.buildMultisigIn(
    this.publicKeys,
    this.threshold,
    this._createSignatures()
  ));
  return this;
};

MultiSigInput.prototype._createSignatures = function() {
  return _.map(
    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),
    // Future signature types may need refactor of toDER
    function(signature) {
      return BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]);
    }
  );
};

MultiSigInput.prototype.clearSignatures = function() {
  this.signatures = new Array(this.publicKeys.length);
  this._updateScript();
};

MultiSigInput.prototype.isFullySigned = function() {
  return this.countSignatures() === this.threshold;
};

MultiSigInput.prototype.countMissingSignatures = function() {
  return this.threshold - this.countSignatures();
};

MultiSigInput.prototype.countSignatures = function() {
  return _.reduce(this.signatures, function(sum, signature) {
    return sum + (!!signature);
  }, 0);
};

MultiSigInput.prototype.publicKeysWithoutSignature = function() {
  var self = this;
  return _.filter(this.publicKeys, function(publicKey) {
    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);
  });
};

MultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signature.signature.nhashtype = signature.sigtype;
  return Sighash.verify(
    transaction,
    signature.signature,
    signature.publicKey,
    signature.inputIndex,
    this.output.script,
    signingMethod
  );
};

/**
 *
 * @param {Buffer[]} signatures
 * @param {PublicKey[]} publicKeys
 * @param {Transaction} transaction
 * @param {Integer} inputIndex
 * @param {Input} input
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @returns {TransactionSignature[]}
 */
MultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {
  return publicKeys.map(function (pubKey) {
    var signatureMatch = null;
    signatures = signatures.filter(function (signatureBuffer) {
      if (signatureMatch) {
        return true;
      }

      var signature = new TransactionSignature({
        signature: Signature.fromTxFormat(signatureBuffer),
        publicKey: pubKey,
        prevTxId: input.prevTxId,
        outputIndex: input.outputIndex,
        inputIndex: inputIndex,
        sigtype: Signature.SIGHASH_ALL
      });

      signature.signature.nhashtype = signature.sigtype;
      var isMatch = Sighash.verify(
          transaction,
          signature.signature,
          signature.publicKey,
          signature.inputIndex,
          input.output.script,
          signingMethod
      );

      if (isMatch) {
        signatureMatch = signature;
        return false;
      }

      return true;
    });

    return signatureMatch ? signatureMatch : null;
  });
};

MultiSigInput.OPCODES_SIZE = 1; // 0
MultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)

MultiSigInput.prototype._estimateSize = function() {
  return MultiSigInput.OPCODES_SIZE +
    this.threshold * MultiSigInput.SIGNATURE_SIZE;
};

module.exports = MultiSigInput;


/***/ }),

/***/ 1512:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/* jshint maxparams:5 */

var _ = __webpack_require__(1);
var inherits = __webpack_require__(9);
var Input = __webpack_require__(272);
var Output = __webpack_require__(163);
var $ = __webpack_require__(36);

var Address = __webpack_require__(142);
var Script = __webpack_require__(106);
var Signature = __webpack_require__(105);
var Sighash = __webpack_require__(182);
var SighashWitness = __webpack_require__(361);
var BufferWriter = __webpack_require__(94);
var BufferUtil = __webpack_require__(49);
var TransactionSignature = __webpack_require__(273);

/**
 * @constructor
 */
function MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {
  /* jshint maxstatements:20 */
  opts = opts || {};
  Input.apply(this, arguments);
  var self = this;
  pubkeys = pubkeys || input.publicKeys;
  threshold = threshold || input.threshold;
  signatures = signatures || input.signatures;
  if (opts.noSorting) {
    this.publicKeys = pubkeys;
  } else  {
    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });
  }
  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);
  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);
  if (nested.equals(this.output.script)) {
    this.nestedWitness = false;
    this.type = Address.PayToWitnessScriptHash;
  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {
    this.nestedWitness = true;
    this.type = Address.PayToScriptHash;
  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {
    this.nestedWitness = false;
    this.type = Address.PayToScriptHash;
  } else {
    throw new Error('Provided public keys don\'t hash to the provided output');
  }

  if (this.nestedWitness) {
    var scriptSig = new Script();
    scriptSig.add(nested.toBuffer());
    this.setScript(scriptSig);
  }

  this.publicKeyIndex = {};
  _.each(this.publicKeys, function(publicKey, index) {
    self.publicKeyIndex[publicKey.toString()] = index;
  });
  this.threshold = threshold;
  // Empty array of signatures
  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
}
inherits(MultiSigScriptHashInput, Input);

MultiSigScriptHashInput.prototype.toObject = function() {
  var obj = Input.prototype.toObject.apply(this, arguments);
  obj.threshold = this.threshold;
  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });
  obj.signatures = this._serializeSignatures();
  return obj;
};

MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
  return _.map(signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return new TransactionSignature(signature);
  });
};

MultiSigScriptHashInput.prototype._serializeSignatures = function() {
  return _.map(this.signatures, function(signature) {
    if (!signature) {
      return undefined;
    }
    return signature.toObject();
  });
};

MultiSigScriptHashInput.prototype.getScriptCode = function() {
  var writer = new BufferWriter();
  if (!this.redeemScript.hasCodeseparators()) {
    var redeemScriptBuffer = this.redeemScript.toBuffer();
    writer.writeVarintNum(redeemScriptBuffer.length);
    writer.write(redeemScriptBuffer);
  } else {
    throw new Error('@TODO');
  }
  return writer.toBuffer();
};

MultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {
  var self = this;
  var hash;
  if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {
    var scriptCode = self.getScriptCode();
    var satoshisBuffer = self.getSatoshisBuffer();
    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);
  } else  {
    hash = Sighash.sighash(transaction, sigtype, index, self.redeemScript);
  }
  return hash;
};

MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
  $.checkState(this.output instanceof Output);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  signingMethod = signingMethod || 'ecdsa';

  var self = this;
  var results = [];
  _.each(this.publicKeys, function(publicKey) {
    if (publicKey.toString() === privateKey.publicKey.toString()) {
      var signature;
      if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {
        var scriptCode = self.getScriptCode();
        var satoshisBuffer = self.getSatoshisBuffer();
        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
      } else  {
        signature = Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript, signingMethod);
      }
      results.push(new TransactionSignature({
        publicKey: privateKey.publicKey,
        prevTxId: self.prevTxId,
        outputIndex: self.outputIndex,
        inputIndex: index,
        signature: signature,
        sigtype: sigtype
      }));
    }
  });
  return results;
};

MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
                  'Signature has no matching public key');
  $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Invalid Signature!");
  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
  this._updateScript();
  return this;
};

MultiSigScriptHashInput.prototype._updateScript = function() {
  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {
    var stack = [
      Buffer.alloc(0),
    ];
    var signatures = this._createSignatures();
    for (var i = 0; i < signatures.length; i++) {
      stack.push(signatures[i]);
    }
    stack.push(this.redeemScript.toBuffer());
    this.setWitnesses(stack);
  } else {
    var scriptSig = Script.buildP2SHMultisigIn(
      this.publicKeys,
      this.threshold,
      this._createSignatures(),
      { cachedMultisig: this.redeemScript }
    );
    this.setScript(scriptSig);
  }
  return this;
};

MultiSigScriptHashInput.prototype._createSignatures = function() {
  return _.map(
    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),
    function(signature) {
      return BufferUtil.concat([
        signature.signature.toDER(),
        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
      ]);
    }
  );
};

MultiSigScriptHashInput.prototype.clearSignatures = function() {
  this.signatures = new Array(this.publicKeys.length);
  this._updateScript();
};

MultiSigScriptHashInput.prototype.isFullySigned = function() {
  return this.countSignatures() === this.threshold;
};

MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
  return this.threshold - this.countSignatures();
};

MultiSigScriptHashInput.prototype.countSignatures = function() {
  return _.reduce(this.signatures, function(sum, signature) {
    return sum + (!!signature);
  }, 0);
};

MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
  var self = this;
  return _.filter(this.publicKeys, function(publicKey) {
    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);
  });
};

MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';
  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {
    signature.signature.nhashtype = signature.sigtype;
    var scriptCode = this.getScriptCode();
    var satoshisBuffer = this.getSatoshisBuffer();
    return SighashWitness.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      scriptCode,
      satoshisBuffer,
      signingMethod
    );
  } else {
    // FIXME: Refactor signature so this is not necessary
    signature.signature.nhashtype = signature.sigtype;
    return Sighash.verify(
      transaction,
      signature.signature,
      signature.publicKey,
      signature.inputIndex,
      this.redeemScript, 
      signingMethod
    );
  }
};

MultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG
MultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)
MultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)
MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)

MultiSigScriptHashInput.prototype._estimateSize = function() {
  var WITNESS_DISCOUNT = 4;
  var witnessSize = MultiSigScriptHashInput.OPCODES_SIZE +
    this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE +
    this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
  if (this.type === Address.PayToWitnessScriptHash) {
    return witnessSize / WITNESS_DISCOUNT;
  } else if (this.nestedWitness) {
    return witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;
  } else {
    return witnessSize;
  }
};

module.exports = MultiSigScriptHashInput;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1513:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BufferWriter = __webpack_require__(94);
var BufferReader = __webpack_require__(162);
var BN = __webpack_require__(75);

var Varint = function Varint(buf) {
  if (!(this instanceof Varint))
    return new Varint(buf);
  if (Buffer.isBuffer(buf)) {
    this.buf = buf;
  } else if (typeof buf === 'number') {
    var num = buf;
    this.fromNumber(num);
  } else if (buf instanceof BN) {
    var bn = buf;
    this.fromBN(bn);
  } else if (buf) {
    var obj = buf;
    this.set(obj);
  }
};

Varint.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf;
  return this;
};

Varint.prototype.fromString = function(str) {
  this.set({
    buf: Buffer.from(str, 'hex')
  });
  return this;
};

Varint.prototype.toString = function() {
  return this.buf.toString('hex');
};

Varint.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Varint.prototype.fromBufferReader = function(br) {
  this.buf = br.readVarintBuf();
  return this;
};

Varint.prototype.fromBN = function(bn) {
  this.buf = BufferWriter().writeVarintBN(bn).concat();
  return this;
};

Varint.prototype.fromNumber = function(num) {
  this.buf = BufferWriter().writeVarintNum(num).concat();
  return this;
};

Varint.prototype.toBuffer = function() {
  return this.buf;
};

Varint.prototype.toBN = function() {
  return BufferReader(this.buf).readVarintBN();
};

Varint.prototype.toNumber = function() {
  return BufferReader(this.buf).readVarintNum();
};

module.exports = Varint;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1514:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1515);

module.exports.BlockHeader = __webpack_require__(363);
module.exports.MerkleBlock = __webpack_require__(865);


/***/ }),

/***/ 1515:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BlockHeader = __webpack_require__(363);
var BN = __webpack_require__(75);
var BufferUtil = __webpack_require__(49);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var Hash = __webpack_require__(76);
var Transaction = __webpack_require__(360);
var $ = __webpack_require__(36);

/**
 * Instantiate a Block from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {Block}
 * @constructor
 */
function Block(arg) {
  if (!(this instanceof Block)) {
    return new Block(arg);
  }
  _.extend(this, Block._from(arg));
  return this;
}

// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14
Block.MAX_BLOCK_SIZE = 1000000;

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
Block._from = function _from(arg) {
  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = Block._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    info = Block._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for Block');
  }
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Object} - An object representing block data
 * @private
 */
Block._fromObject = function _fromObject(data) {
  var transactions = [];
  data.transactions.forEach(function(tx) {
    if (tx instanceof Transaction) {
      transactions.push(tx);
    } else {
      transactions.push(Transaction().fromObject(tx));
    }
  });
  var info = {
    header: BlockHeader.fromObject(data.header),
    transactions: transactions
  };
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
Block.fromObject = function fromObject(obj) {
  var info = Block._fromObject(obj);
  return new Block(info);
};

/**
 * @param {BufferReader} - Block data
 * @returns {Object} - An object representing the block data
 * @private
 */
Block._fromBufferReader = function _fromBufferReader(br) {
  var info = {};
  $.checkState(!br.finished(), 'No block data received');
  info.header = BlockHeader.fromBufferReader(br);
  var transactions = br.readVarintNum();
  info.transactions = [];
  for (var i = 0; i < transactions; i++) {
    info.transactions.push(Transaction().fromBufferReader(br));
  }
  return info;
};

/**
 * @param {BufferReader} - A buffer reader of the block
 * @returns {Block} - An instance of block
 */
Block.fromBufferReader = function fromBufferReader(br) {
  $.checkArgument(br, 'br is required');
  var info = Block._fromBufferReader(br);
  return new Block(info);
};

/**
 * @param {Buffer} - A buffer of the block
 * @returns {Block} - An instance of block
 */
Block.fromBuffer = function fromBuffer(buf) {
  return Block.fromBufferReader(new BufferReader(buf));
};

/**
 * @param {string} - str - A hex encoded string of the block
 * @returns {Block} - A hex encoded string of the block
 */
Block.fromString = function fromString(str) {
  var buf = Buffer.from(str, 'hex');
  return Block.fromBuffer(buf);
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {Block} - An instance of block
 */
Block.fromRawBlock = function fromRawBlock(data) {
  if (!BufferUtil.isBuffer(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader(data);
  br.pos = Block.Values.START_OF_BLOCK;
  var info = Block._fromBufferReader(br);
  return new Block(info);
};

/**
 * @returns {Object} - A plain object with the block properties
 */
Block.prototype.toObject = Block.prototype.toJSON = function toObject() {
  var transactions = [];
  this.transactions.forEach(function(tx) {
    transactions.push(tx.toObject());
  });
  return {
    header: this.header.toObject(),
    transactions: transactions
  };
};

/**
 * @returns {Buffer} - A buffer of the block
 */
Block.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @returns {string} - A hex encoded string of the block
 */
Block.prototype.toString = function toString() {
  return this.toBuffer().toString('hex');
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the Block
 */
Block.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.write(this.header.toBuffer());
  bw.writeVarintNum(this.transactions.length);
  for (var i = 0; i < this.transactions.length; i++) {
    this.transactions[i].toBufferWriter(bw);
  }
  return bw;
};

/**
 * Will iterate through each transaction and return an array of hashes
 * @returns {Array} - An array with transaction hashes
 */
Block.prototype.getTransactionHashes = function getTransactionHashes() {
  var hashes = [];
  if (this.transactions.length === 0) {
    return [Block.Values.NULL_HASH];
  }
  for (var t = 0; t < this.transactions.length; t++) {
    hashes.push(this.transactions[t]._getHash());
  }
  return hashes;
};

/**
 * Will build a merkle tree of all the transactions, ultimately arriving at
 * a single point, the merkle root.
 * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees
 * @returns {Array} - An array with each level of the tree after the other.
 */
Block.prototype.getMerkleTree = function getMerkleTree() {

  var tree = this.getTransactionHashes();

  var j = 0;
  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
    for (var i = 0; i < size; i += 2) {
      var i2 = Math.min(i + 1, size - 1);
      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
      tree.push(Hash.sha256sha256(buf));
    }
    j += size;
  }

  return tree;
};

/**
 * Calculates the merkleRoot from the transactions.
 * @returns {Buffer} - A buffer of the merkle root hash
 */
Block.prototype.getMerkleRoot = function getMerkleRoot() {
  var tree = this.getMerkleTree();
  return tree[tree.length - 1];
};

/**
 * Verifies that the transactions in the block match the header merkle root
 * @returns {Boolean} - If the merkle roots match
 */
Block.prototype.validMerkleRoot = function validMerkleRoot() {

  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');
  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');

  if (h.cmp(c) !== 0) {
    return false;
  }

  return true;
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
Block.prototype._getHash = function() {
  return this.header._getHash();
};

var idProperty = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function() {
    if (!this._id) {
      this._id = this.header.id;
    }
    return this._id;
  },
  set: _.noop
};
Object.defineProperty(Block.prototype, 'id', idProperty);
Object.defineProperty(Block.prototype, 'hash', idProperty);

/**
 * @returns {string} - A string formatted for the console
 */
Block.prototype.inspect = function inspect() {
  return '<Block ' + this.id + '>';
};

Block.Values = {
  START_OF_BLOCK: 8, // Start of block in raw block data
  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

module.exports = Block;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1516:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var PrivateKey = __webpack_require__(270);
var PublicKey = __webpack_require__(141);
var Address = __webpack_require__(142);
var BufferWriter = __webpack_require__(94);
var ECDSA = __webpack_require__(358);
var Signature = __webpack_require__(105);
var sha256sha256 = __webpack_require__(76).sha256sha256;
var JSUtil = __webpack_require__(60);
var $ = __webpack_require__(36);

function Message(message) {
  if (!(this instanceof Message)) {
    return new Message(message);
  }
  $.checkArgument(_.isString(message), 'First argument should be a string');
  this.message = message;

  return this;
}

Message.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\n');

Message.prototype.magicHash = function magicHash() {
  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);
  var messageBuffer = Buffer.from(this.message);
  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);
  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);
  var hash = sha256sha256(buf);
  return hash;
};

Message.prototype._sign = function _sign(privateKey) {
  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');
  var hash = this.magicHash();
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = hash;
  ecdsa.privkey = privateKey;
  ecdsa.pubkey = privateKey.toPublicKey();
  ecdsa.signRandomK();
  ecdsa.calci();
  return ecdsa.sig;
};

/**
 * Will sign a message with a given bitcoin private key.
 *
 * @param {PrivateKey} privateKey - An instance of PrivateKey
 * @returns {String} A base64 encoded compact signature
 */
Message.prototype.sign = function sign(privateKey) {
  var signature = this._sign(privateKey);
  return signature.toCompact().toString('base64');
};

Message.prototype._verify = function _verify(publicKey, signature) {
  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');
  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');
  var hash = this.magicHash();
  var verified = ECDSA.verify(hash, signature, publicKey);
  if (!verified) {
    this.error = 'The signature was invalid';
  }
  return verified;
};

/**
 * Will return a boolean of the signature is valid for a given bitcoin address.
 * If it isn't the specific reason is accessible via the "error" member.
 *
 * @param {Address|String} bitcoinAddress - A bitcoin address
 * @param {String} signatureString - A base64 encoded compact signature
 * @returns {Boolean}
 */
Message.prototype.verify = function verify(bitcoinAddress, signatureString) {
  $.checkArgument(bitcoinAddress);
  $.checkArgument(signatureString && _.isString(signatureString));

  if (_.isString(bitcoinAddress)) {
    bitcoinAddress = Address.fromString(bitcoinAddress);
  }
  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));

  // recover the public key
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = this.magicHash();
  ecdsa.sig = signature;
  var publicKey = ecdsa.toPublicKey();

  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);

  // check that the recovered address and specified address match
  if (bitcoinAddress.toString() !== signatureAddress.toString()) {
    this.error = 'The signature did not match the message digest';
    return false;
  }

  return this._verify(publicKey, signature);
};

/**
 * Will return a public key string if the provided signature and the message digest is correct
 * If it isn't the specific reason is accessible via the "error" member.
 *
 * @param {Address|String} bitcoinAddress - A bitcoin address
 * @param {String} signatureString - A base64 encoded compact signature
 * @returns {String}
 */
Message.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {
  $.checkArgument(bitcoinAddress);
  $.checkArgument(signatureString && _.isString(signatureString));

  if (_.isString(bitcoinAddress)) {
    bitcoinAddress = Address.fromString(bitcoinAddress);
  }
  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));

  // recover the public key
  var ecdsa = new ECDSA();
  ecdsa.hashbuf = this.magicHash();
  ecdsa.sig = signature;
  var publicKey = ecdsa.toPublicKey();

  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);

  // check that the recovered address and specified address match
  if (bitcoinAddress.toString() !== signatureAddress.toString()) {
    this.error = 'The signature did not match the message digest';
  }

  return publicKey.toString();
};

/**
 * Instantiate a message from a message string
 *
 * @param {String} str - A string of the message
 * @returns {Message} A new instance of a Message
 */
Message.fromString = function(str) {
  return new Message(str);
};

/**
 * Instantiate a message from JSON
 *
 * @param {String} json - An JSON string or Object with keys: message
 * @returns {Message} A new instance of a Message
 */
Message.fromJSON = function fromJSON(json) {
  if (JSUtil.isValidJSON(json)) {
    json = JSON.parse(json);
  }
  return new Message(json.message);
};

/**
 * @returns {Object} A plain object with the message information
 */
Message.prototype.toObject = function toObject() {
  return {
    message: this.message
  };
};

/**
 * @returns {String} A JSON representation of the message information
 */
Message.prototype.toJSON = function toJSON() {
  return JSON.stringify(this.toObject());
};

/**
 * Will return a the string representation of the message
 *
 * @returns {String} Message
 */
Message.prototype.toString = function() {
  return this.message;
};

/**
 * Will return a string formatted for the console
 *
 * @returns {String} Message
 */
Message.prototype.inspect = function() {
  return '<Message: ' + this.toString() + '>';
};

module.exports = Message;

var Script = __webpack_require__(106);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1517:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var URL = __webpack_require__(81);

var Address = __webpack_require__(142);
var Unit = __webpack_require__(467);

/**
 * Bitcore URI
 *
 * Instantiate an URI from a tkcoin URI String or an Object. An URI instance
 * can be created with a tkcoin uri string or an object. All instances of
 * URI are valid, the static method isValid allows checking before instantiation.
 *
 * All standard parameters can be found as members of the class, the address
 * is represented using an {Address} instance and the amount is represented in
 * satoshis. Any other non-standard parameters can be found under the extra member.
 *
 * @example
 * ```javascript
 *
 * var uri = new URI('tkcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');
 * console.log(uri.address, uri.amount);
 * ```
 *
 * @param {string|Object} data - A tkcoin URI string or an Object
 * @param {Array.<string>=} knownParams - Required non-standard params
 * @throws {TypeError} Invalid tkcoin address
 * @throws {TypeError} Invalid amount
 * @throws {Error} Unknown required argument
 * @returns {URI} A new valid and frozen instance of URI
 * @constructor
 */
var URI = function(data, knownParams) {
  if (!(this instanceof URI)) {
    return new URI(data, knownParams);
  }

  this.extras = {};
  this.knownParams = knownParams || [];
  this.address = this.network = this.amount = this.message = null;

  if (typeof(data) === 'string') {
    var params = URI.parse(data);
    if (params.amount) {
      params.amount = this._parseAmount(params.amount);
    }
    this._fromObject(params);
  } else if (typeof(data) === 'object') {
    this._fromObject(data);
  } else {
    throw new TypeError('Unrecognized data format.');
  }
};

/**
 * Instantiate a URI from a String
 *
 * @param {string} str - JSON string or object of the URI
 * @returns {URI} A new instance of a URI
 */
URI.fromString = function fromString(str) {
  if (typeof(str) !== 'string') {
    throw new TypeError('Expected a string');
  }
  return new URI(str);
};

/**
 * Instantiate a URI from an Object
 *
 * @param {Object} data - object of the URI
 * @returns {URI} A new instance of a URI
 */
URI.fromObject = function fromObject(json) {
  return new URI(json);
};

/**
 * Check if an tkcoin URI string is valid
 *
 * @example
 * ```javascript
 *
 * var valid = URI.isValid('tkcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');
 * // true
 * ```
 *
 * @param {string|Object} data - A tkcoin URI string or an Object
 * @param {Array.<string>=} knownParams - Required non-standard params
 * @returns {boolean} Result of uri validation
 */
URI.isValid = function(arg, knownParams) {
  try {
    new URI(arg, knownParams);
  } catch (err) {
    return false;
  }
  return true;
};

/**
 * Convert a tkcoin URI string into a simple object.
 *
 * @param {string} uri - A tkcoin URI string
 * @throws {TypeError} Invalid tkcoin URI
 * @returns {Object} An object with the parsed params
 */
URI.parse = function(uri) {
  var info = URL.parse(uri, true);

  if (info.protocol !== 'tkcoin:') {
    throw new TypeError('Invalid tkcoin URI');
  }

  // workaround to host insensitiveness
  var group = /[^:]*:\/?\/?([^?]*)/.exec(uri);
  info.query.address = group && group[1] || undefined;

  return info.query;
};

URI.Members = ['address', 'amount', 'message', 'label', 'r'];

/**
 * Internal function to load the URI instance with an object.
 *
 * @param {Object} obj - Object with the information
 * @throws {TypeError} Invalid tkcoin address
 * @throws {TypeError} Invalid amount
 * @throws {Error} Unknown required argument
 */
URI.prototype._fromObject = function(obj) {
  /* jshint maxcomplexity: 10 */

  if (!Address.isValid(obj.address)) {
    throw new TypeError('Invalid tkcoin address');
  }

  this.address = new Address(obj.address);
  this.network = this.address.network;
  this.amount = obj.amount;

  for (var key in obj) {
    if (key === 'address' || key === 'amount') {
      continue;
    }

    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {
      throw Error('Unknown required argument ' + key);
    }

    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;
    destination[key] = obj[key];
  }
};

/**
 * Internal function to transform a TIK string amount into satoshis
 *
 * @param {string} amount - Amount TIK string
 * @throws {TypeError} Invalid amount
 * @returns {Object} Amount represented in satoshis
 */
URI.prototype._parseAmount = function(amount) {
  amount = Number(amount);
  if (isNaN(amount)) {
    throw new TypeError('Invalid amount');
  }
  return Unit.fromBTC(amount).toSatoshis();
};

URI.prototype.toObject = URI.prototype.toJSON = function toObject() {
  var json = {};
  for (var i = 0; i < URI.Members.length; i++) {
    var m = URI.Members[i];
    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {
      json[m] = this[m].toString();
    }
  }
  _.extend(json, this.extras);
  return json;
};

/**
 * Will return a the string representation of the URI
 *
 * @returns {string} TKCoin URI string
 */
URI.prototype.toString = function() {
  var query = {};
  if (this.amount) {
    query.amount = Unit.fromSatoshis(this.amount).toTIK();
  }
  if (this.message) {
    query.message = this.message;
  }
  if (this.label) {
    query.label = this.label;
  }
  if (this.r) {
    query.r = this.r;
  }
  _.extend(query, this.extras);

  return URL.format({
    protocol: 'tkcoin:',
    host: this.address,
    query: query
  });
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} TKCoin URI
 */
URI.prototype.inspect = function() {
  return '<URI: ' + this.toString() + '>';
};

module.exports = URI;


/***/ }),

/***/ 1588:
/***/ (function(module, exports) {

const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}


/***/ }),

/***/ 1589:
/***/ (function(module, exports, __webpack_require__) {

const EC = __webpack_require__(54).ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}


/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var BufferUtil = __webpack_require__(48);
var BN = __webpack_require__(73);

var BufferReader = function BufferReader(buf) {
  if (!(this instanceof BufferReader)) {
    return new BufferReader(buf);
  }
  if (_.isUndefined(buf)) {
    return;
  }
  if (Buffer.isBuffer(buf)) {
    this.set({
      buf: buf
    });
  } else if (_.isString(buf)) {
    this.set({
      buf: Buffer.from(buf, 'hex'),
    });
  } else if (_.isObject(buf)) {
    var obj = buf;
    this.set(obj);
  } else {
    throw new TypeError('Unrecognized argument for BufferReader');
  }
};

BufferReader.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  this.pos = obj.pos || this.pos || 0;
  return this;
};

BufferReader.prototype.eof = function() {
  if(this.buf) {
    return this.pos >= this.buf.length;
  } else {
    return true;
  }
};

BufferReader.prototype.finished = BufferReader.prototype.eof;

BufferReader.prototype.read = function(len) {
  $.checkArgument(!_.isUndefined(len), 'Must specify a length');
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return buf;
};

BufferReader.prototype.readAll = function() {
  var buf = this.buf.slice(this.pos, this.buf.length);
  this.pos = this.buf.length;
  return buf;
};

BufferReader.prototype.readUInt8 = function() {
  var val = this.buf.readUInt8(this.pos);
  this.pos = this.pos + 1;
  return val;
};

BufferReader.prototype.readUInt16BE = function() {
  var val = this.buf.readUInt16BE(this.pos);
  this.pos = this.pos + 2;
  return val;
};

BufferReader.prototype.readUInt16LE = function() {
  var val = this.buf.readUInt16LE(this.pos);
  this.pos = this.pos + 2;
  return val;
};

BufferReader.prototype.readUInt32BE = function() {
  var val = this.buf.readUInt32BE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readUInt32LE = function() {
  var val = this.buf.readUInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readInt32LE = function() {
  var val = this.buf.readInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readUInt64BEBN = function() {
  var buf = this.buf.slice(this.pos, this.pos + 8);
  var bn = BN.fromBuffer(buf);
  this.pos = this.pos + 8;
  return bn;
};

BufferReader.prototype.readUInt64LEBN = function() {
  var second = this.buf.readUInt32LE(this.pos);
  var first = this.buf.readUInt32LE(this.pos + 4);
  var combined = (first * 0x100000000) + second;
  // Instantiating an instance of BN with a number is faster than with an
  // array or string. However, the maximum safe number for a double precision
  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use
  // non-floating point numbers less than this amount (52 bits). And in the case
  // that the number is larger, we can instatiate an instance of BN by passing
  // an array from the buffer (slower) and specifying the endianness.
  var bn;
  if (combined <= 0x1fffffffffffff) {
    bn = new BN(combined);
  } else {
    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
    bn = new BN(data, 10, 'le');
  }
  this.pos = this.pos + 8;
  return bn;
};

BufferReader.prototype.readVarintNum = function() {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return this.readUInt16LE();
    case 0xFE:
      return this.readUInt32LE();
    case 0xFF:
      var bn = this.readUInt64LEBN();
      var n = bn.toNumber();
      if (n <= Math.pow(2, 53)) {
        return n;
      } else {
        throw new Error('number too large to retain precision - use readVarintBN');
      }
      break;
    default:
      return first;
  }
};

/**
 * reads a length prepended buffer
 */
BufferReader.prototype.readVarLengthBuffer = function() {
  var len = this.readVarintNum();
  var buf = this.read(len);
  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +
    'Expected to read: ' + len + ' and read ' + buf.length);
  return buf;
};

BufferReader.prototype.readVarintBuf = function() {
  var first = this.buf.readUInt8(this.pos);
  switch (first) {
    case 0xFD:
      return this.read(1 + 2);
    case 0xFE:
      return this.read(1 + 4);
    case 0xFF:
      return this.read(1 + 8);
    default:
      return this.read(1);
  }
};

BufferReader.prototype.readVarintBN = function() {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return new BN(this.readUInt16LE());
    case 0xFE:
      return new BN(this.readUInt32LE());
    case 0xFF:
      return this.readUInt64LEBN();
    default:
      return new BN(first);
  }
};

BufferReader.prototype.reverse = function() {
  var buf = Buffer.alloc(this.buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf[i] = this.buf[this.buf.length - 1 - i];
  }
  this.buf = buf;
  return this;
};

BufferReader.prototype.readReverse = function(len) {
  if (_.isUndefined(len)) {
    len = this.buf.length;
  }
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return BufferUtil.reverse(buf);
};

module.exports = BufferReader;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BN = __webpack_require__(73);
var buffer = __webpack_require__(2);
var bufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);
var BufferWriter = __webpack_require__(93);
var Script = __webpack_require__(104);
var $ = __webpack_require__(35);
var errors = __webpack_require__(115);

var MAX_SAFE_INTEGER = 0x1fffffffffffff;

function Output(args) {
  if (!(this instanceof Output)) {
    return new Output(args);
  }
  if (_.isObject(args)) {
    this.satoshis = args.satoshis;
    if (bufferUtil.isBuffer(args.script)) {
      this._scriptBuffer = args.script;
    } else {
      var script;
      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {
        script = Buffer.from(args.script, 'hex');
      } else {
        script = args.script;
      }
      this.setScript(script);
    }
  } else {
    throw new TypeError('Unrecognized argument for Output');
  }
}

Object.defineProperty(Output.prototype, 'script', {
  configurable: false,
  enumerable: true,
  get: function() {
    if (this._script) {
      return this._script;
    } else {
      this.setScriptFromBuffer(this._scriptBuffer);
      return this._script;
    }

  }
});

Object.defineProperty(Output.prototype, 'satoshis', {
  configurable: false,
  enumerable: true,
  get: function() {
    return this._satoshis;
  },
  set: function(num) {
    if (num instanceof BN) {
      this._satoshisBN = num;
      this._satoshis = num.toNumber();
    } else if (_.isString(num)) {
      this._satoshis = parseInt(num);
      this._satoshisBN = BN.fromNumber(this._satoshis);
    } else {
      $.checkArgument(
        JSUtil.isNaturalNumber(num),
        'Output satoshis is not a natural number'
      );
      this._satoshisBN = BN.fromNumber(num);
      this._satoshis = num;
    }
    $.checkState(
      JSUtil.isNaturalNumber(this._satoshis),
      'Output satoshis is not a natural number'
    );
  }
});

Output.prototype.invalidSatoshis = function() {
  if (this._satoshis > MAX_SAFE_INTEGER) {
    return 'transaction txout satoshis greater than max safe integer';
  }
  if (this._satoshis !== this._satoshisBN.toNumber()) {
    return 'transaction txout satoshis has corrupted value';
  }
  if (this._satoshis < 0) {
    return 'transaction txout negative';
  }
  return false;
};

Output.prototype.toObject = Output.prototype.toJSON = function toObject() {
  var obj = {
    satoshis: this.satoshis
  };
  obj.script = this._scriptBuffer.toString('hex');
  return obj;
};

Output.fromObject = function(data) {
  return new Output(data);
};

Output.prototype.setScriptFromBuffer = function(buffer) {
  this._scriptBuffer = buffer;
  try {
    this._script = Script.fromBuffer(this._scriptBuffer);
    this._script._isOutput = true;
  } catch(e) {
    if (e instanceof errors.Script.InvalidBuffer) {
      this._script = null;
    } else {
      throw e;
    }
  }
};

Output.prototype.setScript = function(script) {
  if (script instanceof Script) {
    this._scriptBuffer = script.toBuffer();
    this._script = script;
    this._script._isOutput = true;
  } else if (_.isString(script)) {
    this._script = Script.fromString(script);
    this._scriptBuffer = this._script.toBuffer();
    this._script._isOutput = true;
  } else if (bufferUtil.isBuffer(script)) {
    this.setScriptFromBuffer(script);
  } else {
    throw new TypeError('Invalid argument type: script');
  }
  return this;
};

Output.prototype.inspect = function() {
  var scriptStr;
  if (this.script) {
    scriptStr = this.script.inspect();
  } else {
    scriptStr = this._scriptBuffer.toString('hex');
  }
  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';
};

Output.fromBufferReader = function(br) {
  var obj = {};
  obj.satoshis = br.readUInt64LEBN();
  var size = br.readVarintNum();
  if (size !== 0) {
    obj.script = br.read(size);
  } else {
    obj.script = Buffer.from([]);
  }
  return new Output(obj);
};

Output.prototype.toBufferWriter = function(writer) {
  if (!writer) {
    writer = new BufferWriter();
  }
  writer.writeUInt64LEBN(this._satoshisBN);
  var script = this._scriptBuffer;
  writer.writeVarintNum(script.length);
  writer.write(script);
  return writer;
};

module.exports = Output;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var BufferUtil = __webpack_require__(49);
var BN = __webpack_require__(75);

var BufferReader = function BufferReader(buf) {
  if (!(this instanceof BufferReader)) {
    return new BufferReader(buf);
  }
  if (_.isUndefined(buf)) {
    return;
  }
  if (Buffer.isBuffer(buf)) {
    this.set({
      buf: buf
    });
  } else if (_.isString(buf)) {
    this.set({
      buf: Buffer.from(buf, 'hex'),
    });
  } else if (_.isObject(buf)) {
    var obj = buf;
    this.set(obj);
  } else {
    throw new TypeError('Unrecognized argument for BufferReader');
  }
};

BufferReader.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  this.pos = obj.pos || this.pos || 0;
  return this;
};

BufferReader.prototype.eof = function() {
  if(this.buf) {
    return this.pos >= this.buf.length;
  } else {
    return true;
  }
};

BufferReader.prototype.finished = BufferReader.prototype.eof;

BufferReader.prototype.read = function(len) {
  $.checkArgument(!_.isUndefined(len), 'Must specify a length');
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return buf;
};

BufferReader.prototype.readAll = function() {
  var buf = this.buf.slice(this.pos, this.buf.length);
  this.pos = this.buf.length;
  return buf;
};

BufferReader.prototype.readUInt8 = function() {
  var val = this.buf.readUInt8(this.pos);
  this.pos = this.pos + 1;
  return val;
};

BufferReader.prototype.readUInt16BE = function() {
  var val = this.buf.readUInt16BE(this.pos);
  this.pos = this.pos + 2;
  return val;
};

BufferReader.prototype.readUInt16LE = function() {
  var val = this.buf.readUInt16LE(this.pos);
  this.pos = this.pos + 2;
  return val;
};

BufferReader.prototype.readUInt32BE = function() {
  var val = this.buf.readUInt32BE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readUInt32LE = function() {
  var val = this.buf.readUInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readInt32LE = function() {
  var val = this.buf.readInt32LE(this.pos);
  this.pos = this.pos + 4;
  return val;
};

BufferReader.prototype.readUInt64BEBN = function() {
  var buf = this.buf.slice(this.pos, this.pos + 8);
  var bn = BN.fromBuffer(buf);
  this.pos = this.pos + 8;
  return bn;
};

BufferReader.prototype.readUInt64LEBN = function() {
  var second = this.buf.readUInt32LE(this.pos);
  var first = this.buf.readUInt32LE(this.pos + 4);
  var combined = (first * 0x100000000) + second;
  // Instantiating an instance of BN with a number is faster than with an
  // array or string. However, the maximum safe number for a double precision
  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use
  // non-floating point numbers less than this amount (52 bits). And in the case
  // that the number is larger, we can instatiate an instance of BN by passing
  // an array from the buffer (slower) and specifying the endianness.
  var bn;
  if (combined <= 0x1fffffffffffff) {
    bn = new BN(combined);
  } else {
    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
    bn = new BN(data, 10, 'le');
  }
  this.pos = this.pos + 8;
  return bn;
};

BufferReader.prototype.readVarintNum = function() {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return this.readUInt16LE();
    case 0xFE:
      return this.readUInt32LE();
    case 0xFF:
      var bn = this.readUInt64LEBN();
      var n = bn.toNumber();
      if (n <= Math.pow(2, 53)) {
        return n;
      } else {
        throw new Error('number too large to retain precision - use readVarintBN');
      }
      break;
    default:
      return first;
  }
};

/**
 * reads a length prepended buffer
 */
BufferReader.prototype.readVarLengthBuffer = function() {
  var len = this.readVarintNum();
  var buf = this.read(len);
  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +
    'Expected to read: ' + len + ' and read ' + buf.length);
  return buf;
};

BufferReader.prototype.readVarintBuf = function() {
  var first = this.buf.readUInt8(this.pos);
  switch (first) {
    case 0xFD:
      return this.read(1 + 2);
    case 0xFE:
      return this.read(1 + 4);
    case 0xFF:
      return this.read(1 + 8);
    default:
      return this.read(1);
  }
};

BufferReader.prototype.readVarintBN = function() {
  var first = this.readUInt8();
  switch (first) {
    case 0xFD:
      return new BN(this.readUInt16LE());
    case 0xFE:
      return new BN(this.readUInt32LE());
    case 0xFF:
      return this.readUInt64LEBN();
    default:
      return new BN(first);
  }
};

BufferReader.prototype.reverse = function() {
  var buf = Buffer.alloc(this.buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf[i] = this.buf[this.buf.length - 1 - i];
  }
  this.buf = buf;
  return this;
};

BufferReader.prototype.readReverse = function(len) {
  if (_.isUndefined(len)) {
    len = this.buf.length;
  }
  var buf = this.buf.slice(this.pos, this.pos + len);
  this.pos = this.pos + len;
  return BufferUtil.reverse(buf);
};

module.exports = BufferReader;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 163:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BN = __webpack_require__(75);
var buffer = __webpack_require__(2);
var bufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);
var BufferWriter = __webpack_require__(94);
var Script = __webpack_require__(106);
var $ = __webpack_require__(36);
var errors = __webpack_require__(116);

var MAX_SAFE_INTEGER = 0x1fffffffffffff;

function Output(args) {
  if (!(this instanceof Output)) {
    return new Output(args);
  }
  if (_.isObject(args)) {
    this.satoshis = args.satoshis;
    if (bufferUtil.isBuffer(args.script)) {
      this._scriptBuffer = args.script;
    } else {
      var script;
      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {
        script = Buffer.from(args.script, 'hex');
      } else {
        script = args.script;
      }
      this.setScript(script);
    }
  } else {
    throw new TypeError('Unrecognized argument for Output');
  }
}

Object.defineProperty(Output.prototype, 'script', {
  configurable: false,
  enumerable: true,
  get: function() {
    if (this._script) {
      return this._script;
    } else {
      this.setScriptFromBuffer(this._scriptBuffer);
      return this._script;
    }

  }
});

Object.defineProperty(Output.prototype, 'satoshis', {
  configurable: false,
  enumerable: true,
  get: function() {
    return this._satoshis;
  },
  set: function(num) {
    if (num instanceof BN) {
      this._satoshisBN = num;
      this._satoshis = num.toNumber();
    } else if (_.isString(num)) {
      this._satoshis = parseInt(num);
      this._satoshisBN = BN.fromNumber(this._satoshis);
    } else {
      $.checkArgument(
        JSUtil.isNaturalNumber(num),
        'Output satoshis is not a natural number'
      );
      this._satoshisBN = BN.fromNumber(num);
      this._satoshis = num;
    }
    $.checkState(
      JSUtil.isNaturalNumber(this._satoshis),
      'Output satoshis is not a natural number'
    );
  }
});

Output.prototype.invalidSatoshis = function() {
  if (this._satoshis > MAX_SAFE_INTEGER) {
    return 'transaction txout satoshis greater than max safe integer';
  }
  if (this._satoshis !== this._satoshisBN.toNumber()) {
    return 'transaction txout satoshis has corrupted value';
  }
  if (this._satoshis < 0) {
    return 'transaction txout negative';
  }
  return false;
};

Output.prototype.toObject = Output.prototype.toJSON = function toObject() {
  var obj = {
    satoshis: this.satoshis
  };
  obj.script = this._scriptBuffer.toString('hex');
  return obj;
};

Output.fromObject = function(data) {
  return new Output(data);
};

Output.prototype.setScriptFromBuffer = function(buffer) {
  this._scriptBuffer = buffer;
  try {
    this._script = Script.fromBuffer(this._scriptBuffer);
    this._script._isOutput = true;
  } catch(e) {
    if (e instanceof errors.Script.InvalidBuffer) {
      this._script = null;
    } else {
      throw e;
    }
  }
};

Output.prototype.setScript = function(script) {
  if (script instanceof Script) {
    this._scriptBuffer = script.toBuffer();
    this._script = script;
    this._script._isOutput = true;
  } else if (_.isString(script)) {
    this._script = Script.fromString(script);
    this._scriptBuffer = this._script.toBuffer();
    this._script._isOutput = true;
  } else if (bufferUtil.isBuffer(script)) {
    this.setScriptFromBuffer(script);
  } else {
    throw new TypeError('Invalid argument type: script');
  }
  return this;
};

Output.prototype.inspect = function() {
  var scriptStr;
  if (this.script) {
    scriptStr = this.script.inspect();
  } else {
    scriptStr = this._scriptBuffer.toString('hex');
  }
  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';
};

Output.fromBufferReader = function(br) {
  var obj = {};
  obj.satoshis = br.readUInt64LEBN();
  var size = br.readVarintNum();
  if (size !== 0) {
    obj.script = br.read(size);
  } else {
    obj.script = Buffer.from([]);
  }
  return new Output(obj);
};

Output.prototype.toBufferWriter = function(writer) {
  if (!writer) {
    writer = new BufferWriter();
  }
  writer.writeUInt64LEBN(this._satoshisBN);
  var script = this._scriptBuffer;
  writer.writeVarintNum(script.length);
  writer.write(script);
  return writer;
};

module.exports = Output;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 164:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressBookProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);







let AddressBookProvider = class AddressBookProvider {
    constructor(logger, persistenceProvider, translate, addressProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.addressProvider = addressProvider;
        this.logger.debug('AddressBookProvider initialized');
    }
    get(addr) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                if (ab && ab[addr])
                    return resolve(ab[addr]);
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab => {
                    if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                        ab = JSON.parse(ab);
                    if (ab && ab[addr])
                        return resolve(ab[addr]);
                    return resolve();
                })
                    .catch(() => {
                    return reject();
                });
            })
                .catch(() => {
                return reject();
            });
        });
    }
    list() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab2 => {
                    if (ab2 && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                        ab2 = JSON.parse(ab2);
                    ab2 = ab2 || {};
                    return resolve(__WEBPACK_IMPORTED_MODULE_6_lodash__["defaults"](ab2, ab));
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(() => {
                let msg = this.translate.instant('Could not get the Addressbook');
                return reject(msg);
            });
        });
    }
    add(entry) {
        return new Promise((resolve, reject) => {
            const addrData = this.addressProvider.getCoinAndNetwork(entry.address);
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](addrData)) {
                let msg = this.translate.instant('Not valid bitcoin address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(addrData.network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isArray"](ab))
                    ab = {}; // No array
                if (ab[entry.address]) {
                    let msg = this.translate.instant('Entry already exist');
                    return reject(msg);
                }
                ab[entry.address] = entry;
                this.persistenceProvider
                    .setAddressBook(addrData.network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error adding new entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    remove(addr) {
        return new Promise((resolve, reject) => {
            const addrData = this.addressProvider.getCoinAndNetwork(addr);
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](addrData)) {
                let msg = this.translate.instant('Not valid bitcoin address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(addrData.network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](ab)) {
                    let msg = this.translate.instant('Addressbook is empty');
                    return reject(msg);
                }
                if (!ab[addr]) {
                    let msg = this.translate.instant('Entry does not exist');
                    return reject(msg);
                }
                delete ab[addr];
                this.persistenceProvider
                    .setAddressBook(addrData.network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error deleting entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
};
AddressBookProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__address_address__["a" /* AddressProvider */]])
], AddressBookProvider);

//# sourceMappingURL=address-book.js.map

/***/ }),

/***/ 165:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash__);




// providers










const LIMIT = 100;
let CoinbaseProvider = class CoinbaseProvider {
    constructor(http, logger, persistenceProvider, platformProvider, homeIntegrationsProvider, configProvider, appProvider, currencyProvider, analyticsProvider, rateProvider) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.appProvider = appProvider;
        this.currencyProvider = currencyProvider;
        this.analyticsProvider = analyticsProvider;
        this.rateProvider = rateProvider;
        this.environment = __WEBPACK_IMPORTED_MODULE_4__environments__["a" /* default */].name;
        this.linkedAccount = false;
        // URLs
        this.supportUrl = 'https://support.coinbase.com';
        this.signupUrl = 'https://www.coinbase.com/signup';
        this.debounceSetData = __WEBPACK_IMPORTED_MODULE_13_lodash__["debounce"](this.setData, 5000, {
            leading: false
        });
        /*
         * Development: Gustavo's Account
         * Production: TKCoin Account
         */
        this.logger.debug('Coinbase initialized: ' + this.environment);
        this.credentials = {};
        this.coinbaseData = {
            token: {},
            accounts: [],
            user: {},
            txs: {}
        };
    }
    setCredentials() {
        if (!this.appProvider.servicesInfo ||
            !this.appProvider.servicesInfo.coinbase) {
            return;
        }
        const coinbase = this.appProvider.servicesInfo.coinbase;
        this.credentials.REDIRECT_URI = this.platformProvider.isCordova
            ? coinbase.redirect_uri.mobile
            : coinbase.redirect_uri.desktop;
        // Force to use specific version
        this.credentials.API_VERSION = '2017-10-31'; // TODO: there is a newest version: 2020-02-11
        if (this.environment == 'development') {
            /*
             * Development: Gustavo's Coinbase Account
             */
            this.credentials.HOST = coinbase.sandbox.host;
            this.credentials.API = coinbase.sandbox.api;
            this.credentials.CLIENT_ID = coinbase.sandbox.client_id;
            this.credentials.CLIENT_SECRET = coinbase.sandbox.client_secret;
            this.credentials.SCOPE =
                '' +
                    'wallet:accounts:read,' +
                    'wallet:addresses:read,' +
                    'wallet:addresses:create,' +
                    'wallet:user:read,' +
                    'wallet:user:email,' +
                    'wallet:transactions:read,' +
                    'wallet:transactions:send';
            // Set Authorize URL
            this.oauthUrl =
                this.credentials.HOST +
                    '/oauth/authorize?response_type=code&client_id=' +
                    this.credentials.CLIENT_ID +
                    '&redirect_uri=' +
                    this.credentials.REDIRECT_URI +
                    '&account=all&state=SECURE_RANDOM&scope=' +
                    this.credentials.SCOPE +
                    '&meta[send_limit_amount]=1&meta[send_limit_currency]=USD&meta[send_limit_period]=day';
        }
        else {
            /*
             * Production: TKCoin Account
             */
            this.credentials.HOST = coinbase.production.host;
            this.credentials.API = coinbase.production.api;
            this.credentials.CLIENT_ID = coinbase.production.client_id;
            this.credentials.CLIENT_SECRET = coinbase.production.client_secret;
            this.credentials.SCOPE =
                '' +
                    'wallet:accounts:read,' +
                    'wallet:addresses:read,' +
                    'wallet:addresses:create,' +
                    'wallet:user:read,' +
                    'wallet:user:email,' +
                    'wallet:transactions:read,' +
                    'wallet:transactions:send,' +
                    'wallet:transactions:send:bypass-2fa';
            // Set Authorize URL
            this.oauthUrl =
                this.credentials.HOST +
                    '/oauth/authorize?response_type=code&client_id=' +
                    this.credentials.CLIENT_ID +
                    '&redirect_uri=' +
                    this.credentials.REDIRECT_URI +
                    '&account=all&state=SECURE_RANDOM&scope=' +
                    this.credentials.SCOPE +
                    '&meta[send_limit_amount]=1000&meta[send_limit_currency]=USD&meta[send_limit_period]=day';
        }
    }
    getNativeCurrencyBalance(amount, currency) {
        if (!this.coinbaseExchange)
            return null;
        if (!this.coinbaseExchange.rates[currency])
            return null; // Coin rate has been removed from Coinbase
        return (amount / this.coinbaseExchange.rates[currency]).toFixed(2) || '0';
    }
    parseErrorsAsString(e) {
        let errData;
        try {
            if (e && e.errors)
                errData = e.errors;
            else if (e && e.error)
                errData = e.error_description;
            else
                return JSON.stringify(e);
            if (!__WEBPACK_IMPORTED_MODULE_13_lodash__["isArray"](errData)) {
                errData = errData && errData.message ? errData.message : errData;
                return errData;
            }
            if (__WEBPACK_IMPORTED_MODULE_13_lodash__["isArray"](errData)) {
                var errStr = '';
                for (var i = 0; i < errData.length; i++) {
                    errStr = errStr + errData[i].message + '. ';
                }
                return errStr;
            }
            const msg = JSON.stringify(errData);
            this.logger.error('Coinbase:' + msg);
            return msg;
        }
        catch (e) {
            this.logger.error(e);
            return e;
        }
    }
    isEnabled() {
        return !__WEBPACK_IMPORTED_MODULE_13_lodash__["isEmpty"](this.credentials.CLIENT_ID);
    }
    getData() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getCoinbase(this.environment)
                .then(data => {
                if (__WEBPACK_IMPORTED_MODULE_13_lodash__["isString"](data)) {
                    try {
                        data = JSON.parse(data);
                    }
                    catch (e) {
                        this.logger.error('Coinbase: Parse file error', e);
                        this.removeData();
                        return resolve();
                    }
                }
                return resolve(data);
            })
                .catch(e => {
                return reject(e);
            });
        });
    }
    setData() {
        if (!this.linkedAccount)
            return;
        this.persistenceProvider.setCoinbase(this.environment, this.coinbaseData);
    }
    removeData() {
        if (!this.linkedAccount)
            return;
        this.persistenceProvider.removeCoinbase(this.environment);
    }
    setTransactions(accountId, txs) {
        this.coinbaseData['txs'][accountId] = txs;
        this.debounceSetData();
    }
    setToken(token) {
        this.coinbaseData['token'] = token;
        this.debounceSetData();
    }
    setCurrentUser(user) {
        this.coinbaseData['user'] = user;
        this.debounceSetData();
    }
    setAccounts(accounts) {
        this.coinbaseData['accounts'] = accounts;
        this.debounceSetData();
    }
    setAccount(account) {
        let idxAccount = __WEBPACK_IMPORTED_MODULE_13_lodash__["findIndex"](this.coinbaseData['accounts'], {
            id: account.id
        });
        if (idxAccount == -1) {
            this.coinbaseData['accounts'].push(account);
        }
        else {
            this.coinbaseData['accounts'][idxAccount] = account;
        }
        this.debounceSetData();
    }
    doRefreshToken() {
        return new Promise((resolve, reject) => {
            if (this.isRefreshingToken) {
                return reject('Refresh Token is in progress. Wait...');
            }
            this.isRefreshingToken = true;
            const url = this.credentials.HOST + '/oauth/token';
            const data = {
                grant_type: 'refresh_token',
                client_id: this.credentials.CLIENT_ID,
                client_secret: this.credentials.CLIENT_SECRET,
                redirect_uri: this.credentials.REDIRECT_URI,
                refresh_token: this.refreshToken
            };
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            });
            this.logger.debug('Coinbase: Getting Refresh Token...');
            this.http.post(url, data, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Refresh Access Token SUCCESS');
                this._registerToken(data['access_token'], data['refresh_token']);
                this.setToken(data);
                return resolve();
            }, data => {
                this.isRefreshingToken = false;
                this.logger.error('Coinbase: Refresh Access Token ERROR ' + data.status);
                return reject(this.parseErrorsAsString(data.error));
            });
        });
    }
    linkAccount(code) {
        const url = this.credentials.HOST + '/oauth/token';
        const data = {
            grant_type: 'authorization_code',
            code,
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.logger.debug('Coinbase: Getting Token...');
        return new Promise((resolve, reject) => {
            if (!this.isEnabled()) {
                return reject('Coinbase is Disabled. Missing credentials.');
            }
            if (this.isLinked()) {
                return reject('Coinbase already linked to the wallet. Please, logout before connect to a new one.');
            }
            this.http.post(url, data, { headers }).subscribe(data => {
                this.logger.info('Coinbase: GET Access Token: SUCCESS');
                this._registerToken(data['access_token'], data['refresh_token']);
                this.setToken(data);
                this.preFetchAllData();
                this.logAccountLinked();
                return resolve();
            }, data => {
                this.logger.error('Coinbase: GET Access Token: ERROR ' + data.status);
                return reject(this.parseErrorsAsString(data.error));
            });
        });
    }
    getAccounts(data) {
        if (!this.isLinked())
            return;
        const availableCoins = this.currencyProvider.getAvailableCoins();
        if (data)
            data['accounts'] = this.coinbaseData['accounts'] || [];
        // go to coinbase to update data
        this._getAccounts().then(remoteData => {
            let accounts = [];
            const allAccounts = remoteData.data;
            for (var i = 0; i < allAccounts.length; i++) {
                if (allAccounts[i].type == 'wallet' &&
                    allAccounts[i].currency &&
                    __WEBPACK_IMPORTED_MODULE_13_lodash__["includes"](availableCoins, allAccounts[i].currency.code.toLowerCase())) {
                    accounts.push(allAccounts[i]);
                }
            }
            const orderedAccounts = __WEBPACK_IMPORTED_MODULE_13_lodash__["orderBy"](accounts, ['name'], ['asc']);
            if (data)
                data['accounts'] = orderedAccounts;
            this.setAccounts(orderedAccounts);
        });
    }
    getAccount(id, data) {
        if (!this.isLinked())
            return;
        const acObject = __WEBPACK_IMPORTED_MODULE_13_lodash__["find"](this.coinbaseData['accounts'], { id });
        data['account'] = acObject || {};
        this._getAccount(id).then(remoteData => {
            const account = remoteData.data;
            data['account'] = account;
            this.setAccount(account);
        });
    }
    getCurrentUser(data) {
        if (!this.isLinked())
            return;
        if (data)
            data['user'] = this.coinbaseData['user'] || {};
        this._getCurrentUser().then(remoteData => {
            const user = remoteData.data;
            if (data)
                data['user'] = user;
            this.setCurrentUser(user);
            if (!data)
                this.updateExchangeRates();
        });
    }
    getTransactions(accountId, data) {
        if (!this.isLinked())
            return;
        data['txs'] = this.coinbaseData['txs']
            ? this.coinbaseData['txs'][accountId]
            : [];
        this._getTransactions(accountId).then(remoteData => {
            const txs = remoteData.data;
            data['txs'] = txs;
            this.setTransactions(accountId, txs);
        });
    }
    getAddress(accountId, label) {
        return this._createAddress(accountId, label);
    }
    sendTransaction(accountId, tx, code) {
        return this._sendTransaction(accountId, tx, code);
    }
    preFetchAllData(data) {
        this.getCurrentUser(data);
        this.getAccounts(data);
    }
    isExpiredTokenError(errors) {
        for (let i = 0; i < errors.length; i++) {
            if (errors[i].id == 'expired_token') {
                this.logger.warn('Coinbase: Token has expired');
                return true;
            }
        }
        return false;
    }
    _getAccounts() {
        const url = this.credentials.API + '/v2' + '/accounts?&limit=' + LIMIT;
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        };
        this.logger.debug('Coinbase: Getting Accounts...');
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Get Accounts SUCCESS');
                return resolve(data);
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._getAccounts();
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._getAccounts();
                        }, 5000);
                    });
                }
                else {
                    this.logger.error('Coinbase: Get Accounts ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    _getAccount(id) {
        const url = this.credentials.API + '/v2/accounts/' + id;
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        };
        this.logger.debug('Coinbase: Getting Account...');
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Get Account SUCCESS');
                return resolve(data);
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._getAccount(id);
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._getAccount(id);
                        }, 5000);
                    });
                }
                else {
                    this.logger.error('Coinbase: Get Account ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    _getCurrentUser() {
        const url = this.credentials.API + '/v2/user';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        };
        this.logger.debug('Coinbase: Getting Current User...');
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Get Current User SUCCESS');
                return resolve(data);
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._getCurrentUser();
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._getCurrentUser();
                        }, 5000);
                    });
                }
                else {
                    this.logger.error('Coinbase: Get Current User ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    _getTransactions(accountId) {
        const url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        };
        this.logger.debug('Coinbase: Getting Transactions...');
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Get Transactions SUCCESS');
                return resolve(data);
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._getTransactions(accountId);
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._getTransactions(accountId);
                        }, 5000);
                    });
                }
                else {
                    this.logger.error('Coinbase: Get Transactions ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    _createAddress(accountId, label) {
        const data = {
            name: label
        };
        const url = this.credentials.API + '/v2/accounts/' + accountId + '/addresses';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        });
        this.logger.debug('Coinbase: Creating Address...');
        return new Promise((resolve, reject) => {
            this.http.post(url, data, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Create Address SUCCESS');
                return resolve(data['data']); // return all data
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._createAddress(accountId, label);
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._createAddress(accountId, label);
                        }, 5000);
                    });
                }
                else {
                    this.logger.error('Coinbase: Create Address ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    _sendTransaction(accountId, tx, code) {
        tx['type'] = 'send'; // Required for sending TX
        const url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        let headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + this.accessToken
        });
        if (code)
            headers = headers.append('CB-2FA-TOKEN', code); // 2FA if required
        this.logger.debug('Coinbase: Sending Transaction...');
        return new Promise((resolve, reject) => {
            this.http.post(url, tx, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Send Transaction SUCCESS');
                return resolve(data);
            }, data => {
                if (this.isExpiredTokenError(data.error.errors)) {
                    this.doRefreshToken()
                        .then(_ => {
                        return this._sendTransaction(accountId, tx);
                    })
                        .catch(e => {
                        this.logger.warn(e);
                        setTimeout(() => {
                            return this._sendTransaction(accountId, tx);
                        }, 5000);
                    });
                }
                else if (data.status == 402) {
                    this.logger.error('Coinbase: 2FA is required ' + data.status);
                    return reject('2fa'); // return string to identify
                }
                else {
                    this.logger.error('Coinbase: Send Transaction ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
    updateExchangeRates() {
        if (!this.coinbaseData || !this.coinbaseData['user']['native_currency'])
            return;
        const url = this.credentials.API +
            '/v2/exchange-rates' +
            '?currency=' +
            this.coinbaseData['user']['native_currency'];
        this.logger.debug('Coinbase: Getting Exchange Rates...');
        this.http.get(url).subscribe(data => {
            this.logger.info('Coinbase: Get Exchange Rates SUCCESS');
            this.coinbaseExchange = data['data'];
        }, data => {
            this.logger.error('Coinbase: Get Exchange Rates ERROR ' + data.status);
        });
    }
    _registerToken(access_token, refresh_token) {
        if (!access_token || !refresh_token) {
            this.logger.info('Coinbase: No token to register');
            return;
        }
        if (!this.linkedAccount)
            this.homeIntegrationsProvider.updateLink('coinbase', access_token); // Name, Token
        this.linkedAccount = true;
        this.accessToken = access_token;
        this.refreshToken = refresh_token;
        this.isRefreshingToken = false;
        this.logger.info('Coinbase: Token registered');
    }
    logout() {
        this.removeData();
        this.linkedAccount = this.accessToken = this.refreshToken = null;
        this.coinbaseData = {
            token: {},
            accounts: [],
            user: {},
            txs: {}
        };
        this.homeIntegrationsProvider.updateLink('coinbase', null); // Name, Token
    }
    isLinked() {
        if (!this.linkedAccount)
            this.logger.warn('Coinbase: Accounts not linked');
        return !!this.linkedAccount;
    }
    logEvent(eventParams) {
        this.analyticsProvider.logEvent('coinbase', eventParams);
    }
    logAccountLinked() {
        this.analyticsProvider.setUserProperty('hasLinkedCoinbaseAccount', 'true');
    }
    isLinkedToOldSession() {
        return new Promise(resolve => {
            this.persistenceProvider
                .getCoinbaseToken('livenet')
                .then(accessToken => {
                if (!accessToken)
                    return resolve(false);
                return resolve(true);
            })
                .catch(_ => {
                return resolve(false);
            });
        });
    }
    register() {
        this.isLinkedToOldSession().then(oldLinked => {
            this.getData().then(data => {
                this.coinbaseData = data || {
                    token: {},
                    accounts: [],
                    user: {},
                    txs: {}
                };
                if (this.coinbaseData && this.coinbaseData['token']) {
                    this._registerToken(this.coinbaseData['token']['access_token'], this.coinbaseData['token']['refresh_token']);
                    this.updateExchangeRates();
                }
                this.homeIntegrationsProvider.register({
                    name: 'coinbase',
                    title: 'Coinbase',
                    icon: 'assets/img/coinbase/coinbase-icon.png',
                    logo: 'assets/img/coinbase/coinbase-logo-white.svg',
                    background: '#0667d0',
                    location: '33 Countries',
                    page: 'CoinbasePage',
                    show: !!this.configProvider.get().showIntegration['coinbase'],
                    linked: this.linkedAccount,
                    email: this.coinbaseData['user']['email'] || null,
                    oldLinked,
                    type: 'external-services'
                });
            });
        });
    }
    getAvailableAccounts(coin, minFiatCurrency) {
        let coinbaseData = __WEBPACK_IMPORTED_MODULE_13_lodash__["cloneDeep"](this.coinbaseData);
        let coinbaseAccounts = coinbaseData.accounts.filter(ac => {
            const nativeBalance = this.getNativeCurrencyBalance(ac.balance.amount, ac.balance.currency);
            ac.nativeCurrencyStr = nativeBalance
                ? nativeBalance + ' ' + this.coinbaseData['user']['native_currency']
                : null;
            const accountCoin = ac.balance.currency.toLowerCase();
            if (minFiatCurrency) {
                // check if it's crypto currency
                if (__WEBPACK_IMPORTED_MODULE_12__currency_currency__["a" /* Coin */][minFiatCurrency.currency]) {
                    return __WEBPACK_IMPORTED_MODULE_12__currency_currency__["a" /* Coin */][minFiatCurrency.currency] == accountCoin;
                }
                const availableBalanceFiat = this.rateProvider.toFiat(this.currencyProvider.getPrecision(accountCoin).unitToSatoshi *
                    Number(ac.balance.amount), minFiatCurrency.currency, accountCoin);
                return (availableBalanceFiat >=
                    Number(minFiatCurrency && minFiatCurrency.amount
                        ? minFiatCurrency.amount
                        : null));
            }
            else if (coin) {
                return accountCoin == coin;
            }
            else
                return ac;
        });
        return coinbaseAccounts;
    }
    payInvoice(invoiceId, currency, twoFactorCode) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!twoFactorCode) {
                try {
                    yield this.doRefreshToken();
                }
                catch (error) {
                    this.logger.warn('Coinbase: the token could not be refreshed');
                }
            }
            return this._payInvoice(invoiceId, currency, twoFactorCode);
        });
    }
    _payInvoice(invoiceId, currency, twoFactorCode) {
        const url = 'https://tkcoin.org/oauth/coinbase/pay/' + invoiceId;
        const data = {
            currency,
            token: this.accessToken,
            twoFactorCode
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        return new Promise((resolve, reject) => {
            this.http.post(url, data, { headers }).subscribe(data => {
                this.logger.info('Coinbase: Pay invoice SUCCESS');
                return resolve(data);
            }, data => {
                if (data.error &&
                    data.error.errors &&
                    data.error.errors[0].id == 'two_factor_required') {
                    this.logger.error('Coinbase: 2FA is required ' + data.status);
                    return reject('2fa'); // return string to identify
                }
                else {
                    this.logger.error('Coinbase: Send Transaction ERROR ' + data.status);
                    return reject(this.parseErrorsAsString(data.error));
                }
            });
        });
    }
};
CoinbaseProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_8__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_12__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__rate_rate__["b" /* RateProvider */]])
], CoinbaseProvider);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 166:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImportWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__includes_coin_selector_coin_selector__ = __webpack_require__(974);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__onboarding_disclaimer_disclaimer__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(31);





// Pages



// Providers













let ImportWalletPage = class ImportWalletPage {
    constructor(navCtrl, navParams, form, bwcProvider, walletProvider, configProvider, currencyProvider, platformProvider, logger, onGoingProcessProvider, profileProvider, translate, events, pushNotificationsProvider, actionSheetProvider, derivationPathHelperProvider, modalCtrl, bwcErrorProvider, errorsProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.form = form;
        this.bwcProvider = bwcProvider;
        this.walletProvider = walletProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.modalCtrl = modalCtrl;
        this.bwcErrorProvider = bwcErrorProvider;
        this.errorsProvider = errorsProvider;
        this.updateWordsHandler = data => {
            this.processedInfo = this.processWalletInfo(data.value);
            this.setForm();
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.reader = new FileReader();
        this.defaults = this.configProvider.getDefaults();
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
        this.selectedTab = 'words';
        this.showAdvOpts = false;
        // TODO FIX
        // this.availableCoins = this.currencyProvider.getAvailableChains();
        this.availableCoins = ['edu', 'tik'];
        this.code = this.navParams.data.code;
        this.processedInfo = this.processWalletInfo(this.code);
        this.isOnboardingFlow = this.navParams.data.isOnboardingFlow;
        this.keyId = this.navParams.data.keyId; // re-import option
        this.title = !this.keyId
            ? this.translate.instant('Import Wallet')
            : this.translate.instant('Re-Import Wallets');
        this.formFile = null;
        this.importForm = this.form.group({
            words: [null, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required],
            backupText: [null],
            passphrase: [null],
            file: [null],
            filePassword: [null],
            derivationPathEnabled: [false],
            coin: ['btc'],
            derivationPath: [this.derivationPathHelperProvider.defaultBTC],
            bwsURL: [this.defaults.bws.url],
            isMultisig: [false]
        });
        this.events.subscribe('Local/BackupScan', this.updateWordsHandler);
        this.setForm();
    }
    ionViewWillEnter() {
        const previousView = this.navCtrl.getPrevious();
        if (this.isOnboardingFlow && previousView.name === 'LockMethodPage') {
            this.navCtrl.removeView(previousView);
        }
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/BackupScan', this.updateWordsHandler);
    }
    setForm() {
        if (this.processedInfo) {
            this.importForm.controls['words'].setValue(this.processedInfo.data);
        }
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    selectTab(tab) {
        this.selectedTab = tab;
        switch (tab) {
            case 'words':
                this.file = null;
                this.formFile = null;
                this.importForm.get('words').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
                this.importForm.get('filePassword').clearValidators();
                if (this.isCordova || this.isSafari)
                    this.importForm.get('backupText').clearValidators();
                else
                    this.importForm.get('file').clearValidators();
                break;
            case 'file':
                if (this.isCordova || this.isSafari)
                    this.importForm
                        .get('backupText')
                        .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
                else
                    this.importForm.get('file').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
                this.importForm
                    .get('filePassword')
                    .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
                this.importForm.get('words').clearValidators();
                break;
            default:
                this.importForm.get('words').clearValidators();
                this.importForm.get('file').clearValidators();
                this.importForm.get('filePassword').clearValidators();
                break;
        }
        this.importForm.get('words').updateValueAndValidity();
        this.importForm.get('file').updateValueAndValidity();
        this.importForm.get('filePassword').updateValueAndValidity();
        this.importForm.get('backupText').updateValueAndValidity();
    }
    processWalletInfo(code) {
        if (!code)
            return undefined;
        const parsedCode = code.split('|');
        const info = {
            type: parsedCode[0],
            data: parsedCode[1],
            network: parsedCode[2],
            derivationPath: parsedCode[3],
            hasPassphrase: parsedCode[4] == 'true' ? true : false,
            coin: parsedCode[5] // deprecated
        };
        if (!info.data) {
            this.showErrorInfoSheet(this.translate.instant('Error'), this.translate.instant('Invalid data'));
            return undefined;
        }
        if (info.type == '1' && info.hasPassphrase) {
            const title = this.translate.instant('Warning');
            const subtitle = this.translate.instant('Password required. Make sure to enter your password in advanced options');
            this.showErrorInfoSheet(title, subtitle);
        }
        return info;
    }
    importBlob(str, opts) {
        let str2;
        let err = null;
        try {
            str2 = this.bwcProvider
                .getSJCL()
                .decrypt(this.importForm.value.filePassword, str);
        }
        catch (e) {
            err = this.translate.instant('Could not decrypt file, check your password');
            this.logger.error('Import: could not decrypt file', e);
        }
        if (err) {
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(title, err);
            return;
        }
        this.onGoingProcessProvider.set('importingWallet');
        opts.compressed = null;
        opts.password = null;
        opts.keyId = this.keyId;
        this.profileProvider
            .importFile(str2, opts)
            .then((wallet) => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(title, err);
            return;
        });
    }
    finish(wallets) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            wallets.forEach(wallet => {
                this.walletProvider.updateRemotePreferences(wallet);
                this.pushNotificationsProvider.updateSubscription(wallet);
                this.profileProvider.setWalletBackup(wallet.credentials.walletId);
            });
            if (wallets && wallets[0]) {
                this.profileProvider.setBackupGroupFlag(wallets[0].credentials.keyId);
                yield new Promise(resolve => setTimeout(resolve, 1000));
                this.profileProvider.setNewWalletGroupOrder(wallets[0].credentials.keyId);
            }
            if (!this.isOnboardingFlow)
                this.navCtrl.popToRoot().then(() => {
                    this.events.publish('Local/FetchWallets');
                });
            else {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */], {
                    keyId: wallets[0].credentials.keyId
                });
            }
        });
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importExtendedPrivateKey(xPrivKey, opts)
            .then((wallets) => {
            this.onGoingProcessProvider.clear();
            this.finish(wallets);
        })
            .catch(err => {
            this.processError(err);
        });
    }
    importWithDerivationPath(opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importWithDerivationPath(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.processError(err);
        });
    }
    importMnemonic(words, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importMnemonic(words, opts)
            .then((wallets) => {
            this.onGoingProcessProvider.clear();
            this.finish(wallets);
        })
            .catch(err => {
            this.processError(err);
        });
    }
    processError(err) {
        if (err == 'WALLET_DOES_NOT_EXIST') {
            const noWalletWarningInfoSheet = this.actionSheetProvider.createInfoSheet('import-no-wallet-warning');
            noWalletWarningInfoSheet.present();
            noWalletWarningInfoSheet.onDidDismiss(option => {
                if (option || typeof option === 'undefined') {
                    // Go back
                    this.logger.debug('Go back clicked');
                }
                else {
                    // Continue anyway
                    this.logger.debug('Continue anyway clicked');
                    if (this.importForm.value.derivationPathEnabled) {
                        this.setOptsAndCreate(this.importForm.value.coin);
                    }
                    else {
                        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__includes_coin_selector_coin_selector__["a" /* CoinSelectorPage */], {
                            description: this.translate.instant('Please select the coin of the wallet to import:')
                        }, {
                            enableBackdropDismiss: false,
                            cssClass: 'fullscreen-modal'
                        });
                        modal.present({ animate: false });
                        modal.onDidDismiss(data => {
                            if (data.selectedCoin) {
                                this.setOptsAndCreate(data.selectedCoin);
                            }
                        });
                    }
                }
            });
        }
        else {
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(title, this.bwcErrorProvider.msg(err));
        }
        this.onGoingProcessProvider.clear();
        return;
    }
    setOptsAndCreate(coin) {
        const opts = {
            keyId: undefined,
            name: this.currencyProvider.getCoinName(coin),
            m: 1,
            n: 1,
            myName: null,
            networkName: 'livenet',
            bwsurl: this.importForm.value.bwsURL,
            singleAddress: this.currencyProvider.isSingleAddress(coin),
            coin: __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__["a" /* Coin */][coin.toUpperCase()]
        };
        const words = this.importForm.value.words;
        if (words.indexOf(' ') == -1 &&
            words.indexOf('prv') == 1 &&
            words.length > 108) {
            opts.extendedPrivateKey = words;
        }
        else {
            opts.mnemonic = words;
        }
        let derivationPath;
        if (this.importForm.value.derivationPathEnabled) {
            derivationPath = this.importForm.value.derivationPath;
        }
        else {
            if (this.derivationPathHelperProvider[`default${coin.toUpperCase()}`]) {
                derivationPath = this.derivationPathHelperProvider[`default${coin.toUpperCase()}`];
            }
            else {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant(`No derivation path for: default${coin.toUpperCase()}`);
                this.showErrorInfoSheet(title, subtitle);
                return;
            }
        }
        opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
        opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
        opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
        // set opts.useLegacyPurpose
        if (this.derivationPathHelperProvider.parsePath(derivationPath).purpose ==
            "44'" &&
            opts.n > 1) {
            opts.useLegacyPurpose = true;
            this.logger.debug('Using 44 for Multisig');
        }
        // set opts.useLegacyCoinType
        if (coin == 'bch' &&
            this.derivationPathHelperProvider.parsePath(derivationPath).coinCode ==
                "0'") {
            opts.useLegacyCoinType = true;
            this.logger.debug('Using 0 for BCH creation');
        }
        if (!opts.networkName ||
            !opts.derivationStrategy ||
            !Number.isInteger(opts.account)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        if (!opts.mnemonic && !opts.extendedPrivateKey) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(derivationPath, coin)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path for selected coin');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        this.createSpecifyingWords(opts);
    }
    createSpecifyingWords(opts) {
        this.logger.debug('Creating from import');
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error('Create: could not create wallet', err);
            const title = this.translate.instant('Error');
            err = this.bwcErrorProvider.msg(err);
            this.showErrorInfoSheet(title, err);
        });
    }
    import() {
        if (this.selectedTab === 'file') {
            this.importFromFile();
        }
        else {
            this.importFromMnemonic();
        }
    }
    importFromFile() {
        if (!this.importForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        const backupFile = this.file;
        const backupText = this.importForm.value.backupText;
        if (!backupFile && !backupText) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please, select your backup file');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        if (backupFile) {
            this.reader.readAsBinaryString(backupFile);
        }
        else {
            const opts = {};
            opts.bwsurl = this.importForm.value.bwsURL;
            this.importBlob(backupText, opts);
        }
    }
    importFromMnemonic() {
        if (!this.importForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        const opts = {};
        if (this.importForm.value.bwsURL)
            opts.bwsurl = this.importForm.value.bwsURL;
        if (this.importForm.value.derivationPathEnabled) {
            const derivationPath = this.importForm.value.derivationPath;
            opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
            opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
            opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
            /* TODO: opts.n is just used to determinate if the wallet is multisig (m/48'/xx) or single sig (m/44')
              we should change the name to 'isMultisig'.
              isMultisig is used to allow import old multisig wallets with derivation strategy = 'BIP44'
            */
            opts.n = this.importForm.value.isMultisig
                ? 2
                : opts.derivationStrategy == 'BIP48'
                    ? 2
                    : 1;
            opts.coin = this.importForm.value.coin;
            // set opts.useLegacyPurpose
            if (this.derivationPathHelperProvider.parsePath(derivationPath).purpose ==
                "44'" &&
                opts.n > 1) {
                opts.useLegacyPurpose = true;
                this.logger.debug('Using 44 for Multisig');
            }
            // set opts.useLegacyCoinType
            if (opts.coin == 'bch' &&
                this.derivationPathHelperProvider.parsePath(derivationPath).coinCode ==
                    "0'") {
                opts.useLegacyCoinType = true;
                this.logger.debug('Using 0 for BCH creation');
            }
            if (!opts.networkName ||
                !opts.derivationStrategy ||
                !Number.isInteger(opts.account)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path');
                this.showErrorInfoSheet(title, subtitle);
                return;
            }
            if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.importForm.value.derivationPath, this.importForm.value.coin)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path for selected coin');
                this.showErrorInfoSheet(title, subtitle);
                return;
            }
        }
        opts.passphrase = this.importForm.value.passphrase || null;
        opts.keyId = this.keyId;
        const words = this.importForm.value.words || null;
        if (!words) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the recovery phrase');
            this.showErrorInfoSheet(title, subtitle);
            return;
        }
        else if (words.indexOf('xprv') == 0 || words.indexOf('tprv') == 0) {
            opts.extendedPrivateKey = words;
            return this.importForm.value.derivationPathEnabled
                ? this.importWithDerivationPath(opts)
                : this.importExtendedPrivateKey(words, opts);
        }
        else {
            const wordList = words.trim().split(/[\u3000\s]+/);
            if (wordList.length % 3 != 0) {
                this.logger.warn('Incorrect words length');
                const errorInfoSheet = this.actionSheetProvider.createInfoSheet('recovery-phrase-length', {
                    wordListLength: wordList.length
                });
                errorInfoSheet.present();
                return;
            }
        }
        opts.mnemonic = words;
        this.importForm.value.derivationPathEnabled
            ? this.importWithDerivationPath(opts)
            : this.importMnemonic(words, opts);
    }
    fileChangeEvent($event) {
        this.file = $event.target
            ? $event.target.files[0]
            : $event.srcElement.files[0];
        this.formFile = $event.target.value;
        // Most browsers return `C:\fakepath\FILENAME`
        this.prettyFileName = this.formFile.split('\\').pop();
        this.getFile();
    }
    getFile() {
        // If we use onloadend, we need to check the readyState.
        this.reader.onloadend = () => {
            if (this.reader.readyState === 2) {
                // DONE === 2
                const opts = {};
                opts.bwsurl = this.importForm.value.bwsURL;
                const reader = this.reader.result.toString();
                this.importBlob(reader, opts);
            }
        };
    }
    setDerivationPath(coin) {
        const defaultCoin = `default${coin.toUpperCase()}`;
        const derivationPath = this.derivationPathHelperProvider[defaultCoin];
        this.importForm.controls['derivationPath'].setValue(derivationPath);
    }
    changeDerivationPathValidators() {
        if (this.importForm.value.derivationPathEnabled) {
            this.importForm
                .get('derivationPath')
                .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
            this.setDerivationPath(this.importForm.value.coin);
        }
        else {
            this.importForm.get('derivationPath').clearValidators();
        }
        this.importForm.get('derivationPath').updateValueAndValidity();
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__scan_scan__["a" /* ScanPage */], { fromImport: true });
    }
    showErrorInfoSheet(title, msg) {
        this.errorsProvider.showDefaultError(msg, title);
    }
};
ImportWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-import-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/import-wallet/import-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{ title }}</ion-title>\n    <ion-buttons end>\n      <button ion-button (click)="import()" [disabled]="!importForm.valid">\n        <span translate>Import</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div [attr.padding]="isIOS ? \'\' : null">\n    <ion-segment [(ngModel)]="selectedTab" color="primary" (ionChange)="selectTab(selectedTab)">\n      <ion-segment-button value="words">\n        {{ \'Recovery Phrase\' | translate }}\n      </ion-segment-button>\n      <ion-segment-button value="file">\n        {{ \'File/Text\' | translate }}\n      </ion-segment-button>\n    </ion-segment>\n  </div>\n\n  <form [formGroup]="importForm">\n    <ion-item *ngIf="selectedTab == \'words\'">\n      <ion-label stacked>{{\'Type the recovery phrase\' | translate}}</ion-label>\n      <ion-textarea formControlName="words" [value]="importForm.value.words" autocapitalize="none">\n      </ion-textarea>\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n\n\n    <label-tip *ngIf="selectedTab == \'words\'" type="info" header="no-header" class="no-arrowhead">\n      <div label-tip-body translate>Enter your recovery phrase (usually 12-words) in the correct order. Separate each word with a single space only (no commas or any other punctuation). For backup phrases in non-English languages: Some words may include special symbols (, , , etc.), so be sure to spell all the words correctly. </div>\n    </label-tip>\n\n    <div *ngIf="selectedTab == \'file\'">\n      <ion-item class="hide-validation" *ngIf="!isSafari && !isCordova">\n        <ion-input class="upload-hidden" type="file" accept="json" [(ngModel)]="formFile" (change)="fileChangeEvent($event)" formControlName="file"></ion-input>\n        <div item-content class="upload-ui">\n          <div class="empty-message">{{\'Choose a backup file from your computer\' | translate}}&hellip;</div>\n          <div class="filled-message">{{prettyFileName}}</div>\n        </div>\n      </ion-item>\n\n      <ion-item *ngIf="isSafari || isCordova">\n        <ion-label floating>{{\'Paste the backup plain text code\' | translate}}</ion-label>\n        <ion-textarea formControlName="backupText" rows="7" [value]="importForm.value.backupText"></ion-textarea>\n      </ion-item>\n\n      <ion-item>\n        <ion-label floating>{{\'Password\' | translate}}</ion-label>\n        <ion-input type="password" formControlName="filePassword"></ion-input>\n      </ion-item>\n    </div>\n\n    <button ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n      <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n      <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n    </button>\n\n    <div *ngIf="showAdvOpts" padding-bottom>\n      <ion-item>\n        <ion-label floating>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <div *ngIf="selectedTab == \'words\'">\n        <ion-item>\n          <ion-label>{{\'Specify derivation path\' | translate}}</ion-label>\n          <ion-toggle formControlName="derivationPathEnabled" (ionChange)="changeDerivationPathValidators();"></ion-toggle>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled">\n          <ion-label floating>{{\'Coin\' | translate}}</ion-label>\n          <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="coin" (ionChange)="setDerivationPath($event)">\n            <div *ngFor="let coin of availableCoins">\n              <ion-option value="{{coin}}"> {{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</ion-option>\n            </div>\n          </ion-select>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled">\n          <ion-label floating>{{\'Derivation path\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="derivationPath" [value]="importForm.value.derivationPath"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled && importForm.value.derivationPath === this.derivationPathHelperProvider.defaultBTC">\n          <ion-label>{{\'Shared Wallet\' | translate}}</ion-label>\n          <ion-checkbox formControlName="isMultisig"></ion-checkbox>\n        </ion-item>\n\n        <ion-item class="with-label">\n          <ion-label floating>{{\'Password\' | translate}}</ion-label>\n          <ion-input type="password" formControlName="passphrase"></ion-input>\n        </ion-item>\n\n        <label-tip type="info" header="no-header">\n          <div label-tip-body translate>\n            This field is only for users who, in previous versions (it\'s not supported anymore), set a password to protect their recovery phrase. This field is not for your encrypt password.\n          </div>\n        </label-tip>\n      </div>\n\n    </div>\n  </form>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/import-wallet/import-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_16__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_errors_errors__["a" /* ErrorsProvider */]])
], ImportWalletPage);

//# sourceMappingURL=import-wallet.js.map

/***/ }),

/***/ 167:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__integrations_coinbase_coinbase_account_coinbase_account__ = __webpack_require__(392);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__wallet_details_wallet_details__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_clipboard_clipboard__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_in_app_browser_card__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_wallet_connect_wallet_connect__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__providers_wallet_wallet__ = __webpack_require__(31);





// Pages




// Providers




























let ConfirmPage = class ConfirmPage {
    // // Card flags for zen desk chat support
    // private isCardPurchase: boolean;
    // private isHelpOpen: boolean = false;
    constructor(addressProvider, analyticsProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, errorsProvider, externalLinkProvider, feeProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, platformProvider, profileProvider, popupProvider, replaceParametersProvider, rateProvider, translate, txConfirmNotificationProvider, txFormatProvider, walletProvider, clipboardProvider, events, coinbaseProvider, appProvider, payproProvider, iabCardProvider, homeIntegrationsProvider, persistenceProvider, walletConnectProvider) {
        this.addressProvider = addressProvider;
        this.analyticsProvider = analyticsProvider;
        this.app = app;
        this.actionSheetProvider = actionSheetProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.errorsProvider = errorsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.feeProvider = feeProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.platformProvider = platformProvider;
        this.profileProvider = profileProvider;
        this.popupProvider = popupProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.rateProvider = rateProvider;
        this.translate = translate;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.clipboardProvider = clipboardProvider;
        this.events = events;
        this.coinbaseProvider = coinbaseProvider;
        this.appProvider = appProvider;
        this.payproProvider = payproProvider;
        this.iabCardProvider = iabCardProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.persistenceProvider = persistenceProvider;
        this.walletConnectProvider = walletConnectProvider;
        this.countDown = null;
        // custom fee flag
        this.usingCustomFee = false;
        this.usingMerchantFee = false;
        this.updateDestinationTag = data => {
            this.tx.destinationTag = data.value;
        };
        this.instantiateMultisigContract = (txp, n) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let tryNumber = n ? n : 0;
            if (tryNumber == 5) {
                this.logger.error('Error getting multisig contract instantiation info');
                return;
            }
            setTimeout(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                let multisigContractInstantiationInfo = [];
                const opts = {
                    sender: txp.from,
                    txId: txp.txid
                };
                multisigContractInstantiationInfo = yield this.walletProvider.getMultisigContractInstantiationInfo(this.wallet, opts);
                if (multisigContractInstantiationInfo.length > 0) {
                    const multisigContract = multisigContractInstantiationInfo.filter(multisigContract => {
                        return multisigContract.transactionHash === txp.txid;
                    });
                    if (!multisigContract[0]) {
                        return this.instantiateMultisigContract(txp, tryNumber++);
                    }
                    const multisigEthInfo = {
                        multisigContractAddress: multisigContract[0].instantiation,
                        walletName: this.navParams.data.walletName,
                        n: this.navParams.data.totalCopayers,
                        m: this.navParams.data.requiredConfirmations
                    };
                    const pairedWallet = this.wallet;
                    this.onGoingProcessProvider.clear();
                    return this.createAndBindEthMultisigWallet(pairedWallet, multisigEthInfo);
                }
                else {
                    return this.instantiateMultisigContract(txp, tryNumber++);
                }
            }), 10000);
        });
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.fromWalletDetails = this.navParams.data.fromWalletDetails;
        this.walletConnectRequestId = this.navParams.data.walletConnectRequestId;
        this.fromCoinbase = this.navParams.data.fromCoinbase;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.CONFIRM_LIMIT_USD = 20;
        this.FEE_TOO_HIGH_LIMIT_PER = 15;
        this.config = this.configProvider.get();
        this.isCordova = this.platformProvider.isCordova;
        this.hideSlideButton = false;
        this.showMultiplesOutputs = false;
        this.recipients = this.navParams.data.recipients;
        this.fromMultiSend = this.navParams.data.fromMultiSend;
        this.fromSelectInputs = this.navParams.data.fromSelectInputs;
        this.appName = this.appProvider.info.nameCase;
        this.isSpeedUpTx = this.navParams.data.speedUpTx;
        this.showCoinbase =
            this.homeIntegrationsProvider.shouldShowInHome('coinbase') &&
                this.coinbaseProvider.isLinked();
        // this.isCardPurchase =
        //   this.navParams.data.payProUrl &&
        //   this.navParams.data.payProUrl.includes('redir=wc');
    }
    ngOnInit() {
        // Overrides the ngOnInit logic of WalletTabsChild
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/TagScan', this.updateDestinationTag);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ConfirmPage');
        this.navCtrl.swipeBackEnabled = false;
        this.isOpenSelector = false;
        this.coin = this.navParams.data.coin;
        let networkName;
        let amount;
        this.setTitle();
        if (this.fromMultiSend) {
            networkName = this.navParams.data.network;
            amount = this.navParams.data.totalAmount;
        }
        else if (this.fromSelectInputs) {
            networkName = this.navParams.data.network;
            amount = this.navParams.data.amount
                ? this.navParams.data.amount
                : this.navParams.data.totalInputsAmount;
        }
        else {
            amount = this.navParams.data.amount;
            try {
                networkName = this.addressProvider.getCoinAndNetwork(this.navParams.data.toAddress, this.navParams.data.network || '').network;
            }
            catch (e) {
                const message = this.replaceParametersProvider.replace(this.translate.instant('{{appName}} only supports Bitcoin Cash using new version numbers addresses.'), { appName: this.appName });
                const backText = this.translate.instant('Go back');
                const learnText = this.translate.instant('Learn more');
                this.popupProvider
                    .ionicConfirm(null, message, backText, learnText)
                    .then(back => {
                    if (!back) {
                        const url = 'https://support.tkcoin.org/hc/en-us/articles/115004671663';
                        this.externalLinkProvider.open(url);
                    }
                    this.navCtrl.pop();
                });
                return;
            }
        }
        this.tx = {
            toAddress: this.navParams.data.toAddress,
            description: this.navParams.data.description,
            destinationTag: this.navParams.data.destinationTag,
            paypro: this.navParams.data.paypro,
            data: this.navParams.data.data,
            invoiceID: this.navParams.data.invoiceID,
            payProUrl: this.navParams.data.payProUrl,
            spendUnconfirmed: this.config.wallet.spendUnconfirmed,
            // Vanity tx info (not in the real tx)
            recipientType: this.navParams.data.recipientType,
            name: this.navParams.data.name,
            email: this.navParams.data.email,
            color: this.navParams.data.color,
            network: this.navParams.data.network
                ? this.navParams.data.network
                : networkName,
            coin: this.navParams.data.coin,
            txp: {},
            multisigContractAddress: this.navParams.data.multisigContractAddress,
            tokenAddress: this.navParams.data.tokenAddress,
            gasLimit: this.navParams.data.gasLimit,
            speedUpTx: this.isSpeedUpTx,
            fromSelectInputs: this.navParams.data.fromSelectInputs ? true : false,
            inputs: this.navParams.data.inputs
        };
        this.tx.sendMax = this.navParams.data.useSendMax ? true : false;
        this.tx.amount =
            this.navParams.data.useSendMax && this.shouldUseSendMax()
                ? 0
                : this.tx.coin == 'ETH' ||
                    this.currencyProvider.isERCToken(this.tx.coin)
                    ? Number(amount)
                    : parseInt(amount, 10);
        this.tx.origToAddress = this.tx.toAddress;
        if (this.navParams.data.requiredFeeRate) {
            this.usingMerchantFee = true;
            this.tx.feeRate = +this.navParams.data.requiredFeeRate;
        }
        else if (this.isSpeedUpTx) {
            this.usingCustomFee = true;
            this.tx.feeLevel = 'custom';
        }
        else {
            this.tx.feeLevel = this.feeProvider.getCoinCurrentFeeLevel(this.tx.coin);
        }
        if (this.tx.coin && this.tx.coin == 'bch' && !this.fromMultiSend) {
            this.tx.toAddress = this.bitcoreCash
                .Address(this.tx.toAddress)
                .toString(true);
        }
        this.getAmountDetails();
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.showAddress = false;
        this.walletSelectorTitle = this.translate.instant('Send from');
        this.setWalletSelector(this.tx.coin, this.tx.network)
            .then(() => {
            this.afterWalletSelectorSet();
        })
            .catch(err => {
            this.showErrorInfoSheet(err.msg, err.title, true);
        });
        if (this.isCordova) {
            window.addEventListener('keyboardWillShow', () => {
                this.hideSlideButton = true;
            });
            window.addEventListener('keyboardWillHide', () => {
                this.hideSlideButton = false;
            });
        }
        this.events.subscribe('Local/TagScan', this.updateDestinationTag);
    }
    setTitle() {
        if (this.fromCoinbase) {
            this.mainTitle = this.translate.instant('Confirm Deposit');
        }
        else if (this.isSpeedUpTx) {
            this.mainTitle = this.translate.instant('Confirm Speed Up');
        }
        else {
            this.mainTitle = this.translate.instant('Confirm Payment');
        }
    }
    getAmountDetails() {
        this.amount = this.txFormatProvider.formatAmount(this.coin, this.tx.amount);
    }
    getTotalAmountDetails(tx, wallet) {
        if (wallet && wallet.credentials && !wallet.credentials.token) {
            this.totalAmount = tx.amount + tx.txp[wallet.id].fee;
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(this.coin, tx.amount + tx.txp[wallet.id].fee);
        }
    }
    shouldUseSendMax() {
        const chain = this.currencyProvider.getAvailableChains();
        return chain.includes(this.coin) && !this.tx.multisigContractAddress;
    }
    getChain(coin) {
        return this.currencyProvider.getChain(coin).toLowerCase();
    }
    afterWalletSelectorSet() {
        if (this.wallet &&
            this.tx.coin === this.wallet.coin &&
            this.tx.network === this.wallet.network) {
            this.setWallet(this.wallet);
        }
        else if (this.wallets.length > 1 || this.showCoinbase) {
            return this.showWallets();
        }
        else if (this.wallets.length) {
            this.setWallet(this.wallets[0]);
        }
    }
    setWalletSelector(coin, network) {
        if (this.wallet &&
            this.wallet.network == network &&
            this.wallet.coin == coin) {
            return Promise.resolve();
        }
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            hasFunds: true,
            network,
            coin
        });
        this.coinbaseAccounts =
            this.showCoinbase && network === 'livenet'
                ? this.coinbaseProvider.getAvailableAccounts(coin)
                : [];
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets) && __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseAccounts)) {
            const msg = this.translate.instant('You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals.');
            const title = this.translate.instant('No wallets available');
            return Promise.reject({ msg, title });
        }
        return Promise.resolve();
    }
    /* sets a wallet on the UI, creates a TXPs for that wallet */
    setWallet(wallet) {
        this.wallet = wallet;
        this.coinbaseAccount = null;
        // If select another wallet
        this.tx.coin = this.wallet.coin;
        if (!this.usingCustomFee && !this.usingMerchantFee) {
            this.tx.feeLevel = this.feeProvider.getCoinCurrentFeeLevel(wallet.coin);
        }
        if (this.wallet.credentials.token &&
            this.wallet.credentials.token.address) {
            this.tx.tokenAddress = this.wallet.credentials.token.address;
        }
        if (this.wallet.credentials.multisigEthInfo &&
            this.wallet.credentials.multisigEthInfo.multisigContractAddress) {
            this.tx.multisigContractAddress = this.wallet.credentials.multisigEthInfo.multisigContractAddress;
        }
        this.setButtonText(this.wallet.credentials.m > 1, !!this.tx.paypro, !!this.fromCoinbase, this.isSpeedUpTx);
        if (this.tx.paypro)
            this.paymentTimeControl(this.tx.paypro.expires);
        const exit = this.wallet || (this.wallets && this.wallets.length === 1) ? true : false;
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.updateTx(this.tx, this.wallet, { dryRun: true }).catch(err => {
            const previousView = this.navCtrl.getPrevious().name;
            switch (err) {
                case 'insufficient_funds':
                    if (this.showUseUnconfirmedMsg()) {
                        this.showErrorInfoSheet(this.translate.instant('You do not have enough confirmed funds to make this payment. Wait for your pending transactions to confirm or enable "Use unconfirmed funds" in Advanced Settings.'), this.translate.instant('Not enough confirmed funds'), exit);
                    }
                    else if (previousView === 'AmountPage') {
                        // Do not allow user to change or use max amount if previous view is not Amount
                        this.showInsufficientFundsInfoSheet();
                    }
                    else {
                        this.showErrorInfoSheet(this.translate.instant('You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals.'), this.translate.instant('Insufficient funds'), exit);
                    }
                    break;
                default:
                    this.showErrorInfoSheet(err);
                    break;
            }
        });
    }
    setCoinbaseAccount(option) {
        this.wallet = null;
        this.coinbaseAccount = option.accountSelected;
        this.tx.coin = this.coinbaseAccount.currency.code.toLowerCase();
        this.setButtonText(false, !!this.tx.paypro, !!this.fromCoinbase, this.isSpeedUpTx);
        if (this.tx.paypro) {
            this.paymentTimeControl(this.tx.paypro.expires);
            this.tx.paypro.host = new URL(this.tx.payProUrl).host;
            this.tx.paypro.invoiceId = this.tx.payProUrl.replace('https://tkcoin.org/i/', '');
            this.tx.minerFee = this.navParams.data.minerFee;
            this.totalAmount = this.tx.amount - this.tx.minerFee;
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(this.coin, this.totalAmount);
        }
    }
    showUseUnconfirmedMsg() {
        return (this.wallet.cachedStatus &&
            this.wallet.cachedStatus.balance.totalAmount >=
                this.tx.amount + this.tx.feeRate &&
            !this.tx.spendUnconfirmed);
    }
    setButtonText(isMultisig, isPayPro, isCoinbase, isSpeedUp) {
        if (isPayPro) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to pay')
                : this.translate.instant('Click to pay');
        }
        else if (isCoinbase) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to deposit')
                : this.translate.instant('Click to deposit');
            this.successText =
                this.wallet.credentials.n == 1
                    ? this.translate.instant('Deposit success')
                    : this.translate.instant('Deposit pending');
        }
        else if (isMultisig) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText =
                this.wallet.credentials.n == 1
                    ? this.translate.instant('Payment Sent')
                    : this.translate.instant('Proposal created');
            if (this.tx.multisigContractAddress &&
                (this.navParams.data.isEthMultisigConfirm ||
                    this.navParams.data.isEthMultisigExecute)) {
                this.successText = this.translate.instant('Proposal confirmed');
            }
        }
        else if (isSpeedUp) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to speed up')
                : this.translate.instant('Click to speed up');
            this.successText = this.translate.instant('Speed up successful');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        const countDown = setInterval(() => {
            this.setExpirationTime(expirationTime, countDown);
        }, 1000);
    }
    setExpirationTime(expirationTime, countDown) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (countDown) {
                /* later */
                clearInterval(countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        // if (this.isCardPurchase && m < 11 && !this.isHelpOpen) {
        //   this.isHelpOpen = true;
        //   this.iabCardProvider.show();
        //   this.iabCardProvider.sendMessage({ message: 'openZEChatStandalone' });
        // }
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    updateTx(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            if (opts.clearCache) {
                tx.txp = {};
            }
            this.tx = tx;
            // End of quick refresh, before wallet is selected.
            if (!wallet) {
                return resolve();
            }
            this.onGoingProcessProvider.set('calculatingFee');
            this.feeProvider
                .getFeeRate(wallet.coin, tx.network, this.usingMerchantFee
                ? this.currencyProvider.getMaxMerchantFee(wallet.coin)
                : this.tx.feeLevel)
                .then(feeRate => {
                let msg;
                if (this.usingCustomFee) {
                    msg = this.translate.instant('Custom');
                    tx.feeLevelName = msg;
                }
                else if (this.usingMerchantFee) {
                    const maxAllowedFee = feeRate * 5;
                    this.logger.info(`Using Merchant Fee: ${tx.feeRate} vs. referent level (5 * feeRate) ${maxAllowedFee}`);
                    const isUtxo = this.currencyProvider.isUtxoCoin(wallet.coin);
                    if (tx.network != 'testnet' &&
                        tx.feeRate > maxAllowedFee &&
                        isUtxo) {
                        this.onGoingProcessProvider.set('calculatingFee');
                        this.showHighFeeSheet();
                    }
                    msg = this.translate.instant('This payment requires a miner fee of:');
                    this.merchantFeeLabel = msg;
                }
                else {
                    const feeOpts = this.feeProvider.getFeeOpts();
                    tx.feeLevelName = feeOpts[tx.feeLevel];
                    tx.feeRate = feeRate;
                }
                // call getSendMaxInfo if was selected from amount view
                if (tx.sendMax && this.shouldUseSendMax()) {
                    this.useSendMax(tx, wallet, opts)
                        .then(() => {
                        return resolve();
                    })
                        .catch(err => {
                        return reject(err);
                    });
                }
                else if (tx.speedUpTx && this.shouldUseSendMax()) {
                    this.speedUpTx(tx, wallet, opts)
                        .then(() => {
                        return resolve();
                    })
                        .catch(err => {
                        return reject(err);
                    });
                }
                else {
                    // txp already generated for this wallet?
                    if (tx.txp[wallet.id]) {
                        this.onGoingProcessProvider.clear();
                        this.getTotalAmountDetails(tx, wallet);
                        return resolve();
                    }
                    this.buildTxp(tx, wallet, opts)
                        .then(() => {
                        this.onGoingProcessProvider.clear();
                        return resolve();
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        return reject(err);
                    });
                }
            })
                .catch(err => {
                this.logger.warn('Error getting fee rate', err);
                this.onGoingProcessProvider.clear();
                return reject(this.translate.instant('Error getting fee rate'));
            });
        });
    }
    useSendMax(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getSendMaxInfo(__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](tx), wallet)
                .then(sendMaxInfo => {
                if (sendMaxInfo) {
                    this.logger.debug('Send max info', sendMaxInfo);
                    if (sendMaxInfo.amount <= 0) {
                        this.showErrorInfoSheet(this.translate.instant('Not enough funds for fee'));
                        return resolve();
                    }
                    tx.sendMaxInfo = sendMaxInfo;
                    tx.amount = tx.sendMaxInfo.amount;
                    this.getAmountDetails();
                }
                this.showWarningSheet(wallet, sendMaxInfo);
                // txp already generated for this wallet?
                if (tx.txp[wallet.id]) {
                    this.getTotalAmountDetails(tx, wallet);
                    return resolve();
                }
                this.buildTxp(tx, wallet, opts)
                    .then(() => {
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(() => {
                const msg = this.translate.instant('Error getting SendMax information');
                return reject(msg);
            });
        });
    }
    speedUpTx(tx, wallet, opts) {
        return this.getSpeedUpTxInfo(__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](tx), wallet)
            .then(speedUpTxInfo => {
            if (speedUpTxInfo) {
                this.logger.debug('Speed Up info', speedUpTxInfo);
                if (speedUpTxInfo.amount <= 0) {
                    this.showErrorInfoSheet(this.translate.instant('Not enough funds for fee'));
                    return Promise.resolve();
                }
                tx.speedUpTxInfo = speedUpTxInfo;
            }
            return this.feeProvider
                .getSpeedUpTxFee(wallet.network, speedUpTxInfo.size)
                .then(speedUpTxFee => {
                speedUpTxInfo.fee = speedUpTxFee;
                this.showWarningSheet(wallet, speedUpTxInfo);
                return this.getInput(wallet).then(input => {
                    tx.speedUpTxInfo.input = input;
                    tx.amount = tx.speedUpTxInfo.input.satoshis - speedUpTxInfo.fee;
                    this.tx.amount = tx.amount;
                    this.getAmountDetails();
                    return this.buildTxp(tx, wallet, opts);
                });
            })
                .catch(err => {
                const error = err
                    ? err
                    : this.translate.instant('Error getting Speed Up fee');
                return Promise.reject(error);
            });
        })
            .catch(err => {
            const error = err
                ? err
                : this.translate.instant('Error getting Speed Up information');
            return Promise.reject(error);
        });
    }
    getFeeRate(amount, fee) {
        return (fee / amount) * 100;
    }
    isHighFee(amount, fee) {
        return this.getFeeRate(amount, fee) > this.FEE_TOO_HIGH_LIMIT_PER;
    }
    showHighFeeSheet() {
        const minerFeeWarning = this.actionSheetProvider.createMinerFeeWarningComponent();
        minerFeeWarning.present({ maxHeight: '100%', minHeight: '100%' });
    }
    showTotalAmountSheet() {
        const totalAmountFeeInfoSheet = this.actionSheetProvider.createInfoSheet('total-amount');
        totalAmountFeeInfoSheet.present();
    }
    showSubtotalAmountSheet() {
        const subtotalAmountFeeInfoSheet = this.actionSheetProvider.createInfoSheet('subtotal-amount');
        subtotalAmountFeeInfoSheet.present();
    }
    buildTxp(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getTxp(__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](tx), wallet, opts.dryRun)
                .then(txp => {
                this.isERCToken = this.currencyProvider.isERCToken(tx.coin);
                if (this.isERCToken) {
                    const chain = this.getChain(tx.coin);
                    const fiatOfAmount = this.rateProvider.toFiat(tx.paypro ? tx.amount : txp.amount, this.config.wallet.settings.alternativeIsoCode, tx.coin);
                    const fiatOfFee = this.rateProvider.toFiat(txp.fee, this.config.wallet.settings.alternativeIsoCode, chain);
                    const per = this.getFeeRate(fiatOfAmount, fiatOfFee);
                    txp.feeRatePerStr = per.toFixed(2) + '%';
                    txp.feeTooHigh = this.isHighFee(tx.paypro ? tx.amount : txp.amount, txp.fee);
                    this.totalAmountStr =
                        (fiatOfAmount + fiatOfFee).toFixed(2) +
                            ' ' +
                            this.config.wallet.settings.alternativeIsoCode;
                }
                else {
                    const per = this.getFeeRate(txp.amount, txp.fee);
                    txp.feeRatePerStr = per.toFixed(2) + '%';
                    txp.feeTooHigh = this.isHighFee(txp.amount, txp.fee);
                }
                if (txp.feeTooHigh) {
                    this.showHighFeeSheet();
                }
                tx.txp[wallet.id] = txp;
                this.tx = tx;
                this.logger.debug('Confirm. TX Fully Updated for wallet:' +
                    wallet.id +
                    ' Txp:' +
                    txp.id);
                this.getTotalAmountDetails(tx, wallet);
                return resolve();
            })
                .catch(err => {
                if (err.message == 'Insufficient funds') {
                    return reject('insufficient_funds');
                }
                else {
                    return reject(err);
                }
            });
        });
    }
    getSendMaxInfo(tx, wallet) {
        return new Promise((resolve, reject) => {
            if (!tx.sendMax)
                return resolve();
            this.onGoingProcessProvider.set('retrievingInputs');
            this.walletProvider
                .getSendMaxInfo(wallet, {
                feePerKb: tx.feeRate,
                excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
                returnInputs: true
            })
                .then(res => {
                this.onGoingProcessProvider.clear();
                return resolve(res);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Error getting send max info', err);
                return reject(err);
            });
        });
    }
    getSpeedUpTxInfo(tx, wallet) {
        if (!tx.speedUpTx)
            return Promise.resolve();
        this.onGoingProcessProvider.set('retrievingInputs');
        return this.walletProvider
            .getTx(wallet, this.navParams.data.txid)
            .then(res => {
            this.onGoingProcessProvider.clear();
            return Promise.resolve(res);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Error getting speed up info', err);
            return Promise.reject(err);
        });
    }
    showWarningSheet(wallet, info) {
        if (!info)
            return;
        let msg, infoSheetType;
        if (this.tx.sendMax) {
            const warningMsg = this.verifyExcludedUtxos(wallet, info);
            msg = !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](warningMsg) ? warningMsg : '';
            infoSheetType = 'miner-fee-notice';
        }
        else {
            infoSheetType = 'speed-up-notice';
            msg = '';
        }
        const coinName = this.currencyProvider.getCoinName(wallet.coin);
        const { unitToSatoshi } = this.currencyProvider.getPrecision(this.tx.coin);
        const fee = info.fee / unitToSatoshi;
        const minerFeeNoticeInfoSheet = this.actionSheetProvider.createInfoSheet(infoSheetType, {
            coinName,
            fee,
            coin: this.tx.coin.toUpperCase(),
            msg
        });
        minerFeeNoticeInfoSheet.present();
    }
    verifyExcludedUtxos(_, sendMaxInfo) {
        const warningMsg = [];
        if (sendMaxInfo.utxosBelowFee > 0) {
            const amountBelowFeeStr = sendMaxInfo.amountBelowFee /
                this.currencyProvider.getPrecision(this.tx.coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (sendMaxInfo.utxosAboveMaxSize > 0) {
            const amountAboveMaxSizeStr = sendMaxInfo.amountAboveMaxSize /
                this.currencyProvider.getPrecision(this.tx.coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountAboveMaxSizeStr}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { amountAboveMaxSizeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
    getTxp(tx, wallet, dryRun) {
        return new Promise((resolve, reject) => {
            // ToDo: use a credential's (or fc's) function for this
            if (tx.description && !wallet.credentials.sharedEncryptingKey) {
                const msg = this.translate.instant('Could not add message to imported wallet without shared encrypting key');
                return reject(msg);
            }
            if (this.currencyProvider.isUtxoCoin(tx.coin) &&
                tx.amount > Number.MAX_SAFE_INTEGER) {
                const msg = this.translate.instant('Amount too big');
                return reject(msg);
            }
            const txp = {};
            // set opts.coin to wallet.coin
            txp.coin = wallet.coin;
            if (this.fromMultiSend) {
                txp.outputs = [];
                this.navParams.data.recipients.forEach(recipient => {
                    if (tx.coin && tx.coin == 'bch') {
                        recipient.toAddress = this.bitcoreCash
                            .Address(recipient.toAddress)
                            .toString(true);
                        recipient.addressToShow = this.walletProvider.getAddressView(tx.coin, tx.network, recipient.toAddress);
                    }
                    txp.outputs.push({
                        toAddress: recipient.toAddress,
                        amount: recipient.amount,
                        message: tx.description,
                        data: tx.data
                    });
                });
            }
            else if (tx.paypro) {
                txp.outputs = [];
                const { instructions } = tx.paypro;
                for (const instruction of instructions) {
                    txp.outputs.push({
                        toAddress: instruction.toAddress,
                        amount: instruction.amount,
                        message: instruction.message,
                        data: instruction.data
                    });
                }
            }
            else {
                if (tx.fromSelectInputs) {
                    const size = this.walletProvider.getEstimatedTxSize(wallet, 1, tx.inputs.length);
                    let estimatedFee;
                    switch (tx.coin) {
                        case 'doge':
                            estimatedFee = 1e8; // 1 DOGE
                            break;
                        default:
                            estimatedFee =
                                size * parseInt((tx.feeRate / 1000).toFixed(0), 10);
                            break;
                    }
                    tx.fee = estimatedFee;
                    tx.amount = tx.amount - estimatedFee;
                }
                txp.outputs = [
                    {
                        toAddress: tx.toAddress,
                        amount: tx.amount,
                        message: tx.description,
                        data: tx.data,
                        gasLimit: tx.gasLimit // wallet connect needs exact gasLimit value
                    }
                ];
            }
            txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
            txp.dryRun = dryRun;
            if (tx.sendMaxInfo) {
                txp.inputs = tx.sendMaxInfo.inputs;
                txp.fee = tx.sendMaxInfo.fee;
            }
            else if (tx.speedUpTx) {
                txp.inputs = [];
                txp.inputs.push(tx.speedUpTxInfo.input);
                txp.fee = tx.speedUpTxInfo.fee;
                txp.excludeUnconfirmedUtxos = true;
            }
            else if (tx.fromSelectInputs) {
                txp.inputs = tx.inputs;
                txp.fee = tx.fee;
            }
            else {
                if (this.usingCustomFee || this.usingMerchantFee) {
                    txp.feePerKb = tx.feeRate;
                }
                else
                    txp.feeLevel = tx.feeLevel;
            }
            txp.message = tx.description;
            if (tx.paypro) {
                txp.payProUrl = tx.payProUrl;
                tx.paypro.host = new URL(tx.payProUrl).host;
            }
            if (tx.recipientType == 'wallet') {
                txp.customData = {
                    toWalletName: tx.name ? tx.name : null
                };
            }
            else if (tx.recipientType == 'coinbase') {
                txp.customData = {
                    service: 'coinbase'
                };
            }
            if (tx.tokenAddress) {
                txp.tokenAddress = tx.tokenAddress;
                if (!tx.paypro) {
                    for (const output of txp.outputs) {
                        if (!output.data) {
                            output.data = this.bwcProvider
                                .getCore()
                                .Transactions.get({ chain: 'ERC20' })
                                .encodeData({
                                recipients: [
                                    { address: output.toAddress, amount: output.amount }
                                ],
                                tokenAddress: tx.tokenAddress
                            });
                        }
                    }
                }
            }
            if (tx.multisigContractAddress &&
                !this.navParams.data.isEthMultisigInstantiation &&
                !this.navParams.data.isEthMultisigConfirm &&
                !this.navParams.data.isEthMultisigExecute) {
                txp.multisigContractAddress = tx.multisigContractAddress;
                for (const output of txp.outputs) {
                    const data = output.data ? output.data : '0x';
                    output.data = this.bwcProvider
                        .getCore()
                        .Transactions.get({ chain: 'ETHMULTISIG' })
                        .submitEncodeData({
                        recipients: [
                            { address: output.toAddress, amount: output.amount }
                        ],
                        multisigContractAddress: tx.multisigContractAddress,
                        data
                    });
                }
            }
            if (tx.multisigContractAddress &&
                !this.navParams.data.isEthMultisigInstantiation &&
                this.navParams.data.isEthMultisigConfirm &&
                !this.navParams.data.isEthMultisigExecute) {
                txp.multisigContractAddress = tx.multisigContractAddress;
                for (const output of txp.outputs) {
                    if (!output.data) {
                        output.data = this.bwcProvider
                            .getCore()
                            .Transactions.get({ chain: 'ETHMULTISIG' })
                            .confirmTransactionEncodeData({
                            multisigContractAddress: tx.multisigContractAddress,
                            transactionId: +this.navParams.data.transactionId
                        });
                    }
                }
            }
            if (tx.multisigContractAddress &&
                !this.navParams.data.isEthMultisigInstantiation &&
                !this.navParams.data.isEthMultisigConfirm &&
                this.navParams.data.isEthMultisigExecute) {
                txp.multisigContractAddress = tx.multisigContractAddress;
                for (const output of txp.outputs) {
                    if (!output.data) {
                        output.data = this.bwcProvider
                            .getCore()
                            .Transactions.get({ chain: 'ETHMULTISIG' })
                            .executeTransactionEncodeData({
                            multisigContractAddress: tx.multisigContractAddress,
                            transactionId: +this.navParams.data.transactionId
                        });
                    }
                }
            }
            if (tx.multisigContractAddress &&
                this.navParams.data.isEthMultisigInstantiation &&
                !this.navParams.data.isEthMultisigConfirm &&
                !this.navParams.data.isEthMultisigExecute) {
                txp.multisigContractAddress = tx.multisigContractAddress;
                for (const output of txp.outputs) {
                    if (!output.data) {
                        output.data = this.bwcProvider
                            .getCore()
                            .Transactions.get({ chain: 'ETHMULTISIG' })
                            .instantiateEncodeData({
                            addresses: this.navParams.data.multisigAddresses,
                            requiredConfirmations: this.navParams.data
                                .requiredConfirmations,
                            multisigGnosisContractAddress: tx.multisigContractAddress,
                            dailyLimit: 0
                        });
                    }
                }
            }
            if (wallet.coin === 'xrp') {
                txp.invoiceID = tx.invoiceID;
                txp.destinationTag = tx.destinationTag;
            }
            this.walletProvider
                .getAddress(this.wallet, false)
                .then(address => {
                if (wallet.coin === 'xrp' && tx.toAddress === address) {
                    const err = this.translate.instant('Cannot send XRP to the same wallet you are trying to send from. Please check the destination address and try it again.');
                    return reject(err);
                }
                txp.from = address;
                this.walletProvider
                    .createTx(wallet, txp)
                    .then(ctxp => {
                    return resolve(ctxp);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createAndBindEthMultisigWallet(pairedWallet, multisigEthInfo) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](pairedWallet)) {
            this.profileProvider
                .createMultisigEthWallet(pairedWallet, multisigEthInfo)
                .then(multisigWallet => {
                // store preferences for the paired eth wallet
                this.walletProvider.updateRemotePreferences(pairedWallet);
                this.openFinishModal(false, { redir: null }, multisigWallet.id).then(() => {
                    this.events.publish('Local/WalletListChange');
                });
            });
        }
    }
    getInput(wallet) {
        return this.walletProvider.getUtxos(wallet).then(utxos => {
            let biggestUtxo = 0;
            let input;
            __WEBPACK_IMPORTED_MODULE_4_lodash__["forEach"](utxos, (u, i) => {
                if (u.txid === this.navParams.data.txid) {
                    if (u.confirmations <= 0)
                        throw new Error(this.translate.instant('Some inputs you want to speed up have no confirmations. Please wait until they are confirmed and try again.'));
                    if (u.amount > biggestUtxo) {
                        biggestUtxo = u.amount;
                        input = utxos[i];
                    }
                }
            });
            return input;
        });
    }
    showInsufficientFundsInfoSheet() {
        const insufficientFundsInfoSheet = this.actionSheetProvider.createInfoSheet('insufficient-funds');
        insufficientFundsInfoSheet.present();
        insufficientFundsInfoSheet.onDidDismiss(option => {
            if (option || typeof option === 'undefined') {
                this.fromWalletDetails ? this.navCtrl.pop() : this.navCtrl.popToRoot();
            }
            else {
                this.tx.sendMax = true;
                this.setWallet(this.wallet);
            }
        });
    }
    showErrorInfoSheet(error, title, exit) {
        let msg;
        if (!error)
            return;
        this.logger.warn('ERROR:', error);
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        if (error.message === 'FINGERPRINT_CANCELLED' ||
            error.message === 'PASSWORD_CANCELLED') {
            return;
        }
        if (error.message === 'WRONG_PASSWORD') {
            this.errorsProvider.showWrongEncryptPasswordError();
            return;
        }
        // Currently the paypro error is the following string: 500 - "{}"
        if (error.toString().includes('500')) {
            msg = this.translate.instant('Error 500 - There is a temporary problem, please try again later.');
        }
        const infoSheetTitle = title ? title : this.translate.instant('Error');
        this.errorsProvider.showDefaultError(msg || this.bwcErrorProvider.msg(error), infoSheetTitle, () => {
            if (exit) {
                this.fromWalletDetails
                    ? this.navCtrl.popToRoot()
                    : this.navCtrl.pop();
            }
        });
    }
    toggleAddress() {
        this.showAddress = !this.showAddress;
    }
    onWalletSelect(option) {
        if (option.isCoinbaseAccount)
            this.setCoinbaseAccount(option);
        else
            this.setWallet(option);
    }
    approve(tx, wallet) {
        if (!tx || (!wallet && !this.coinbaseAccount))
            return undefined;
        if (this.paymentExpired) {
            this.showErrorInfoSheet(this.translate.instant('This bitcoin payment request has expired.'));
            return undefined;
        }
        if (wallet) {
            this.onGoingProcessProvider.set('creatingTx');
            return this.getTxp(__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](tx), wallet, false)
                .then(txp => {
                this.logger.debug('Transaction Fee:', txp.fee);
                return this.confirmTx(txp, wallet).then((nok) => {
                    if (nok) {
                        if (this.isCordova)
                            this.slideButton.isConfirmed(false);
                        this.onGoingProcessProvider.clear();
                        return;
                    }
                    this.publishAndSign(txp, wallet);
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Error getting transaction proposal', err);
            });
        }
        else {
            return this.payWithCoinbaseAccount(this.tx.paypro.invoiceId, this.coinbaseAccount.currency.code);
        }
    }
    confirmTx(txp, wallet) {
        return new Promise(resolve => {
            if (wallet.isPrivKeyEncrypted)
                return resolve(false);
            this.txFormatProvider.formatToUSD(wallet.coin, txp.amount).then(val => {
                const amountUsd = parseFloat(val);
                if (amountUsd <= this.CONFIRM_LIMIT_USD)
                    return resolve(false);
                const unit = txp.coin.toUpperCase();
                const amount = (this.tx.amount /
                    this.currencyProvider.getPrecision(txp.coin).unitToSatoshi).toFixed(8);
                const name = wallet.name;
                const message = this.replaceParametersProvider.replace(this.translate.instant('Sending {{amount}} {{unit}} from your {{name}} wallet'), { amount, unit, name });
                const okText = this.translate.instant('Confirm');
                const cancelText = this.translate.instant('Cancel');
                this.popupProvider
                    .ionicConfirm(null, message, okText, cancelText)
                    .then((ok) => {
                    return resolve(!ok);
                });
            });
        });
    }
    publishAndSign(txp, wallet) {
        if (!wallet.canSign) {
            return this.onlyPublish(txp, wallet);
        }
        return this.walletProvider
            .publishAndSign(wallet, txp)
            .then(txp => {
            if (this.config.confirmedTxsNotifications &&
                this.config.confirmedTxsNotifications.enabled) {
                this.txConfirmNotificationProvider.subscribe(wallet, {
                    txid: txp.txid,
                    amount: txp.amount
                });
            }
            let redir;
            if (txp.payProUrl && txp.payProUrl.includes('redir=wc')) {
                redir = 'wc';
            }
            if (this.navParams.data.isEthMultisigInstantiation) {
                this.onGoingProcessProvider.set('creatingEthMultisigWallet');
                return this.instantiateMultisigContract(txp);
            }
            else if (this.walletConnectRequestId) {
                this.walletConnectProvider.approveRequest(this.walletConnectRequestId, txp.txid);
                this.onGoingProcessProvider.clear();
                return this.openFinishModal(false, { redir });
            }
            else {
                this.onGoingProcessProvider.clear();
                return this.openFinishModal(false, { redir });
            }
        })
            .catch(err => {
            if (this.isCordova)
                this.slideButton.isConfirmed(false);
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err);
            if (txp.payProUrl || this.navParams.data.isEthMultisigInstantiation) {
                this.logger.warn('Paypro error: removing payment proposal');
                this.walletProvider.removeTx(wallet, txp).catch(() => {
                    this.logger.warn('Could not delete payment proposal');
                });
            }
            else if (this.isSpeedUpTx) {
                this.logger.warn('Speed up transaction error: removing transaction');
                this.walletProvider.removeTx(wallet, txp).catch(() => {
                    this.logger.warn('Could not delete transaction');
                });
            }
        });
    }
    onlyPublish(txp, wallet) {
        this.logger.info('No signing proposal: No private key');
        this.onGoingProcessProvider.set('sendingTx');
        return this.walletProvider
            .onlyPublish(wallet, txp)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal(true);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err);
        });
    }
    openFinishModal(onlyPublish, redirectionParam, walletId) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const { redir } = redirectionParam || { redir: '' };
            let params = {
                finishText: this.successText,
                autoDismiss: !!redir,
                coin: this.coin
            };
            if (onlyPublish) {
                const finishText = this.translate.instant('Payment Published');
                const finishComment = this.translate.instant('You could sign the transaction later in your wallet details');
                params = { finishText, finishComment, coin: this.coin };
            }
            const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], params, {
                showBackdrop: true,
                enableBackdropDismiss: false,
                cssClass: 'finish-modal'
            });
            yield modal.present();
            this.clipboardProvider.clearClipboardIfValidData([
                'PayPro',
                'BitcoinUri',
                'BitcoinCashUri',
                'EthereumUri',
                'DogecoinUri',
                'RippleUri',
                'InvoiceUri'
            ]);
            this.navCtrl.popToRoot().then(_ => {
                if (this.fromCoinbase) {
                    this.coinbaseProvider.logEvent({
                        method: 'deposit',
                        amount: this.amount,
                        currency: this.coin
                    });
                    this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__integrations_coinbase_coinbase_account_coinbase_account__["a" /* CoinbaseAccountPage */], {
                        id: this.fromCoinbase.accountId
                    });
                }
                else {
                    if (redir) {
                        setTimeout(() => {
                            this.iabCardProvider.show();
                            this.iabCardProvider.sendMessage({
                                message: 'paymentBroadcasted'
                            }, () => {
                                this.logger.log('card IAB -> payment broadcasting opening IAB');
                            });
                        }, 1000);
                    }
                    else if (this.wallet) {
                        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                            walletId: walletId ? walletId : this.wallet.credentials.walletId
                        });
                    }
                }
            });
        });
    }
    chooseFeeLevel() {
        if (this.tx.coin === 'bch' ||
            this.tx.coin === 'xrp' ||
            this.tx.coin === 'doge' ||
            this.usingMerchantFee ||
            this.tx.speedUpTxInfo)
            return;
        const txObject = {
            network: this.tx.network,
            coin: this.tx.coin,
            feeLevel: this.tx.feeLevel,
            noSave: true,
            customFeePerKB: this.usingCustomFee ? this.tx.feeRate : undefined,
            feePerSatByte: this.usingCustomFee ? this.tx.feeRate / 1000 : undefined
        };
        const chooseFeeLevelAction = this.actionSheetProvider.createChooseFeeLevel(txObject);
        chooseFeeLevelAction.present();
        chooseFeeLevelAction.onDidDismiss(data => {
            data && data.showMinWarning
                ? this.showCustomFeeWarningSheet(data)
                : this.onFeeModalDismiss(data);
        });
    }
    onFeeModalDismiss(data) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](data))
            return;
        this.logger.debug('New fee level chosen:' + data.newFeeLevel + ' was:' + this.tx.feeLevel);
        this.usingCustomFee = data.newFeeLevel == 'custom' ? true : false;
        if (this.tx.feeLevel == data.newFeeLevel && !this.usingCustomFee) {
            return;
        }
        this.tx.feeLevel = data.newFeeLevel;
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        if (this.usingCustomFee)
            this.tx.feeRate = parseInt(data.customFeePerKB, 10);
        this.updateTx(this.tx, this.wallet, {
            clearCache: true,
            dryRun: true
        }).catch(err => {
            if (err.message && err.message.includes('Insufficient funds')) {
                this.showErrorInfoSheet(this.translate.instant('Not enough funds for fee'));
            }
            this.logger.warn('Error updateTx', err);
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        const id = this.wallet ? this.wallet.credentials.walletId : null;
        let coinbaseData = { user: [], availableAccounts: [] };
        if (this.showCoinbase) {
            coinbaseData = {
                user: this.coinbaseProvider.coinbaseData.user,
                availableAccounts: this.coinbaseAccounts
            };
        }
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: this.walletSelectorTitle,
            coinbaseData
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(option => {
            this.onSelectWalletEvent(option);
        });
    }
    onSelectWalletEvent(option) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](option))
            this.onWalletSelect(option);
        this.isOpenSelector = false;
    }
    close() {
        this.navCtrl.popToRoot();
    }
    editMemo(memo) {
        const memoComponent = this.actionSheetProvider.createMemoComponent(memo);
        memoComponent.present();
        memoComponent.onDidDismiss(memo => {
            if (memo)
                this.tx.description = memo;
        });
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__scan_scan__["a" /* ScanPage */], { fromConfirm: true });
    }
    payWithCoinbaseAccount(invoiceId, coin, code) {
        this.onGoingProcessProvider.set('payingWithCoinbase');
        return this.coinbaseProvider
            .payInvoice(invoiceId, coin, code)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err == '2fa') {
                const message = this.translate.instant('Enter 2-step verification');
                const opts = {
                    type: 'number',
                    enableBackdropDismiss: false
                };
                this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                    if (res === null) {
                        this.showErrorAndBack(this.translate.instant('Missing 2-step verification'));
                        return;
                    }
                    this.payWithCoinbaseAccount(invoiceId, coin, res);
                });
            }
            else {
                this.showErrorAndBack(err);
            }
        });
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
    }
    showCustomFeeWarningSheet(data) {
        const warningSheet = this.actionSheetProvider.createInfoSheet('custom-fee-warning');
        warningSheet.present();
        warningSheet.onDidDismiss(option => {
            option ? this.chooseFeeLevel() : this.onFeeModalDismiss(data);
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], ConfirmPage.prototype, "slideButton", void 0);
ConfirmPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-confirm',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/confirm/confirm.html"*/'<wide-header-page title="{{ mainTitle }}" [hasSlideButton]="!hideSlideButton && isCordova">\n  <div page-content>\n    <label-tip *ngIf="isSpeedUpTx" type="info" header="no-header" class="no-arrowhead">\n      <div label-tip-body translate>\n        A transaction using your delayed transaction inputs will be sent to your own wallet with a higher miner fee to speed up the last confirmation time.\n        <br>\n      </div>\n    </label-tip>\n    <ion-list *ngIf="tx" class="bp-list">\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label" translate>SUMMARY</div>\n        </ion-label>\n      </ion-item>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span *ngIf="tx.recipientType != \'coinbase\'" translate>Sending to</span>\n            <span *ngIf="tx.recipientType == \'coinbase\'" translate>Transfer to</span>\n          </div>\n        </ion-label>\n\n        <ion-note item-end>\n          <div class="payment-proposal-to" *ngIf="!tx.recipientType">\n            <div class="background-content" *ngIf="!tx.paypro && !fromCoinbase" copy-to-clipboard="{{ tx.origToAddress }}">\n              <img class="coin-img" src="assets/img/currencies/{{tx.coin}}.svg" [ngClass]="{\'testnet\': tx.network === \'testnet\'}" alt="Coin" />\n              <span *ngIf="!tx.name">{{tx.origToAddress | shortenedAddress}}</span>\n              <span class="ellipsis" *ngIf="tx.name">{{tx.name}}</span>\n            </div>\n\n            <div class="paypro" *ngIf="tx.paypro">\n\n              <ion-icon *ngIf="tx.paypro.verified" name="lock" color="success"></ion-icon>\n              <ion-icon *ngIf="!tx.paypro.verified" name="unlock" color="danger"></ion-icon>\n\n              <span>{{tx.paypro.host || tx.paypro.toAddress}}</span>\n            </div>\n\n            <div *ngIf="!tx.paypro && fromCoinbase">\n              <img class="coin-img" src="assets/img/coinbase/coinbase-icon.png">\n              <span class="ellipsis">{{ fromCoinbase.accountName }}</span>\n            </div>\n          </div>\n\n          <ion-row align-items-center class="wallet" *ngIf="tx.recipientType == \'wallet\'">\n            <ion-col>\n              <coin-icon [coin]="tx.coin" [network]="tx.network"></coin-icon>\n            </ion-col>\n\n            <ion-col>\n              <div copy-to-clipboard="{{ tx.origToAddress }}">\n                <span class="note-container ellipsis" *ngIf="!tx.name">{{tx.origToAddress}}</span>\n                <span class="note-container ellipsis" *ngIf="tx.name">{{tx.name}}</span>\n              </div>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="tx.recipientType == \'contact\'" (longPress)="toggleAddress()">\n            <ion-col>\n              <gravatar [name]="tx.name" [height]="40" [width]="40" [email]="tx.email" [coin]="tx.coin" [network]="tx.network"></gravatar>\n            </ion-col>\n\n            <ion-col>\n              <div copy-to-clipboard="{{ tx.origToAddress }}">\n                <span class="note-container ellipsis" *ngIf="tx.name && !showAddress">{{tx.name}}</span>\n                <span class="note-container ellipsis" *ngIf="tx.name && showAddress" copy-to-clipboard="{{ tx.toAddress }}">{{tx.toAddress}}</span>\n              </div>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="tx.recipientType == \'coinbase\'">\n            <ion-col>\n              <ion-icon item-start>\n                <img src="assets/img/coinbase/coinbase-icon.png" width="32">\n              </ion-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="ellipsis">{{ fromCoinbase?.accountName }}</span>\n            </ion-col>\n          </ion-row>\n\n          <div class="multi-recip-title" (click)="showMultiplesOutputs = !showMultiplesOutputs" *ngIf="fromMultiSend">\n            <ion-icon item-start>\n              <img class="coin-img" src="assets/img/icon-{{tx.coin}}-small.svg" alt="Coin" />\n            </ion-icon>\n            <span class="ellipsis">{{\'Multiple recipients ({recipientsCount})\' | translate: { recipientsCount: recipients?.length } }}</span>\n            <button ion-button clear color="grey" icon-only item-end>\n              <ion-icon *ngIf="showMultiplesOutputs" name="ios-arrow-up-outline"></ion-icon>\n              <ion-icon *ngIf="!showMultiplesOutputs" name="ios-arrow-down-outline"></ion-icon>\n            </button>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div *ngIf="tx && fromMultiSend && showMultiplesOutputs">\n        <ion-item *ngFor="let recipient of recipients; let i = index" copy-to-clipboard="{{recipient.toAddress}}">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Recipient {{ i + 1 }}</span>\n            </div>\n          </ion-label>\n          <div item-end>\n            <div class="payment-proposal-to align-right">\n              <div class="background-content">\n                <img class="coin-img" src="assets/img/currencies/{{tx.coin}}.svg" [ngClass]="{\'testnet\': tx.network === \'testnet\'}" alt="Coin" />\n                <span>{{(recipient.addressToShow || recipient.toAddress || recipient.address) | shortenedAddress}}</span>\n              </div>\n            </div>\n            <div class="multi-amount">{{recipient.amountToShow}} {{coin | uppercase}}</div>\n            <div class="secondary-note" *ngIf="recipient.altAmountStr">{{recipient.altAmountStr}}</div>\n          </div>\n        </ion-item>\n      </div>\n\n      <div class="line-divider" *ngIf="!coinbaseAccount"></div>\n\n      <button ion-item [attr.detail-none]="usingMerchantFee ? \'\' : null" *ngIf="!coinbaseAccount" (click)="chooseFeeLevel()" class="item-fee" [ngClass]="{\'warn\': wallet && tx.txp[wallet.id] && tx.txp[wallet.id].feeTooHigh, \'btn-opacity\': usingMerchantFee}">\n        <ion-label>\n          <div class="summary-item">\n            <span *ngIf="!merchantFeeLabel" translate>Miner fee</span>\n            <span *ngIf="merchantFeeLabel">{{ merchantFeeLabel }}</span>\n          </div>\n        </ion-label>\n        <ion-note *ngIf="wallet && tx.txp[wallet.id]" item-end>\n          <div class="fee-loading" *ngIf="!wallet || !tx.txp[wallet.id]">\n            <div>...</div>\n            <div>...</div>\n          </div>\n          <div class="summary-item-detail">\n            <span class="text-bold">{{tx.feeLevelName | uppercase}}</span>\n          </div>\n          <div class="summary-item-detail">\n            {{tx.txp[wallet.id].fee | satToUnit: getChain(tx.coin)}}\n          </div>\n          <div class="secondary-note fee-details" [ngStyle]="tx.txp[wallet.id].feeTooHigh === true ? { opacity: 1 } : null">\n            {{tx.txp[wallet.id].fee | satToFiat: getChain(tx.coin)}}\n            <span *ngIf="tx.txp[wallet.id].feeRatePerStr">\n              &middot;\n              <span>\n                <ion-icon *ngIf="tx.txp[wallet.id].feeTooHigh" name="warning"></ion-icon>\n                {{tx.txp[wallet.id].feeRatePerStr}}\n              </span>\n            </span>\n          </div>\n        </ion-note>\n      </button>\n\n      <div class="line-divider"></div>\n\n      <button ion-item detail-none (click)="showWallets()" [ngClass]="{\'not-clickable\': fromWalletDetails || walletConnectRequestId}">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Sending from</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <ion-row align-items-center class="wallet" *ngIf="wallet">\n            <ion-col>\n              <coin-icon [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{wallet.name}}</span>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="coinbaseAccount">\n            <ion-col>\n              <ion-icon item-start>\n                <img src="assets/img/coinbase/coinbase-icon.png" width="32">\n              </ion-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{coinbaseAccount.name}}</span>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="!wallet && !coinbaseAccount">\n            <div translate>Select a wallet</div>\n            <div class="last-item" item-end>\n              <button ion-button clear color="grey" icon-only>\n                <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n                <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n              </button>\n            </div>\n          </ion-row>\n        </ion-note>\n      </button>\n\n      <div class="line-divider"></div>\n\n      <ion-item *ngIf="tx.paypro && (wallet || coinbaseAccount)">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Payment Expires</span>\n          </div>\n        </ion-label>\n        <ion-note class="main-note" *ngIf="!paymentExpired" item-end>{{remainingTimeStr}}</ion-note>\n        <ion-note class="main-note" *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n      </ion-item>\n\n      <div class="summary-line"></div>\n\n      <ion-item *ngIf="!coinbaseAccount">\n        <ion-label>\n          <div class="main-label total-label" [ngClass]="{\'subtotal-label\': !wallet?.credentials.token}">\n            <span class="title" translate>SUBTOTAL</span>\n            <ion-icon *ngIf="tx.paypro" class="item-img info" (click)="showSubtotalAmountSheet()">\n              <img src="assets/img/icon-info-blue.svg" width="22">\n            </ion-icon>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="total-amount" [ngClass]="{\'subtotal-amount\': !wallet?.credentials.token}">\n            {{amount}} {{tx.coin | uppercase}}\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="amount-details" padding-bottom *ngIf="!coinbaseAccount">\n        <div class="total-amount-note" [ngClass]="{\'subtotal-amount-note\': !wallet?.credentials.token}">\n          {{tx.amount | satToFiat: tx.coin}}\n        </div>\n        <div class="total-amount-note" [ngClass]="{\'subtotal-amount-note\': !wallet?.credentials.token}">\n          <span translate *ngIf="tx.sendMax">Sending maximum amount</span>\n        </div>\n      </div>\n\n\n      <ion-item *ngIf="totalAmountStr">\n        <ion-label>\n          <div class="main-label total-label">\n            <span translate>TOTAL</span>\n            <ion-icon class="item-img info" (click)="showTotalAmountSheet()">\n              <img src="assets/img/icon-info-blue.svg" width="22">\n            </ion-icon>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <div class="total-amount">\n            {{totalAmountStr}}\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <div class="amount-details" *ngIf="totalAmount" padding-bottom>\n        <div class="total-amount-note total-amount-note">\n          {{totalAmount | satToFiat: tx.coin}}\n        </div>\n      </div>\n\n      <div class="amount-details" padding-bottom *ngIf="coinbaseAccount">\n        <div class="total-amount-note subtotal-amount-note">\n          <div translate>Miner fee not required for payments with Coinbase accounts</div>\n          <div translate>You are saving {{tx.minerFee | satToUnit: tx.coin}}</div>\n        </div>\n      </div>\n\n      <div class="line-divider"></div>\n\n      <ion-item *ngIf="(wallet && wallet.coin !== \'xrp\') || coinbaseAccount; else destinationTag" (click)="editMemo(tx.description)">\n        <ion-label stacked>{{\'Memo\' | translate}}</ion-label>\n        <ion-textarea placeholder="{{\'Enter a transaction memo\' | translate}}" [(ngModel)]="tx.description" name="tx.description" autocomplete="off" autocorrect="off" readonly disabled></ion-textarea>\n      </ion-item>\n\n      <ng-template #destinationTag>\n        <ion-item *ngIf="!tx.paypro">\n          <ion-label stacked>{{\'Destination Tag\' | translate}}</ion-label>\n          <ion-input class="padded-input" type="number" placeholder="{{\'Enter a destination tag\' | translate}}" [(ngModel)]="tx.destinationTag" name="tx.destinationTag" autocomplete="off" autocorrect="off"></ion-input>\n          <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n        </ion-item>\n\n        <label-tip *ngIf="!tx.paypro && !tx.destinationTag" type="info" header="no-header">\n          <div label-tip-body translate>\n            A Destination Tag is an optional number that corresponds to an invoice or a XRP account on an exchange.\n            <br>\n            <a class="pointer" (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/360039839312-What-are-XRP-Destination-Tags-\')" translate>Learn more</a>\n          </div>\n        </label-tip>\n      </ng-template>\n    </ion-list>\n  </div>\n\n  <div footer-content>\n    <page-slide-to-accept #slideButton *ngIf="isCordova" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}" [disabled]="(!wallet && !coinbaseAccount) || (wallet && !tx?.txp[wallet.id]) || paymentExpired" [buttonText]="buttonText" [isDogecoin]="wallet && wallet.coin == \'doge\'" (slideDone)="approve(tx, wallet)">\n    </page-slide-to-accept>\n    <ion-toolbar *ngIf="!isCordova && (wallet || coinbaseAccount)">\n      <button ion-button full class="button-footer" (click)="approve(tx, wallet)" [disabled]="(!wallet && !coinbaseAccount) || (wallet && !tx?.txp[wallet.id]) || paymentExpired">{{buttonText}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/confirm/confirm.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_24__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_25__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_30__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_32__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_31__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_33__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_34__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_36__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_16__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_in_app_browser_card__["a" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_35__providers_wallet_connect_wallet_connect__["a" /* WalletConnectProvider */]])
], ConfirmPage);

//# sourceMappingURL=confirm.js.map

/***/ }),

/***/ 17:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/@ngx-translate/core.es5.js
var core_es5 = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// EXTERNAL MODULE: ./node_modules/rxjs/Rx.js
var Rx = __webpack_require__(90);
var Rx_default = /*#__PURE__*/__webpack_require__.n(Rx);

// EXTERNAL MODULE: ./src/providers/derivation-path-helper/derivation-path-helper.ts
var derivation_path_helper = __webpack_require__(206);

// EXTERNAL MODULE: ./src/providers/action-sheet/action-sheet.ts
var action_sheet = __webpack_require__(30);

// EXTERNAL MODULE: ./src/providers/app/app.ts
var app = __webpack_require__(23);

// EXTERNAL MODULE: ./src/providers/bwc-error/bwc-error.ts
var bwc_error = __webpack_require__(45);

// EXTERNAL MODULE: ./src/providers/bwc/bwc.ts
var bwc = __webpack_require__(46);

// EXTERNAL MODULE: ./src/providers/config/config.ts
var config_config = __webpack_require__(11);

// EXTERNAL MODULE: ./src/providers/currency/currency.ts + 2 modules
var currency = __webpack_require__(24);

// EXTERNAL MODULE: ./src/providers/errors/errors.ts
var errors = __webpack_require__(41);

// EXTERNAL MODULE: ./src/providers/key/key.ts
var key_key = __webpack_require__(98);

// EXTERNAL MODULE: ./src/providers/language/language.ts
var language = __webpack_require__(226);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger_logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/on-going-process/on-going-process.ts
var on_going_process = __webpack_require__(32);

// EXTERNAL MODULE: ./src/providers/persistence/persistence.ts + 3 modules
var persistence = __webpack_require__(20);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ./src/providers/rate/rate.ts
var rate = __webpack_require__(78);

// EXTERNAL MODULE: ./src/providers/replace-parameters/replace-parameters.ts
var replace_parameters = __webpack_require__(119);

// EXTERNAL MODULE: ./src/providers/tx-format/tx-format.ts
var tx_format = __webpack_require__(85);

// CONCATENATED MODULE: ./src/models/profile/profile.model.ts
class Profile {
    constructor() {
        this.version = '2.0.0';
    }
    static create() {
        let x = new Profile();
        x.createdOn = Date.now();
        x.credentials = [];
        x.disclaimerAccepted = false;
        x.checked = {};
        return x;
    }
    static fromObj(obj) {
        if (!obj || typeof obj != 'object') {
            throw new Error('Wrong params at Profile.fromObj: ' + obj);
        }
        let x = new Profile();
        x.createdOn = obj.createdOn;
        x.credentials = obj.credentials || [];
        x.disclaimerAccepted = obj.disclaimerAccepted || false;
        x.checked = obj.checked || {};
        x.checkedUA = obj.checkedUA;
        if (x.credentials[0] && typeof x.credentials[0] != 'object')
            throw new Error('credentials should be an array of objects');
        return x;
    }
    hasWallet(walletId) {
        for (let i in this.credentials) {
            let c = this.credentials[i];
            if (c.walletId == walletId)
                return true;
        }
        return false;
    }
    isChecked(ua, walletId) {
        return !!(this.checkedUA == ua && this.checked[walletId]);
    }
    isDeviceChecked(ua) {
        return this.checkedUA == ua;
    }
    setChecked(ua, walletId) {
        if (this.checkedUA != ua) {
            this.checkedUA = ua;
            this.checked = {};
        }
        this.checked[walletId] = true;
        this.dirty = true;
    }
    addWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (this.hasWallet(credentials.walletId))
            return false;
        this.credentials.push(credentials);
        this.dirty = true;
        return true;
    }
    updateWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (!this.hasWallet(credentials.walletId))
            return false;
        this.credentials = this.credentials.map(c => {
            if (c.walletId != credentials.walletId) {
                return c;
            }
            else {
                return credentials;
            }
        });
        this.dirty = true;
        return true;
    }
    deleteWallet(walletId) {
        if (!this.hasWallet(walletId))
            return false;
        this.credentials = this.credentials.filter(c => {
            return c.walletId != walletId;
        });
        this.dirty = true;
        return true;
    }
    acceptDisclaimer() {
        this.disclaimerAccepted = true;
        this.dirty = true;
    }
}
//# sourceMappingURL=profile.model.js.map
// CONCATENATED MODULE: ./src/providers/profile/profile.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return profile_ProfileProvider; });






// providers

















// models

let profile_ProfileProvider = class ProfileProvider {
    constructor(currencyProvider, logger, persistenceProvider, configProvider, replaceParametersProvider, bwcProvider, bwcErrorProvider, platformProvider, appProvider, languageProvider, events, onGoingProcessProvider, translate, txFormatProvider, actionSheetProvider, keyProvider, derivationPathHelperProvider, errorsProvider, rateProvider) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bwcProvider = bwcProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.languageProvider = languageProvider;
        this.events = events;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.txFormatProvider = txFormatProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.errorsProvider = errorsProvider;
        this.rateProvider = rateProvider;
        this.walletsGroups = {}; // TODO walletGroups Class
        this.wallet = {};
        this.orderedWalletsByGroup = [];
        this.UPDATE_PERIOD = 15;
        this.UPDATE_PERIOD_FAST = 5;
        this.validationLock = false;
        this.errors = this.bwcProvider.getErrors();
        this.throttledBwsEvent = lodash["throttle"]((n, wallet) => {
            this.newBwsEvent(n, wallet);
        }, 10000);
    }
    trySetName(wallet, i = 0) {
        const config = this.configProvider.get();
        if (i > 5) {
            // just put the Id is the prev fails
            wallet.linkedEthWalletName = wallet.linkedEthWallet;
            return;
        }
        let linked = this.getWallet(wallet.linkedEthWallet);
        if (linked && linked.credentials) {
            this.logger.debug('Setting linkedEthWalletName:' + wallet.linkedEthWallet);
            wallet.linkedEthWalletName =
                (config.aliasFor && config.aliasFor[linked.id]) ||
                    linked.credentials.walletName;
            return;
        }
        else {
            this.logger.debug('Waiting to set name for linkedEthWalletName:' + wallet.linkedEthWallet);
            return window.setTimeout(() => {
                this.trySetName(wallet, i + 1);
            }, 2000);
        }
    }
    updateWalletFromConfig(wallet) {
        const config = this.configProvider.get();
        const defaults = this.configProvider.getDefaults();
        // this.config.whenAvailable( (config) => { TODO
        wallet.usingCustomBWS =
            config.bwsFor &&
                config.bwsFor[wallet.id] &&
                config.bwsFor[wallet.id] != defaults.bws.url;
        wallet.name =
            (config.aliasFor && config.aliasFor[wallet.id]) ||
                wallet.credentials.walletName;
        wallet.email = config.emailFor && config.emailFor[wallet.id];
        // for token wallets
        wallet.linkedEthWallet = this.currencyProvider.getLinkedEthWallet(wallet.coin, wallet.id, wallet.n);
        if (wallet.linkedEthWallet) {
            this.trySetName(wallet);
        }
    }
    setWalletOrder(walletId, index) {
        this.persistenceProvider.setWalletOrder(walletId, index).then(() => {
            this.logger.debug('Wallet new order stored for ' + walletId + ': ' + index);
        });
        if (this.wallet[walletId])
            this.wallet[walletId]['order'] = index;
    }
    setWalletGroupOrder(keyId, index) {
        this.persistenceProvider.setWalletGroupOrder(keyId, index).then(() => {
            this.logger.debug('Wallet group new order stored for ' + keyId + ': ' + index);
        });
        if (this.walletsGroups[keyId])
            this.walletsGroups[keyId]['order'] = index;
    }
    setNewWalletGroupOrder(newWalletKeyId) {
        const promises = [];
        Object.keys(this.walletsGroups).forEach(keyId => {
            promises.push(this.getWalletGroupOrder(keyId));
        });
        Promise.all(promises).then(order => {
            const index = !lodash["max"](order) ? 0 : +lodash["max"](order) + 1;
            this.setWalletGroupOrder(newWalletKeyId, index);
            this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
        });
    }
    setWalletGroupName(keyId, name) {
        this.persistenceProvider.setWalletGroupName(keyId, name);
        if (this.walletsGroups[keyId])
            this.walletsGroups[keyId].name = name;
        this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
    }
    getWalletGroupName(keyId) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const name = yield this.persistenceProvider.getWalletGroupName(keyId);
            return name;
        });
    }
    getWalletOrder(walletId) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const order = yield this.persistenceProvider.getWalletOrder(walletId);
            return order;
        });
    }
    getWalletGroupOrder(keyId) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const order = yield this.persistenceProvider.getWalletGroupOrder(keyId);
            return order;
        });
    }
    setBackupGroupFlag(keyId, timestamp, migrating) {
        if (!keyId)
            return;
        this.persistenceProvider.setBackupGroupFlag(keyId, timestamp);
        this.logger.debug('Backup flag stored');
        if (!migrating)
            this.walletsGroups[keyId].needsBackup = false;
    }
    setWalletBackup(walletId) {
        this.wallet[walletId].needsBackup = false;
    }
    requiresGroupBackup(keyId) {
        let k = this.keyProvider.getKey(keyId);
        if (!k)
            return false;
        const keyObj = k.toObj();
        if (!keyObj.mnemonic && !keyObj.mnemonicEncrypted)
            return false;
        return true;
    }
    requiresBackup(wallet) {
        let k = this.keyProvider.getKey(wallet.credentials.keyId);
        if (!k)
            return false;
        const keyObj = k.toObj();
        if (!keyObj.mnemonic && !keyObj.mnemonicEncrypted)
            return false;
        return true;
    }
    getBackupInfo(wallet) {
        if (!this.requiresBackup(wallet)) {
            return Promise.resolve({ needsBackup: false });
        }
        return this.persistenceProvider
            .getBackupFlag(wallet.credentials.walletId)
            .then(timestamp => {
            if (timestamp) {
                return Promise.resolve({ needsBackup: false, timestamp });
            }
            return Promise.resolve({ needsBackup: true });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    getBackupGroupInfo(keyId, wallet) {
        if (!this.requiresGroupBackup(keyId)) {
            return Promise.resolve({ needsBackup: false });
        }
        return this.persistenceProvider
            .getBackupGroupFlag(keyId)
            .then((timestamp) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (timestamp) {
                return Promise.resolve({ needsBackup: false, timestamp });
            }
            else {
                const backupInfo = yield this.getBackupInfo(wallet);
                if (backupInfo && !backupInfo.needsBackup) {
                    this.setBackupGroupFlag(keyId, backupInfo.timestamp, true);
                    return Promise.resolve({
                        needsBackup: false,
                        timestamp: backupInfo.timestamp
                    });
                }
            }
            return Promise.resolve({ needsBackup: true });
        }))
            .catch(err => {
            this.logger.error(err);
        });
    }
    isBalanceHidden(wallet) {
        return new Promise(resolve => {
            this.persistenceProvider
                .getHideBalanceFlag(wallet.credentials.walletId)
                .then(shouldHideBalance => {
                const isHidden = shouldHideBalance && shouldHideBalance.toString() == 'true'
                    ? true
                    : false;
                return resolve(isHidden);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    isWalletHidden(wallet) {
        return new Promise(resolve => {
            this.persistenceProvider
                .getHideWalletFlag(wallet.credentials.walletId)
                .then(shouldHideWallet => {
                const isHidden = shouldHideWallet && shouldHideWallet.toString() == 'true'
                    ? true
                    : false;
                return resolve(isHidden);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    bindWalletClient(wallet) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const walletId = wallet.credentials.walletId;
            let keyId = wallet.credentials.keyId;
            if (this.wallet[walletId] && this.wallet[walletId].started) {
                this.logger.info('This wallet has been initialized. Skip. ' + walletId);
                return Promise.resolve(false);
            }
            // Workaround to avoid wrong order relatad to async functions
            if (keyId)
                this.walletsGroups[keyId] = {};
            this.wallet[walletId] = {};
            // INIT WALLET VIEWMODEL
            wallet.id = walletId;
            wallet.started = true;
            wallet.network = wallet.credentials.network;
            wallet.copayerId = wallet.credentials.copayerId;
            wallet.m = wallet.credentials.m;
            wallet.n = wallet.credentials.n;
            wallet.coin = wallet.credentials.coin;
            wallet.cachedStatus = {};
            wallet.balanceHidden = yield this.isBalanceHidden(wallet);
            wallet.order = yield this.getWalletOrder(wallet.id);
            wallet.hidden = yield this.isWalletHidden(wallet);
            wallet.lastAddress = yield this.persistenceProvider.getLastAddress(walletId);
            wallet.canSign = keyId ? true : false;
            wallet.isPrivKeyEncrypted = wallet.canSign
                ? this.keyProvider.isPrivKeyEncrypted(keyId)
                : false;
            wallet.canAddNewAccount = this.checkAccountCreation(wallet, keyId);
            wallet.isSegwit = this.checkIfSegwit(wallet.credentials.addressType);
            this.updateWalletFromConfig(wallet);
            this.wallet[walletId] = wallet;
            // INIT WALLET GROUP VIEWMODEL
            let groupBackupInfo, needsBackup, order, name, isPrivKeyEncrypted, canSign, isDeletedSeed;
            if (keyId) {
                groupBackupInfo = yield this.getBackupGroupInfo(keyId, wallet);
                needsBackup = groupBackupInfo.needsBackup;
                isPrivKeyEncrypted = this.keyProvider.isPrivKeyEncrypted(keyId);
                canSign = true;
                isDeletedSeed = this.keyProvider.isDeletedSeed(keyId);
                order = yield this.getWalletGroupOrder(keyId);
                name = yield this.getWalletGroupName(keyId);
                if (!name) {
                    let walletsGroups = lodash["cloneDeep"](this.walletsGroups);
                    delete walletsGroups['read-only'];
                    // use wallets name for wallets group name at migration
                    name = `Key ${Object.keys(walletsGroups).indexOf(keyId) + 1}`;
                }
            }
            else {
                keyId = 'read-only';
                needsBackup = false;
                name = 'Read Only Wallets';
                isPrivKeyEncrypted = false;
                canSign = false;
                isDeletedSeed = true;
            }
            wallet.needsBackup = needsBackup;
            wallet.keyId = keyId;
            wallet.walletGroupName = name;
            this.walletsGroups[keyId] = {
                order,
                name,
                isPrivKeyEncrypted,
                needsBackup,
                canSign,
                isDeletedSeed
            };
            let date;
            if (groupBackupInfo && groupBackupInfo.timestamp)
                date = new Date(Number(groupBackupInfo.timestamp));
            this.logger.info(`Binding wallet: ${wallet.id} - Backed up: ${!needsBackup} ${date ? date : ''} - Encrypted: ${wallet.isPrivKeyEncrypted} - Token: ${!!wallet
                .credentials.token}`);
            // If this is a token wallet, no need to initialize the rest
            if (wallet.credentials.token) {
                return Promise.resolve(true);
            }
            wallet.removeAllListeners();
            wallet.on('report', n => {
                this.logger.info('BWC Report:' + n);
            });
            // Desktop: uses this event 'notification'
            // Mobile: uses 'bwsEvent'
            //
            // Disabled on mobile to avoid duplicate notifications
            if (!this.platformProvider.isCordova) {
                wallet.on('notification', n => {
                    if (this.platformProvider.isElectron) {
                        this.showDesktopNotifications(n, wallet);
                    }
                    if ((n.data.network && n.data.network != wallet.network) ||
                        (n.data.coin && n.data.coin != wallet.coin))
                        return;
                    // TODO many NewBlocks notifications...if many blocks
                    if (n.type == 'NewBlock' && n.data.network == 'testnet') {
                        this.throttledBwsEvent(n, wallet);
                    }
                    else {
                        this.newBwsEvent(n, wallet);
                    }
                });
            }
            wallet.on('walletCompleted', () => {
                this.logger.debug('Wallet completed');
                this.updateCredentials(JSON.parse(wallet.toString()));
                this.setOrderedWalletsByGroup();
                this.events.publish('Local/WalletUpdate', { walletId: wallet.id });
            });
            wallet.initialize({
                notificationIncludeOwn: true
            }, err => {
                if (err) {
                    this.logger.error('Could not init notifications err:', err);
                    return;
                }
                wallet.setNotificationsInterval(this.UPDATE_PERIOD);
                wallet.openWallet(() => { });
            });
            this.events.subscribe('Local/ConfigUpdate', opts => {
                this.logger.debug('Local/ConfigUpdate handler @profile', opts);
                if (opts.walletId && opts.walletId == wallet.id) {
                    this.logger.debug('Updating wallet from config ' + wallet.id);
                    this.updateWalletFromConfig(wallet);
                }
                else if (opts.walletId && opts.walletId.includes(wallet.id)) {
                    const tokenWallet = this.getWallet(opts.walletId);
                    this.logger.debug('Updating token wallet from config ' + opts.walletId);
                    this.updateWalletFromConfig(tokenWallet);
                }
            });
            return Promise.resolve(true);
        });
    }
    checkAccountCreation(wallet, keyId) {
        /* Allow account creation only for wallets:
        wallet n=1 : BIP44 - P2PKH - BTC o BCH only if it is 145'
        wallet n>1 : BIP48 - P2SH - BTC o BCH only if it is 145'
        wallet n=1 : BIP44 - P2SH - ETH only if it is 60'
        key : !use44forMultisig - !use0forBCH - compliantDerivation - !BIP45
         */
        const key = this.keyProvider.getKey(keyId);
        if (!wallet) {
            return false;
        }
        else if (!key) {
            return false;
        }
        else if (key.use44forMultisig ||
            key.use0forBCH ||
            key.BIP45 ||
            key.compliantDerivation === false) {
            return false;
        }
        else {
            const derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(wallet.credentials.rootPath);
            const coinCode = this.derivationPathHelperProvider.parsePath(wallet.credentials.rootPath).coinCode;
            const chain = this.currencyProvider.getChain(wallet.coin).toLowerCase();
            if ((wallet.n == 1 && wallet.credentials.addressType == 'P2PKH') ||
                (wallet.credentials.addressType == 'P2WPKH' &&
                    derivationStrategy == 'BIP44' &&
                    (chain == 'btc' || (chain == 'bch' && coinCode == "145'") || (chain == 'edu' && coinCode == "199'") || (chain == 'tik' && coinCode == "299'")))) {
                return true;
            }
            if ((wallet.n > 1 && wallet.credentials.addressType == 'P2SH') ||
                (wallet.credentials.addressType == 'P2WSH' &&
                    derivationStrategy == 'BIP48' &&
                    (chain == 'btc' || (chain == 'bch' && coinCode == "145'") || (chain == 'edu' && coinCode == "199'") || (chain == 'tik' && coinCode == "299'")))) {
                return true;
            }
            if (wallet.n == 1 &&
                wallet.credentials.addressType == 'P2PKH' &&
                derivationStrategy == 'BIP44' &&
                chain == 'eth' &&
                coinCode == "60'") {
                return true;
            }
            if (wallet.n == 1 &&
                wallet.credentials.addressType == 'P2PKH' &&
                derivationStrategy == 'BIP44' &&
                chain == 'xrp' &&
                coinCode == "144'") {
                return true;
            }
            return false;
        }
    }
    checkIfSegwit(addressType) {
        if (!addressType)
            return false;
        else if (addressType == 'P2WPKH' || addressType == 'P2WSH') {
            return true;
        }
        else
            return false;
    }
    setFastRefresh(wallet) {
        this.logger.debug(`Wallet ${wallet.id} set to fast refresh`);
        wallet.setNotificationsInterval(this.UPDATE_PERIOD_FAST);
    }
    setSlowRefresh(wallet) {
        this.logger.debug(`Wallet ${wallet.id} back to slow refresh`);
        wallet.setNotificationsInterval(this.UPDATE_PERIOD);
    }
    showDesktopNotifications(n, wallet) {
        if (!this.configProvider.get().desktopNotifications.enabled)
            return;
        const creatorId = n && n.data && n.data.creatorId;
        const amount = n && n.data && n.data.amount;
        const walletName = wallet.name;
        let title;
        let body;
        let translatedMsg;
        switch (n.type) {
            case 'NewCopayer':
                if (wallet.copayerId != creatorId) {
                    title = this.translate.instant('New copayer');
                    translatedMsg = this.translate.instant('A new copayer just joined your wallet {{walletName}}.');
                    body = this.replaceParametersProvider.replace(translatedMsg, {
                        walletName
                    });
                }
                break;
            case 'WalletComplete':
                title = this.translate.instant('Wallet complete');
                translatedMsg = this.translate.instant('Your wallet {{walletName}} is complete.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
            case 'NewTxProposal':
                if (wallet && wallet.m > 1 && wallet.copayerId != creatorId) {
                    title = this.translate.instant('New payment proposal');
                    translatedMsg = this.translate.instant('A new payment proposal has been created in your wallet {{walletName}}.');
                    body = this.replaceParametersProvider.replace(translatedMsg, {
                        walletName
                    });
                }
                break;
            case 'NewIncomingTx':
                title = this.translate.instant('New payment received');
                const amountStr = this.txFormatProvider.formatAmountStr(wallet.coin, amount);
                translatedMsg = this.translate.instant('A payment of {{amountStr}} has been received into your wallet {{walletName}}.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    amountStr,
                    walletName
                });
                break;
            case 'TxProposalFinallyRejected':
                title = this.translate.instant('Payment proposal rejected');
                translatedMsg = this.translate.instant('A payment proposal in your wallet {{walletName}} has been rejected.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
            case 'TxConfirmation':
                title = this.translate.instant('Transaction confirmed');
                translatedMsg = this.translate.instant('The transaction from {{walletName}} that you were waiting for has been confirmed.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
        }
        if (!body)
            return;
        const OS = this.platformProvider.getOS();
        if (OS && OS.OSName === 'MacOS')
            this.showOsNotifications(title, body);
        else
            this.showInAppNotification(title, body);
    }
    showInAppNotification(title, body) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const infoSheet = this.actionSheetProvider.createInfoSheet('in-app-notification', {
                title,
                body
            });
            yield infoSheet.present();
            yield Rx["Observable"].timer(7000).toPromise();
            infoSheet.dismiss();
        });
    }
    showOsNotifications(title, body) {
        const { ipcRenderer } = window.require('electron');
        ipcRenderer.send('new-notification', {
            title,
            body
        });
    }
    newBwsEvent(n, wallet) {
        let id = wallet.id;
        if (n.data && n.data.tokenAddress) {
            id = wallet.id + '-' + n.data.tokenAddress.toLowerCase();
            this.logger.debug(`event for token wallet: ${id}`);
        }
        this.events.publish('bwsEvent', id, n.type, n);
    }
    updateCredentials(credentials) {
        this.profile.updateWallet(credentials);
        this.storeProfileIfDirty();
    }
    runValidation(wallet, delay, retryDelay) {
        delay = delay ? delay : 500;
        retryDelay = retryDelay ? retryDelay : 50;
        if (this.validationLock) {
            return setTimeout(() => {
                return this.runValidation(wallet, delay, retryDelay);
            }, retryDelay);
        }
        this.validationLock = true;
        // IOS devices are already checked
        const skipDeviceValidation = this.platformProvider.isIOS ||
            this.profile.isDeviceChecked(this.platformProvider.ua);
        const walletId = wallet.credentials.walletId;
        this.logger.debug(`ValidatingWallet: ${walletId} skip Device: ${skipDeviceValidation}`);
        setTimeout(() => {
            wallet.validateKeyDerivation({
                skipDeviceValidation
            }, (_, isOK) => {
                this.validationLock = false;
                this.logger.debug(`ValidatingWallet End: ${walletId} isOK: ${isOK}`);
                if (isOK) {
                    this.profile.setChecked(this.platformProvider.ua, walletId);
                }
                else {
                    this.logger.warn(`Key Derivation failed for wallet: ${walletId}`);
                    this.persistenceProvider.clearLastAddress(walletId);
                }
                this.storeProfileIfDirty();
            });
        }, delay);
    }
    storeProfileLegacy(oldProfile) {
        this.persistenceProvider
            .storeProfileLegacy(oldProfile)
            .then(() => {
            this.logger.debug('Saved legacy Profile');
        })
            .catch(err => {
            this.logger.error('Could not save legacy Profile', err);
        });
    }
    storeProfileIfDirty() {
        if (!this.profile.dirty) {
            return Promise.resolve();
        }
        return this.persistenceProvider
            .storeProfile(this.profile)
            .then(() => {
            this.logger.debug('Saved modified Profile (Dirty)');
            return Promise.resolve();
        })
            .catch(err => {
            this.logger.error('Could not save Profile (Dirty)', err);
            return Promise.reject(err);
        });
    }
    askToEncryptKey(key) {
        if (!key)
            return Promise.resolve();
        // if the key is already encrypted, keep it that way for new wallets
        if (key.isPrivKeyEncrypted())
            return Promise.resolve();
        // do not request encryption if wallets were already created without it
        const wallets = this.getWalletsFromGroup({ keyId: key.id });
        if (!key.isPrivKeyEncrypted() && wallets && wallets.length)
            return Promise.resolve();
        return this.showEncryptPasswordInfoModal().then((password) => {
            if (!password) {
                return Promise.resolve();
            }
            else {
                try {
                    this.keyProvider.encryptPrivateKey(key, password);
                }
                catch (error) {
                    return Promise.reject(error);
                }
                return Promise.resolve();
            }
        });
    }
    showEncryptPasswordInfoModal() {
        const encryptPasswordModal = this.actionSheetProvider.createEncryptPasswordComponent();
        encryptPasswordModal.present({ maxHeight: '100%', minHeight: '100%' });
        return new Promise(resolve => {
            encryptPasswordModal.onDidDismiss(password => resolve(password));
        });
    }
    addAndBindWalletClients(data, opts = { bwsurl: null, keyId: null }) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (opts.keyId) {
                // re-import attempt
                if (this.checkIfCorrectWalletToReImport(opts.keyId, data.key)) {
                    const wallets = this.getWalletsFromGroup({
                        keyId: opts.keyId,
                        showHidden: true
                    });
                    yield this.deleteWalletGroup(opts.keyId, wallets);
                    yield this.keyProvider.removeKey(opts.keyId);
                }
                else {
                    return Promise.reject(this.translate.instant('The recovery phrase you entered do not match the wallet you are trying to re-import'));
                }
            }
            this.onGoingProcessProvider.pause();
            // Encrypt wallet
            return this.askToEncryptKey(data.key).then(() => {
                this.onGoingProcessProvider.resume();
                return this.keyProvider.addKey(data.key).then(() => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                    const boundWalletClients = [];
                    for (const walletClient of data.walletClients) {
                        const boundClient = yield this.addAndBindWalletClient(walletClient, {
                            bwsurl: opts.bwsurl,
                            store: false
                        });
                        boundWalletClients.push(boundClient);
                    }
                    this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
                    return this.storeProfileIfDirty()
                        .then(() => {
                        return this.checkIfAlreadyExist(boundWalletClients).then(() => {
                            return Promise.resolve(lodash["compact"](boundWalletClients));
                        });
                    })
                        .catch(err => {
                        return Promise.reject('failed to bind wallets:' + err);
                    });
                }));
            });
        });
    }
    checkIfAlreadyExist(walletClients) {
        return new Promise(resolve => {
            const countInArray = lodash["filter"](walletClients, item => item == undefined)
                .length;
            if (countInArray > 0) {
                const msg1 = this.replaceParametersProvider.replace(this.translate.instant('The wallet is already in the app'), { nameCase: this.appProvider.info.nameCase });
                const msg2 = this.replaceParametersProvider.replace(this.translate.instant('{{countInArray}} of your wallets already exist in {{nameCase}}'), {
                    countInArray,
                    nameCase: this.appProvider.info.nameCase
                });
                const msg = countInArray == 1 ? msg1 : msg2;
                const title = this.translate.instant('Error');
                this.errorsProvider.showDefaultError(msg, title, () => {
                    return resolve();
                });
            }
            else {
                return resolve();
            }
        });
    }
    // Adds and bind a new client to the profile
    addAndBindWalletClient(wallet, opts = {}) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (!wallet || !wallet.credentials) {
                return Promise.reject(this.translate.instant('Could not access wallet'));
            }
            const { bwsurl, store = true } = opts;
            const walletId = wallet.credentials.walletId;
            if (!this.profile.addWallet(JSON.parse(wallet.toString()))) {
                return Promise.resolve();
            }
            const skipKeyValidation = this.shouldSkipValidation(walletId);
            if (!skipKeyValidation) {
                this.logger.debug('Trying to runValidation: ' + walletId);
                yield this.runValidation(wallet);
            }
            this.saveBwsUrl(walletId, bwsurl);
            return this.bindWalletClient(wallet).then(() => {
                if (!store) {
                    this.logger.debug('No storing new walletClient');
                    return Promise.resolve(wallet);
                }
                else {
                    this.logger.debug('Storing new walletClient');
                    this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
                    return this.storeProfileIfDirty().then(() => {
                        return Promise.resolve(wallet);
                    });
                }
            });
        });
    }
    saveBwsUrl(walletId, bwsurl = null) {
        const defaults = this.configProvider.getDefaults();
        const bwsFor = {};
        bwsFor[walletId] = bwsurl || defaults.bws.url;
        // Dont save the default
        if (bwsFor[walletId] == defaults.bws.url) {
            return;
        }
        this.configProvider.set({ bwsFor });
    }
    shouldSkipValidation(walletId) {
        return (true ||
            this.profile.isChecked(this.platformProvider.ua, walletId) ||
            this.platformProvider.isIOS); // disabled for now
    }
    setMetaData(wallet, addressBook) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(wallet.credentials.network)
                .then(localAddressBook => {
                try {
                    localAddressBook = JSON.parse(localAddressBook);
                }
                catch (ex) {
                    this.logger.info('Address Book: JSON.parse not neccesary.', localAddressBook);
                }
                const mergeAddressBook = lodash["merge"](addressBook, localAddressBook);
                this.persistenceProvider
                    .setAddressBook(wallet.credentials.network, JSON.stringify(mergeAddressBook))
                    .then(() => {
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    checkIfCorrectWalletToReImport(keyId, key) {
        this.logger.info("Checking if it's the correct wallet to re import");
        const keyToReImport = this.keyProvider.getKey(keyId);
        return this.keyProvider.isMatch(keyToReImport, key);
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        this.logger.info('Importing Wallet xPrivKey');
        opts.xPrivKey = xPrivKey;
        return this.serverAssistedImport(opts).then(data => {
            // If the key already exists, bind the new wallets to it.
            const key = this.keyProvider.getMatchedKey(data.key);
            // skip if re-importing to clear encrypt
            if (key && !opts.keyId) {
                data.key = this.keyProvider.getKey(key.id);
                opts.keyId = key.id;
                data.walletClients.forEach(walletClient => {
                    walletClient.credentials.keyId = walletClient.keyId = key.id;
                });
            }
            return this.addAndBindWalletClients(data, {
                bwsurl: opts.bwsurl,
                keyId: opts.keyId
            });
        });
    }
    importMnemonic(words, opts) {
        this.logger.info('Importing Wallets Mnemonic');
        words = this.normalizeMnemonic(words);
        opts.words = words;
        return this.serverAssistedImport(opts).then(data => {
            // If the key already exists, bind the new wallets to it.
            const key = this.keyProvider.getMatchedKey(data.key);
            // skip if re-importing to clear encrypt
            if (key && !opts.keyId) {
                data.key = this.keyProvider.getKey(key.id);
                opts.keyId = key.id;
                data.walletClients.forEach(walletClient => {
                    walletClient.credentials.keyId = walletClient.keyId = key.id;
                });
            }
            return this.addAndBindWalletClients(data, {
                bwsurl: opts.bwsurl,
                keyId: opts.keyId
            });
        });
    }
    importFile(str, opts) {
        return this._importFile(str, opts).then((data) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (opts.keyId) {
                // re-import attempt
                if (this.checkIfCorrectWalletToReImport(opts.keyId, data.key)) {
                    const wallets = this.getWalletsFromGroup({
                        keyId: opts.keyId,
                        showHidden: true
                    });
                    yield this.deleteWalletGroup(opts.keyId, wallets);
                    yield this.keyProvider.removeKey(opts.keyId);
                }
                else {
                    return Promise.reject(this.translate.instant('The recovery phrase you entered do not match the wallet you are trying to re-import'));
                }
            }
            this.onGoingProcessProvider.pause();
            return this.askToEncryptKey(data.key).then(() => {
                this.onGoingProcessProvider.resume();
                return this.keyProvider.addKey(data.key).then(() => {
                    return this.addAndBindWalletClient(data.walletClient, {
                        bwsurl: opts.bwsurl
                    }).then(walletClient => {
                        return this.checkIfAlreadyExist([].concat(walletClient)).then(() => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        }));
    }
    _importFile(str, opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            opts['bp_partner'] = this.appProvider.info.name;
            opts['bp_partner_version'] = this.appProvider.info.version;
            this.logger.info('Importing Wallet:', opts);
            const client = this.bwcProvider.getClient(null, opts);
            let credentials;
            let key;
            let addressBook;
            const Key = this.bwcProvider.getKey();
            const data = JSON.parse(str);
            if (data.credentials) {
                try {
                    credentials = data.credentials;
                    // check if the key exists to just add the wallet
                    if (data.key) {
                        key = this.keyProvider.getMatchedKey(data.key);
                        // skip if re-importing to clear encrypt
                        if (key && !opts.keyId) {
                            data.key = this.keyProvider.getKey(key.id);
                            opts.keyId = null;
                            data.credentials.keyId = key.id;
                        }
                        else {
                            key = new Key({
                                seedType: 'object',
                                seedData: data.key
                            });
                        }
                    }
                    addressBook = data.addressBook;
                }
                catch (err) {
                    this.logger.error(err);
                    return reject(this.translate.instant('Could not import. Check input file.'));
                }
            }
            else {
                // old format ? root = credentials.
                try {
                    // needs to migrate?
                    if (data.xPrivKey && data.xPrivKeyEncrypted) {
                        this.logger.warn('Found both encrypted and decrypted key. Deleting the encrypted version');
                        delete data.xPrivKeyEncrypted;
                        delete data.mnemonicEncrypted;
                    }
                    let migrated = this.bwcProvider.upgradeCredentialsV1(data);
                    credentials = migrated.credentials;
                    key = migrated.key;
                    addressBook = data.addressBook ? data.addressBook : {};
                }
                catch (error) {
                    this.logger.error(error);
                    return reject(this.translate.instant('Could not import. Check input file.'));
                }
            }
            if (!credentials.n) {
                return reject('Backup format not recognized. If you are using a Copay Beta backup and version is older than 0.10, please see: https://github.com/tkcoin/copay/issues/4730#issuecomment-244522614');
            }
            client.fromString(JSON.stringify(credentials));
            if (key) {
                this.logger.info(`Wallet ${credentials.walletId} key's extracted`);
            }
            else {
                this.logger.info(`READ-ONLY Wallet ${credentials.walletId} migrated`);
            }
            this.setMetaData(client, addressBook).catch(err => {
                this.logger.warn('Could not set meta data: ', err);
            });
            return resolve({ key, walletClient: client });
        });
    }
    // opts.words opts.xPrivKey
    serverAssistedImport(opts) {
        return new Promise((resolve, reject) => {
            this.bwcProvider.Client.serverAssistedImport(opts, {
                baseUrl: opts.bwsurl // clientOpts
            }, (err, key, walletClients) => {
                if (err) {
                    return reject(err);
                }
                if (walletClients.length === 0) {
                    return reject('WALLET_DOES_NOT_EXIST');
                }
                else {
                    return resolve({ key, walletClients });
                }
            });
        });
    }
    normalizeMnemonic(words) {
        if (!words || !words.indexOf)
            return words;
        // \u3000: A space of non-variable width: used in Chinese, Japanese, Korean
        const isJA = words.indexOf('\u3000') > -1;
        const wordList = words
            .trim()
            .toLowerCase()
            .split(/[\u3000\s]+/);
        return wordList.join(isJA ? '\u3000' : ' ');
    }
    createProfile() {
        this.logger.info('Creating profile');
        this.profile = Profile.create();
        this.persistenceProvider.storeNewProfile(this.profile);
    }
    bindWallets(profile) {
        const profileLength = profile.credentials.length;
        if (!profileLength) {
            return Promise.resolve();
        }
        const promises = [];
        return this.upgradeMultipleCredentials(profile).then(() => {
            lodash["each"](profile.credentials, credentials => {
                promises.push(this.bindWallet(credentials));
            });
            return Promise.all(promises).then(() => {
                this.logger.info(`Bound ${profileLength} wallets`);
                this.setOrderedWalletsByGroup(); // Update Ordered Wallet List When App Start
                return Promise.resolve();
            });
        });
    }
    bindProfile(profile) {
        return this.bindWallets(profile).then(() => {
            return this.isDisclaimerAccepted();
        });
    }
    upgradeMultipleCredentials(profile) {
        const oldProfile = lodash["clone"](profile);
        const migrated = this.bwcProvider.upgradeMultipleCredentialsV1(profile.credentials);
        const newKeys = migrated.keys;
        const newCrededentials = migrated.credentials;
        if (newKeys.length > 0) {
            this.logger.info(`Storing ${newKeys.length} migrated Keys`);
            this.storeProfileLegacy(oldProfile);
            return this.keyProvider.addKeys(newKeys).then(() => {
                profile.credentials = newCrededentials;
                profile.dirty = true;
                return this.storeProfileIfDirty();
            });
        }
        else {
            if (newCrededentials.length > 0) {
                // Only RO wallets.
                this.storeProfileLegacy(oldProfile);
                profile.credentials = newCrededentials;
                profile.dirty = true;
                return this.storeProfileIfDirty();
            }
            return Promise.resolve();
        }
    }
    isDisclaimerAccepted() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const disclaimerAccepted = this.profile && this.profile.disclaimerAccepted;
            if (disclaimerAccepted)
                return Promise.resolve();
            // OLD flag
            let disclaimerFlag;
            try {
                disclaimerFlag = yield this.persistenceProvider.getCopayDisclaimerFlag();
            }
            catch (error) { }
            if (disclaimerFlag) {
                this.profile.disclaimerAccepted = true;
                return Promise.resolve();
            }
            else {
                const onboardingState = this.profile.credentials.length
                    ? 'NONAGREEDDISCLAIMER'
                    : 'UNFINISHEDONBOARDING';
                return Promise.resolve(onboardingState);
            }
        });
    }
    getBWSURL(walletId) {
        const config = this.configProvider.get();
        const defaults = this.configProvider.getDefaults();
        return (config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url;
    }
    bindWallet(credentials) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            if (!credentials.walletId || !credentials.m) {
                return Promise.reject(new Error('bindWallet should receive credentials JSON'));
            }
            // Create the client
            const walletClient = this.bwcProvider.getClient(JSON.stringify(credentials), {
                bwsurl: this.getBWSURL(credentials.walletId),
                bp_partner: this.appProvider.info.name,
                bp_partner_version: this.appProvider.info.version
            });
            const skipKeyValidation = this.shouldSkipValidation(credentials.walletId);
            if (!skipKeyValidation) {
                this.logger.debug('Trying to runValidation: ' + credentials.walletId);
                yield this.runValidation(walletClient, 500);
            }
            return this.bindWalletClient(walletClient);
        });
    }
    getProfileLegacy() {
        return this.persistenceProvider.getProfileLegacy().catch(err => {
            this.logger.info('Error getting old Profile', err);
        });
    }
    removeProfileLegacy() {
        return this.persistenceProvider.removeProfileLegacy().catch(err => {
            this.logger.info('Error getting old Profile', err);
        });
    }
    loadAndBindProfile() {
        return this.persistenceProvider.getProfile().then(profile => {
            if (!profile) {
                return Promise.resolve();
            }
            this.profile = Profile.fromObj(profile);
            // Deprecated: storageService.tryToMigrate
            this.logger.info('Profile loaded');
            return this.bindProfile(this.profile);
        });
    }
    importWithDerivationPath(opts) {
        return new Promise((resolve, reject) => {
            this.logger.info('Importing Wallet with derivation path');
            this._importWithDerivationPath(opts)
                .then(data => {
                // Check if wallet exists
                data.walletClient.openWallet((err) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                    if (err) {
                        if (err.message.indexOf('not found') > 0) {
                            err = 'WALLET_DOES_NOT_EXIST';
                        }
                        return reject(err);
                    }
                    if (opts.keyId) {
                        // re-import attempt
                        if (this.checkIfCorrectWalletToReImport(opts.keyId, data.key)) {
                            const wallets = this.getWalletsFromGroup({
                                keyId: opts.keyId,
                                showHidden: true
                            });
                            yield this.deleteWalletGroup(opts.keyId, wallets);
                            yield this.keyProvider.removeKey(opts.keyId);
                        }
                        else {
                            return reject(this.translate.instant('The recovery phrase you entered do not match the wallet you are trying to re-import'));
                        }
                    }
                    this.keyProvider.addKey(data.key).then(() => {
                        this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        })
                            .then(walletClient => {
                            return this.checkIfAlreadyExist([].concat(walletClient)).then(() => {
                                return resolve(walletClient);
                            });
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                }));
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    _importWithDerivationPath(opts) {
        const showOpts = lodash["clone"](opts);
        if (showOpts.extendedPrivateKey)
            showOpts.extendedPrivateKey = '[hidden]';
        if (showOpts.mnemonic)
            showOpts.mnemonic = '[hidden]';
        this.logger.debug('Importing Wallet:', JSON.stringify(showOpts));
        return this.seedWallet(opts);
    }
    seedWallet(opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            opts['bp_partner'] = this.appProvider.info.name;
            opts['bp_partner_version'] = this.appProvider.info.version;
            // Token wallet?
            if (opts.pairedWallet) {
                return resolve();
            }
            const walletClient = this.bwcProvider.getClient(null, opts);
            const network = opts.networkName || 'livenet';
            const Key = this.bwcProvider.getKey();
            let key;
            if (opts.mnemonic) {
                try {
                    opts.mnemonic = this.normalizeMnemonic(opts.mnemonic);
                    // new BWC 8.23 api
                    key = new Key({
                        seedType: 'mnemonic',
                        seedData: opts.mnemonic,
                        useLegacyCoinType: opts.useLegacyCoinType,
                        useLegacyPurpose: opts.useLegacyPurpose,
                        passphrase: opts.passphrase
                    });
                    walletClient.fromString(key.createCredentials(opts.password, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        addressType: opts.addressType,
                        n: opts.n || 1
                    }));
                }
                catch (ex) {
                    this.logger.info('Invalid wallet recovery phrase: ' + ex);
                    return reject(this.translate.instant('Could not create: Invalid wallet recovery phrase'));
                }
            }
            else if (opts.extendedPrivateKey) {
                try {
                    key = new Key({
                        seedType: 'extendedPrivateKey',
                        seedData: opts.extendedPrivateKey,
                        useLegacyCoinType: opts.useLegacyCoinType,
                        useLegacyPurpose: opts.useLegacyPurpose
                    });
                    walletClient.fromString(key.createCredentials(null, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        n: opts.n || 1
                    }));
                    if (opts.duplicateKeyId) {
                        walletClient.credentials.keyId = opts.duplicateKeyId;
                        this.logger.debug(`Reusing ${opts.duplicateKeyId} on the duplicated wallet`);
                    }
                }
                catch (ex) {
                    this.logger.warn('Could not get seed from Extended Private Key: ', ex);
                    return reject(this.translate.instant('Could not create using the specified extended private key'));
                }
            }
            else {
                const lang = this.languageProvider.getCurrent();
                try {
                    if (!opts.key && !opts.keyId) {
                        key = new Key({
                            seedType: 'new',
                            language: lang
                        });
                    }
                    else if (opts.key) {
                        key = opts.key;
                    }
                    else if (opts.keyId) {
                        key = this.keyProvider.getKey(opts.keyId);
                    }
                    walletClient.fromString(key.createCredentials(opts.password, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        n: opts.n || 1
                    }));
                }
                catch (e) {
                    this.logger.info('Error creating recovery phrase: ' + e.message);
                    if (e.message.indexOf('language') > 0) {
                        this.logger.info('Using default language for recovery phrase');
                        key = new Key({ seedType: 'new' });
                        walletClient.fromString(key.createCredentials(opts.password, {
                            coin: opts.coin,
                            network,
                            account: opts.account || 0,
                            n: opts.n || 1
                        }));
                    }
                    else {
                        return reject(e);
                    }
                }
            }
            return resolve({ walletClient, key });
        });
    }
    // Creates a wallet on BWC/BWS and store it
    _createWallet(opts) {
        return new Promise((resolve, reject) => {
            const showOpts = lodash["clone"](opts);
            if (showOpts.extendedPrivateKey)
                showOpts.extendedPrivateKey = '[hidden]';
            if (showOpts.mnemonic)
                showOpts.mnemonic = '[hidden]';
            if (showOpts.password)
                showOpts.password = '[hidden]';
            if (showOpts.key)
                showOpts.key = '[hidden]';
            this.logger.debug('Creating Wallet:', JSON.stringify(showOpts));
            if (opts.useNativeSegwit && !(opts.coin === 'btc' || opts.coin === 'edu' || opts.coin === 'tik')) {
                const err = 'Wrong useNativeSegwit opt for non btc/edu/tik wallet';
                return reject(err);
            }
            setTimeout(() => {
                this.seedWallet(opts)
                    .then(data => {
                    const coin = `[${opts.coin.toUpperCase()}]`;
                    const name = opts.name ||
                        `${this.translate.instant('Personal Wallet')} ${coin}`;
                    const myName = opts.myName || this.translate.instant('me');
                    data.walletClient.createWallet(name, myName, opts.m, opts.n, {
                        network: opts.networkName,
                        singleAddress: opts.singleAddress,
                        walletPrivKey: opts.walletPrivKey,
                        coin: opts.coin,
                        useNativeSegwit: opts.useNativeSegwit
                    }, err => {
                        const copayerRegistered = err instanceof this.errors.COPAYER_REGISTERED;
                        const isSetSeed = opts.mnemonic || opts.extendedPrivateKey;
                        if (err && (!copayerRegistered || isSetSeed)) {
                            const msg = this.bwcErrorProvider.msg(err, this.translate.instant('Error creating wallet'));
                            return reject(msg);
                        }
                        else if (copayerRegistered) {
                            // try with account + 1
                            opts.account = opts.account ? opts.account + 1 : 1;
                            if (opts.account === 20)
                                return reject(this.translate.instant('You reach the limit of twenty wallets from the same coin and network'));
                            return resolve(this._createWallet(opts));
                        }
                        else {
                            // Set default preferences.
                            const config = this.configProvider.get();
                            const prefs = {
                                email: config.emailNotifications.email,
                                language: this.languageProvider.getCurrent(),
                                unit: 'btc' // deprecated
                            };
                            data.walletClient.preferences = lodash["assign"](prefs, data.walletClient.preferences);
                            return resolve(data);
                        }
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }, 50);
        });
    }
    // joins and stores a wallet
    _joinWallet(opts) {
        return new Promise((resolve, reject) => {
            this.logger.info('Joining Wallet...');
            let walletData;
            try {
                walletData = this.bwcProvider.parseSecret(opts.secret);
                // check if exist
                if (lodash["find"](this.profile.credentials, {
                    walletId: walletData.walletId
                })) {
                    return reject(this.translate.instant('Cannot join the same wallet more that once'));
                }
            }
            catch (ex) {
                this.logger.error(ex);
                return reject(this.translate.instant('Bad wallet invitation'));
            }
            opts.networkName = walletData.network;
            /* TODO: opts.n is just used to determinate if the wallet is multisig (m/48'/xx) or single sig (m/44')
              we should change the name to 'isMultisig'
             */
            opts.n = 2;
            this.logger.debug('Joining Wallet:', opts);
            this.seedWallet(opts)
                .then(data => {
                data.walletClient.joinWallet(opts.secret, opts.myName || 'me', {
                    coin: opts.coin
                }, err => {
                    if (err) {
                        if (err instanceof this.errors.COPAYER_REGISTERED) {
                            // try with account + 1
                            opts.account = opts.account ? opts.account + 1 : 1;
                            if (opts.account === 20)
                                return reject(this.translate.instant('You reach the limit of twenty wallets from the same coin and network'));
                            return resolve(this._joinWallet(opts));
                        }
                        else {
                            const msg = this.bwcErrorProvider.msg(err, this.translate.instant('Could not join wallet'));
                            return reject(msg);
                        }
                    }
                    return resolve(data);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getWallet(walletId) {
        return this.wallet[walletId];
    }
    getWalletGroup(keyId) {
        keyId = keyId ? keyId : 'read-only';
        return this.walletsGroups[keyId];
    }
    _deleteWalletClient(wallet) {
        this.logger.info('Deleting Wallet:', wallet.credentials.walletName);
        const walletId = wallet.credentials.walletId;
        wallet.removeAllListeners();
        this.profile.deleteWallet(walletId);
        delete this.wallet[walletId];
        this.persistenceProvider.removeAllWalletData(walletId);
    }
    deleteWalletClient(wallet) {
        this.logger.info('Deleting Wallet:', wallet.credentials.walletName);
        const walletId = wallet.credentials.walletId;
        wallet.removeAllListeners();
        this.profile.deleteWallet(walletId);
        delete this.wallet[walletId];
        this.persistenceProvider.removeAllWalletData(walletId);
        this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
        this.events.publish('Local/FetchWallets');
        return this.storeProfileIfDirty();
    }
    deleteWalletGroup(keyId, wallets) {
        wallets.forEach(wallet => {
            this._deleteWalletClient(wallet);
        });
        this.persistenceProvider.removeAllWalletGroupData(keyId);
        this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
        this.events.publish('Local/FetchWallets');
        return this.storeProfileIfDirty();
    }
    getDefaultWalletOpts(coin) {
        const defaults = this.configProvider.getDefaults();
        const opts = {
            name: this.currencyProvider.getCoinName(coin),
            m: 1,
            n: 1,
            myName: null,
            networkName: 'livenet',
            bwsurl: defaults.bws.url,
            singleAddress: this.currencyProvider.isSingleAddress(coin) || false,
            coin
        };
        if (coin === 'btc' || coin === 'edu' || coin === 'tik')
            opts.useNativeSegwit = true;
        return opts;
    }
    _createTokenWallet(ethWallet, tokenObj) {
        this.logger.debug(`Creating token wallet ${tokenObj.name} for ${ethWallet.id}:`);
        const tokenCredentials = ethWallet.credentials.getTokenCredentials(tokenObj);
        const walletClient = this.bwcProvider.getClient(null, {
            baseUrl: this.getBWSURL(ethWallet.credentials.walletId),
            bp_partner: ethWallet.bp_partner,
            bp_partner_version: ethWallet.bp_partner_version
        });
        walletClient.fromObj(tokenCredentials);
        // Add the token info to the ethWallet.
        ethWallet.preferences = ethWallet.preferences || {};
        ethWallet.preferences.tokenAddresses =
            ethWallet.preferences.tokenAddresses || [];
        ethWallet.preferences.tokenAddresses.push(tokenObj.address);
        return walletClient;
    }
    _createMultisigEthWallet(ethWallet, multisigEthInfo) {
        this.logger.debug(`Creating ETH multisig wallet ${multisigEthInfo.walletName} for ${ethWallet.id}:`);
        const multisigEthCredentials = ethWallet.credentials.getMultisigEthCredentials(multisigEthInfo);
        const walletClient = this.bwcProvider.getClient(null, {
            bwsurl: this.getBWSURL(ethWallet.credentials.walletId),
            bp_partner: ethWallet.bp_partner,
            bp_partner_version: ethWallet.bp_partner_version
        });
        walletClient.fromObj(multisigEthCredentials);
        // Add the token info to the ethWallet.
        ethWallet.preferences = ethWallet.preferences || {};
        ethWallet.preferences.multisigEthInfo =
            ethWallet.preferences.multisigEthInfo || [];
        ethWallet.preferences.multisigEthInfo.push(multisigEthInfo);
        return walletClient;
    }
    createTokenWallet(ethWallet, token) {
        if (lodash["isString"](token)) {
            let tokens = this.currencyProvider.getAvailableTokens();
            token = tokens.find(x => x.symbol == token);
        }
        const tokenWalletClient = this._createTokenWallet(ethWallet, token);
        return this.addAndBindWalletClient(tokenWalletClient);
    }
    createMultisigEthWallet(ethWallet, multisigEthInfo) {
        const multisigEthWalletClient = this._createMultisigEthWallet(ethWallet, multisigEthInfo);
        return this.addAndBindWalletClient(multisigEthWalletClient);
    }
    createMultipleWallets(coins, tokens = []) {
        return new Promise((resolve, reject) => {
            if (tokens && tokens.length && coins.indexOf('eth') < 0) {
                reject('No ethereum wallets for tokens');
            }
            const defaultOpts = this.getDefaultWalletOpts(coins[0]);
            this._createWallet(defaultOpts).then(data => {
                const key = data.key;
                const firstWalletData = data;
                const create2ndWallets = [];
                coins.slice(1).forEach(coin => {
                    const newOpts = {};
                    Object.assign(newOpts, this.getDefaultWalletOpts(coin));
                    newOpts['key'] = key; // Add Key
                    create2ndWallets.push(this._createWallet(newOpts));
                });
                Promise.all(create2ndWallets)
                    .then(walletsData => {
                    walletsData.unshift(firstWalletData);
                    let walletClients = lodash["map"](walletsData, 'walletClient');
                    // Handle tokens
                    if (!lodash["isEmpty"](tokens)) {
                        const ethWalletClient = walletClients.find(wallet => wallet.credentials.coin === 'eth');
                        if (!ethWalletClient)
                            reject('no eth wallet for tokens');
                        let tokenObjs = this.currencyProvider.getAvailableTokens();
                        const tokenClients = tokens.map(token => {
                            token = tokenObjs.find(x => x.symbol == token);
                            return this._createTokenWallet(ethWalletClient, token);
                        });
                        walletClients = walletClients.concat(tokenClients);
                    }
                    this.addAndBindWalletClients({
                        key: firstWalletData.key,
                        walletClients
                    })
                        .then(() => {
                        return resolve(walletClients);
                    })
                        .catch(e => {
                        reject(e);
                    });
                })
                    .catch(e => {
                    reject(e);
                });
            });
        });
    }
    createWallet(opts) {
        return this.keyProvider.handleEncryptedWallet(opts.keyId).then(password => {
            opts.password = password;
            return this._createWallet(opts).then(data => {
                // Encrypt wallet
                this.onGoingProcessProvider.pause();
                return this.askToEncryptKey(data.key).then(() => {
                    this.onGoingProcessProvider.resume();
                    return this.keyProvider.addKey(data.key).then(() => {
                        return this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        }).then(walletClient => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        });
    }
    joinWallet(opts) {
        return this.keyProvider.handleEncryptedWallet(opts.keyId).then(password => {
            opts.password = password;
            return this._joinWallet(opts).then(data => {
                // Encrypt wallet
                this.onGoingProcessProvider.pause();
                return this.askToEncryptKey(data.key).then(() => {
                    this.onGoingProcessProvider.resume();
                    return this.keyProvider.addKey(data.key).then(() => {
                        return this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        }).then(walletClient => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        });
    }
    setDisclaimerAccepted() {
        this.profile.acceptDisclaimer();
        return this.storeProfileIfDirty();
    }
    setLastKnownBalance() {
        // Add cached balance async
        lodash["each"](lodash["values"](this.wallet), x => {
            this.persistenceProvider.getLastKnownBalance(x.id).then(datum => {
                // this.logger.debug("Last known balance for ",x.id,datum);
                datum = datum || {};
                let limit = Math.floor(Date.now() / 1000) - 2 * 60;
                let { balance = null, updatedOn = null } = datum;
                x.lastKnownBalance = balance;
                x.lastKnownBalanceUpdatedOn = updatedOn < limit ? updatedOn : null;
            });
        });
    }
    getWallets(opts) {
        const wallets = [];
        opts = opts || {};
        // workaround to get wallets and wallets groups in the correct order
        this.getOrderedWalletsGroups().forEach(walletsGroup => {
            opts.keyId = walletsGroup.key;
            wallets.push(this.getWalletsFromGroup(opts));
        });
        return lodash["flatten"](wallets);
    }
    setOrderedWalletsByGroup() {
        this.logger.debug('Set Ordered Wallets By Group');
        const wallets = [];
        this.getOrderedWalletsGroups().forEach(walletsGroup => {
            wallets.push(this.getWalletsFromGroup({ keyId: walletsGroup.key }));
        });
        this.orderedWalletsByGroup = lodash["values"](lodash["groupBy"](lodash["flatten"](wallets), 'keyId'));
    }
    getOrderedWalletsGroups() {
        let walletsGroups = [];
        for (let key in this.walletsGroups) {
            walletsGroups.push({
                key,
                value: this.walletsGroups[key]
            });
        }
        const orderedWalletsGroups = lodash["sortBy"](walletsGroups, walletGroup => {
            return +walletGroup.value.order;
        });
        return orderedWalletsGroups;
    }
    getWalletsFromGroup(opts) {
        if (opts && !lodash["isObject"](opts))
            throw new Error('bad argument');
        opts = opts || {};
        let ret = lodash["values"](this.wallet);
        if (opts.keyId === 'read-only') {
            ret = lodash["filter"](ret, x => {
                return !x.credentials.keyId;
            });
        }
        else if (opts.keyId) {
            ret = lodash["filter"](ret, x => {
                return x.credentials.keyId == opts.keyId;
            });
        }
        if (opts.coin) {
            let coins = [].concat(opts.coin);
            ret = lodash["filter"](ret, x => {
                return lodash["findIndex"](coins, coin => x.credentials.coin == coin) >= 0;
            });
        }
        if (opts.backedUp) {
            ret = lodash["filter"](ret, x => {
                return !x.needsBackup;
            });
        }
        if (opts.network) {
            ret = lodash["filter"](ret, x => {
                return x.credentials.network == opts.network;
            });
        }
        if (opts.n) {
            ret = lodash["filter"](ret, w => {
                return w.credentials.n == opts.n;
            });
        }
        if (opts.m) {
            ret = lodash["filter"](ret, w => {
                return w.credentials.m == opts.m;
            });
        }
        if (opts.onlyComplete) {
            ret = lodash["filter"](ret, w => {
                return w.isComplete();
            });
        }
        if (opts.minAmount) {
            ret = lodash["filter"](ret, w => {
                // IF no cached Status => return true!
                if (lodash["isEmpty"](w.cachedStatus))
                    return true;
                return w.cachedStatus.availableBalanceSat > opts.minAmount;
            });
        }
        if (opts.hasFunds) {
            ret = lodash["filter"](ret, w => {
                // IF no cached Status => return true!
                if (lodash["isEmpty"](w.cachedStatus))
                    return true;
                return w.cachedStatus.availableBalanceSat > 0;
            });
        }
        if (!opts.showHidden) {
            // remove hidden wallets
            ret = lodash["filter"](ret, w => {
                return !w.hidden;
            });
        }
        if (opts.canAddNewAccount) {
            ret = lodash["filter"](ret, w => {
                return w.canAddNewAccount;
            });
        }
        if (opts.pairFor) {
            // grab walletIds from current wallet for this token (if any)
            const tokenWalletIds = ret
                .filter(wallet => wallet.coin === opts.pairFor.symbol.toLowerCase())
                .map(wallet => wallet.id);
            ret = ret.filter(wallet => !tokenWalletIds.includes(`${wallet.id}-${opts.pairFor.address}`) &&
                wallet.coin === 'eth');
        }
        if (opts.minFiatCurrency) {
            ret = ret.filter(wallet => {
                if (lodash["isEmpty"](wallet.cachedStatus))
                    return true;
                const availableBalanceFiat = this.rateProvider.toFiat(wallet.cachedStatus.availableBalanceSat, opts.minFiatCurrency.currency, wallet.coin);
                return availableBalanceFiat >= Number(opts.minFiatCurrency.amount);
            });
        }
        if (opts.minPendingAmount) {
            ret = ret.filter(wallet => {
                if (lodash["isEmpty"](wallet.cachedStatus))
                    return true;
                const availablePendingFiat = this.rateProvider.toFiat(wallet.cachedStatus.pendingAmount, opts.minPendingAmount.currency, wallet.coin);
                return availablePendingFiat >= Number(opts.minPendingAmount.amount);
            });
        }
        if (opts.lastAddress) {
            ret = lodash["filter"](ret, w => {
                return w.lastAddress == opts.lastAddress;
            });
        }
        return lodash["sortBy"](ret, 'order');
    }
    toggleHideBalanceFlag(walletId) {
        this.wallet[walletId].balanceHidden = !this.wallet[walletId].balanceHidden;
        this.persistenceProvider.setHideBalanceFlag(walletId, this.wallet[walletId].balanceHidden);
    }
    toggleHideWalletFlag(walletId) {
        this.wallet[walletId].hidden = !this.wallet[walletId].hidden;
        this.persistenceProvider.setHideWalletFlag(walletId, this.wallet[walletId].hidden);
        this.setOrderedWalletsByGroup(); // Update Ordered Wallet List
    }
    getTxps(opts) {
        return new Promise((resolve, reject) => {
            const MAX = 100;
            opts = opts ? opts : {};
            const w = this.getWallets(opts);
            if (lodash["isEmpty"](w)) {
                return reject('No wallets available');
            }
            let txps = [];
            lodash["each"](w, x => {
                if (x.pendingTxps)
                    txps = txps.concat(x.pendingTxps);
            });
            const n = txps.length;
            txps = lodash["sortBy"](txps, 'createdOn').reverse();
            txps = lodash["compact"](lodash["flatten"](txps)).slice(0, opts.limit || MAX);
            return resolve({ txps, n });
        });
    }
    isKeyInUse(keyId) {
        const keyIdIndex = this.profile.credentials.findIndex(c => {
            if (keyId === 'read-only') {
                return !c.keyId;
            }
            else {
                return c.keyId == keyId;
            }
        });
        return keyIdIndex >= 0;
    }
    // Checks to see if a wallet exists with minimim fiat amount's worth in it (to pay invoice, for example)
    hasWalletWithFunds(fiatAmount, fiatCurrency) {
        const minFiatCurrency = {
            amount: fiatAmount,
            currency: fiatCurrency
        };
        const wallets = this.getWalletsFromGroup({ minFiatCurrency });
        return Boolean(wallets.length);
    }
};
profile_ProfileProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [currency["b" /* CurrencyProvider */],
        logger_logger["a" /* Logger */],
        persistence["b" /* PersistenceProvider */],
        config_config["a" /* ConfigProvider */],
        replace_parameters["a" /* ReplaceParametersProvider */],
        bwc["a" /* BwcProvider */],
        bwc_error["a" /* BwcErrorProvider */],
        platform["a" /* PlatformProvider */],
        app["a" /* AppProvider */],
        language["a" /* LanguageProvider */],
        ionic_angular["f" /* Events */],
        on_going_process["a" /* OnGoingProcessProvider */],
        core_es5["f" /* TranslateService */],
        tx_format["a" /* TxFormatProvider */],
        action_sheet["a" /* ActionSheetProvider */],
        key_key["a" /* KeyProvider */],
        derivation_path_helper["a" /* DerivationPathHelperProvider */],
        errors["a" /* ErrorsProvider */],
        rate["b" /* RateProvider */]])
], profile_ProfileProvider);

//# sourceMappingURL=profile.js.map

/***/ }),

/***/ 170:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/providers/currency/currency.ts + 2 modules
var currency = __webpack_require__(24);

// CONCATENATED MODULE: ./src/environments/prod.ts

/**
 * Environment: prod
 */
const env = {
    name: 'production',
    enableAnimations: true,
    ratesAPI: new currency["b" /* CurrencyProvider */]().getRatesApi(),
    activateScanner: true
};
/* harmony default export */ var prod = (env);
//# sourceMappingURL=prod.js.map
// CONCATENATED MODULE: ./src/environments/index.ts

/**
 * Environment: dev
 */
const environments_env = Object.assign({}, prod, { 
    // override for development:
    name: 'development' });
/* harmony default export */ var environments = __webpack_exports__["a"] = (environments_env);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var buffer = __webpack_require__(2);

var Signature = __webpack_require__(103);
var Script = __webpack_require__(104);
var Output = __webpack_require__(161);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var BN = __webpack_require__(73);
var Hash = __webpack_require__(74);
var ECDSA = __webpack_require__(351);
var $ = __webpack_require__(35);
var _ = __webpack_require__(1);

var SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';
var BITS_64_ON = 'ffffffffffffffff';

/**
 * Returns a buffer of length 32 bytes with the hash that needs to be signed
 * for OP_CHECKSIG.
 *
 * @name Signing.sighash
 * @param {Transaction} transaction the transaction to sign
 * @param {number} sighashType the type of the hash
 * @param {number} inputNumber the input index for the signature
 * @param {Script} subscript the script that will be signed
 */
var sighash = function sighash(transaction, sighashType, inputNumber, subscript) {
  var Transaction = __webpack_require__(461);
  var Input = __webpack_require__(462);

  var i;
  // Copy transaction
  var txcopy = Transaction.shallowCopy(transaction);

  // Copy script
  subscript = new Script(subscript);
  subscript.removeCodeseparators();

  for (i = 0; i < txcopy.inputs.length; i++) {
    // Blank signatures for other inputs
    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
  }

  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);

  if ((sighashType & 31) === Signature.SIGHASH_NONE ||
    (sighashType & 31) === Signature.SIGHASH_SINGLE) {

    // clear all sequenceNumbers
    for (i = 0; i < txcopy.inputs.length; i++) {
      if (i !== inputNumber) {
        txcopy.inputs[i].sequenceNumber = 0;
      }
    }
  }

  if ((sighashType & 31) === Signature.SIGHASH_NONE) {
    txcopy.outputs = [];

  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
    // The SIGHASH_SINGLE bug.
    // https://bitcointalk.org/index.php?topic=260595.0
    if (inputNumber >= txcopy.outputs.length) {
      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');
    }

    txcopy.outputs.length = inputNumber + 1;

    for (i = 0; i < inputNumber; i++) {
      txcopy.outputs[i] = new Output({
        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),
        script: Script.empty()
      });
    }
  }

  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
    txcopy.inputs = [txcopy.inputs[inputNumber]];
  }

  var buf = new BufferWriter()
    .write(txcopy.toBuffer())
    .writeInt32LE(sighashType)
    .toBuffer();
  var ret = Hash.sha256sha256(buf);
  ret = new BufferReader(ret).readReverse();
  return ret;
};

/**
 * Create a signature
 *
 * @name Signing.sign
 * @param {Transaction} transaction
 * @param {PrivateKey} privateKey
 * @param {number} sighash
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Signature}
 */
function sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';

  var sig;
  if(signingMethod === 'ecdsa') {
    var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);
    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({
    nhashtype: sighashType
  });
  return sig;
 }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * Verify a signature
 *
 * @name Signing.verify
 * @param {Transaction} transaction
 * @param {Signature} signature
 * @param {PublicKey} publicKey
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {boolean}
 */
function verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {
  $.checkArgument(!_.isUndefined(transaction), "Transaction Undefined");
  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), "Signature Undefined");

  signingMethod = signingMethod || 'ecdsa';
  if (signingMethod === 'ecdsa') {
    var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);
    return ECDSA.verify(hashbuf, signature, publicKey, 'little');
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * @namespace Signing
 */
module.exports = {
  sighash: sighash,
  sign: sign,
  verify: verify
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1811:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var buffer = __webpack_require__(2);

var Signature = __webpack_require__(105);
var Script = __webpack_require__(106);
var Output = __webpack_require__(163);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var BN = __webpack_require__(75);
var Hash = __webpack_require__(76);
var ECDSA = __webpack_require__(358);
var $ = __webpack_require__(36);
var _ = __webpack_require__(1);

var SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';
var BITS_64_ON = 'ffffffffffffffff';

/**
 * Returns a buffer of length 32 bytes with the hash that needs to be signed
 * for OP_CHECKSIG.
 *
 * @name Signing.sighash
 * @param {Transaction} transaction the transaction to sign
 * @param {number} sighashType the type of the hash
 * @param {number} inputNumber the input index for the signature
 * @param {Script} subscript the script that will be signed
 */
var sighash = function sighash(transaction, sighashType, inputNumber, subscript) {
  var Transaction = __webpack_require__(465);
  var Input = __webpack_require__(466);

  var i;
  // Copy transaction
  var txcopy = Transaction.shallowCopy(transaction);

  // Copy script
  subscript = new Script(subscript);
  subscript.removeCodeseparators();

  for (i = 0; i < txcopy.inputs.length; i++) {
    // Blank signatures for other inputs
    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
  }

  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);

  if ((sighashType & 31) === Signature.SIGHASH_NONE ||
    (sighashType & 31) === Signature.SIGHASH_SINGLE) {

    // clear all sequenceNumbers
    for (i = 0; i < txcopy.inputs.length; i++) {
      if (i !== inputNumber) {
        txcopy.inputs[i].sequenceNumber = 0;
      }
    }
  }

  if ((sighashType & 31) === Signature.SIGHASH_NONE) {
    txcopy.outputs = [];

  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
    // The SIGHASH_SINGLE bug.
    // https://bitcointalk.org/index.php?topic=260595.0
    if (inputNumber >= txcopy.outputs.length) {
      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');
    }

    txcopy.outputs.length = inputNumber + 1;

    for (i = 0; i < inputNumber; i++) {
      txcopy.outputs[i] = new Output({
        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),
        script: Script.empty()
      });
    }
  }

  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
    txcopy.inputs = [txcopy.inputs[inputNumber]];
  }

  var buf = new BufferWriter()
    .write(txcopy.toBuffer())
    .writeInt32LE(sighashType)
    .toBuffer();
  var ret = Hash.sha256sha256(buf);
  ret = new BufferReader(ret).readReverse();
  return ret;
};

/**
 * Create a signature
 *
 * @name Signing.sign
 * @param {Transaction} transaction
 * @param {PrivateKey} privateKey
 * @param {number} sighash
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {Signature}
 */
function sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';

  var sig;
  if(signingMethod === 'ecdsa') {
    var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);
    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({
    nhashtype: sighashType
  });
  return sig;
 }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * Verify a signature
 *
 * @name Signing.verify
 * @param {Transaction} transaction
 * @param {Signature} signature
 * @param {PublicKey} publicKey
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {boolean}
 */
function verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {
  $.checkArgument(!_.isUndefined(transaction), "Transaction Undefined");
  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), "Signature Undefined");

  signingMethod = signingMethod || 'ecdsa';
  if (signingMethod === 'ecdsa') {
    var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);
    return ECDSA.verify(hashbuf, signature, publicKey, 'little');
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * @namespace Signing
 */
module.exports = {
  sighash: sighash,
  sign: sign,
  verify: verify
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 185:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PayproProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__ = __webpack_require__(32);



// providers



let PayproProvider = class PayproProvider {
    constructor(logger, bwcProvider, currencyProvider, onGoingProcessProvider) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.currencyProvider = currencyProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger.debug('PayproProvider initialized');
    }
    getPayProOptions(paymentUrl, disableLoader, attempt = 1) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('PayPro Options: try... ' + attempt);
            const bwc = this.bwcProvider.getPayProV2();
            const options = {
                paymentUrl
            };
            if (!disableLoader) {
                this.onGoingProcessProvider.set('fetchingPayProOptions');
            }
            const payOpts = yield bwc.getPaymentOptions(options).catch((err) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                this.logger.error(`PayPro Options ERR: ${err.message}`);
                if (attempt <= 3) {
                    yield new Promise(resolve => setTimeout(resolve, 5000 * attempt));
                    return this.getPayProOptions(paymentUrl, disableLoader, ++attempt);
                }
                else {
                    if (!disableLoader)
                        this.onGoingProcessProvider.clear();
                    throw err;
                }
            }));
            if (!disableLoader)
                this.onGoingProcessProvider.clear();
            this.logger.info('PayPro Options: SUCCESS');
            return payOpts;
        });
    }
    getPayProDetails(params) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let { paymentUrl, coin, payload, disableLoader, attempt = 1 } = params;
            this.logger.info('PayPro Details: try... ' + attempt);
            const bwc = this.bwcProvider.getPayProV2();
            const chain = this.currencyProvider.getChain(coin).toUpperCase();
            const options = {
                paymentUrl,
                chain,
                currency: coin.toUpperCase(),
                payload
            };
            if (!disableLoader) {
                this.onGoingProcessProvider.set('fetchingPayPro');
            }
            const payDetails = yield bwc
                .selectPaymentOption(options)
                .catch((err) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                this.logger.error(`PayPro Details ERR: ${err.message}`);
                if (attempt <= 3) {
                    yield new Promise(resolve => setTimeout(resolve, 5000 * attempt));
                    return this.getPayProDetails({
                        paymentUrl,
                        coin,
                        payload,
                        disableLoader,
                        attempt: ++attempt
                    });
                }
                else {
                    if (!disableLoader)
                        this.onGoingProcessProvider.clear();
                    throw err;
                }
            }));
            if (!disableLoader)
                this.onGoingProcessProvider.clear();
            this.logger.info('PayPro Details: SUCCESS');
            return payDetails;
        });
    }
};
PayproProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], PayproProvider);

//# sourceMappingURL=paypro.js.map

/***/ }),

/***/ 186:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectCurrencyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__onboarding_recovery_key_recovery_key__ = __webpack_require__(390);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__settings_key_settings_key_onboarding_key_onboarding__ = __webpack_require__(389);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__create_wallet_create_wallet__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__join_wallet_join_wallet__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__ = __webpack_require__(24);





// pages





// providers


let SelectCurrencyPage = class SelectCurrencyPage {
    constructor(actionSheetProvider, currencyProvider, navCtrl, logger, navParam, profileProvider, onGoingProcessProvider, walletProvider, pushNotificationsProvider, bwcErrorProvider, translate, modalCtrl, persistenceProvider, errorsProvider, events) {
        this.actionSheetProvider = actionSheetProvider;
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.navParam = navParam;
        this.profileProvider = profileProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.persistenceProvider = persistenceProvider;
        this.errorsProvider = errorsProvider;
        this.events = events;
        this.coinsSelected = {};
        this.tokensSelected = {};
        this.tokenDisabled = {};
        this.isJoin = this.navParam.data.isJoin;
        this.isShared = this.navParam.data.isShared;
        this.keyId = this.navParam.data.keyId;
        this.availableChains =
            this.isShared || this.isJoin
                ? this.currencyProvider.getMultiSigCoins()
                : this.currencyProvider.getAvailableChains();
        this.availableTokens = this.currencyProvider.getAvailableTokens();
        // TODO FIX 
        for (const chain of this.availableChains) {
            if (chain === 'edu' || chain === 'tik') {
                this.coinsSelected[chain] = true;
            }
        }
        this.shouldShowKeyOnboarding();
        this.setTokens();
    }
    ionViewWillEnter() {
        const previousView = this.navCtrl.getPrevious();
        if (this.isOnboardingFlow && previousView.name === 'LockMethodPage') {
            this.navCtrl.removeView(previousView);
        }
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SelectCurrencyPage');
        this.isOnboardingFlow = this.navParam.data.isOnboardingFlow;
        this.isZeroState = this.navParam.data.isZeroState;
        this.title = this.isZeroState
            ? this.translate.instant('Select Currencies')
            : this.translate.instant('Select Currency');
    }
    shouldShowKeyOnboarding() {
        this.persistenceProvider.getKeyOnboardingFlag().then(value => {
            if (!value) {
                this.showKeyOnboarding = true;
                const wallets = this.profileProvider.getWallets();
                const walletsGroups = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](__WEBPACK_IMPORTED_MODULE_4_lodash__["groupBy"](wallets, 'keyId'));
                walletsGroups.forEach((walletsGroup) => {
                    if (walletsGroup[0].canAddNewAccount)
                        this.showKeyOnboarding = false;
                });
            }
            else {
                this.showKeyOnboarding = false;
            }
        });
    }
    showKeyOnboardingSlides(coins) {
        this.logger.debug('Showing key onboarding');
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_7__settings_key_settings_key_onboarding_key_onboarding__["a" /* KeyOnboardingPage */], null, {
            showBackdrop: false,
            enableBackdropDismiss: false
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.persistenceProvider.setKeyOnboardingFlag();
            this._createWallets(coins);
        });
    }
    goToCreateWallet(coin) {
        if (this.isJoin) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__join_wallet_join_wallet__["a" /* JoinWalletPage */], {
                keyId: this.keyId,
                url: this.navParam.data.url,
                coin
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__create_wallet_create_wallet__["a" /* CreateWalletPage */], {
                isShared: this.isShared,
                coin,
                keyId: this.keyId,
                showKeyOnboarding: this.showKeyOnboarding
            });
        }
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
    _createWallets(coins) {
        const selectedCoins = __WEBPACK_IMPORTED_MODULE_4_lodash__["keys"](__WEBPACK_IMPORTED_MODULE_4_lodash__["pickBy"](this.coinsSelected));
        coins = coins || selectedCoins;
        const selectedTokens = __WEBPACK_IMPORTED_MODULE_4_lodash__["keys"](__WEBPACK_IMPORTED_MODULE_4_lodash__["pickBy"](this.tokensSelected));
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createMultipleWallets(coins, selectedTokens)
            .then((wallets) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.walletProvider.updateRemotePreferences(wallets);
            this.pushNotificationsProvider.updateSubscription(wallets);
            yield new Promise(resolve => setTimeout(resolve, 1000));
            this.profileProvider.setNewWalletGroupOrder(wallets[0].credentials.keyId);
            this.endProcess(wallets[0].credentials.keyId);
        }))
            .catch(e => {
            this.showError(e);
        });
    }
    createWallets(coins) {
        if (this.isZeroState && !this.isOnboardingFlow) {
            this.showInfoSheet(coins);
            return;
        }
        this._createWallets(coins);
    }
    showError(err) {
        this.onGoingProcessProvider.clear();
        this.logger.error('Create: could not create wallet', err);
        const title = this.translate.instant('Error');
        err = this.bwcErrorProvider.msg(err);
        this.errorsProvider.showDefaultError(err, title);
    }
    endProcess(keyId) {
        this.onGoingProcessProvider.clear();
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__onboarding_recovery_key_recovery_key__["a" /* RecoveryKeyPage */], {
            keyId,
            isOnboardingFlow: this.isOnboardingFlow,
            hideBackButton: true
        });
    }
    createAndBindTokenWallet(pairedWallet, token) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](pairedWallet)) {
            this.profileProvider.createTokenWallet(pairedWallet, token).then(() => {
                // store preferences for the paired eth wallet
                this.walletProvider.updateRemotePreferences(pairedWallet);
                if (pairedWallet.needsBackup) {
                    this.endProcess();
                }
                else {
                    this.navCtrl.popToRoot().then(() => {
                        this.events.publish('Local/FetchWallets');
                    });
                }
            });
        }
    }
    showPairedWalletSelector(token) {
        const eligibleWallets = this.keyId
            ? this.profileProvider.getWalletsFromGroup({
                keyId: this.keyId,
                network: 'livenet',
                pairFor: token
            })
            : [];
        const walletSelector = this.actionSheetProvider.createInfoSheet('linkEthWallet', {
            wallets: eligibleWallets,
            token
        });
        walletSelector.present();
        walletSelector.onDidDismiss(pairedWallet => {
            return this.createAndBindTokenWallet(pairedWallet, token);
        });
    }
    setTokens(coin) {
        if (coin === 'eth' || !coin) {
            for (const token of this.availableTokens) {
                if (this.isZeroState) {
                    this.tokensSelected[token.symbol] = false;
                }
                else {
                    let canCreateit = __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.profileProvider.getWalletsFromGroup({
                        keyId: this.keyId,
                        network: 'livenet',
                        pairFor: token
                    }));
                    this.tokenDisabled[token.symbol] = canCreateit;
                }
            }
        }
    }
    showInfoSheet(coins) {
        const infoSheet = this.actionSheetProvider.createInfoSheet('new-key');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.showKeyOnboardingSlides(coins);
                return;
            }
            this._createWallets(coins);
        });
    }
};
SelectCurrencyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-select-currency',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/select-currency/select-currency.html"*/'<wide-header-page title="{{title}}">\n  <div page-content *ngIf="!isZeroState || (isZeroState && isJoin)">\n    <span class="list-subtitle" translate>Featured Currencies</span>\n    <ion-list class="settings-list bp-list">\n      <div *ngFor="let coin of availableChains">\n        <button class="list-button" *ngIf="coin === \'edu\' || coin === \'tik\'" [disabled]="coin === \'eth\' && (isShared || isJoin) && !keyId" ion-item (click)="goToCreateWallet(coin)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{coin}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</div>\n          <div class="item-note" *ngIf="coin === \'eth\' && (isShared || isJoin) && !keyId" translate>Only available for already created keys</div>\n          <div class="item-note" *ngIf="coin === \'eth\' && (isShared || isJoin) && !keyId" translate>Try "create new wallet" option instead</div>\n        </button>\n      </div>\n      <!-- TODO FIX HIDE TOKENS\n      <div *ngIf="!isShared && !isJoin">\n        <span class="list-subtitle">Tokens</span>\n        <button *ngFor="let token of availableTokens" class="list-button" [disabled]="tokenDisabled[token.symbol]" ion-item (click)="showPairedWalletSelector(token)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{token.symbol.toLowerCase()}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ token.name }} ({{ token.symbol }})</div>\n        </button>\n      </div>\n      -->\n    </ion-list>\n  </div>\n  <div page-content *ngIf="isZeroState && !isJoin">\n    <span class="list-subtitle" translate>Featured Currencies</span>\n    <div class="flex-content">\n      <ion-list class="settings-list bp-list">\n        <div *ngFor="let coin of availableChains">\n          <!--   HIDE EVERY COIN BUT EDU/TIK -->\n          <ion-item *ngIf="coin === \'edu\' || coin === \'tik\'" class="list-button">\n            <ion-icon item-start>\n              <img src="assets/img/currencies/{{coin}}.svg" />\n            </ion-icon>\n            <ion-label class="item-title">{{ getCoinName(coin) }} ({{coin.toUpperCase() }})</ion-label>\n            <ion-toggle *ngIf="coin === \'edu\' || coin === \'tik\'" [(ngModel)]="coinsSelected[coin]" (ngModelChange)="setTokens(coin)"></ion-toggle>\n          </ion-item>\n        </div>\n        <!-- TODO FIX HIDE TOKENS\n        <div *ngIf="!isShared && !isJoin">\n          <span class="list-subtitle">Tokens</span>\n          <ion-item *ngFor="let token of availableTokens" class="list-button">\n            <ion-icon item-start>\n              <img src="assets/img/currencies/{{token.symbol.toLowerCase()}}.svg" />\n            </ion-icon>\n            <ion-label class="item-title">\n              {{ token.name }} ({{ token.symbol }})\n            </ion-label>\n            <ion-toggle [(ngModel)]="tokensSelected[token.symbol]" [disabled]="!coinsSelected.eth"></ion-toggle>\n          </ion-item>\n        </div>\n        -->\n      </ion-list>\n    </div>\n  </div>\n  <div footer-content *ngIf="isZeroState && !isJoin">\n    <button ion-button class="button-standard" [ngClass]="{\'no-margin-bottom\': !isOnboardingFlow}" [disabled]="!coinsSelected.btc && !coinsSelected.edu && !coinsSelected.tik && !coinsSelected.bch && !coinsSelected.eth && !coinsSelected.xrp && !coinsSelected.doge" (click)="createWallets()">\n      {{isOnboardingFlow ? \'Continue\' : \'Create\' | translate}}\n    </button>\n    <button ion-button clear class="button-standard" (click)="goToImportWallet()" *ngIf="!isOnboardingFlow">\n      {{ \'Import existing wallet\' | translate }}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/select-currency/select-currency.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["_5" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["_0" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["_31" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["_6" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["k" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["C" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], SelectCurrencyPage);

//# sourceMappingURL=select-currency.js.map

/***/ }),

/***/ 1951:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const elliptic = __webpack_require__(54);
const ecdsa = new elliptic.ec(elliptic.curves.secp256k1);

const BitAuth = __webpack_require__(942);

BitAuth._generateRandomPair = function() {
  const keys = ecdsa.genKeyPair();
  const privateKey = keys.getPrivate('hex');
  const publicKey = BitAuth.getPublicKeyFromPrivateKey(privateKey);
  return [privateKey, publicKey];
};

BitAuth._getPublicKeyFromPrivateKey = function(privkey) {
  let privKeyString;
  if (Buffer.isBuffer(privkey)) {
    privKeyString = privkey.toString('hex');
  } else {
    privKeyString = privkey;
  }
  const keys = ecdsa.keyFromPrivate(privKeyString, 'hex');

  // compressed public key
  const pubKey = keys.getPublic();
  const xbuf = Buffer.from(pubKey.x.toString('hex', 64), 'hex');
  const ybuf = Buffer.from(pubKey.y.toString('hex', 64), 'hex');
  let pub;

  if (ybuf[ybuf.length - 1] % 2) { //odd
    pub = Buffer.concat([Buffer.from([3]), xbuf]);
  } else { //even
    pub = Buffer.concat([Buffer.from([2]), xbuf]);
  }
  return pub;
};

BitAuth._sign = function(hashBuffer, privkey) {
  const keys = ecdsa.keyFromPrivate(privkey, 'hex');
  const signature = keys.sign(hashBuffer.toString('hex'));
  return signature.toDER('hex');
};

BitAuth._verifySignature = function(hashBuffer, signatureBuffer, pubkey) {
  return ecdsa.verify(hashBuffer.toString('hex'), signatureBuffer, pubkey, 'hex');
};

module.exports = BitAuth;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1952:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const base58 = __webpack_require__(91);
const crypto = __webpack_require__(52);

module.exports = function encrypt(password, str) {
  const aes256 = crypto.createCipher('aes-256-cbc', password);
  const a = aes256.update(str, 'utf8');
  const b = aes256.final();
  return base58.encode(Buffer.concat([a, b]));
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1953:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const base58 = __webpack_require__(91);
const crypto = __webpack_require__(52);

module.exports = function decrypt(password, str) {
  const aes256 = crypto.createDecipher('aes-256-cbc', password);
  const a = aes256.update(Buffer.from(base58.decode(str)));
  const b = aes256.final();
  return Buffer.concat([a, b]).toString('utf8');
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 1954:
/***/ (function(module, exports, __webpack_require__) {

const bitauth = __webpack_require__(943);

module.exports = function(req, res, next) {
  if (req.headers && req.headers['x-identity'] && req.headers['x-signature']) {
    // Check signature is valid
    // First construct data to check signature on
    const fullUrl = req.protocol + '://' + req.get('host') + req.url;
    const data = fullUrl + req.rawBody;

    bitauth.verifySignature(data, req.headers['x-identity'], req.headers['x-signature'], function(err, result) {
      if (err || !result) {
        return res.send(400, {
          error: 'Invalid signature'
        });
      }

      // Get the SIN from the public key
      const sin = bitauth.getSinFromPublicKey(req.headers['x-identity']);
      if (!sin) {
        return res.send(400, {
          error: 'Bad public key from identity'
        });
      }
      req.sin = sin;
      next();
    });
  } else {
    next();
  }
};


/***/ }),

/***/ 1973:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1974:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 199:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ = __webpack_require__(1);

var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);
var networks = [];
var networkMaps = {};

/**
 * A network is merely a map containing values that correspond to version
 * numbers for each bitcoin network. Currently only supporting "livenet"
 * (a.k.a. "mainnet") and "testnet".
 * @constructor
 */
function Network() {}

Network.prototype.toString = function toString() {
  return this.name;
};

/**
 * @function
 * @member Networks#get
 * Retrieves the network associated with a magic number or string.
 * @param {string|number|Network} arg
 * @param {string|Array} keys - if set, only check if the magic number associated with this name matches
 * @return Network
 */
function get(arg, keys) {
  if (~networks.indexOf(arg)) {
    return arg;
  }
  if (keys) {
    if (!_.isArray(keys)) {
      keys = [keys];
    }
    var containsArg = function(key) {
      return networks[index][key] === arg;
    };
    for (var index in networks) {
      if (_.some(keys, containsArg)) {
        return networks[index];
      }
    }
    return undefined;
  }
  if(networkMaps[arg] && networkMaps[arg].length >= 1) {
    return networkMaps[arg][0];
  } else {
    return networkMaps[arg];
  }
}

/**
 * @function
 * @member Networks#add
 * Will add a custom Network
 * @param {Object} data
 * @param {string} data.name - The name of the network
 * @param {string} data.alias - The aliased name of the network
 * @param {Number} data.pubkeyhash - The publickey hash prefix
 * @param {Number} data.privatekey - The privatekey prefix
 * @param {Number} data.scripthash - The scripthash prefix
 * @param {string} data.bech32prefix - The native segwit prefix
 * @param {Number} data.xpubkey - The extended public key magic
 * @param {Number} data.xprivkey - The extended private key magic
 * @param {Number} data.networkMagic - The network magic number
 * @param {Number} data.port - The network port
 * @param {Array}  data.dnsSeeds - An array of dns seeds
 * @return Network
 */
function addNetwork(data) {

  var network = new Network();

  JSUtil.defineImmutable(network, {
    name: data.name,
    alias: data.alias,
    pubkeyhash: data.pubkeyhash,
    privatekey: data.privatekey,
    scripthash: data.scripthash,
    bech32prefix: data.bech32prefix,
    xpubkey: data.xpubkey,
    xprivkey: data.xprivkey
  });

  if (data.networkMagic) {
    JSUtil.defineImmutable(network, {
      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)
    });
  }

  if (data.port) {
    JSUtil.defineImmutable(network, {
      port: data.port
    });
  }

  if (data.dnsSeeds) {
    JSUtil.defineImmutable(network, {
      dnsSeeds: data.dnsSeeds
    });
  }
  _.each(network, function(value) {
    if (!_.isUndefined(value) && !_.isObject(value)) {
      if(!networkMaps[value]) {
        networkMaps[value] = [];
      }
      networkMaps[value].push(network);
    }
  });

  networks.push(network);

  return network;

}

/**
 * @function
 * @member Networks#remove
 * Will remove a custom network
 * @param {Network} network
 */
function removeNetwork(network) {
  for (var i = 0; i < networks.length; i++) {
    if (networks[i] === network) {
      networks.splice(i, 1);
    }
  }
  for (var key in networkMaps) {
    const index = networkMaps[key].indexOf(network);
    if (index >= 0) {
      delete networkMaps[key][index];
    }
  }
}

addNetwork({
  name: 'livenet',
  alias: 'mainnet',
  pubkeyhash: 0x00,
  privatekey: 0x80,
  scripthash: 0x05,
  bech32prefix: 'ec',
  xpubkey: 0x0488b21e,
  xprivkey: 0x0488ade4,
  networkMagic: 0xfabcbdd1,
  port: 65500,
  dnsSeeds: [
    'tkcoin.org'
  ]
});

/**
 * @instance
 * @member Networks#livenet
 */
var livenet = get('livenet');

addNetwork({
  name: 'testnet',
  alias: 'test',
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  bech32prefix: 'tb',
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: 0x0b110907,
  port: 18333,
  dnsSeeds: [
    'testnet-seed.bitcoin.petertodd.org',
    'testnet-seed.bluematt.me',
    'testnet-seed.alexykot.me',
    'testnet-seed.bitcoin.schildbach.de'
  ]
});

/**
 * @instance
 * @member Networks#testnet
 */
var testnet = get('testnet');

addNetwork({
  name: 'regtest',
  alias: 'dev',
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  bech32prefix: 'bcrt',
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: 0xfabfb5da,
  port: 18444,
  dnsSeeds: []
});

/**
 * @instance
 * @member Networks#testnet
 */
var regtest = get('regtest');

/**
 * @function
 * @deprecated
 * @member Networks#enableRegtest
 * Will enable regtest features for testnet
 */
function enableRegtest() {
  testnet.regtestEnabled = true;
}

/**
 * @function
 * @deprecated
 * @member Networks#disableRegtest
 * Will disable regtest features for testnet
 */
function disableRegtest() {
  testnet.regtestEnabled = false;
}

/**
 * @namespace Networks
 */
module.exports = {
  add: addNetwork,
  remove: removeNetwork,
  defaultNetwork: livenet,
  livenet: livenet,
  mainnet: livenet,
  testnet: testnet,
  regtest: regtest,
  get: get,
  enableRegtest: enableRegtest,
  disableRegtest: disableRegtest
};


/***/ }),

/***/ 20:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@ionic-native/file/index.js
var file = __webpack_require__(189);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// CONCATENATED MODULE: ./src/providers/persistence/storage/istorage.ts

class KeyAlreadyExistsError extends Error {
    constructor() {
        super('Key already exists');
    }
}
let ISTORAGE = new core["InjectionToken"]('storage');
//# sourceMappingURL=istorage.js.map
// CONCATENATED MODULE: ./src/providers/persistence/storage/file-storage.ts






let file_storage_FileStorage = class FileStorage {
    constructor(file, log) {
        this.file = file;
        this.log = log;
    }
    init() {
        return new Promise((resolve, reject) => {
            if (this.fs && this.dir)
                return resolve();
            const onSuccess = (fs) => {
                this.log.debug('File system started: ', fs.name, fs.root.name);
                this.fs = fs;
                return this.getDir().then(dir => {
                    if (!dir.nativeURL)
                        return reject();
                    this.dir = dir;
                    this.log.debug('Got main dir:', dir.nativeURL);
                    return resolve();
                });
            };
            const onFailure = (err) => {
                this.log.error('Could not init file system: ' + err.message);
                return Promise.reject(err);
            };
            window.requestFileSystem(1, 0, onSuccess, onFailure);
        });
    }
    // See https://github.com/apache/cordova-plugin-file/#where-to-store-files
    getDir() {
        if (!this.file) {
            return Promise.reject(new Error('Could not write on device storage'));
        }
        const url = this.file.dataDirectory;
        return this.file.resolveDirectoryUrl(url).catch(err => {
            const msg = 'Could not resolve filesystem ' + url;
            this.log.warn(msg, err);
            throw err || new Error(msg);
        });
    }
    parseResult(v) {
        if (!v)
            return null;
        if (!lodash["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    readFileEntry(fileEntry) {
        return new Promise((resolve, reject) => {
            fileEntry.file(file => {
                const reader = new FileReader();
                reader.onerror = () => {
                    reader.abort();
                    return reject();
                };
                reader.onloadend = () => {
                    return resolve(this.parseResult(reader.result));
                };
                reader.readAsText(file);
            });
        });
    }
    get(k) {
        return new Promise(resolve => {
            this.init()
                .then(() => {
                this.file
                    .getFile(this.dir, k, { create: false })
                    .then(fileEntry => {
                    if (!fileEntry)
                        return resolve();
                    this.readFileEntry(fileEntry)
                        .then(result => {
                        return resolve(result);
                    })
                        .catch(() => {
                        this.log.error('Problem parsing input file.');
                    });
                })
                    .catch(err => {
                    // Not found
                    if (err.code == 1)
                        return resolve();
                    else
                        throw err;
                });
            })
                .catch(err => {
                this.log.error(err);
            });
        });
    }
    set(k, v) {
        return Promise.resolve(this.init().then(() => {
            this.file.getFile(this.dir, k, { create: true }).then(fileEntry => {
                // Create a FileWriter object for our FileEntry (log.txt).
                return new Promise((resolve, reject) => {
                    fileEntry.createWriter(fileWriter => {
                        fileWriter.onwriteend = () => {
                            this.log.debug('Successful file write...');
                            return resolve();
                        };
                        fileWriter.onerror = e => {
                            this.log.error('Failed file write: ' + e.toString());
                            return reject(e.toString());
                        };
                        if (lodash["isObject"](v))
                            v = JSON.stringify(v);
                        if (!lodash["isString"](v))
                            v = v.toString();
                        fileWriter.write(v);
                    });
                });
            });
        }));
    }
    remove(k) {
        return new Promise((resolve, reject) => {
            this.file
                .removeFile(this.dir.nativeURL, k)
                .then(() => {
                this.log.debug(`Storage Key: ${k} removed`);
                resolve();
            })
                .catch(e => {
                reject(e);
            });
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new KeyAlreadyExistsError();
            this.set(k, v);
        });
    }
};
file_storage_FileStorage = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [file["a" /* File */], logger["a" /* Logger */]])
], file_storage_FileStorage);

//# sourceMappingURL=file-storage.js.map
// CONCATENATED MODULE: ./src/providers/persistence/storage/local-storage.ts





let local_storage_LocalStorage = class LocalStorage {
    constructor(logger) {
        this.logger = logger;
        if (!window.localStorage)
            throw new Error('localstorage not available');
        this.ls = window.localStorage;
    }
    processValue(v) {
        if (!v)
            return null;
        if (!lodash["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    get(k) {
        return new Promise(resolve => {
            let v = this.ls.getItem(k);
            return resolve(this.processValue(v));
        });
    }
    set(k, v) {
        return new Promise(resolve => {
            if (lodash["isObject"](v))
                v = JSON.stringify(v);
            if (!lodash["isString"](v))
                v = v.toString();
            this.ls.setItem(k, v);
            resolve();
        });
    }
    remove(k) {
        return new Promise(resolve => {
            this.ls.removeItem(k);
            this.logger.debug(`Storage Key: ${k} removed`);
            resolve();
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new KeyAlreadyExistsError();
            this.set(k, v);
        });
    }
};
local_storage_LocalStorage = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [logger["a" /* Logger */]])
], local_storage_LocalStorage);

//# sourceMappingURL=local-storage.js.map
// CONCATENATED MODULE: ./src/providers/persistence/persistence.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Network; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return persistence_PersistenceProvider; });








// TODO import { RamStorage } from './storage/ram-storage';
var Network;
(function (Network) {
    Network["livenet"] = "livenet";
    Network["testnet"] = "testnet";
})(Network || (Network = {}));
const Keys = {
    ADDRESS_BOOK: network => 'addressbook-' + network,
    AGREE_DISCLAIMER: 'agreeDisclaimer',
    GIFT_CARD_USER_INFO: 'amazonUserInfo',
    APP_IDENTITY: network => 'appIdentity-' + network,
    BACKUP: walletId => 'backup-' + walletId,
    BACKUP_WALLET_GROUP: keyId => 'walletGroupBackup-' + keyId,
    TESTING_ADVERTISEMENTS: 'testingAdvertisements',
    BALANCE_CACHE: cardId => 'balanceCache-' + cardId,
    HISTORY_CACHE: cardId => 'historyCache-' + cardId,
    BITPAY_ACCOUNTS_V2: network => 'tkcoinAccounts-v2-' + network,
    CLEAN_AND_SCAN_ADDRESSES: 'CleanAndScanAddresses',
    COINBASE_REFRESH_TOKEN: network => 'coinbaseRefreshToken-' + network,
    COINBASE_TOKEN: network => 'coinbaseToken-' + network,
    COINBASE_TXS: network => 'coinbaseTxs-' + network,
    COINBASE: env => 'coinbase-' + env,
    CONFIG: 'config',
    FEEDBACK: 'feedback',
    FOCUSED_WALLET_ID: 'focusedWalletId',
    GIFT_CARD_CONFIG_CACHE: (network) => {
        const suffix = network === Network.livenet ? '' : `-${network}`;
        return `giftCardConfigCache${suffix}`;
    },
    ACTIVE_GIFT_CARDS: (network) => {
        return `activeGiftCards-${network}`;
    },
    GIFT_CARDS: (cardName, network) => {
        const legacyGiftCardKey = getLegacyGiftCardKey(cardName, network);
        return legacyGiftCardKey || `giftCards-${cardName}-${network}`;
    },
    HIDE_GIFT_CARD_DISCOUNT_ITEM: 'hideGiftCardDiscountItem',
    HIDE_BALANCE: walletId => 'hideBalance-' + walletId,
    TOTAL_BALANCE: 'totalBalance',
    HIDE_WALLET: walletId => 'hideWallet-' + walletId,
    KEY_ONBOARDING: 'keyOnboarding',
    KEYS: 'keys',
    LAST_ADDRESS: walletId => 'lastAddress-' + walletId,
    LAST_CURRENCY_USED: 'lastCurrencyUsed',
    LAST_COUNTRY_USED: 'buyCryptoLastCountry',
    PHONE: 'phone',
    PHONE_COUNTRY_INFO: 'phoneCountryInfo',
    PROFILE: 'profile',
    PROFILE_OLD: 'profileOld',
    REMOTE_PREF_STORED: 'remotePrefStored',
    TX_CONFIRM_NOTIF: txid => 'txConfirmNotif-' + txid,
    TX_HISTORY: walletId => 'txsHistory-' + walletId,
    ORDER_WALLET: walletId => 'order-' + walletId,
    ORDER_WALLET_GROUP: keyId => 'order-' + keyId,
    SERVER_MESSAGE_DISMISSED: messageId => 'serverMessageDismissed-' + messageId,
    RELEASE_MESSAGE_DISMISSED: 'releaseMessageDismissed',
    ADVERTISEMENT_DISMISSED: name => 'advertisementDismissed-' + name,
    WALLET_GROUP_NAME: keyId => `Key-${keyId}`,
    BITPAY_ID_PAIRING_TOKEN: network => `tkcoinIdToken-${network}`,
    BITPAY_ID_USER_INFO: network => `tkcoinIdUserInfo-${network}`,
    BITPAY_ID_SETTINGS: network => `tkcoinIdSettings-${network}`,
    APP_THEME: 'app-theme',
    USER_LOCATION: 'user-location',
    COUNTRIES: 'countries',
    CARD_FAST_TRACK_ENABLED: 'cardFastTrackEnabled',
    TEMP_MDES_DEBUG_FLAG: 'tempMdesDebugFlag',
    TEMP_MDES_CERT_ONLY_DEBUG_FLAG: 'tempMdesCertOnlyDebugFlag',
    NETWORK: 'network'
};
let persistence_PersistenceProvider = class PersistenceProvider {
    constructor(logger, platform, file) {
        this.logger = logger;
        this.platform = platform;
        this.file = file;
        this.logger.debug('PersistenceProvider initialized');
    }
    load() {
        this.storage = this.platform.isCordova
            ? new file_storage_FileStorage(this.file, this.logger)
            : new local_storage_LocalStorage(this.logger);
    }
    storeProfileLegacy(profileOld) {
        return this.storage.set(Keys.PROFILE_OLD, profileOld);
    }
    getProfileLegacy() {
        return this.storage.get(Keys.PROFILE_OLD);
    }
    removeProfileLegacy() {
        return this.storage.remove(Keys.PROFILE_OLD);
    }
    storeNewProfile(profile) {
        return this.storage.create(Keys.PROFILE, profile);
    }
    storeProfile(profile) {
        return this.storage.set(Keys.PROFILE, profile);
    }
    getProfile() {
        return new Promise(resolve => {
            this.storage.get(Keys.PROFILE).then(profile => {
                resolve(profile);
            });
        });
    }
    setKeys(keys) {
        return this.storage.set(Keys.KEYS, keys);
    }
    getKeys() {
        return this.storage.get(Keys.KEYS);
    }
    setFeedbackInfo(feedbackValues) {
        return this.storage.set(Keys.FEEDBACK, feedbackValues);
    }
    getFeedbackInfo() {
        return this.storage.get(Keys.FEEDBACK);
    }
    setKeyOnboardingFlag() {
        return this.storage.set(Keys.KEY_ONBOARDING, true);
    }
    getKeyOnboardingFlag() {
        return this.storage.get(Keys.KEY_ONBOARDING);
    }
    storeFocusedWalletId(walletId) {
        return this.storage.set(Keys.FOCUSED_WALLET_ID, walletId || '');
    }
    getFocusedWalletId() {
        return this.storage.get(Keys.FOCUSED_WALLET_ID);
    }
    getLastAddress(walletId) {
        return this.storage.get(Keys.LAST_ADDRESS(walletId));
    }
    storeLastAddress(walletId, address) {
        return this.storage.set(Keys.LAST_ADDRESS(walletId), address);
    }
    clearLastAddress(walletId) {
        return this.storage.remove(Keys.LAST_ADDRESS(walletId));
    }
    setBackupFlag(walletId) {
        return this.storage.set(Keys.BACKUP(walletId), Date.now());
    }
    getBackupFlag(walletId) {
        return this.storage.get(Keys.BACKUP(walletId));
    }
    clearBackupFlag(walletId) {
        return this.storage.remove(Keys.BACKUP(walletId));
    }
    getPhone() {
        return this.storage.get(Keys.PHONE);
    }
    setPhone(phone) {
        return this.storage.set(Keys.PHONE, phone);
    }
    getPhoneCountryInfo() {
        return this.storage.get(Keys.PHONE_COUNTRY_INFO);
    }
    setPhoneCountryInfo(phoneCountryInfo) {
        return this.storage.set(Keys.PHONE_COUNTRY_INFO, phoneCountryInfo);
    }
    setBackupGroupFlag(keyId, timestamp) {
        timestamp = timestamp || Date.now();
        return this.storage.set(Keys.BACKUP_WALLET_GROUP(keyId), timestamp);
    }
    getBackupGroupFlag(keyId) {
        return this.storage.get(Keys.BACKUP_WALLET_GROUP(keyId));
    }
    clearBackupGroupFlag(keyId) {
        return this.storage.remove(Keys.BACKUP_WALLET_GROUP(keyId));
    }
    setCleanAndScanAddresses(walletId) {
        return this.storage.set(Keys.CLEAN_AND_SCAN_ADDRESSES, walletId);
    }
    setTestingAdvertisements(isViewingTestAdvertisements) {
        return this.storage.set(Keys.TESTING_ADVERTISEMENTS, isViewingTestAdvertisements);
    }
    getTestingAdvertisments() {
        return this.storage.get(Keys.TESTING_ADVERTISEMENTS);
    }
    removeTestingAdvertisments() {
        return this.storage.remove(Keys.TESTING_ADVERTISEMENTS);
    }
    getCleanAndScanAddresses() {
        return this.storage.get(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    removeCleanAndScanAddresses() {
        return this.storage.remove(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    getConfig() {
        return this.storage.get(Keys.CONFIG);
    }
    storeConfig(config) {
        return this.storage.set(Keys.CONFIG, config);
    }
    clearConfig() {
        return this.storage.remove(Keys.CONFIG);
    }
    setHideBalanceFlag(walletId, val) {
        return this.storage.set(Keys.HIDE_BALANCE(walletId), val);
    }
    getHideBalanceFlag(walletId) {
        return this.storage.get(Keys.HIDE_BALANCE(walletId));
    }
    setTotalBalance(data) {
        return this.storage.set(Keys.TOTAL_BALANCE, data);
    }
    getTotalBalance() {
        return this.storage.get(Keys.TOTAL_BALANCE);
    }
    setHideWalletFlag(walletId, val) {
        return this.storage.set(Keys.HIDE_WALLET(walletId), val);
    }
    getHideWalletFlag(walletId) {
        return this.storage.get(Keys.HIDE_WALLET(walletId));
    }
    setDisclaimerAccepted() {
        return this.storage.set(Keys.AGREE_DISCLAIMER, true);
    }
    // for compatibility
    getCopayDisclaimerFlag() {
        return this.storage.get(Keys.AGREE_DISCLAIMER);
    }
    setRemotePrefsStoredFlag() {
        return this.storage.set(Keys.REMOTE_PREF_STORED, true);
    }
    getRemotePrefsStoredFlag() {
        return this.storage.get(Keys.REMOTE_PREF_STORED);
    }
    setCoinbase(env, data) {
        return this.storage.set(Keys.COINBASE(env), data);
    }
    getCoinbase(env) {
        return this.storage.get(Keys.COINBASE(env));
    }
    removeCoinbase(env) {
        return this.storage.remove(Keys.COINBASE(env));
    }
    setCoinbaseToken(network, token) {
        return this.storage.set(Keys.COINBASE_TOKEN(network), token);
    }
    getCoinbaseToken(network) {
        return this.storage.get(Keys.COINBASE_TOKEN(network));
    }
    removeCoinbaseToken(network) {
        return this.storage.remove(Keys.COINBASE_TOKEN(network));
    }
    setCoinbaseRefreshToken(network, token) {
        return this.storage.set(Keys.COINBASE_REFRESH_TOKEN(network), token);
    }
    getCoinbaseRefreshToken(network) {
        return this.storage.get(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    removeCoinbaseRefreshToken(network) {
        return this.storage.remove(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    setCoinbaseTxs(network, ctx) {
        return this.storage.set(Keys.COINBASE_TXS(network), ctx);
    }
    getCoinbaseTxs(network) {
        return this.storage.get(Keys.COINBASE_TXS(network));
    }
    removeCoinbaseTxs(network) {
        return this.storage.remove(Keys.COINBASE_TXS(network));
    }
    setAddressBook(network, addressbook) {
        return this.storage.set(Keys.ADDRESS_BOOK(network), addressbook);
    }
    getAddressBook(network) {
        return this.storage.get(Keys.ADDRESS_BOOK(network));
    }
    removeAddressbook(network) {
        return this.storage.remove(Keys.ADDRESS_BOOK(network));
    }
    setLastCurrencyUsed(lastCurrencyUsed) {
        return this.storage.set(Keys.LAST_CURRENCY_USED, lastCurrencyUsed);
    }
    getLastCurrencyUsed() {
        return this.storage.get(Keys.LAST_CURRENCY_USED);
    }
    setLastCountryUsed(lastCountryUsed) {
        return this.storage.set(Keys.LAST_COUNTRY_USED, lastCountryUsed);
    }
    getLastCountryUsed() {
        return this.storage.get(Keys.LAST_COUNTRY_USED);
    }
    checkQuota() {
        let block = '';
        // 50MB
        for (let i = 0; i < 1024 * 1024; ++i) {
            block += '12345678901234567890123456789012345678901234567890';
        }
        this.storage.set('test', block).catch(err => {
            this.logger.error('CheckQuota Return:' + err);
        });
    }
    setTxHistory(walletId, txs) {
        return this.storage.set(Keys.TX_HISTORY(walletId), txs).catch(err => {
            this.logger.error('Error saving tx History. Size:' + txs.length);
            this.logger.error(err);
        });
    }
    getTxHistory(walletId) {
        return this.storage.get(Keys.TX_HISTORY(walletId));
    }
    removeTxHistory(walletId) {
        return this.storage.remove(Keys.TX_HISTORY(walletId));
    }
    setLastKnownHistory(id, txs) {
        let updatedOn = Math.floor(Date.now() / 1000);
        return this.storage.set(Keys.HISTORY_CACHE(id), {
            updatedOn,
            txs
        });
    }
    getLastKnownHistory(id) {
        return this.storage.get(Keys.HISTORY_CACHE(id));
    }
    setLastKnownBalance(id, balance) {
        let updatedOn = Math.floor(Date.now() / 1000);
        return this.storage.set(Keys.BALANCE_CACHE(id), {
            updatedOn,
            balance
        });
    }
    getLastKnownBalance(id) {
        return this.storage.get(Keys.BALANCE_CACHE(id));
    }
    removeLastKnownBalance(id) {
        return this.storage.remove(Keys.BALANCE_CACHE(id));
    }
    setAppIdentity(network, data) {
        return this.storage.set(Keys.APP_IDENTITY(network), data);
    }
    getAppIdentity(network) {
        return this.storage.get(Keys.APP_IDENTITY(network));
    }
    removeAppIdentity(network) {
        return this.storage.remove(Keys.APP_IDENTITY(network));
    }
    removeAllWalletData(walletId) {
        this.clearLastAddress(walletId);
        this.removeTxHistory(walletId);
        this.clearBackupFlag(walletId);
        this.removeWalletOrder(walletId);
    }
    removeAllWalletGroupData(keyId) {
        this.clearBackupGroupFlag(keyId);
    }
    getActiveGiftCards(network) {
        return this.storage.get(Keys.ACTIVE_GIFT_CARDS(network));
    }
    setActiveGiftCards(network, data) {
        return this.storage.set(Keys.ACTIVE_GIFT_CARDS(network), data);
    }
    getGiftCardConfigCache(network) {
        return this.storage.get(Keys.GIFT_CARD_CONFIG_CACHE(network));
    }
    removeGiftCardConfigCache(network) {
        return this.storage.remove(Keys.GIFT_CARD_CONFIG_CACHE(network));
    }
    setGiftCardConfigCache(network, data) {
        return this.storage.set(Keys.GIFT_CARD_CONFIG_CACHE(network), data);
    }
    setGiftCardUserInfo(data) {
        return this.storage.set(Keys.GIFT_CARD_USER_INFO, data);
    }
    getGiftCardUserInfo() {
        return this.storage.get(Keys.GIFT_CARD_USER_INFO);
    }
    removeGiftCardUserInfo() {
        return this.storage.remove(Keys.GIFT_CARD_USER_INFO);
    }
    setHideGiftCardDiscountItem(data) {
        return this.storage.set(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM, data);
    }
    getHideGiftCardDiscountItem() {
        return this.storage.get(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM);
    }
    removeHideGiftCardDiscountItem() {
        return this.storage.remove(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM);
    }
    setTxConfirmNotification(txid, val) {
        return this.storage.set(Keys.TX_CONFIRM_NOTIF(txid), val);
    }
    getTxConfirmNotification(txid) {
        return this.storage.get(Keys.TX_CONFIRM_NOTIF(txid));
    }
    removeTxConfirmNotification(txid) {
        return this.storage.remove(Keys.TX_CONFIRM_NOTIF(txid));
    }
    getBitpayAccounts(network) {
        return this.storage.get(Keys.BITPAY_ACCOUNTS_V2(network));
    }
    setBitpayAccount(network, data) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            let account = allAccounts[data.email] || {};
            account.token = data.token;
            account.familyName = data.familyName;
            account.givenName = data.givenName;
            allAccounts[data.email] = account;
            this.logger.info('Storing TKCoin accounts with new account:' + data.email);
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    removeBitpayAccount(network, email) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            delete allAccounts[email];
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    removeBitpayAccountV2(network) {
        return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), {});
    }
    setBitpayDebitCards(network, email, cards) {
        return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), {
            [email]: { cards }
        });
    }
    setCountries(countries) {
        return this.storage.set(Keys.COUNTRIES, countries);
    }
    getCountries() {
        return this.storage.get(Keys.COUNTRIES);
    }
    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    //   email: account email
    // ]
    getBitpayDebitCards(network) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            let allCards = [];
            lodash["each"](allAccounts, (account, email) => {
                if (account.cards) {
                    // Add account's email to each card
                    var cards = lodash["clone"](account.cards);
                    lodash["each"](cards, x => {
                        x.email = email;
                    });
                    allCards = allCards.concat(cards);
                }
            });
            return allCards;
        });
    }
    removeBitpayDebitCard(network, cardEid) {
        return this.getBitpayAccounts(network)
            .then(allAccounts => {
            return lodash["each"](allAccounts, account => {
                account.cards = lodash["reject"](account.cards, {
                    eid: cardEid
                });
            });
        })
            .then(allAccounts => {
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    removeAllTKCoinAccounts(network) {
        return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), {});
    }
    setGiftCards(cardName, network, gcs) {
        return this.storage.set(Keys.GIFT_CARDS(cardName, network), gcs);
    }
    getGiftCards(cardName, network) {
        return this.storage.get(Keys.GIFT_CARDS(cardName, network));
    }
    setServerMessageDismissed(id) {
        return this.storage.set(Keys.SERVER_MESSAGE_DISMISSED(id), 'dismissed');
    }
    getServerMessageDismissed(id) {
        return this.storage.get(Keys.SERVER_MESSAGE_DISMISSED(id));
    }
    removeServerMessageDismissed(id) {
        return this.storage.remove(Keys.SERVER_MESSAGE_DISMISSED(id));
    }
    setNewReleaseMessageDismissed(version) {
        return this.storage.set(Keys.RELEASE_MESSAGE_DISMISSED, version);
    }
    getNewReleaseMessageDismissed() {
        return this.storage.get(Keys.RELEASE_MESSAGE_DISMISSED);
    }
    setAdvertisementDismissed(name) {
        return this.storage.set(Keys.ADVERTISEMENT_DISMISSED(name), 'dismissed');
    }
    getAdvertisementDismissed(name) {
        return this.storage.get(Keys.ADVERTISEMENT_DISMISSED(name));
    }
    removeAdvertisementDismissed(name) {
        return this.storage.remove(Keys.ADVERTISEMENT_DISMISSED(name));
    }
    setChangelly(env, tx) {
        return this.storage.set('changelly-' + env, tx);
    }
    getChangelly(env) {
        return this.storage.get('changelly-' + env);
    }
    removeChangelly(env) {
        return this.storage.remove('changelly-' + env);
    }
    setSimplex(env, paymentRequests) {
        return this.storage.set('simplex-' + env, paymentRequests);
    }
    getSimplex(env) {
        return this.storage.get('simplex-' + env);
    }
    removeSimplex(env) {
        return this.storage.remove('simplex-' + env);
    }
    setWyre(env, paymentRequests) {
        return this.storage.set('wyre-' + env, paymentRequests);
    }
    getWyre(env) {
        return this.storage.get('wyre-' + env);
    }
    removeWyre(env) {
        return this.storage.remove('wyre-' + env);
    }
    setWalletOrder(walletId, order) {
        return this.storage.set(Keys.ORDER_WALLET(walletId), order);
    }
    getWalletOrder(walletId) {
        return this.storage.get(Keys.ORDER_WALLET(walletId));
    }
    removeWalletOrder(walletId) {
        return this.storage.remove(Keys.ORDER_WALLET(walletId));
    }
    setWalletGroupOrder(keyId, order) {
        return this.storage.set(Keys.ORDER_WALLET_GROUP(keyId), order);
    }
    getWalletGroupOrder(keyId) {
        return this.storage.get(Keys.ORDER_WALLET_GROUP(keyId));
    }
    removeWalletGroupOrder(keyId) {
        return this.storage.remove(Keys.ORDER_WALLET_GROUP(keyId));
    }
    setLockStatus(isLocked) {
        return this.storage.set('lockStatus', isLocked);
    }
    getLockStatus() {
        return this.storage.get('lockStatus');
    }
    removeLockStatus() {
        return this.storage.remove('lockStatus');
    }
    setNewFeatureSlidesFlag(value) {
        return this.storage.set('newFeatureSlides', value);
    }
    getNewFeatureSlidesFlag() {
        return this.storage.get('newFeatureSlides');
    }
    removeNewFeatureSlidesFlag() {
        return this.storage.remove('newFeatureSlides');
    }
    setEmailLawCompliance(value) {
        return this.storage.set('emailLawCompliance', value);
    }
    getEmailLawCompliance() {
        return this.storage.get('emailLawCompliance');
    }
    removeEmailLawCompliance() {
        return this.storage.remove('emailLawCompliance');
    }
    setHiddenFeaturesFlag(value) {
        this.logger.debug('Hidden features: ', value);
        return this.storage.set('hiddenFeatures', value);
    }
    getHiddenFeaturesFlag() {
        return this.storage.get('hiddenFeatures');
    }
    removeHiddenFeaturesFlag() {
        return this.storage.remove('hiddenFeatures');
    }
    setCardExperimentFlag(value) {
        return this.storage.set('cardExperimentEnabled', value);
    }
    getCardExperimentFlag() {
        return this.storage.get('cardExperimentEnabled');
    }
    removeCardExperimentFlag() {
        return this.storage.remove('cardExperimentEnabled');
    }
    getCardExperimentNetwork() {
        return this.storage.get('cardExperimentNetwork');
    }
    setCardExperimentNetwork(network) {
        return this.storage.set('cardExperimentNetwork', network);
    }
    setWalletGroupName(keyId, name) {
        return this.storage.set(Keys.WALLET_GROUP_NAME(keyId), name);
    }
    getWalletGroupName(keyId) {
        return this.storage.get(Keys.WALLET_GROUP_NAME(keyId));
    }
    removeWalletGroupName(keyId) {
        return this.storage.remove(Keys.WALLET_GROUP_NAME(keyId));
    }
    setTKCoinIdPairingToken(network, token) {
        return this.storage.set(Keys.BITPAY_ID_PAIRING_TOKEN(network), token);
    }
    getTKCoinIdPairingToken(network) {
        return this.storage.get(Keys.BITPAY_ID_PAIRING_TOKEN(network));
    }
    removeTKCoinIdPairingToken(network) {
        return this.storage.remove(Keys.BITPAY_ID_PAIRING_TOKEN(network));
    }
    setTKCoinIdUserInfo(network, userInfo) {
        return this.storage.set(Keys.BITPAY_ID_USER_INFO(network), userInfo);
    }
    getTKCoinIdUserInfo(network) {
        return this.storage.get(Keys.BITPAY_ID_USER_INFO(network));
    }
    removeTKCoinIdUserInfo(network) {
        return this.storage.remove(Keys.BITPAY_ID_USER_INFO(network));
    }
    setTKCoinIdSettings(network, userSettings) {
        return this.storage.set(Keys.BITPAY_ID_SETTINGS(network), userSettings);
    }
    getTKCoinIdSettings(network) {
        return this.storage.get(Keys.BITPAY_ID_SETTINGS(network));
    }
    setCardNotificationBadge(value) {
        return this.storage.set('cardNotificationBadge', value);
    }
    getCardNotificationBadge() {
        return this.storage.get('cardNotificationBadge');
    }
    removeTKCoinIdSettings(network) {
        return this.storage.remove(Keys.BITPAY_ID_SETTINGS(network));
    }
    setBitpayIdPairingFlag(value) {
        this.logger.debug('card experiment enabled: ', value);
        return this.storage.set('BitpayIdPairingFlag', value);
    }
    getBitpayIdPairingFlag() {
        return this.storage.get('BitpayIdPairingFlag');
    }
    removeBitpayIdPairingFlag() {
        return this.storage.remove('BitpayIdPairingFlag');
    }
    getWalletConnect() {
        return this.storage.get('walletConnectSession');
    }
    setWalletConnect(session) {
        return this.storage.set('walletConnectSession', session);
    }
    removeWalletConnect() {
        return this.storage.remove('walletConnectSession');
    }
    setWaitingListStatus(onList) {
        return this.storage.set('waitingListStatus', onList);
    }
    getWaitingListStatus() {
        return this.storage.get('waitingListStatus');
    }
    removeWaitingListStatus() {
        return this.storage.remove('waitingListStatus');
    }
    setReachedCardLimit(reachedCardLimit) {
        return this.storage.set('reachedCardLimit', reachedCardLimit);
    }
    getReachedCardLimit() {
        return this.storage.get('reachedCardLimit');
    }
    setAppTheme(value) {
        return this.storage.set(Keys.APP_THEME, value);
    }
    getAppTheme() {
        return this.storage.get(Keys.APP_THEME);
    }
    setUserLocation(location) {
        return this.storage.set(Keys.USER_LOCATION, location);
    }
    getUserLocation() {
        return this.storage.get(Keys.USER_LOCATION);
    }
    setCardFastTrackEnabled(value) {
        return this.storage.set(Keys.CARD_FAST_TRACK_ENABLED, value);
    }
    getCardFastTrackEnabled() {
        return this.storage.get(Keys.CARD_FAST_TRACK_ENABLED);
    }
    setOnboardingFlowFlag(value) {
        return this.storage.set('onboardingFlowFlag', value);
    }
    getOnboardingFlowFlag() {
        return this.storage.get('onboardingFlowFlag');
    }
    setTempMdesFlag(value) {
        return this.storage.set(Keys.TEMP_MDES_DEBUG_FLAG, value);
    }
    getTempMdesFlag() {
        return this.storage.get(Keys.TEMP_MDES_DEBUG_FLAG);
    }
    setTempMdesCertOnlyFlag(value) {
        return this.storage.set(Keys.TEMP_MDES_CERT_ONLY_DEBUG_FLAG, value);
    }
    getTempMdesCertOnlyFlag() {
        return this.storage.get(Keys.TEMP_MDES_CERT_ONLY_DEBUG_FLAG);
    }
    setDynamicLink(deepLink) {
        return this.storage.set('TKCoin-DynamicLink', deepLink);
    }
    getDynamicLink() {
        return this.storage.get('TKCoin-DynamicLink');
    }
    removeDynamicLink() {
        return this.storage.remove('TKCoin-DynamicLink');
    }
    setNetwork(network) {
        return this.storage.set(Keys.NETWORK, network);
    }
    getNetwork() {
        return this.storage.get(Keys.NETWORK);
    }
};
persistence_PersistenceProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [logger["a" /* Logger */],
        platform["a" /* PlatformProvider */],
        file["a" /* File */]])
], persistence_PersistenceProvider);

function getLegacyGiftCardKey(cardName, network) {
    switch (cardName + network) {
        case 'Amazon.com' + Network.livenet:
            return 'amazonGiftCards-livenet';
        case 'Amazon.com' + Network.testnet:
            return 'amazonGiftCards-testnet';
        case 'Amazon.co.jp' + Network.livenet:
            return 'amazonGiftCards-livenet-japan';
        case 'Amazon.co.jp' + Network.testnet:
            return 'amazonGiftCards-testnet-japan';
        case 'Mercado Livre' + Network.livenet:
            return 'MercadoLibreGiftCards-livenet';
        case 'Mercado Livre' + Network.testnet:
            return 'MercadoLibreGiftCards-testnet';
        default:
            return undefined;
    }
}
//# sourceMappingURL=persistence.js.map

/***/ }),

/***/ 200:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ = __webpack_require__(1);

var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);
var networks = [];
var networkMaps = {};

/**
 * A network is merely a map containing values that correspond to version
 * numbers for each bitcoin network. Currently only supporting "livenet"
 * (a.k.a. "mainnet") and "testnet".
 * @constructor
 */
function Network() {}

Network.prototype.toString = function toString() {
  return this.name;
};

/**
 * @function
 * @member Networks#get
 * Retrieves the network associated with a magic number or string.
 * @param {string|number|Network} arg
 * @param {string|Array} keys - if set, only check if the magic number associated with this name matches
 * @return Network
 */
function get(arg, keys) {
  if (~networks.indexOf(arg)) {
    return arg;
  }
  if (keys) {
    if (!_.isArray(keys)) {
      keys = [keys];
    }
    var containsArg = function(key) {
      return networks[index][key] === arg;
    };
    for (var index in networks) {
      if (_.some(keys, containsArg)) {
        return networks[index];
      }
    }
    return undefined;
  }
  if(networkMaps[arg] && networkMaps[arg].length >= 1) {
    return networkMaps[arg][0];
  } else {
    return networkMaps[arg];
  }
}

/**
 * @function
 * @member Networks#add
 * Will add a custom Network
 * @param {Object} data
 * @param {string} data.name - The name of the network
 * @param {string} data.alias - The aliased name of the network
 * @param {Number} data.pubkeyhash - The publickey hash prefix
 * @param {Number} data.privatekey - The privatekey prefix
 * @param {Number} data.scripthash - The scripthash prefix
 * @param {string} data.bech32prefix - The native segwit prefix
 * @param {Number} data.xpubkey - The extended public key magic
 * @param {Number} data.xprivkey - The extended private key magic
 * @param {Number} data.networkMagic - The network magic number
 * @param {Number} data.port - The network port
 * @param {Array}  data.dnsSeeds - An array of dns seeds
 * @return Network
 */
function addNetwork(data) {

  var network = new Network();

  JSUtil.defineImmutable(network, {
    name: data.name,
    alias: data.alias,
    pubkeyhash: data.pubkeyhash,
    privatekey: data.privatekey,
    scripthash: data.scripthash,
    bech32prefix: data.bech32prefix,
    xpubkey: data.xpubkey,
    xprivkey: data.xprivkey
  });

  if (data.networkMagic) {
    JSUtil.defineImmutable(network, {
      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)
    });
  }

  if (data.port) {
    JSUtil.defineImmutable(network, {
      port: data.port
    });
  }

  if (data.dnsSeeds) {
    JSUtil.defineImmutable(network, {
      dnsSeeds: data.dnsSeeds
    });
  }
  _.each(network, function(value) {
    if (!_.isUndefined(value) && !_.isObject(value)) {
      if(!networkMaps[value]) {
        networkMaps[value] = [];
      }
      networkMaps[value].push(network);
    }
  });

  networks.push(network);

  return network;

}

/**
 * @function
 * @member Networks#remove
 * Will remove a custom network
 * @param {Network} network
 */
function removeNetwork(network) {
  for (var i = 0; i < networks.length; i++) {
    if (networks[i] === network) {
      networks.splice(i, 1);
    }
  }
  for (var key in networkMaps) {
    const index = networkMaps[key].indexOf(network);
    if (index >= 0) {
      delete networkMaps[key][index];
    }
  }
}

addNetwork({
  name: 'livenet',
  alias: 'mainnet',
  pubkeyhash: 0x00,
  privatekey: 0x80,
  scripthash: 0x05,
  bech32prefix: 'tk',
  xpubkey: 0x0488b21e,
  xprivkey: 0x0488ade4,
  networkMagic: 0x9a9c9d91,
  port: 65510,
  dnsSeeds: [
    'tkcoin.org'
  ]
});

/**
 * @instance
 * @member Networks#livenet
 */
var livenet = get('livenet');

addNetwork({
  name: 'testnet',
  alias: 'test',
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  bech32prefix: 'tb',
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: 0x0b110907,
  port: 18333,
  dnsSeeds: [
    'testnet-seed.bitcoin.petertodd.org',
    'testnet-seed.bluematt.me',
    'testnet-seed.alexykot.me',
    'testnet-seed.bitcoin.schildbach.de'
  ]
});

/**
 * @instance
 * @member Networks#testnet
 */
var testnet = get('testnet');

addNetwork({
  name: 'regtest',
  alias: 'dev',
  pubkeyhash: 0x6f,
  privatekey: 0xef,
  scripthash: 0xc4,
  bech32prefix: 'bcrt',
  xpubkey: 0x043587cf,
  xprivkey: 0x04358394,
  networkMagic: 0xfabfb5da,
  port: 18444,
  dnsSeeds: []
});

/**
 * @instance
 * @member Networks#testnet
 */
var regtest = get('regtest');

/**
 * @function
 * @deprecated
 * @member Networks#enableRegtest
 * Will enable regtest features for testnet
 */
function enableRegtest() {
  testnet.regtestEnabled = true;
}

/**
 * @function
 * @deprecated
 * @member Networks#disableRegtest
 * Will disable regtest features for testnet
 */
function disableRegtest() {
  testnet.regtestEnabled = false;
}

/**
 * @namespace Networks
 */
module.exports = {
  add: addNetwork,
  remove: removeNetwork,
  defaultNetwork: livenet,
  livenet: livenet,
  mainnet: livenet,
  testnet: testnet,
  regtest: regtest,
  get: get,
  enableRegtest: enableRegtest,
  disableRegtest: disableRegtest
};


/***/ }),

/***/ 2006:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2012:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./m3vuuhwg.entry.js": [
		2013,
		7
	],
	"./m3vuuhwg.sc.entry.js": [
		2014,
		6
	]
};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids)
		return Promise.reject(new Error("Cannot find module '" + req + "'."));
	return __webpack_require__.e(ids[1]).then(function() {
		return __webpack_require__(ids[0]);
	});
};
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = 2012;
module.exports = webpackAsyncContext;

/***/ }),

/***/ 205:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TouchIdErrors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TouchIdProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_fingerprint_aio__ = __webpack_require__(793);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__platform_platform__ = __webpack_require__(13);



// Providers




var TouchIdErrors;
(function (TouchIdErrors) {
    TouchIdErrors["fingerprintCancelled"] = "FINGERPRINT_CANCELLED";
})(TouchIdErrors || (TouchIdErrors = {}));
let TouchIdProvider = class TouchIdProvider {
    constructor(app, platform, config, logger, faio) {
        this.app = app;
        this.platform = platform;
        this.config = config;
        this.logger = logger;
        this.faio = faio;
    }
    isAvailable() {
        if (!this.platform.isCordova)
            return Promise.resolve(false);
        return this.faio
            .isAvailable()
            .then(val => {
            this.logger.debug('Biometric: ', val);
            this.iosBiometricMethod = val;
            return Promise.resolve(true);
        })
            .catch(e => {
            this.logger.error('Biometric: ' + e.message, e.code);
            return Promise.resolve(false);
        });
    }
    check() {
        if (!this.platform.isCordova)
            return undefined;
        if (!this.app.isLockModalOpen && this.platform.isAndroid)
            this.app.skipLockModal = true;
        return this.faio
            .show({
            clientId: this.app.info.name
        })
            .then((result) => {
            this.logger.debug('Biometric: ', result);
        })
            .catch((e) => {
            this.logger.error('Biometric: ' + e.message, e.code);
            throw e;
        });
    }
    isNeeded(wallet) {
        let config = this.config.get();
        config.touchIdFor = config.touchIdFor || {};
        return config.touchIdFor[wallet.credentials.walletId];
    }
    checkWallet(wallet) {
        return this.isAvailable().then((isAvailable) => {
            if (!isAvailable)
                return undefined;
            if (this.isNeeded(wallet))
                return this.check();
            return undefined;
        });
    }
    getIosBiometricMethod() {
        return this.iosBiometricMethod;
    }
};
TouchIdProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_fingerprint_aio__["a" /* FingerprintAIO */]])
], TouchIdProvider);

//# sourceMappingURL=touchid.js.map

/***/ }),

/***/ 206:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DerivationPathHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let DerivationPathHelperProvider = class DerivationPathHelperProvider {
    constructor() {
        this.defaultBTC = "m/44'/0'/0'";
        this.defaultEDU = "m/44'/199'/0'";
        this.defaultTIK = "m/44'/299'/0'";
        this.defaultBCH = "m/44'/145'/0'";
        this.defaultETH = "m/44'/60'/0'";
        this.defaultXRP = "m/44'/144'/0'";
        this.defaultDOGE = "m/44'/3'/0'";
        this.defaultMultisigBTC = "m/48'/0'/0'";
        this.defaultMultisigEDU = "m/48'/199'/0'";
        this.defaultMultisigTIK = "m/48'/299'/0'";
        this.defaultMultisigBCH = "m/48'/145'/0'";
        this.defaultTestnet = "m/44'/1'/0'";
    }
    parsePath(path) {
        return {
            purpose: path.split('/')[1],
            coinCode: path.split('/')[2],
            account: path.split('/')[3]
        };
    }
    getDerivationStrategy(path) {
        const purpose = this.parsePath(path).purpose;
        let derivationStrategy;
        switch (purpose) {
            case "44'":
                derivationStrategy = 'BIP44';
                break;
            case "45'":
                derivationStrategy = 'BIP45';
                break;
            case "48'":
                derivationStrategy = 'BIP48';
                break;
        }
        return derivationStrategy;
    }
    getNetworkName(path) {
        // BIP45
        const purpose = this.parsePath(path).purpose;
        if (purpose == "45'")
            return 'livenet';
        const coinCode = this.parsePath(path).coinCode;
        let networkName;
        switch (coinCode) {
            case "0'":// for BTC
                networkName = 'livenet';
                break;
            case "199'":// for EDU
                networkName = 'livenet';
                break;
            case "299'":// for TIK
                networkName = 'livenet';
                break;
            case "1'":// testnet for all coins
                networkName = 'testnet';
                break;
            case "145'":// for BCH
                networkName = 'livenet';
                break;
            case "60'":// for ETH
                networkName = 'livenet';
                break;
            case "144'":// for XRP
                networkName = 'livenet';
                break;
            case "3'":// for DOGE
                networkName = 'livenet';
                break;
        }
        return networkName;
    }
    getAccount(path) {
        // BIP45
        const purpose = this.parsePath(path).purpose;
        if (purpose == "45'")
            return 0;
        const account = this.parsePath(path).account || '';
        const match = account.match(/(\d+)'/);
        if (!match)
            return undefined;
        return +match[1];
    }
    isValidDerivationPathCoin(path, coin) {
        let isValid;
        const coinCode = this.parsePath(path).coinCode;
        // BIP45
        if (path == "m/45'")
            return true;
        switch (coin) {
            case 'btc':
                isValid = ["0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'edu':
                isValid = ["199'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'tik':
                isValid = ["299'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'bch':
                isValid = ["145'", "0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'eth':
                isValid = ["60'", "0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'xrp':
                isValid = ["144'", "0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'doge':
                isValid = ["3'", "1'"].indexOf(coinCode) > -1;
                break;
        }
        return isValid;
    }
};
DerivationPathHelperProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], DerivationPathHelperProvider);

//# sourceMappingURL=derivation-path-helper.js.map

/***/ }),

/***/ 207:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_bitauth__);




// providers


let TKCoinProvider = class TKCoinProvider {
    constructor(http, appIdentityProvider, logger) {
        this.http = http;
        this.appIdentityProvider = appIdentityProvider;
        this.logger = logger;
        this.logger.debug('TKCoinProvider initialized');
    }
    setNetwork(network) {
        this.NETWORK = network;
        this.BITPAY_API_URL =
            this.NETWORK == 'livenet'
                ? 'https://tkcoin.org'
                : 'https://test.tkcoin.org';
        this.logger.log(`tkcoin provider initialized with ${this.NETWORK}`);
    }
    getEnvironment() {
        return {
            network: this.NETWORK
        };
    }
    get(endpoint, successCallback, errorCallback) {
        let url = this.BITPAY_API_URL + endpoint;
        let headers = {
            'Content-Type': 'application/json'
        };
        this.http.get(url, { headers }).subscribe(data => {
            successCallback(data);
        }, data => {
            errorCallback(data);
        });
    }
    post(endpoint, json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            let dataToSign = this.BITPAY_API_URL + endpoint + JSON.stringify(json);
            let signedData = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
            let url = this.BITPAY_API_URL + endpoint;
            let headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]().set('content-type', 'application/json');
            headers = headers.append('x-identity', appIdentity.pub);
            headers = headers.append('x-signature', signedData);
            this.http.post(url, json, { headers }).subscribe(data => {
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
    postAuth(json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            json['params'].signature = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](JSON.stringify(json.params), appIdentity.priv);
            json['params'].pubkey = appIdentity.pub;
            json['params'] = JSON.stringify(json.params);
            let url = this.BITPAY_API_URL + '/api/v2/';
            let headers = {
                'Content-Type': 'application/json'
            };
            this.logger.debug('post auth:' + JSON.stringify(json));
            this.http.post(url, json, { headers }).subscribe((data) => {
                data.appIdentity = appIdentity;
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
};
TKCoinProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], TKCoinProvider);

//# sourceMappingURL=tkcoin.js.map

/***/ }),

/***/ 208:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinCardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tkcoin_tkcoin__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__ = __webpack_require__(68);



// providers









let TKCoinCardProvider = class TKCoinCardProvider {
    constructor(logger, bitPayProvider, appIdentityProvider, onGoingProcessProvider, persistenceProvider, configProvider, homeIntegrationsProvider, analyticsProvider) {
        this.logger = logger;
        this.bitPayProvider = bitPayProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.analyticsProvider = analyticsProvider;
        this.logger.debug('TKCoinCardProvider initialized');
    }
    logDebitCardLinked() {
        this.analyticsProvider.setUserProperty('hasLinkedDebitCard', 'true');
    }
    isActive(cb) {
        this.getCards(cards => {
            return cb(!__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](cards));
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        var error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
    _buildDate(date, time) {
        date = date.match(/(\d{2})\/(\d{2})\/(\d{4})/);
        time = time.match(/(\d{2})(\d{2})(\d{2})/);
        var newDate = new Date(date[1] + '/' + date[2] + '/' + date[3]);
        newDate.setHours(time[1], time[2], time[3]);
        return newDate;
    }
    _lowercaseMerchant(merchant) {
        if (merchant.name && merchant.name.toLowerCase) {
            merchant.name = merchant.name.toLowerCase();
        }
        if (merchant.city && merchant.city.toLowerCase) {
            merchant.city = merchant.city.toLowerCase();
        }
        return merchant;
    }
    _getMerchantInfo(tx) {
        var bpTranCodesTemp = bpTranCodes;
        __WEBPACK_IMPORTED_MODULE_9_lodash__["keys"](bpTranCodesTemp).forEach(code => {
            if (tx.type.indexOf(code) === 0) {
                __WEBPACK_IMPORTED_MODULE_9_lodash__["assign"](tx, bpTranCodesTemp[code]);
            }
        });
        return tx;
    }
    _getIconName(tx) {
        var icon = tx.mcc || tx.category || null;
        if (!icon || iconMap[icon] == undefined)
            return 'default';
        return iconMap[icon];
    }
    _processDescription(tx) {
        if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isArray"](tx.description)) {
            return tx.description[0];
        }
        return tx.description;
    }
    _processLocation(tx) {
        if (tx.merchant.city && tx.merchant.state) {
            return tx.merchant.city + ', ' + tx.merchant.state;
        }
        else {
            return tx.merchant.city || tx.merchant.state || '';
        }
    }
    _fromTransaction(txn, runningBalance) {
        var dateTime = this._buildDate(txn.date, txn.time);
        var merchant = this._lowercaseMerchant(txn.merchant);
        return this._getMerchantInfo({
            date: txn.timestamp || dateTime,
            category: txn.mcc,
            merchant,
            description: txn.description[0],
            price: parseFloat(txn.amount) + parseFloat(txn.fee),
            type: txn.type,
            runningBalance
        });
    }
    logEvent(eventName, eventParams) {
        this.analyticsProvider.logEvent(eventName, eventParams);
    }
    _processTransactions(invoices, history) {
        var balance = history.endingBalance || history.currentCardBalance;
        var runningBalance = parseFloat(balance);
        var activityList = [];
        if (history && history.transactionList) {
            for (let j = 0; j < history.transactionList.length; j++) {
                runningBalance -= parseFloat(history.transactionList[j].amount);
                activityList.push(this._fromTransaction(history.transactionList[j], runningBalance));
            }
        }
        if (activityList.length > 0) {
            invoices = invoices || [];
            for (let i = 0; i < invoices.length; i++) {
                var matched = false;
                for (let j = 0; j < history.transactionList.length; j++) {
                    var description = history.transactionList[j].description;
                    for (let k = 0; k < description.length; k++) {
                        if (description[k] && description[k].indexOf(invoices[i].id) > -1) {
                            matched = true;
                        }
                    }
                }
                var isInvoiceLessThanOneDayOld = __WEBPACK_IMPORTED_MODULE_10_moment__() < __WEBPACK_IMPORTED_MODULE_10_moment__(new Date(invoices[i].invoiceTime)).add(1, 'day');
                if (!matched && isInvoiceLessThanOneDayOld) {
                    var isInvoiceUnderpaid = invoices[i].exceptionStatus === 'paidPartial';
                    if (['paid', 'confirmed', 'complete'].indexOf(invoices[i].status) >=
                        0 ||
                        invoices[i].status === 'invalid' ||
                        isInvoiceUnderpaid) {
                        activityList.unshift(this._getMerchantInfo({
                            date: new Date(invoices[i].invoiceTime),
                            category: '',
                            merchant: '',
                            description: invoices[i].itemDesc,
                            price: invoices[i].price,
                            type: '00611 = Client Funded Deposit',
                            runningBalance: null,
                            pending: true,
                            transactionId: invoices[i].transactions && invoices[i].transactions[0]
                                ? invoices[i].transactions[0].txid
                                : ''
                        }));
                    }
                }
            }
        }
        for (let i = 0; i < activityList.length; i++) {
            activityList[i].icon = this._getIconName(activityList[i]);
            activityList[i].desc = this._processDescription(activityList[i]);
            activityList[i].merchant['location'] = this._processLocation(activityList[i]);
        }
        return activityList;
    }
    filterTransactions(type, txns) {
        var list, getPreAuth = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return txn.type.indexOf('93') > -1;
        }), getPending = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return txn.pending;
        }), getCompleted = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return !txn.pending && txn.type.indexOf('93') == -1;
        });
        switch (type) {
            case 'preAuth':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getPreAuth);
                break;
            case 'confirming':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getPending);
                break;
            case 'completed':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getCompleted);
                break;
            default:
                // code...
                break;
        }
        return list;
    }
    sync(apiContext, cb) {
        var json = {
            method: 'getDebitCards'
        };
        this.onGoingProcessProvider.set('fetchingTKCoinCards');
        // Get Debit Cards
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error) {
                this.onGoingProcessProvider.clear();
                return cb(data.error);
            }
            this.logger.info('TKCoin Get Debit Cards: SUCCESS');
            var cards = [];
            __WEBPACK_IMPORTED_MODULE_9_lodash__["each"](data.data, x => {
                var n = {};
                if (!x.eid || !x.id || !x.lastFourDigits || !x.token) {
                    this.logger.warn('BAD data from TKCoin card' + JSON.stringify(x));
                    return;
                }
                n.eid = x.eid;
                n.id = x.id;
                n.lastFourDigits = x.lastFourDigits;
                n.token = x.token;
                n.currency = x.currency;
                n.country = x.country;
                cards.push(n);
            });
            this.persistenceProvider
                .setBitpayDebitCards(this.bitPayProvider.getEnvironment().network, apiContext.pairData.email, cards)
                .then(() => {
                this.logDebitCardLinked();
                this.onGoingProcessProvider.clear();
                return cb(null, cards);
            });
        }, data => {
            this.onGoingProcessProvider.clear();
            return cb(this._setError('BitPay Card Error: Get Debit Cards', data));
        });
    }
    setCurrencySymbol(card) {
        // Sets a currency symbol.
        // Uses the currency code if no symbol is mapped (should never happen).
        // Backwards compatibility for FirstView cards (all USD).
        // This avoids users having to re-pair their account.
        if (!card.currency) {
            card.currency = 'USD';
        }
        card.currencySymbol = currencySymbols[card.currency] || card.currency + ' ';
    }
    // opts: range
    updateHistory(cardId, opts, cb) {
        var invoices, history;
        opts = opts || {};
        var json = {
            method: 'getInvoiceHistory'
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_9_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                // Get invoices
                this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                    this.logger.info('TKCoin Get Invoices: SUCCESS');
                    invoices = data.data || [];
                    if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](invoices))
                        this.logger.info('No invoices');
                    json = {
                        method: 'getTransactionHistory',
                        params: JSON.stringify(opts)
                    };
                    // Get transactions History list
                    this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                        this.logger.info('TKCoin Get History: SUCCESS');
                        history = data.data || {};
                        history['txs'] = this._processTransactions(invoices, history);
                        this.persistenceProvider.setLastKnownHistory(cardId, history.txs);
                        this.persistenceProvider.setLastKnownBalance(cardId, history.currentCardBalance);
                        return cb(data.error, history);
                    }, data => {
                        this.logger.info('Error loading BitPay Card transaction history for ', 'card id: ', cardId, 'Message: ', data.error);
                        return cb(this._setError('BitPay Card Error: Get History', data));
                    });
                }, data => {
                    this.logger.info('Error loading BitPay Card invoice history for ', 'card id: ', cardId, 'Message: ', data.error);
                    return cb(this._setError('BitPay Card Error: Get Invoices', data));
                });
            });
        });
    }
    topUp(cardId, opts, cb) {
        opts = opts || {};
        var json = {
            method: 'generateTopUpInvoice',
            params: JSON.stringify(opts)
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_9_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                this.bitPayProvider.post('/api/v2/' + card.token, json, res => {
                    if (res.error) {
                        this.logger.error('TKCoin TopUp: With Errors');
                        return cb(res.error);
                    }
                    else {
                        this.logger.info('TKCoin TopUp: SUCCESS');
                        return cb(null, res.data);
                    }
                }, res => {
                    return cb(this._setError('BitPay Card Error: TopUp', res));
                });
            });
        });
    }
    getInvoice(id, cb) {
        this.bitPayProvider.get('/invoices/' + id, res => {
            this.logger.info('TKCoin Get Invoice: SUCCESS');
            return cb(res.error, res.data);
        }, res => {
            return cb(this._setError('BitPay Card Error: Get Invoice', res));
        });
    }
    // get all cards, for all accounts.
    getCards(cb) {
        this.persistenceProvider
            .getBitpayDebitCards(this.bitPayProvider.getEnvironment().network)
            .then(val => {
            return cb(val);
        });
    }
    remove(cardId, cb) {
        this.persistenceProvider
            .removeBitpayDebitCard(this.bitPayProvider.getEnvironment().network, cardId)
            .then(() => {
            this.persistenceProvider.removeLastKnownBalance(cardId);
            return cb();
        })
            .catch(err => {
            this.logger.error('Error removing TKCoin debit card: ' + err);
            return cb(err);
        });
    }
    getRates(currency, cb) {
        this.bitPayProvider.get('/rates/' + currency, data => {
            this.logger.info('TKCoin Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('TKCoin Error: Get Rates', data));
        });
    }
    getRatesFromCoin(coin, currency, cb) {
        this.bitPayProvider.get('/rates/' + coin + '/' + currency, data => {
            this.logger.info('TKCoin Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('TKCoin Error: Get Rates', data));
        });
    }
    get(opts) {
        opts = opts || {};
        return new Promise(resolve => {
            this.getCards(cards => {
                if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](cards)) {
                    this.homeIntegrationsProvider.updateLink('debitcard', null); // Name, linked
                    return resolve();
                }
                this.homeIntegrationsProvider.updateLink('debitcard', true); // Name, linked
                if (opts.cardId) {
                    cards = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](cards, card => {
                        return opts.cardId == card.eid;
                    });
                }
                const completeBalance = () => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                    for (let i = 0; i < cards.length; i++) {
                        this.setCurrencySymbol(cards[i]);
                        if (!opts.noBalance) {
                            yield this.persistenceProvider
                                .getLastKnownBalance(cards[i].eid)
                                .then(balanceCache => {
                                cards[i].balance =
                                    balanceCache && balanceCache.balance
                                        ? Number(balanceCache.balance)
                                        : null;
                                cards[i].updateOn = balanceCache && balanceCache.updatedOn;
                            });
                        }
                        // async refresh
                        if (!opts.noHistory) {
                            yield this.persistenceProvider
                                .getLastKnownHistory(cards[i].eid)
                                .then(historyCache => {
                                cards[i].history = historyCache && historyCache.txs;
                                cards[i].updateOn = historyCache && historyCache.updatedOn;
                            });
                        }
                    }
                    return resolve(cards);
                });
                completeBalance();
            });
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'debitcard',
                title: 'TKCoin Visa Card',
                icon: 'assets/img/tkcoin-card/icon-tkcoin.svg',
                page: 'TKCoinCardIntroPage',
                show: !!this.configProvider.get().showIntegration['debitcard'],
                linked: !!isActive,
                type: 'card'
            });
        });
    }
};
TKCoinCardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__tkcoin_tkcoin__["a" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_6__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__["a" /* AnalyticsProvider */]])
], TKCoinCardProvider);

/*
 * CONSTANTS
 */
const currencySymbols = {
    EUR: '',
    GBP: '',
    USD: '$'
};
const bpTranCodes = {
    '00611': {
        merchant: {
            name: 'TKCoin',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    '602': {
        merchant: {
            name: 'ATM Withdrawal Fee'
        },
        category: 'bp002',
        description: ''
    },
    '604': {
        merchant: {
            name: 'Foreign Transaction Fee'
        },
        category: 'bp002',
        description: ''
    },
    '606': {
        merchant: {
            name: 'International ATM Fee'
        },
        category: 'bp002',
        description: ''
    },
    '00240': {
        merchant: {
            name: 'ACH Debit Fee'
        },
        category: 'bp002',
        description: ''
    },
    '5032': {
        merchant: {
            name: 'ACH Debit'
        },
        category: 'bp002',
        description: ''
    },
    '37': {
        merchant: {
            name: 'ACH / Payroll Deposit'
        },
        category: 'bp002',
        description: ''
    },
    '10036': {
        merchant: {
            name: 'Inactivity Fee (90 days)'
        },
        category: 'bp002',
        description: ''
    },
    load: {
        merchant: {
            name: 'TKCoin',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    'unload | pos': {
        description: 'Purchase'
    },
    'unload | epos': {
        description: 'Online Purchase'
    },
    transactionfee: {
        merchant: {
            name: 'Transaction Fee'
        },
        category: 'bp002',
        description: ''
    }
};
const iconMap = {
    742: 'medical',
    763: 'plant',
    780: 'plant',
    1520: 'repair',
    1711: 'repair',
    1731: 'repair',
    1740: 'repair',
    1750: 'repair',
    1761: 'repair',
    1771: 'repair',
    1799: 'repair',
    2741: 'books',
    2791: 'books',
    2842: 'clean',
    3000: 'airplane',
    3001: 'airplane',
    3002: 'airplane',
    3003: 'airplane',
    3004: 'airplane',
    3005: 'airplane',
    3006: 'airplane',
    3007: 'airplane',
    3008: 'airplane',
    3009: 'airplane',
    3010: 'airplane',
    3011: 'airplane',
    3012: 'airplane',
    3013: 'airplane',
    3014: 'airplane',
    3015: 'airplane',
    3016: 'airplane',
    3017: 'airplane',
    3018: 'airplane',
    3019: 'airplane',
    3020: 'airplane',
    3021: 'airplane',
    3022: 'airplane',
    3023: 'airplane',
    3024: 'airplane',
    3025: 'airplane',
    3026: 'airplane',
    3027: 'airplane',
    3028: 'airplane',
    3029: 'airplane',
    3030: 'airplane',
    3031: 'airplane',
    3032: 'airplane',
    3033: 'airplane',
    3034: 'airplane',
    3035: 'airplane',
    3036: 'airplane',
    3037: 'airplane',
    3038: 'airplane',
    3039: 'airplane',
    3040: 'airplane',
    3041: 'airplane',
    3042: 'airplane',
    3043: 'airplane',
    3044: 'airplane',
    3045: 'airplane',
    3046: 'airplane',
    3047: 'airplane',
    3048: 'airplane',
    3049: 'airplane',
    3050: 'airplane',
    3051: 'airplane',
    3052: 'airplane',
    3053: 'airplane',
    3054: 'airplane',
    3055: 'airplane',
    3056: 'airplane',
    3057: 'airplane',
    3058: 'airplane',
    3059: 'airplane',
    3060: 'airplane',
    3061: 'airplane',
    3062: 'airplane',
    3063: 'airplane',
    3064: 'airplane',
    3065: 'airplane',
    3066: 'airplane',
    3067: 'airplane',
    3068: 'airplane',
    3069: 'airplane',
    3070: 'airplane',
    3071: 'airplane',
    3072: 'airplane',
    3073: 'airplane',
    3074: 'airplane',
    3075: 'airplane',
    3076: 'airplane',
    3077: 'airplane',
    3078: 'airplane',
    3079: 'airplane',
    3080: 'airplane',
    3081: 'airplane',
    3082: 'airplane',
    3083: 'airplane',
    3084: 'airplane',
    3085: 'airplane',
    3086: 'airplane',
    3087: 'airplane',
    3088: 'airplane',
    3089: 'airplane',
    3090: 'airplane',
    3091: 'airplane',
    3092: 'airplane',
    3093: 'airplane',
    3094: 'airplane',
    3095: 'airplane',
    3096: 'airplane',
    3097: 'airplane',
    3098: 'airplane',
    3099: 'airplane',
    3100: 'airplane',
    3101: 'airplane',
    3102: 'airplane',
    3103: 'airplane',
    3104: 'airplane',
    3105: 'airplane',
    3106: 'airplane',
    3107: 'airplane',
    3108: 'airplane',
    3109: 'airplane',
    3110: 'airplane',
    3111: 'airplane',
    3112: 'airplane',
    3113: 'airplane',
    3114: 'airplane',
    3115: 'airplane',
    3116: 'airplane',
    3117: 'airplane',
    3118: 'airplane',
    3119: 'airplane',
    3120: 'airplane',
    3121: 'airplane',
    3122: 'airplane',
    3123: 'airplane',
    3124: 'airplane',
    3125: 'airplane',
    3126: 'airplane',
    3127: 'airplane',
    3128: 'airplane',
    3129: 'airplane',
    3130: 'airplane',
    3131: 'airplane',
    3132: 'airplane',
    3133: 'airplane',
    3134: 'airplane',
    3135: 'airplane',
    3136: 'airplane',
    3137: 'airplane',
    3138: 'airplane',
    3139: 'airplane',
    3140: 'airplane',
    3141: 'airplane',
    3142: 'airplane',
    3143: 'airplane',
    3144: 'airplane',
    3145: 'airplane',
    3146: 'airplane',
    3147: 'airplane',
    3148: 'airplane',
    3149: 'airplane',
    3150: 'airplane',
    3151: 'airplane',
    3152: 'airplane',
    3153: 'airplane',
    3154: 'airplane',
    3155: 'airplane',
    3156: 'airplane',
    3157: 'airplane',
    3158: 'airplane',
    3159: 'airplane',
    3160: 'airplane',
    3161: 'airplane',
    3162: 'airplane',
    3163: 'airplane',
    3164: 'airplane',
    3165: 'airplane',
    3166: 'airplane',
    3167: 'airplane',
    3168: 'airplane',
    3169: 'airplane',
    3170: 'airplane',
    3171: 'airplane',
    3172: 'airplane',
    3173: 'airplane',
    3174: 'airplane',
    3175: 'airplane',
    3176: 'airplane',
    3177: 'airplane',
    3178: 'airplane',
    3179: 'airplane',
    3180: 'airplane',
    3181: 'airplane',
    3182: 'airplane',
    3183: 'airplane',
    3184: 'airplane',
    3185: 'airplane',
    3186: 'airplane',
    3187: 'airplane',
    3188: 'airplane',
    3189: 'airplane',
    3190: 'airplane',
    3191: 'airplane',
    3192: 'airplane',
    3193: 'airplane',
    3194: 'airplane',
    3195: 'airplane',
    3196: 'airplane',
    3197: 'airplane',
    3198: 'airplane',
    3199: 'airplane',
    3200: 'airplane',
    3201: 'airplane',
    3202: 'airplane',
    3203: 'airplane',
    3204: 'airplane',
    3205: 'airplane',
    3206: 'airplane',
    3207: 'airplane',
    3208: 'airplane',
    3209: 'airplane',
    3210: 'airplane',
    3211: 'airplane',
    3212: 'airplane',
    3213: 'airplane',
    3214: 'airplane',
    3215: 'airplane',
    3216: 'airplane',
    3217: 'airplane',
    3218: 'airplane',
    3219: 'airplane',
    3220: 'airplane',
    3221: 'airplane',
    3222: 'airplane',
    3223: 'airplane',
    3224: 'airplane',
    3225: 'airplane',
    3226: 'airplane',
    3227: 'airplane',
    3228: 'airplane',
    3229: 'airplane',
    3230: 'airplane',
    3231: 'airplane',
    3232: 'airplane',
    3233: 'airplane',
    3234: 'airplane',
    3235: 'airplane',
    3236: 'airplane',
    3237: 'airplane',
    3238: 'airplane',
    3239: 'airplane',
    3240: 'airplane',
    3241: 'airplane',
    3242: 'airplane',
    3243: 'airplane',
    3244: 'airplane',
    3245: 'airplane',
    3246: 'airplane',
    3247: 'airplane',
    3248: 'airplane',
    3249: 'airplane',
    3250: 'airplane',
    3251: 'airplane',
    3252: 'airplane',
    3253: 'airplane',
    3254: 'airplane',
    3255: 'airplane',
    3256: 'airplane',
    3257: 'airplane',
    3258: 'airplane',
    3259: 'airplane',
    3260: 'airplane',
    3261: 'airplane',
    3262: 'airplane',
    3263: 'airplane',
    3264: 'airplane',
    3265: 'airplane',
    3266: 'airplane',
    3267: 'airplane',
    3268: 'airplane',
    3269: 'airplane',
    3270: 'airplane',
    3271: 'airplane',
    3272: 'airplane',
    3273: 'airplane',
    3274: 'airplane',
    3275: 'airplane',
    3276: 'airplane',
    3277: 'airplane',
    3278: 'airplane',
    3279: 'airplane',
    3280: 'airplane',
    3281: 'airplane',
    3282: 'airplane',
    3283: 'airplane',
    3284: 'airplane',
    3285: 'airplane',
    3286: 'airplane',
    3287: 'airplane',
    3288: 'airplane',
    3289: 'airplane',
    3290: 'airplane',
    3291: 'airplane',
    3292: 'airplane',
    3293: 'airplane',
    3294: 'airplane',
    3295: 'airplane',
    3296: 'airplane',
    3297: 'airplane',
    3298: 'airplane',
    3299: 'airplane',
    3351: 'car',
    3352: 'car',
    3353: 'car',
    3354: 'car',
    3355: 'car',
    3356: 'car',
    3357: 'car',
    3358: 'car',
    3359: 'car',
    3360: 'car',
    3361: 'car',
    3362: 'car',
    3363: 'car',
    3364: 'car',
    3365: 'car',
    3366: 'car',
    3367: 'car',
    3368: 'car',
    3369: 'car',
    3370: 'car',
    3371: 'car',
    3372: 'car',
    3373: 'car',
    3374: 'car',
    3375: 'car',
    3376: 'car',
    3377: 'car',
    3378: 'car',
    3379: 'car',
    3380: 'car',
    3381: 'car',
    3382: 'car',
    3383: 'car',
    3384: 'car',
    3385: 'car',
    3386: 'car',
    3387: 'car',
    3388: 'car',
    3389: 'car',
    3390: 'car',
    3391: 'car',
    3392: 'car',
    3393: 'car',
    3394: 'car',
    3395: 'car',
    3396: 'car',
    3397: 'car',
    3398: 'car',
    3399: 'car',
    3400: 'car',
    3401: 'car',
    3402: 'car',
    3403: 'car',
    3404: 'car',
    3405: 'car',
    3406: 'car',
    3407: 'car',
    3408: 'car',
    3409: 'car',
    3410: 'car',
    3411: 'car',
    3412: 'car',
    3413: 'car',
    3414: 'car',
    3415: 'car',
    3416: 'car',
    3417: 'car',
    3418: 'car',
    3419: 'car',
    3420: 'car',
    3421: 'car',
    3422: 'car',
    3423: 'car',
    3424: 'car',
    3425: 'car',
    3426: 'car',
    3427: 'car',
    3428: 'car',
    3429: 'car',
    3430: 'car',
    3431: 'car',
    3432: 'car',
    3433: 'car',
    3434: 'car',
    3435: 'car',
    3436: 'car',
    3437: 'car',
    3438: 'car',
    3439: 'car',
    3440: 'car',
    3441: 'car',
    3501: 'hotel',
    3502: 'hotel',
    3503: 'hotel',
    3504: 'hotel',
    3505: 'hotel',
    3506: 'hotel',
    3507: 'hotel',
    3508: 'hotel',
    3509: 'hotel',
    3510: 'hotel',
    3511: 'hotel',
    3512: 'hotel',
    3513: 'hotel',
    3514: 'hotel',
    3515: 'hotel',
    3516: 'hotel',
    3517: 'hotel',
    3518: 'hotel',
    3519: 'hotel',
    3520: 'hotel',
    3521: 'hotel',
    3522: 'hotel',
    3523: 'hotel',
    3524: 'hotel',
    3525: 'hotel',
    3526: 'hotel',
    3527: 'hotel',
    3528: 'hotel',
    3529: 'hotel',
    3530: 'hotel',
    3531: 'hotel',
    3532: 'hotel',
    3533: 'hotel',
    3534: 'hotel',
    3535: 'hotel',
    3536: 'hotel',
    3537: 'hotel',
    3538: 'hotel',
    3539: 'hotel',
    3540: 'hotel',
    3541: 'hotel',
    3542: 'hotel',
    3543: 'hotel',
    3544: 'hotel',
    3545: 'hotel',
    3546: 'hotel',
    3547: 'hotel',
    3548: 'hotel',
    3549: 'hotel',
    3550: 'hotel',
    3551: 'hotel',
    3552: 'hotel',
    3553: 'hotel',
    3554: 'hotel',
    3555: 'hotel',
    3556: 'hotel',
    3557: 'hotel',
    3558: 'hotel',
    3559: 'hotel',
    3560: 'hotel',
    3561: 'hotel',
    3562: 'hotel',
    3563: 'hotel',
    3564: 'hotel',
    3565: 'hotel',
    3566: 'hotel',
    3567: 'hotel',
    3568: 'hotel',
    3569: 'hotel',
    3570: 'hotel',
    3571: 'hotel',
    3572: 'hotel',
    3573: 'hotel',
    3574: 'hotel',
    3575: 'hotel',
    3576: 'hotel',
    3577: 'hotel',
    3578: 'hotel',
    3579: 'hotel',
    3580: 'hotel',
    3581: 'hotel',
    3582: 'hotel',
    3583: 'hotel',
    3584: 'hotel',
    3585: 'hotel',
    3586: 'hotel',
    3587: 'hotel',
    3588: 'hotel',
    3589: 'hotel',
    3590: 'hotel',
    3591: 'hotel',
    3592: 'hotel',
    3593: 'hotel',
    3594: 'hotel',
    3595: 'hotel',
    3596: 'hotel',
    3597: 'hotel',
    3598: 'hotel',
    3599: 'hotel',
    3600: 'hotel',
    3601: 'hotel',
    3602: 'hotel',
    3603: 'hotel',
    3604: 'hotel',
    3605: 'hotel',
    3606: 'hotel',
    3607: 'hotel',
    3608: 'hotel',
    3609: 'hotel',
    3610: 'hotel',
    3611: 'hotel',
    3612: 'hotel',
    3613: 'hotel',
    3614: 'hotel',
    3615: 'hotel',
    3616: 'hotel',
    3617: 'hotel',
    3618: 'hotel',
    3619: 'hotel',
    3620: 'hotel',
    3621: 'hotel',
    3622: 'hotel',
    3623: 'hotel',
    3624: 'hotel',
    3625: 'hotel',
    3626: 'hotel',
    3627: 'hotel',
    3628: 'hotel',
    3629: 'hotel',
    3630: 'hotel',
    3631: 'hotel',
    3632: 'hotel',
    3633: 'hotel',
    3634: 'hotel',
    3635: 'hotel',
    3636: 'hotel',
    3637: 'hotel',
    3638: 'hotel',
    3639: 'hotel',
    3640: 'hotel',
    3641: 'hotel',
    3642: 'hotel',
    3643: 'hotel',
    3644: 'hotel',
    3645: 'hotel',
    3646: 'hotel',
    3647: 'hotel',
    3648: 'hotel',
    3649: 'hotel',
    3650: 'hotel',
    3651: 'hotel',
    3652: 'hotel',
    3653: 'hotel',
    3654: 'hotel',
    3655: 'hotel',
    3656: 'hotel',
    3657: 'hotel',
    3658: 'hotel',
    3659: 'hotel',
    3660: 'hotel',
    3661: 'hotel',
    3662: 'hotel',
    3663: 'hotel',
    3664: 'hotel',
    3665: 'hotel',
    3666: 'hotel',
    3667: 'hotel',
    3668: 'hotel',
    3669: 'hotel',
    3670: 'hotel',
    3671: 'hotel',
    3672: 'hotel',
    3673: 'hotel',
    3674: 'hotel',
    3675: 'hotel',
    3676: 'hotel',
    3677: 'hotel',
    3678: 'hotel',
    3679: 'hotel',
    3680: 'hotel',
    3681: 'hotel',
    3682: 'hotel',
    3683: 'hotel',
    3684: 'hotel',
    3685: 'hotel',
    3686: 'hotel',
    3687: 'hotel',
    3688: 'hotel',
    3689: 'hotel',
    3690: 'hotel',
    3691: 'hotel',
    3692: 'hotel',
    3693: 'hotel',
    3694: 'hotel',
    3695: 'hotel',
    3696: 'hotel',
    3697: 'hotel',
    3698: 'hotel',
    3699: 'hotel',
    3700: 'hotel',
    3701: 'hotel',
    3702: 'hotel',
    3703: 'hotel',
    3704: 'hotel',
    3705: 'hotel',
    3706: 'hotel',
    3707: 'hotel',
    3708: 'hotel',
    3709: 'hotel',
    3710: 'hotel',
    3711: 'hotel',
    3712: 'hotel',
    3713: 'hotel',
    3714: 'hotel',
    3715: 'hotel',
    3716: 'hotel',
    3717: 'hotel',
    3718: 'hotel',
    3719: 'hotel',
    3720: 'hotel',
    3721: 'hotel',
    3722: 'hotel',
    3723: 'hotel',
    3724: 'hotel',
    3725: 'hotel',
    3726: 'hotel',
    3727: 'hotel',
    3728: 'hotel',
    3729: 'hotel',
    3730: 'hotel',
    3731: 'hotel',
    3732: 'hotel',
    3733: 'hotel',
    3734: 'hotel',
    3735: 'hotel',
    3736: 'hotel',
    3737: 'hotel',
    3738: 'hotel',
    3739: 'hotel',
    3740: 'hotel',
    3741: 'hotel',
    3742: 'hotel',
    3743: 'hotel',
    3744: 'hotel',
    3745: 'hotel',
    3746: 'hotel',
    3747: 'hotel',
    3748: 'hotel',
    3749: 'hotel',
    3750: 'hotel',
    3751: 'hotel',
    3752: 'hotel',
    3753: 'hotel',
    3754: 'hotel',
    3755: 'hotel',
    3756: 'hotel',
    3757: 'hotel',
    3758: 'hotel',
    3759: 'hotel',
    3760: 'hotel',
    3761: 'hotel',
    3762: 'hotel',
    3763: 'hotel',
    3764: 'hotel',
    3765: 'hotel',
    3766: 'hotel',
    3767: 'hotel',
    3768: 'hotel',
    3769: 'hotel',
    3770: 'hotel',
    3771: 'hotel',
    3772: 'hotel',
    3773: 'hotel',
    3774: 'hotel',
    3775: 'hotel',
    3776: 'hotel',
    3777: 'hotel',
    3778: 'hotel',
    3779: 'hotel',
    3780: 'hotel',
    3781: 'hotel',
    3782: 'hotel',
    3783: 'hotel',
    3784: 'hotel',
    3785: 'hotel',
    3786: 'hotel',
    3787: 'hotel',
    3788: 'hotel',
    3789: 'hotel',
    3790: 'hotel',
    3816: 'hotel',
    3835: 'hotel',
    4011: 'car',
    4111: 'car',
    4112: 'car',
    4119: 'car',
    4121: 'car',
    4131: 'car',
    4214: 'car',
    4215: 'bus',
    4225: 'default',
    4411: 'boat',
    4457: 'boat',
    4468: 'boat',
    4511: 'airplane',
    4582: 'airplane',
    4722: 'airplane',
    4723: 'airplane',
    4784: 'car',
    4789: 'car',
    4812: 'car',
    4814: 'telephone',
    4815: 'telephone',
    4816: 'computer',
    4821: 'money',
    4829: 'money',
    4899: 'television',
    4900: 'gas',
    5013: 'car',
    5021: 'default',
    5039: 'repair',
    5044: 'computer',
    5045: 'computer',
    5046: 'default',
    5047: 'medical',
    5051: 'default',
    5065: 'default',
    5072: 'default',
    5074: 'default',
    5085: 'default',
    5094: 'diamond-ring',
    5099: 'default',
    5111: 'default',
    5122: 'medical',
    5131: 'default',
    5137: 'shirt',
    5139: 'shoes',
    5169: 'gas',
    5172: 'gas',
    5192: 'books',
    5193: 'plant',
    5198: 'repair',
    5199: 'repair',
    5200: 'repair',
    5211: 'repair',
    5231: 'repair',
    5251: 'default',
    5261: 'plant',
    5271: 'bus',
    5300: 'purchase',
    5309: 'purchase',
    5310: 'purchase',
    5311: 'purchase',
    5331: 'purchase',
    5399: 'purchase',
    5411: 'food',
    5422: 'food',
    5441: 'food',
    5451: 'food',
    5462: 'food',
    5499: 'food',
    5511: 'car',
    5521: 'car',
    5531: 'car',
    5532: 'car',
    5533: 'car',
    5541: 'gas',
    5542: 'gas',
    5551: 'boat',
    5561: 'motorcycle',
    5571: 'motorcycle',
    5592: 'default',
    5598: 'default',
    5599: 'car',
    5611: 'shirt',
    5621: 'shirt',
    5631: 'shirt',
    5641: 'shirt',
    5651: 'shirt',
    5655: 'shirt',
    5661: 'shoes',
    5681: 'default',
    5691: 'shirt',
    5697: 'default',
    5698: 'default',
    5699: 'default',
    5712: 'default',
    5713: 'default',
    5714: 'default',
    5718: 'default',
    5719: 'default',
    5722: 'default',
    5732: 'computer',
    5733: 'music',
    5734: 'computer',
    5735: 'music',
    5811: 'food',
    5812: 'food',
    5813: 'cocktail',
    5814: 'food',
    5815: 'books',
    5816: 'computer',
    5817: 'default',
    5818: 'default',
    5832: 'default',
    5912: 'medical',
    5921: 'cocktail',
    5931: 'default',
    5932: 'default',
    5933: 'default',
    5935: 'default',
    5937: 'default',
    5940: 'bicycle',
    5941: 'bicycle',
    5942: 'books',
    5943: 'default',
    5944: 'clock',
    5945: 'toy',
    5946: 'camera',
    5947: 'default',
    5948: 'default',
    5949: 'default',
    5950: 'default',
    5960: 'default',
    5961: 'mail',
    5962: 'telephone',
    5963: 'default',
    5964: 'telephone',
    5965: 'telephone',
    5966: 'telephone',
    5967: 'telephone',
    5968: 'telephone',
    5969: 'telephone',
    5970: 'art',
    5971: 'art',
    5972: 'coins',
    5973: 'default',
    5975: 'default',
    5976: 'default',
    5977: 'default',
    5978: 'default',
    5983: 'gas',
    5992: 'plant',
    5993: 'default',
    5994: 'newspaper',
    5995: 'pet',
    5996: 'cocktail',
    5997: 'purchase',
    5998: 'tent',
    5999: 'money',
    6010: 'money',
    6011: 'money',
    6012: 'money',
    6051: 'money',
    6211: 'money',
    6300: 'money',
    6381: 'money',
    6399: 'repair',
    6513: 'repair',
    7011: 'hotel',
    7012: 'hotel',
    7032: 'park',
    7033: 'park',
    7210: 'shirt',
    7211: 'shirt',
    7216: 'shirt',
    7217: 'default',
    7221: 'camera',
    7230: 'scissors',
    7251: 'shoe',
    7261: 'sadface',
    7273: 'smiley-face',
    7276: 'money',
    7277: 'people',
    7278: 'people',
    7296: 'shirt',
    7297: 'smiley-face',
    7298: 'smiley-face',
    7299: 'default',
    7311: 'default',
    7321: 'default',
    7332: 'computer',
    7333: 'camera',
    7338: 'computer',
    7339: 'people',
    7342: 'bug',
    7349: 'default',
    7361: 'people',
    7372: 'computer',
    7375: 'computer',
    7379: 'computer',
    7392: 'people',
    7393: 'search',
    7394: 'default',
    7395: 'car',
    7399: 'car',
    7511: 'truck',
    7512: 'car',
    7513: 'truck',
    7519: 'truck',
    7523: 'car',
    7531: 'car',
    7534: 'car',
    7535: 'car',
    7538: 'car',
    7542: 'car',
    7549: 'truck',
    7622: 'television',
    7623: 'default',
    7629: 'default',
    7631: 'watch',
    7641: 'furniture',
    7692: 'default',
    7699: 'default',
    7800: 'money',
    7801: 'money',
    7802: 'money',
    7829: 'money',
    7832: 'film',
    7841: 'film',
    7911: 'music',
    7922: 'ticket',
    7929: 'ticket',
    7932: 'music',
    7933: 'bowling',
    7941: 'football',
    7991: 'people',
    7992: 'golf',
    7993: 'game',
    7994: 'game',
    7995: 'coins',
    7996: 'ticket',
    7997: 'money',
    7998: 'ticket',
    7999: 'people',
    8011: 'medical',
    8021: 'medical',
    8031: 'medical',
    8041: 'medical',
    8042: 'medical',
    8043: 'medical',
    8044: 'medical',
    8049: 'medical',
    8050: 'medical',
    8062: 'medical',
    8071: 'medical',
    8099: 'medical',
    8111: 'law',
    8211: 'books',
    8220: 'books',
    8241: 'books',
    8244: 'books',
    8249: 'books',
    8299: 'people',
    8351: 'people',
    8398: 'people',
    8641: 'people',
    8651: 'people',
    8661: 'people',
    8675: 'car',
    8699: 'people',
    8734: 'medical',
    8911: 'tree',
    8931: 'books',
    8999: 'suitcase',
    9211: 'law',
    9222: 'law',
    9223: 'law',
    9311: 'law',
    9399: 'default',
    9402: 'mail',
    9405: 'default',
    9700: 'default',
    9701: 'default',
    9702: 'default',
    9950: 'default',
    bp001: 'bitcoin-topup',
    bp002: 'default'
};
//# sourceMappingURL=tkcoin-card.js.map

/***/ }),

/***/ 209:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TimeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let TimeProvider = class TimeProvider {
    constructor() { }
    withinSameMonth(time1, time2) {
        if (!time1 || !time2)
            return false;
        let date1 = new Date(time1);
        let date2 = new Date(time2);
        return this.getMonthYear(date1) === this.getMonthYear(date2);
    }
    withinPastDay(time) {
        let now = new Date();
        let date = new Date(time);
        return now.getTime() - date.getTime() < 1000 * 60 * 60 * 24;
    }
    isDateInCurrentMonth(date) {
        let now = new Date();
        return this.getMonthYear(now) === this.getMonthYear(date);
    }
    getMonthYear(date) {
        return `${date.getMonth()}-${date.getFullYear()}`;
    }
};
TimeProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], TimeProvider);

//# sourceMappingURL=time.js.map

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExternalLinkProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent__ = __webpack_require__(784);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__electron_electron__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__popup_popup__ = __webpack_require__(25);



// providers






let ExternalLinkProvider = class ExternalLinkProvider {
    constructor(popupProvider, logger, platformProvider, electronProvider, events) {
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.electronProvider = electronProvider;
        this.events = events;
        this.logger.debug('ExternalLinkProvider initialized');
    }
    restoreHandleOpenURL(old) {
        setTimeout(() => {
            window.handleOpenURL = old;
        }, 500);
    }
    open(url, optIn, title, message, okText, cancelText) {
        return new Promise(resolve => {
            if (optIn) {
                this.popupProvider
                    .ionicConfirm(title, message, okText, cancelText)
                    .then((res) => {
                    this.openBrowser(res, url);
                    resolve();
                });
            }
            else {
                this.openBrowser(true, url);
                resolve();
            }
        });
    }
    openBrowser(res, url) {
        let old = window.handleOpenURL;
        // Ignore external URLs: avoid opening action sheet
        window.handleOpenURL = url => {
            this.logger.debug('Skip: ' + url);
        };
        if (res) {
            if (this.platformProvider.isElectron) {
                this.electronProvider.openExternalLink(url);
            }
            else {
                // workaround for an existing cordova inappbrowser plugin issue - redirecting events back to the iab ref
                const w = this.platformProvider.isCordova
                    ? cordova.InAppBrowser.open(url, '_system')
                    : window.open(url, '_system');
                __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].fromEvent(w, 'message').subscribe(e => this.events.publish('iab_message_update', e));
            }
        }
        this.restoreHandleOpenURL(old);
    }
};
ExternalLinkProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__electron_electron__["a" /* ElectronProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], ExternalLinkProvider);

//# sourceMappingURL=external-link.js.map

/***/ }),

/***/ 216:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(73);
var BufferUtil = __webpack_require__(48);

var EC = __webpack_require__(54).ec;
var ec = new EC('secp256k1');
var ecPoint = ec.curve.point.bind(ec.curve);
var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);

/**
 *
 * Instantiate a valid secp256k1 Point from the X and Y coordinates.
 *
 * @param {BN|String} x - The X coordinate
 * @param {BN|String} y - The Y coordinate
 * @link https://github.com/indutny/elliptic
 * @augments elliptic.curve.point
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 * @constructor
 */
var Point = function Point(x, y, isRed) {
  try {
    var point = ecPoint(x, y, isRed);
  } catch (e) {
    throw new Error('Invalid Point');
  }
  point.validate();
  return point;
};

Point.prototype = Object.getPrototypeOf(ec.curve.point());

/**
 *
 * Instantiate a valid secp256k1 Point from only the X coordinate
 *
 * @param {boolean} odd - If the Y coordinate is odd
 * @param {BN|String} x - The X coordinate
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 */
Point.fromX = function fromX(odd, x){
  try {
    var point = ecPointFromX(x, odd);
  } catch (e) {
    throw new Error('Invalid X');
  }
  point.validate();
  return point;
};

/**
 *
 * Will return a secp256k1 ECDSA base point.
 *
 * @link https://en.bitcoin.it/wiki/Secp256k1
 * @returns {Point} An instance of the base point.
 */
Point.getG = function getG() {
  return ec.curve.g;
};

/**
 *
 * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.
 *
 * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys
 * @returns {BN} A BN instance of the number of points on the curve
 */
Point.getN = function getN() {
  return new BN(ec.curve.n.toArray());
};

Point._getX = Point.prototype.getX;
/**
 *
 * Will return the X coordinate of the Point
 *
 * @returns {BN} A BN instance of the X coordinate
 */
Point.getX = function getX() {
  return new BN(this._getX().toArray());
};

Point._getY = Point.prototype.getY;

/**
 *
 * Will return the Y coordinate of the Point
 *
 * @returns {BN} A BN instance of the Y coordinate
 */
Point.getY = function getY() {
  return new BN(this._getY().toArray());
};

/**
 *
 * Will determine if the point is valid
 *
 * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
 * @param {Point} An instance of Point
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of the same Point
 */
Point.prototype.validate = function validate() {

  if (this.isInfinity()){
    throw new Error('Point cannot be equal to Infinity');
  }

  var p2;
  try {
    p2 = ecPointFromX(this.getX(), this.getY().isOdd());
  } catch (e) {
    throw new Error('Point does not lie on the curve');
  }

  if (p2.y.cmp(this.y) !== 0) {
    throw new Error('Invalid y value for curve.');
  }


  //todo: needs test case
  if (!(this.mul(Point.getN()).isInfinity())) {
    throw new Error('Point times N must be infinity');
  }

  return this;

};

Point.pointToCompressed = function pointToCompressed(point) {
  var xbuf = point.getX().toBuffer({size: 32});
  var ybuf = point.getY().toBuffer({size: 32});

  var prefix;
  var odd = ybuf[ybuf.length - 1] % 2;
  if (odd) {
    prefix = Buffer.from([0x03]);
  } else {
    prefix = Buffer.from([0x02]);
  }
  return BufferUtil.concat([prefix, xbuf]);
};

module.exports = Point;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 217:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(75);
var BufferUtil = __webpack_require__(49);

var EC = __webpack_require__(54).ec;
var ec = new EC('secp256k1');
var ecPoint = ec.curve.point.bind(ec.curve);
var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);

/**
 *
 * Instantiate a valid secp256k1 Point from the X and Y coordinates.
 *
 * @param {BN|String} x - The X coordinate
 * @param {BN|String} y - The Y coordinate
 * @link https://github.com/indutny/elliptic
 * @augments elliptic.curve.point
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 * @constructor
 */
var Point = function Point(x, y, isRed) {
  try {
    var point = ecPoint(x, y, isRed);
  } catch (e) {
    throw new Error('Invalid Point');
  }
  point.validate();
  return point;
};

Point.prototype = Object.getPrototypeOf(ec.curve.point());

/**
 *
 * Instantiate a valid secp256k1 Point from only the X coordinate
 *
 * @param {boolean} odd - If the Y coordinate is odd
 * @param {BN|String} x - The X coordinate
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of Point
 */
Point.fromX = function fromX(odd, x){
  try {
    var point = ecPointFromX(x, odd);
  } catch (e) {
    throw new Error('Invalid X');
  }
  point.validate();
  return point;
};

/**
 *
 * Will return a secp256k1 ECDSA base point.
 *
 * @link https://en.bitcoin.it/wiki/Secp256k1
 * @returns {Point} An instance of the base point.
 */
Point.getG = function getG() {
  return ec.curve.g;
};

/**
 *
 * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.
 *
 * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys
 * @returns {BN} A BN instance of the number of points on the curve
 */
Point.getN = function getN() {
  return new BN(ec.curve.n.toArray());
};

Point._getX = Point.prototype.getX;
/**
 *
 * Will return the X coordinate of the Point
 *
 * @returns {BN} A BN instance of the X coordinate
 */
Point.getX = function getX() {
  return new BN(this._getX().toArray());
};

Point._getY = Point.prototype.getY;

/**
 *
 * Will return the Y coordinate of the Point
 *
 * @returns {BN} A BN instance of the Y coordinate
 */
Point.getY = function getY() {
  return new BN(this._getY().toArray());
};

/**
 *
 * Will determine if the point is valid
 *
 * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
 * @param {Point} An instance of Point
 * @throws {Error} A validation error if exists
 * @returns {Point} An instance of the same Point
 */
Point.prototype.validate = function validate() {

  if (this.isInfinity()){
    throw new Error('Point cannot be equal to Infinity');
  }

  var p2;
  try {
    p2 = ecPointFromX(this.getX(), this.getY().isOdd());
  } catch (e) {
    throw new Error('Point does not lie on the curve');
  }

  if (p2.y.cmp(this.y) !== 0) {
    throw new Error('Invalid y value for curve.');
  }


  //todo: needs test case
  if (!(this.mul(Point.getN()).isInfinity())) {
    throw new Error('Point times N must be infinity');
  }

  return this;

};

Point.pointToCompressed = function pointToCompressed(point) {
  var xbuf = point.getX().toBuffer({size: 32});
  var ybuf = point.getY().toBuffer({size: 32});

  var prefix;
  var odd = ybuf[ybuf.length - 1] % 2;
  if (odd) {
    prefix = Buffer.from([0x03]);
  } else {
    prefix = Buffer.from([0x02]);
  }
  return BufferUtil.concat([prefix, xbuf]);
};

module.exports = Point;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 225:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let DomProvider = class DomProvider {
    constructor(componentFactoryResolver, injector, appRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.appRef = appRef;
    }
    appendComponentToBody(component) {
        const componentRef = this.componentFactoryResolver
            .resolveComponentFactory(component)
            .create(this.injector);
        this.appRef.attachView(componentRef.hostView);
        const domElem = componentRef.hostView
            .rootNodes[0];
        this.appendToDom(domElem);
        return componentRef;
    }
    appendToDom(domElem) {
        document.getElementsByTagName('ion-app')[0].appendChild(domElem);
    }
    removeComponent(componentRef) {
        this.appRef.detachView(componentRef.hostView);
        componentRef.destroy();
    }
};
DomProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ComponentFactoryResolver"],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injector"],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ApplicationRef"]])
], DomProvider);

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 226:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguageProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);







let LanguageProvider = class LanguageProvider {
    constructor(logger, translate, configProvider) {
        this.logger = logger;
        this.translate = translate;
        this.configProvider = configProvider;
        this.languages = [
            {
                name: 'English',
                isoCode: 'en'
            },
            {
                name: 'Espaol',
                isoCode: 'es'
            },
            {
                name: 'Franais',
                isoCode: 'fr'
            },
            {
                name: 'Italiano',
                isoCode: 'it'
            },
            {
                name: 'Nederlands',
                isoCode: 'nl'
            },
            {
                name: 'Polski',
                isoCode: 'pl'
            },
            {
                name: 'Deutsch',
                isoCode: 'de'
            },
            {
                name: '',
                isoCode: 'ja',
                useIdeograms: true
            },
            {
                name: '',
                isoCode: 'zh',
                useIdeograms: true
            },
            {
                name: 'P',
                isoCode: 'ru'
            },
            {
                name: 'Portugus',
                isoCode: 'pt'
            }
        ];
        this.logger.debug('LanguageProvider initialized');
        this.translate.onLangChange.subscribe(event => {
            this.logger.info('Setting new default language to: ' + event.lang);
        });
    }
    load() {
        let lang = this.configProvider.get().wallet.settings.defaultLanguage;
        if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](lang))
            this.current = lang;
        else {
            // Get from browser
            const browserLang = this.translate.getBrowserLang();
            this.current = this.getName(browserLang)
                ? browserLang
                : this.getDefault();
        }
        this.logger.info('Default language: ' + this.current);
        this.translate.setDefaultLang(this.current);
        __WEBPACK_IMPORTED_MODULE_6_moment__["locale"](this.current);
    }
    set(lang) {
        this.current = lang;
        this.translate.use(lang);
        __WEBPACK_IMPORTED_MODULE_6_moment__["locale"](lang);
        this.configProvider.set({
            wallet: { settings: { defaultLanguage: lang } }
        });
    }
    getName(lang) {
        return __WEBPACK_IMPORTED_MODULE_5_lodash__["result"](__WEBPACK_IMPORTED_MODULE_5_lodash__["find"](this.languages, {
            isoCode: lang
        }), 'name');
    }
    getDefault() {
        return this.languages[0]['isoCode'];
    }
    getCurrent() {
        return this.current;
    }
    getAvailables() {
        return this.languages;
    }
};
LanguageProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */]])
], LanguageProvider);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 227:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppIdentityProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_bitauth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);



// providers



let AppIdentityProvider = class AppIdentityProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.debug('AppIdentityProvider initialized');
    }
    getIdentity(network, cb) {
        let pubkey;
        let isNew;
        this.persistenceProvider.getAppIdentity(network).then(data => {
            let appIdentity = data || {};
            if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](appIdentity) || (appIdentity && !appIdentity.priv)) {
                isNew = true;
                appIdentity = __WEBPACK_IMPORTED_MODULE_4_bitauth__["generateSin"]();
            }
            try {
                pubkey = __WEBPACK_IMPORTED_MODULE_4_bitauth__["getPublicKeyFromPrivateKey"](appIdentity.priv);
                __WEBPACK_IMPORTED_MODULE_4_bitauth__["getSinFromPublicKey"](pubkey);
                if (isNew)
                    this.persistenceProvider.setAppIdentity(network, appIdentity);
            }
            catch (e) {
                return cb(e);
            }
            return cb(null, appIdentity);
        });
    }
};
AppIdentityProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__["b" /* PersistenceProvider */]])
], AppIdentityProvider);

//# sourceMappingURL=app-identity.js.map

/***/ }),

/***/ 228:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimplexProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__rate_rate__ = __webpack_require__(78);





// providers









const PASSTHROUGH_URI_DEV = 'https://cmgustavo.github.io/website/simplex/';
const PASSTHROUGH_URI_PROD = 'https://bws.tkcoin.org/static/simplex/';
let SimplexProvider = class SimplexProvider {
    constructor(appProvider, configProvider, homeIntegrationsProvider, logger, persistenceProvider, platformProvider, translate, rateProvider, currencyProvider) {
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.rateProvider = rateProvider;
        this.currencyProvider = currencyProvider;
        this.logger.debug('Simplex Provider initialized');
        this.env = __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].name == 'development' ? 'sandbox' : 'production';
        this.passthrough_uri =
            __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].name == 'development' ? PASSTHROUGH_URI_DEV : PASSTHROUGH_URI_PROD;
        this.supportedFiatAltCurrencies = [
            'AED',
            'ARS',
            'AUD',
            'AZN',
            'BGN',
            'BRL',
            'CAD',
            'CHF',
            'CLP',
            'CNY',
            'COP',
            'CRC',
            'CZK',
            'DKK',
            'DOP',
            'EUR',
            'GBP',
            'GEL',
            'HKD',
            'HUF',
            'ILS',
            'INR',
            'JPY',
            'KRW',
            'KZT',
            'MAD',
            'MDL',
            'MXN',
            'MYR',
            'NAD',
            'NGN',
            'NOK',
            'NZD',
            'PEN',
            'PHP',
            'PLN',
            'QAR',
            'RON',
            'RUB',
            'SEK',
            'SGD',
            'TRY',
            'TWD',
            'UAH',
            'USD',
            'UYU',
            'UZS',
            'VND',
            'ZAR'
        ];
        this.supportedCoins = [
            'btc',
            'edu',
            'tik',
            'bch',
            'eth',
            'pax',
            'busd',
            'doge',
            'dai',
            'usdc'
        ];
        this.fiatAmountLimits = {
            min: 50,
            max: 20000
        };
    }
    getSupportedFiatAltCurrencies() {
        return this.supportedFiatAltCurrencies;
    }
    getQuote(wallet, data) {
        data.env = this.env;
        return wallet.simplexGetQuote(data);
    }
    paymentRequest(wallet, data) {
        data.env = this.env;
        return wallet.simplexPaymentRequest(data);
    }
    getCheckoutUrl() {
        return __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].name == 'development'
            ? 'https://sandbox.test-simplexcc.com'
            : 'https://checkout.simplexcc.com';
    }
    getEvents(wallet) {
        let data = {};
        data.env = this.env;
        return wallet.simplexGetEvents(data);
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'simplex',
            title: this.translate.instant('Buy Crypto'),
            icon: 'assets/img/simplex/icon-simplex.png',
            showIcon: true,
            logo: 'assets/img/simplex/logo-simplex-color.svg',
            logoWidth: '110',
            background: 'linear-gradient(to bottom,rgba(60, 63, 69, 1) 0,rgba(45, 47, 51, 1) 100%)',
            page: 'SimplexPage',
            show: !!this.configProvider.get().showIntegration['simplex'],
            type: 'exchange'
        });
    }
    saveSimplex(data, opts) {
        const env = this.env;
        return this.persistenceProvider.getSimplex(env).then(oldData => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](oldData)) {
                oldData = JSON.parse(oldData);
            }
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            let inv = oldData ? oldData : {};
            inv[data.payment_id] = data;
            if (opts && (opts.error || opts.status)) {
                inv[data.payment_id] = __WEBPACK_IMPORTED_MODULE_3_lodash__["assign"](inv[data.payment_id], opts);
            }
            if (opts && opts.remove) {
                delete inv[data.payment_id];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setSimplex(env, inv);
            return Promise.resolve();
        });
    }
    getSimplex() {
        const env = this.env;
        return this.persistenceProvider.getSimplex(env);
    }
    getFiatCurrencyLimits(fiatCurrency, coin) {
        this.fiatAmountLimits.min = this.calculateFiatRate(50, fiatCurrency, coin);
        this.fiatAmountLimits.max = this.calculateFiatRate(20000, fiatCurrency, coin);
        return this.fiatAmountLimits;
    }
    calculateFiatRate(amount, fiatCurrency, cryptoCurrency) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](['USD', 'ARS', 'EUR'], fiatCurrency)) {
            return amount;
        }
        const rateFromFiat = this.rateProvider.fromFiat(amount, 'USD', cryptoCurrency);
        return +this.rateProvider
            .toFiat(rateFromFiat, fiatCurrency, cryptoCurrency)
            .toFixed(2);
    }
    simplexPaymentRequest(wallet, address, quoteData) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.debug('Simplex: creating payment request');
            const profile = yield this.persistenceProvider.getProfile();
            const createdOn = profile && profile.createdOn
                ? __WEBPACK_IMPORTED_MODULE_4_moment__(profile.createdOn).format('YYYY-MM-DDTHH:mm:ss.SSSZ')
                : __WEBPACK_IMPORTED_MODULE_4_moment__().format('YYYY-MM-DDTHH:mm:ss.SSSZ');
            const userAgent = this.platformProvider.getUserAgent();
            const data = {
                account_details: {
                    app_version_id: this.appProvider.info.version,
                    app_install_date: createdOn,
                    app_end_user_id: wallet.id,
                    signup_login: {
                        user_agent: userAgent,
                        timestamp: __WEBPACK_IMPORTED_MODULE_4_moment__().format('YYYY-MM-DDTHH:mm:ss.SSSZ')
                    }
                },
                transaction_details: {
                    payment_details: {
                        quote_id: quoteData.quoteId,
                        fiat_total_amount: {
                            currency: quoteData.currency,
                            amount: quoteData.fiatTotalAmount
                        },
                        requested_digital_amount: {
                            currency: wallet.coin.toUpperCase(),
                            amount: quoteData.cryptoAmount
                        },
                        destination_wallet: {
                            currency: wallet.coin.toUpperCase(),
                            address,
                            tag: ''
                        },
                        original_http_ref_url: 'https://' + this.passthrough_uri
                    }
                }
            };
            this.logger.debug(JSON.stringify(data));
            return this.paymentRequest(wallet, data);
        });
    }
    getPaymentUrl(wallet, quoteData, remoteData) {
        const dataSrc = {
            version: '1',
            partner: remoteData.app_provider_id,
            payment_flow_type: 'wallet',
            return_url_success: this.passthrough_uri +
                'end.html?success=true&paymentId=' +
                remoteData.payment_id +
                '&quoteId=' +
                quoteData.quoteId +
                '&userId=' +
                wallet.id +
                '&returnApp=' +
                this.appProvider.info.name,
            return_url_fail: this.passthrough_uri +
                'end.html?success=false&paymentId=' +
                remoteData.payment_id +
                '&quoteId=' +
                quoteData.quoteId +
                '&userId=' +
                wallet.id +
                '&returnApp=' +
                this.appProvider.info.name,
            quote_id: quoteData.quoteId,
            payment_id: remoteData.payment_id,
            user_id: wallet.id,
            'destination_wallet[address]': remoteData.address,
            'destination_wallet[currency]': this.currencyProvider.getChain(wallet.coin),
            'fiat_total_amount[amount]': quoteData.fiatTotalAmount,
            'fiat_total_amount[currency]': quoteData.currency,
            'digital_total_amount[amount]': quoteData.cryptoAmount,
            'digital_total_amount[currency]': this.currencyProvider.getChain(wallet.coin)
        };
        let str = '';
        for (let key in dataSrc) {
            if (str != '') {
                str += '&';
            }
            str += key + '=' + encodeURIComponent(dataSrc[key]);
        }
        const api_host = this.getCheckoutUrl();
        const url = this.passthrough_uri + '?api_host=' + api_host + '/payments/new/&' + str;
        this.logger.debug('Simplex: ready for payment form submission');
        return url;
    }
};
SimplexProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_10__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_12__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_8__currency_currency__["b" /* CurrencyProvider */]])
], SimplexProvider);

//# sourceMappingURL=simplex.js.map

/***/ }),

/***/ 229:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChangellyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(20);





// providers


let ChangellyProvider = class ChangellyProvider {
    constructor(http, logger, persistenceProvider, translate) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.logger.debug('ChangellyProvider initialized');
        this.env = 'production';
        this.uri = 'https://bws.tkcoin.org/bws/api';
        this.supportedCoins = [
            'btc',
            'edu',
            'tik',
            'bch',
            'eth',
            'pax',
            'usdc',
            'gusd',
            'dai',
            'doge'
        ];
    }
    generateMessageId(walletId) {
        const now = Date.now();
        if (walletId)
            return `${walletId}-${now}`;
        const randomInt = Math.floor(1e8 * Math.random());
        return `${randomInt}-${now}`;
    }
    getCurrencies(full) {
        return new Promise((resolve, reject) => {
            const body = {
                id: this.generateMessageId(),
                full
            };
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/json'
            });
            this.logger.debug('Making a Changelly request with body: ' + JSON.stringify(body));
            this.http
                .post(this.uri + '/v1/service/changelly/getCurrencies', body, {
                headers
            })
                .subscribe((data) => {
                if (data.id && data.id != body.id)
                    return reject('The response does not match the origin of the request');
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    getPairsParams(wallet, data) {
        return new Promise((resolve, reject) => {
            const messageData = {
                id: this.generateMessageId(wallet.walletId),
                coinFrom: data.coinFrom,
                coinTo: data.coinTo
            };
            wallet
                .changellyGetPairsParams(messageData)
                .then(data => {
                if (data.id && data.id != messageData.id)
                    return reject('The response does not match the origin of the request');
                return resolve(data);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getFixRateForAmount(wallet, data) {
        return new Promise((resolve, reject) => {
            const messageData = {
                id: this.generateMessageId(wallet.walletId),
                coinFrom: data.coinFrom,
                coinTo: data.coinTo,
                amountFrom: data.amountFrom
            };
            wallet
                .changellyGetFixRateForAmount(messageData)
                .then(data => {
                if (data.id && data.id != messageData.id)
                    return reject('The response does not match the origin of the request');
                return resolve(data);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createFixTransaction(wallet, data) {
        return new Promise((resolve, reject) => {
            const messageData = {
                id: this.generateMessageId(wallet.walletId),
                coinFrom: data.coinFrom,
                coinTo: data.coinTo,
                addressTo: data.addressTo,
                amountFrom: data.amountFrom,
                fixedRateId: data.fixedRateId,
                refundAddress: data.refundAddress
            };
            wallet
                .changellyCreateFixTransaction(messageData)
                .then(data => {
                if (data.id && data.id != messageData.id)
                    return reject('The response does not match the origin of the request');
                return resolve(data);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getStatus(exchangeTxId, oldStatus) {
        return new Promise((resolve, reject) => {
            const body = {
                id: this.generateMessageId(),
                exchangeTxId
            };
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/json'
            });
            this.logger.debug('Making a Changelly request with body: ' + JSON.stringify(body));
            this.http
                .post(this.uri + '/v1/service/changelly/getStatus', body, {
                headers
            })
                .subscribe((data) => {
                if (data.id && data.id != body.id)
                    return reject('The response does not match the origin of the request');
                data.exchangeTxId = exchangeTxId;
                data.oldStatus = oldStatus;
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    getStatusDetails(status) {
        let statusDescription, statusTitle;
        switch (status) {
            case 'new':
                statusTitle = this.translate.instant('New');
                statusDescription = this.translate.instant('Transaction is waiting for an incoming payment.');
                break;
            case 'waiting':
                statusTitle = this.translate.instant('Waiting');
                statusDescription = this.translate.instant('Transaction is waiting for an incoming payment.');
                break;
            case 'confirming':
                statusTitle = this.translate.instant('Confirming');
                statusDescription = this.translate.instant('Changelly has received payin and is waiting for certain amount of confirmations depending of incoming currency.');
                break;
            case 'exchanging':
                statusTitle = this.translate.instant('Exchanging');
                statusDescription = this.translate.instant('Payment was confirmed and is being exchanged.');
                break;
            case 'sending':
                statusTitle = this.translate.instant('Sending');
                statusDescription = this.translate.instant('Coins are being sent to the recipient address.');
                break;
            case 'finished':
                statusTitle = this.translate.instant('Finished');
                statusDescription = this.translate.instant('Coins were successfully sent to the recipient address.');
                break;
            case 'failed':
                statusTitle = this.translate.instant('Failed');
                statusDescription = this.translate.instant(`Transaction has failed. In most cases, the amount was less than the minimum.`);
                break;
            case 'refunded':
                statusTitle = this.translate.instant('Failed');
                statusDescription = this.translate.instant("Exchange failed and coins were refunded to user's wallet.");
                break;
            case 'hold':
                statusTitle = this.translate.instant('Hold');
                statusDescription = this.translate.instant('Due to AML/KYC procedure, exchange may be delayed.');
                break;
            case 'expired':
                statusTitle = this.translate.instant('Expired');
                statusDescription = this.translate.instant('Payin was not sent within the indicated timeframe.');
                break;
            default:
                statusTitle = null;
                statusDescription = null;
                break;
        }
        return {
            statusTitle,
            statusDescription
        };
    }
    saveChangelly(data, opts) {
        const env = this.env;
        return this.persistenceProvider.getChangelly(env).then(oldData => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](oldData)) {
                oldData = JSON.parse(oldData);
            }
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            let inv = oldData ? oldData : {};
            inv[data.exchangeTxId] = data;
            if (opts && (opts.error || opts.status)) {
                inv[data.exchangeTxId] = __WEBPACK_IMPORTED_MODULE_4_lodash__["assign"](inv[data.exchangeTxId], opts);
            }
            if (opts && opts.remove) {
                delete inv[data.exchangeTxId];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setChangelly(env, inv);
            return Promise.resolve();
        });
    }
    getChangelly() {
        const env = this.env;
        return this.persistenceProvider.getChangelly(env);
    }
};
ChangellyProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], ChangellyProvider);

//# sourceMappingURL=changelly.js.map

/***/ }),

/***/ 23:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_language_language__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__theme_theme__ = __webpack_require__(56);





// providers






let AppProvider = class AppProvider {
    constructor(http, logger, language, config, persistence, file, platformProvider, themeProvider) {
        this.http = http;
        this.logger = logger;
        this.language = language;
        this.config = config;
        this.persistence = persistence;
        this.file = file;
        this.platformProvider = platformProvider;
        this.themeProvider = themeProvider;
        this.info = {};
        this.jsonPathApp = 'assets/appConfig.json';
        this.jsonPathServices = 'assets/externalServices.json';
        this.logger.debug('AppProvider initialized');
    }
    load() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield Promise.all([this.getInfo(), this.loadProviders()]);
        });
    }
    setTotalBalance() {
        this.persistence.getTotalBalance().then(data => {
            if (!data)
                return;
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            this.homeBalance = data;
        });
    }
    getInfo() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            [this.servicesInfo, this.info] = yield Promise.all([
                this.getServicesInfo(),
                this.getAppInfo()
            ]);
            if (this.platformProvider.isCordova) {
                this.info = JSON.parse(this.info);
                this.servicesInfo = JSON.parse(this.servicesInfo);
            }
            this.version = this.formatVersionString();
        });
    }
    formatVersionString() {
        var formattedNumber = this.info.version.replace(/^v/i, '').split('.');
        return {
            major: +formattedNumber[0],
            minor: +formattedNumber[1],
            patch: +formattedNumber[2]
        };
    }
    loadProviders() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.persistence.load();
            yield this.config.load();
            yield this.themeProvider.load();
            yield this.language.load();
        });
    }
    getAppInfo() {
        if (this.platformProvider.isCordova) {
            return this.file.readAsText(this.file.applicationDirectory + 'www/', this.jsonPathApp);
        }
        else {
            return this.http.get(this.jsonPathApp).toPromise();
        }
    }
    getServicesInfo() {
        if (this.platformProvider.isCordova) {
            return this.file.readAsText(this.file.applicationDirectory + 'www/', this.jsonPathServices);
        }
        else {
            return this.http.get(this.jsonPathServices).toPromise();
        }
    }
};
AppProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a" /* File */],
        __WEBPACK_IMPORTED_MODULE_9__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__theme_theme__["a" /* ThemeProvider */]])
], AppProvider);

//# sourceMappingURL=app.js.map

/***/ }),

/***/ 230:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipboardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_electron_electron__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__incoming_data_incoming_data__ = __webpack_require__(126);




// providers




const validDataByCoin = {
    paypro: ['InvoiceUri', 'PayPro', 'TKCoinUri'],
    btc: ['BitcoinUri', 'BitcoinAddress'],
    edu: ['EducoinUri', 'EducoinAddress'],
    tik: ['TKCoinUri', 'TKCoinAddress'],
    bch: ['BitcoinCashUri', 'BitcoinCashAddress'],
    eth: ['EthereumUri', 'EthereumAddress'],
    xrp: ['RippleUri', 'RippleAddress'],
    doge: ['DogecoinUri', 'DogecoinAddress']
};
let ClipboardProvider = class ClipboardProvider {
    constructor(platformProvider, logger, clipboard, electronProvider, incomingDataProvider) {
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.clipboard = clipboard;
        this.electronProvider = electronProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger.debug('ClipboardProvider initialized');
        this.isCordova = this.platformProvider.isCordova;
        this.isElectron = this.platformProvider.isElectron;
    }
    getData() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.isCordova) {
                return this.clipboard.paste();
            }
            else if (this.isElectron) {
                return this.electronProvider.readFromClipboard();
            }
            else {
                let text;
                try {
                    text = navigator.clipboard.readText();
                }
                catch (error) {
                    return Promise.reject('Not supported for this device');
                }
                return text;
            }
        });
    }
    copy(value) {
        if (this.isCordova) {
            this.clipboard.copy(value);
        }
        else if (this.isElectron) {
            this.electronProvider.writeToClipboard(value);
        }
        else {
            throw new Error('Copied to Clipboard using a Web Browser.');
        }
    }
    clear() {
        if (this.isCordova) {
            this.clipboard.copy(null);
        }
        else if (this.isElectron) {
            this.electronProvider.clearClipboard();
        }
    }
    clearClipboardIfValidData(typeArray) {
        this.getData()
            .then(data => {
            const validDataFromClipboard = this.incomingDataProvider.parseData(data);
            if (validDataFromClipboard &&
                typeArray.indexOf(validDataFromClipboard.type) != -1) {
                this.logger.info('Cleaning clipboard data: done');
                this.clear(); // clear clipboard data if exist
            }
        })
            .catch(err => {
            this.logger.debug('Cleaning clipboard data: ', err);
        });
    }
    getValidData(coin) {
        return new Promise(resolve => {
            this.getData()
                .then(data => {
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](data))
                    return resolve();
                const dataFromClipboard = this.incomingDataProvider.parseData(data);
                if (!dataFromClipboard)
                    return resolve();
                // Check crypto/paypro uri
                if (validDataByCoin['paypro'].indexOf(dataFromClipboard.type) > -1 ||
                    validDataByCoin[coin].indexOf(dataFromClipboard.type) > -1) {
                    return resolve(dataFromClipboard.data);
                }
            })
                .catch(err => {
                this.logger.warn('Clipboard Warning: ', err);
                resolve();
            });
        });
    }
};
ClipboardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_4__providers_electron_electron__["a" /* ElectronProvider */],
        __WEBPACK_IMPORTED_MODULE_7__incoming_data_incoming_data__["a" /* IncomingDataProvider */]])
], ClipboardProvider);

//# sourceMappingURL=clipboard.js.map

/***/ }),

/***/ 232:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopayersPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_push_notifications_push_notifications__ = __webpack_require__(143);




// Native

// Providers









let CopayersPage = CopayersPage_1 = class CopayersPage {
    constructor(plt, appProvider, events, logger, navParams, platformProvider, popupProvider, profileProvider, socialSharing, onGoingProcessProvider, translate, pushNotificationsProvider, viewCtrl, keyProvider, configProvider) {
        this.plt = plt;
        this.appProvider = appProvider;
        this.events = events;
        this.logger = logger;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.socialSharing = socialSharing;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.viewCtrl = viewCtrl;
        this.keyProvider = keyProvider;
        this.configProvider = configProvider;
        this.secret = null;
        this.appName = this.appProvider.info.userVisibleName;
        this.appUrl = this.appProvider.info.url;
        this.isCordova = this.platformProvider.isCordova;
        this.copayers = [];
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.canSign = this.wallet.canSign;
        this.useLegacyQrCode = this.configProvider.get().legacyQrCode.show;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CopayersPage');
    }
    ngOnInit() {
        this.subscribeEvents();
        this.events.publish('Local/WalletFocus', {
            walletId: this.wallet.credentials.walletId
        });
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.events.publish('Local/WalletFocus', {
                walletId: this.wallet.credentials.walletId
            });
            this.subscribeEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.unsubscribeEvents();
        });
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.walletUpdate.bind(this));
    }
    unsubscribeEvents() {
        this.events.unsubscribe('Local/WalletUpdate', this.walletUpdate.bind(this));
    }
    close() {
        this.unsubscribeEvents();
        this.viewCtrl.dismiss();
    }
    walletUpdate(opts) {
        if (!opts.finished)
            return;
        if (this.wallet && opts.walletId == this.wallet.id) {
            this.copayers = this.wallet.cachedStatus.wallet.copayers;
            this.secret = this.wallet.cachedStatus.wallet.secret;
            if (this.wallet.cachedStatus.wallet.status == 'complete' &&
                !CopayersPage_1.processed[opts.walletId]) {
                CopayersPage_1.processed[opts.walletId] = true;
                // TODO?
                this.wallet.openWallet(err => {
                    if (err)
                        this.logger.error(err);
                    this.close();
                });
            }
        }
    }
    showDeletePopup() {
        const title = this.translate.instant('Confirm');
        let msg;
        if (!this.canSign) {
            msg = this.translate.instant('Are you sure you want to delete this wallet?');
        }
        msg = this.translate.instant('Are you sure you want to hide this wallet?');
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        if (this.canSign) {
            this.profileProvider.toggleHideWalletFlag(this.wallet.id);
            setTimeout(() => {
                this.close();
            }, 1000);
            return;
        }
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            const keyId = this.wallet.credentials.keyId;
            if (keyId) {
                const keyInUse = this.profileProvider.isKeyInUse(keyId);
                if (!keyInUse) {
                    this.keyProvider.removeKey(keyId);
                }
                else {
                    this.logger.warn('Key was not removed. Still in use');
                }
            }
            setTimeout(() => {
                this.close();
            }, 1000);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            let errorText = this.translate.instant('Error');
            this.popupProvider.ionicAlert(errorText, err.message || err);
        });
    }
    shareAddress() {
        this.socialSharing.share(this.secret);
    }
};
CopayersPage.processed = {};
CopayersPage = CopayersPage_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-copayers',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/copayers/copayers.html"*/'<wide-header-page title="{{ wallet.name }} [{{wallet.m}}-{{wallet.n}}]" hideBackButton="true">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="showDeletePopup()" *ngIf="wallet.notAuthorized || (!wallet.notAuthorized && secret)" ion-button>\n      <span *ngIf="!canSign" translate>Delete</span>\n      <span *ngIf="canSign" translate>Hide</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div *ngIf="!wallet.notAuthorized" class="copayers-header">\n      <div class="copayers-header-content">\n        <div class="title" translate>Wallet Invitation</div>\n        <div class="text" translate>Share this address with the devices joining this account.</div>\n        <div class="text" translate>Each copayer has their own recovery phrase. To recover funds stored in a Shared Wallet you will need the recovery phrase from each copayer.</div>\n      </div>\n    </div>\n    <div class="qr-container" *ngIf="!wallet.notAuthorized && secret">\n      <bp-qr-code *ngIf="!useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ secret }}" contents="{{ secret }}" mask-x-to-y-ratio="1">\n        <img [ngClass]="{\'testnet\': wallet.network === \'testnet\', \'background_xrp\': wallet.coin === \'xrp\'}" src="assets/img/currencies/{{ wallet.coin }}.svg" slot="icon" />\n      </bp-qr-code>\n      <div *ngIf="useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ secret }}">\n        <ngx-qrcode hide-toast="true" qrc-value="{{ secret }}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n      </div>\n\n    </div>\n\n    <div class="white-card" *ngIf="!wallet.notAuthorized && copayers && secret">\n      <span class="title">{{\'Waiting for authorized copayers to join\' | translate}}</span>\n      <div class="timeline-item" *ngFor="let copayer of copayers; let i = index">\n        <div class="timeline-content">\n          <div class="timeline-content-icon">\n            <div class="line" *ngIf="copayers.length < wallet.n">\n              <ion-icon name="checkmark" item-end color="success"></ion-icon>\n            </div>\n          </div>\n          <div class="timeline-content-label ellipsis">\n            <div *ngIf="copayer.id == wallet.copayerId" class="name ellipsis">{{\'Me\'|translate}}</div>\n            <div *ngIf="copayer.id != wallet.copayerId" class="name ellipsis">{{copayer.name}}</div>\n          </div>\n        </div>\n      </div>\n      <div class="timeline-item" *ngIf="!wallet.isComplete() && copayers.length < wallet.n">\n        <div class="timeline-content">\n          <div class="timeline-content-icon">\n            <div class="line no-border">\n              <ion-icon name="ios-time-outline" item-end></ion-icon>\n            </div>\n          </div>\n          <div class="timeline-content-label ellipsis">\n            <div class="name ellipsis">{{\'Waiting\'|translate}}</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <button class="share-button" *ngIf="isCordova && !wallet.notAuthorized" ion-button clear (click)="shareAddress()">\n      {{ \'Share this invitation with your copayers\' | translate }}\n      &rarr;\n    </button>\n\n    <div class="error-msg" *ngIf="wallet.notAuthorized" padding>\n      <h3 class="assertive" translate>Wallet incomplete and broken</h3>\n      <div translate>Delete it and create a new one</div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/copayers/copayers.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */]])
], CopayersPage);

var CopayersPage_1;
//# sourceMappingURL=copayers.js.map

/***/ }),

/***/ 24:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// CONCATENATED MODULE: ./src/providers/currency/coin.ts
const availableCoins = {
    btc: {
        name: 'Bitcoin',
        chain: 'BTC',
        coin: 'btc',
        unitInfo: {
            unitName: 'BTC',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'btc'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'bitcoin', testnet: 'bitcoin' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/btc',
            blockExplorerUrls: 'tkcoin.org/insight/#/BTC/mainnet/',
            blockExplorerUrlsTestnet: 'tkcoin.org/insight/#/BTC/testnet/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#f7931a',
            backgroundColor: '#f7921a',
            gradientBackgroundColor: '#f7921a'
        }
    },
    edu: {
        name: 'Educoin',
        chain: 'EDU',
        coin: 'edu',
        unitInfo: {
            unitName: 'EDU',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'edu'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: true,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'educoin', testnet: 'educoin' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/edu',
            blockExplorerUrls: 'edu.explorer.tkcoin.org/',
            blockExplorerUrlsTestnet: 'explorer.tkcoin.org/insight/#/EDU/testnet/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#ff00f0',
            backgroundColor: '#ff00f0',
            gradientBackgroundColor: '#ff00f0'
        }
    },
    tik: {
        name: 'TKCoin',
        chain: 'TIK',
        coin: 'tik',
        unitInfo: {
            unitName: 'TIK',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'tik'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: true,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'tkcoin', testnet: 'tkcoin' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/tik',
            blockExplorerUrls: 'tik.explorer.tkcoin.org/',
            blockExplorerUrlsTestnet: 'explorer.tkcoin.org/insight/#/TIK/testnet/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#ffddf0',
            backgroundColor: '#ffddf0',
            gradientBackgroundColor: '#ffddf0'
        }
    },
    bch: {
        name: 'Bitcoin Cash',
        chain: 'BCH',
        coin: 'bch',
        unitInfo: {
            unitName: 'BCH',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'bch'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'bitcoincash', testnet: 'bchtest' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/bch',
            blockExplorerUrls: 'tkcoin.org/insight/#/BCH/mainnet/',
            blockExplorerUrlsTestnet: 'tkcoin.org/insight/#/BCH/testnet/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'normal'
        },
        theme: {
            coinColor: '#2fcf6e',
            backgroundColor: '#2fcf6e',
            gradientBackgroundColor: '#2fcf6e'
        }
    },
    eth: {
        name: 'Ethereum',
        chain: 'ETH',
        coin: 'eth',
        unitInfo: {
            unitName: 'ETH',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'eth'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/eth',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#6b71d6',
            backgroundColor: '#1e90ff',
            gradientBackgroundColor: '#1e90ff'
        }
    },
    xrp: {
        name: 'XRP',
        chain: 'XRP',
        coin: 'xrp',
        unitInfo: {
            unitName: 'XRP',
            unitToSatoshi: 1e6,
            unitDecimals: 6,
            unitCode: 'xrp'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'ripple', testnet: 'ripple' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/xrp',
            blockExplorerUrls: 'xrpscan.com/',
            blockExplorerUrlsTestnet: 'test.bithomp.com/explorer/'
        },
        feeInfo: {
            feeUnit: 'drops',
            feeUnitAmount: 1e6,
            blockTime: 0.05,
            maxMerchantFee: 'normal'
        },
        theme: {
            coinColor: '#000000',
            backgroundColor: '#565d6d',
            gradientBackgroundColor: '#565d6d'
        }
    },
    busd: {
        name: 'Binance USD Coin',
        chain: 'ETH',
        coin: 'busd',
        unitInfo: {
            unitName: 'BUSD',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'busd'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/busd',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#f3ba2d',
            backgroundColor: 'rgba(135,206,250,1)',
            gradientBackgroundColor: 'rgba(30,144,255, 0.2)'
        }
    },
    pax: {
        name: 'Paxos Standard',
        chain: 'ETH',
        coin: 'pax',
        unitInfo: {
            unitName: 'PAX',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'pax'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/pax',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#e6f3f9',
            backgroundColor: '#00845d',
            gradientBackgroundColor: '#00845d'
        }
    },
    usdc: {
        name: 'USD Coin',
        chain: 'ETH',
        coin: 'usdc',
        unitInfo: {
            unitName: 'USDC',
            unitToSatoshi: 1e6,
            unitDecimals: 6,
            unitCode: 'usdc'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/usdc',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#2775ca',
            backgroundColor: '#2775c9',
            gradientBackgroundColor: '#2775c9'
        }
    },
    gusd: {
        name: 'Gemini Dollar',
        chain: 'ETH',
        coin: 'gusd',
        unitInfo: {
            unitName: 'GUSD',
            unitToSatoshi: 1e2,
            unitDecimals: 2,
            unitCode: 'gusd'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/gusd',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#00ddfa',
            backgroundColor: '#00dcfa',
            gradientBackgroundColor: '#00dcfa'
        }
    },
    dai: {
        name: 'DAI',
        chain: 'ETH',
        coin: 'dai',
        unitInfo: {
            unitName: 'DAI',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'dai'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/gusd',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#00ddfa',
            backgroundColor: '#00dcfa',
            gradientBackgroundColor: '#00dcfa' // TODO: change to proper color after beta
        }
    },
    wbtc: {
        name: 'Wrapped Bitcoin',
        chain: 'ETH',
        coin: 'wbtc',
        unitInfo: {
            unitName: 'WBTC',
            unitToSatoshi: 1e8,
            unitDecimals: 8,
            unitCode: 'wbtc'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/btc',
            blockExplorerUrls: 'etherscan.io/',
            blockExplorerUrlsTestnet: 'kovan.etherscan.io/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            coinColor: '#00ddfa',
            backgroundColor: '#00dcfa',
            gradientBackgroundColor: '#00dcfa' // TODO: change to proper color after beta
        }
    },
    doge: {
        name: 'Dogecoin',
        chain: 'DOGE',
        coin: 'doge',
        unitInfo: {
            unitName: 'DOGE',
            unitToSatoshi: 1e8,
            unitDecimals: 8,
            unitCode: 'doge'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'dogecoin', testnet: 'dogecoin' },
            ratesApi: 'https://bws.tkcoin.org/bws/api/v3/fiatrates/doge',
            blockExplorerUrls: 'blockchair.com/',
            blockExplorerUrlsTestnet: 'sochain.com/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1e8,
            blockTime: 10,
            maxMerchantFee: 'normal'
        },
        theme: {
            coinColor: '#d8c172',
            backgroundColor: '#d8c172',
            gradientBackgroundColor: '#d8c172'
        }
    }
};
//# sourceMappingURL=coin.js.map
// CONCATENATED MODULE: ./src/providers/currency/token.ts
const TokenOpts = {
    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': {
        name: 'USD Coin',
        symbol: 'USDC',
        decimal: 6,
        address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
    },
    '0x8e870d67f660d95d5be530380d0ec0bd388289e1': {
        name: 'Paxos Standard',
        symbol: 'PAX',
        decimal: 18,
        address: '0x8e870d67f660d95d5be530380d0ec0bd388289e1'
    },
    '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd': {
        name: 'Gemini Dollar',
        symbol: 'GUSD',
        decimal: 2,
        address: '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd'
    },
    '0x4fabb145d64652a948d72533023f6e7a623c7c53': {
        name: 'Binance USD Coin',
        symbol: 'BUSD',
        decimal: 18,
        address: '0x4fabb145d64652a948d72533023f6e7a623c7c53'
    },
    '0x6b175474e89094c44da98b954eedeac495271d0f': {
        name: 'Dai',
        symbol: 'DAI',
        decimal: 18,
        address: '0x6b175474e89094c44da98b954eedeac495271d0f'
    },
    '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': {
        name: 'Wrapped Bitcoin',
        symbol: 'WBTC',
        decimal: 9,
        address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599'
    }
};
//# sourceMappingURL=token.js.map
// CONCATENATED MODULE: ./src/providers/currency/currency.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Coin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return currency_CurrencyProvider; });





var Coin;
(function (Coin) {
    Coin["BTC"] = "btc";
    Coin["EDU"] = "edu";
    Coin["TIK"] = "tik";
    Coin["BCH"] = "bch";
    Coin["ETH"] = "eth";
    Coin["XRP"] = "xrp";
    Coin["USDC"] = "usdc";
    Coin["GUSD"] = "gusd";
    Coin["PAX"] = "pax";
    Coin["BUSD"] = "busd";
    Coin["DAI"] = "dai";
    Coin["WBTC"] = "wbtc";
    Coin["DOGE"] = "doge";
})(Coin || (Coin = {}));
let currency_CurrencyProvider = class CurrencyProvider {
    constructor() {
        this.ratesApi = {};
        this.blockExplorerUrls = {};
        this.blockExplorerUrlsTestnet = {};
        this.coinOpts = availableCoins;
        this.availableTokens = Object.values(TokenOpts);
        this.availableCoins = Object.keys(this.coinOpts);
        for (const opts of Object.values(this.coinOpts)) {
            const { paymentInfo, coin } = opts;
            const { blockExplorerUrls, blockExplorerUrlsTestnet, ratesApi } = paymentInfo;
            this.blockExplorerUrls[coin] = blockExplorerUrls;
            this.blockExplorerUrlsTestnet[coin] = blockExplorerUrlsTestnet;
            this.ratesApi[coin] = ratesApi;
        }
    }
    isUtxoCoin(coin) {
        return !!this.coinOpts[coin].properties.isUtxo;
    }
    isSingleAddress(coin) {
        return !!this.coinOpts[coin].properties.singleAddress;
    }
    isSharedCoin(coin) {
        return !!this.coinOpts[coin].properties.hasMultiSig;
    }
    isERCToken(coin) {
        return !!this.coinOpts[coin].properties.isERCToken;
    }
    getLinkedEthWallet(coin, walletId, m) {
        if (!this.coinOpts[coin].properties.isERCToken && coin !== 'eth')
            return null;
        if (coin === 'eth' && m === 1)
            return null;
        return walletId.replace(/-0x.*$/, '');
    }
    isMultiSend(coin) {
        return !!this.coinOpts[coin].properties.hasMultiSend;
    }
    getAvailableCoins() {
        return this.availableCoins;
    }
    getAvailableChains() {
        return lodash["uniq"](lodash["map"](Object.values(this.coinOpts), (opts) => opts.chain.toLowerCase()));
    }
    getAvailableTokens() {
        return this.availableTokens;
    }
    getMultiSigCoins() {
        return this.availableCoins.filter(coin => this.isSharedCoin(coin));
    }
    getCoinName(coin) {
        return this.coinOpts[coin].name;
    }
    getChain(coin) {
        return this.coinOpts[coin].chain;
    }
    getRatesApi() {
        return this.ratesApi;
    }
    getBlockExplorerUrls() {
        return this.blockExplorerUrls;
    }
    getBlockExplorerUrlsTestnet() {
        return this.blockExplorerUrlsTestnet;
    }
    getPaymentCode(coin) {
        return this.coinOpts[coin].paymentInfo.paymentCode;
    }
    getPrecision(coin) {
        return this.coinOpts[coin].unitInfo;
    }
    getProtocolPrefix(coin, network) {
        return this.coinOpts[coin].paymentInfo.protocolPrefix[network];
    }
    getFeeUnits(coin) {
        return this.coinOpts[coin].feeInfo;
    }
    getMaxMerchantFee(coin) {
        return this.coinOpts[coin].feeInfo.maxMerchantFee;
    }
    getTheme(coin) {
        return this.coinOpts[coin].theme;
    }
};
currency_CurrencyProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [])
], currency_CurrencyProvider);

//# sourceMappingURL=currency.js.map

/***/ }),

/***/ 25:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PopupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);





let PopupProvider = class PopupProvider {
    constructor(alertCtrl, logger, translate) {
        this.alertCtrl = alertCtrl;
        this.logger = logger;
        this.translate = translate;
    }
    ionicAlert(title, subTitle, okText) {
        return new Promise(resolve => {
            let alert = this.alertCtrl.create({
                title,
                subTitle,
                enableBackdropDismiss: false,
                buttons: [
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Ok clicked');
                            resolve();
                        }
                    }
                ],
                cssClass: 'alertTheme'
            });
            alert.present();
        });
    }
    ionicConfirm(title, message, okText, cancelText) {
        return new Promise(resolve => {
            let confirm = this.alertCtrl.create({
                title,
                message,
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Disagree clicked');
                            resolve(false);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Agree clicked');
                            resolve(true);
                        }
                    }
                ],
                enableBackdropDismiss: false,
                cssClass: 'alertTheme'
            });
            confirm.present();
        });
    }
    ionicPrompt(title, message, opts, okText, cancelText) {
        return new Promise(resolve => {
            let defaultText = opts && opts.defaultText ? opts.defaultText : null;
            let placeholder = opts && opts.placeholder ? opts.placeholder : null;
            let inputType = opts && opts.type ? opts.type : 'text';
            let cssClass = opts && opts.useDanger ? 'alertDanger' : null;
            let enableBackdropDismiss = !!(opts && opts.enableBackdropDismiss);
            let prompt = this.alertCtrl.create({
                title,
                message,
                cssClass,
                enableBackdropDismiss,
                inputs: [
                    {
                        value: defaultText,
                        placeholder,
                        type: inputType
                    }
                ],
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Cancel clicked');
                            resolve(null);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: data => {
                            this.logger.info('Saved clicked');
                            resolve(data[0]);
                        }
                    }
                ]
            });
            prompt.present();
        });
    }
};
PopupProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], PopupProvider);

//# sourceMappingURL=popup.js.map

/***/ }),

/***/ 266:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var Address = __webpack_require__(140);
var Base58Check = __webpack_require__(267);
var BN = __webpack_require__(73);
var JSUtil = __webpack_require__(59);
var Networks = __webpack_require__(199);
var Point = __webpack_require__(216);
var PublicKey = __webpack_require__(139);
var Random = __webpack_require__(355);
var $ = __webpack_require__(35);

/**
 * Instantiate a PrivateKey from a BN, Buffer and WIF.
 *
 * @example
 * ```javascript
 * // generate a new random key
 * var key = PrivateKey();
 *
 * // get the associated address
 * var address = key.toAddress();
 *
 * // encode into wallet export format
 * var exported = key.toWIF();
 *
 * // instantiate from the exported (and saved) private key
 * var imported = PrivateKey.fromWIF(exported);
 * ```
 *
 * @param {string} data - The encoded data in various formats
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {PrivateKey} A new valid instance of an PrivateKey
 * @constructor
 */
function PrivateKey(data, network) {
  /* jshint maxstatements: 20 */
  /* jshint maxcomplexity: 8 */

  if (!(this instanceof PrivateKey)) {
    return new PrivateKey(data, network);
  }
  if (data instanceof PrivateKey) {
    return data;
  }

  var info = this._classifyArguments(data, network);

  // validation
  if (!info.bn || info.bn.cmp(new BN(0)) === 0){
    throw new TypeError('Number can not be equal to zero, undefined, null or false');
  }
  if (!info.bn.lt(Point.getN())) {
    throw new TypeError('Number must be less than N');
  }
  if (typeof(info.network) === 'undefined') {
    throw new TypeError('Must specify the network ("livenet" or "testnet")');
  }

  JSUtil.defineImmutable(this, {
    bn: info.bn,
    compressed: info.compressed,
    network: info.network
  });

  Object.defineProperty(this, 'publicKey', {
    configurable: false,
    enumerable: true,
    get: this.toPublicKey.bind(this)
  });

  return this;

};

/**
 * Internal helper to instantiate PrivateKey internal `info` object from
 * different kinds of arguments passed to the constructor.
 *
 * @param {*} data
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @return {Object}
 */
PrivateKey.prototype._classifyArguments = function(data, network) {
  /* jshint maxcomplexity: 10 */
  var info = {
    compressed: true,
    network: network ? Networks.get(network) : Networks.defaultNetwork
  };

  // detect type of data
  if (_.isUndefined(data) || _.isNull(data)){
    info.bn = PrivateKey._getRandomBN();
  } else if (data instanceof BN) {
    info.bn = data;
  } else if (data instanceof Buffer || data instanceof Uint8Array) {
    info = PrivateKey._transformBuffer(data, network);
  } else if (data.bn && data.network){
    info = PrivateKey._transformObject(data);
  } else if (!network && Networks.get(data)) {
    info.bn = PrivateKey._getRandomBN();
    info.network = Networks.get(data);
  } else if (typeof(data) === 'string'){
    if (JSUtil.isHexa(data)) {
      info.bn = new BN(Buffer.from(data, 'hex'));
    } else {
      info = PrivateKey._transformWIF(data, network);
    }
  } else {
    throw new TypeError('First argument is an unrecognized data type.');
  }
  return info;
};

/**
 * Internal function to get a random Big Number (BN)
 *
 * @returns {BN} A new randomly generated BN
 * @private
 */
PrivateKey._getRandomBN = function(){
  var condition;
  var bn;
  do {
    var privbuf = Random.getRandomBuffer(32);
    bn = BN.fromBuffer(privbuf);
    condition = bn.lt(Point.getN());
  } while (!condition);
  return bn;
};

/**
 * Internal function to transform a WIF Buffer into a private key
 *
 * @param {Buffer} buf - An WIF string
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformBuffer = function(buf, network) {

  var info = {};

  if (buf.length === 32) {
    return PrivateKey._transformBNBuffer(buf, network);
  }

  info.network = Networks.get(buf[0], 'privatekey');

  if (!info.network) {
    throw new Error('Invalid network');
  }

  if (network && info.network !== Networks.get(network)) {
    throw new TypeError('Private key network mismatch');
  }

  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
    info.compressed = true;
  } else if (buf.length === 1 + 32) {
    info.compressed = false;
  } else {
    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');
  }

  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));

  return info;
};

/**
 * Internal function to transform a BN buffer into a private key
 *
 * @param {Buffer} buf
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {object} an Object with keys: bn, network, and compressed
 * @private
 */
PrivateKey._transformBNBuffer = function(buf, network) {
  var info = {};
  info.network = Networks.get(network) || Networks.defaultNetwork;
  info.bn = BN.fromBuffer(buf);
  info.compressed = false;
  return info;
};

/**
 * Internal function to transform a WIF string into a private key
 *
 * @param {string} buf - An WIF string
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformWIF = function(str, network) {
  return PrivateKey._transformBuffer(Base58Check.decode(str), network);
};

/**
 * Instantiate a PrivateKey from a Buffer with the DER or WIF representation
 *
 * @param {Buffer} arg
 * @param {Network} network
 * @return {PrivateKey}
 */
PrivateKey.fromBuffer = function(arg, network) {
  return new PrivateKey(arg, network);
};

/**
 * Internal function to transform a JSON string on plain object into a private key
 * return this.
 *
 * @param {string} json - A JSON string or plain object
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformObject = function(json) {
  var bn = new BN(json.bn, 'hex');
  var network = Networks.get(json.network);
  return {
    bn: bn,
    network: network,
    compressed: json.compressed
  };
};

/**
 * Instantiate a PrivateKey from a WIF string
 *
 * @param {string} str - The WIF encoded private key string
 * @returns {PrivateKey} A new valid instance of PrivateKey
 */
PrivateKey.fromString = PrivateKey.fromWIF = function(str) {
  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');
  return new PrivateKey(str);
};

/**
 * Instantiate a PrivateKey from a plain JavaScript object
 *
 * @param {Object} obj - The output from privateKey.toObject()
 */
PrivateKey.fromObject = function(obj) {
  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');
  return new PrivateKey(obj);
};

/**
 * Instantiate a PrivateKey from random bytes
 *
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {PrivateKey} A new valid instance of PrivateKey
 */
PrivateKey.fromRandom = function(network) {
  var bn = PrivateKey._getRandomBN();
  return new PrivateKey(bn, network);
};

/**
 * Check if there would be any errors when initializing a PrivateKey
 *
 * @param {string} data - The encoded data in various formats
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {null|Error} An error if exists
 */

PrivateKey.getValidationError = function(data, network) {
  var error;
  try {
    /* jshint nonew: false */
    new PrivateKey(data, network);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Check if the parameters are valid
 *
 * @param {string} data - The encoded data in various formats
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {Boolean} If the private key is would be valid
 */
PrivateKey.isValid = function(data, network){
  if (!data) {
    return false;
  }
  return !PrivateKey.getValidationError(data, network);
};

/**
 * Will output the PrivateKey encoded as hex string
 *
 * @returns {string}
 */
PrivateKey.prototype.toString = function() {
  return this.toBuffer().toString('hex');
};

/**
 * Will output the PrivateKey to a WIF string
 *
 * @returns {string} A WIP representation of the private key
 */
PrivateKey.prototype.toWIF = function() {
  var network = this.network;
  var compressed = this.compressed;

  var buf;
  if (compressed) {
    buf = Buffer.concat([Buffer.from([network.privatekey]),
                         this.bn.toBuffer({size: 32}),
                         Buffer.from([0x01])]);
  } else {
    buf = Buffer.concat([Buffer.from([network.privatekey]),
                         this.bn.toBuffer({size: 32})]);
  }

  return Base58Check.encode(buf);
};

/**
 * Will return the private key as a BN instance
 *
 * @returns {BN} A BN instance of the private key
 */
PrivateKey.prototype.toBigNumber = function(){
  return this.bn;
};

/**
 * Will return the private key as a BN buffer
 *
 * @returns {Buffer} A buffer of the private key
 */
PrivateKey.prototype.toBuffer = function(){
  return this.bn.toBuffer({size: 32});
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Will return the private key as a BN buffer without leading zero padding
 *
 * @returns {Buffer} A buffer of the private key
 */
PrivateKey.prototype.toBufferNoPadding = function() {
  return this.bn.toBuffer();
};

/**
 * Will return the corresponding public key
 *
 * @returns {PublicKey} A public key generated from the private key
 */
PrivateKey.prototype.toPublicKey = function(){
  if (!this._pubkey) {
    this._pubkey = PublicKey.fromPrivateKey(this);
  }
  return this._pubkey;
};

/**
 * Will return an address for the private key
 * @param {Network=} network - optional parameter specifying
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * the desired network for the address
 *
 * @returns {Address} An address generated from the private key
 */
PrivateKey.prototype.toAddress = function(network, type) {
  var pubkey = this.toPublicKey();
  return Address.fromPublicKey(pubkey, network || this.network, type);
};

/**
 * @returns {Object} A plain object representation
 */
PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {
  return {
    bn: this.bn.toString('hex'),
    compressed: this.compressed,
    network: this.network.toString()
  };
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Private key
 */
PrivateKey.prototype.inspect = function() {
  var uncompressed = !this.compressed ? ', uncompressed' : '';
  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';
};

module.exports = PrivateKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 267:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var Base58 = __webpack_require__(352);
var buffer = __webpack_require__(2);
var sha256sha256 = __webpack_require__(74).sha256sha256;

var Base58Check = function Base58Check(obj) {
  if (!(this instanceof Base58Check))
    return new Base58Check(obj);
  if (Buffer.isBuffer(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  } else if (obj) {
    this.set(obj);
  }
};

Base58Check.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this;
};

Base58Check.validChecksum = function validChecksum(data, checksum) {
  if (_.isString(data)) {
    data = Buffer.from(Base58.decode(data));
  }
  if (_.isString(checksum)) {
    checksum =  Buffer.from(Base58.decode(checksum));
  }
  if (!checksum) {
    checksum = data.slice(-4);
    data = data.slice(0, -4);
  }
  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');
};

Base58Check.decode = function(s) {
  if (typeof s !== 'string')
    throw new Error('Input must be a string');

  var buf = Buffer.from(Base58.decode(s));

  if (buf.length < 4)
    throw new Error("Input string too short");

  var data = buf.slice(0, -4);
  var csum = buf.slice(-4);

  var hash = sha256sha256(data);
  var hash4 = hash.slice(0, 4);

  if (csum.toString('hex') !== hash4.toString('hex'))
    throw new Error("Checksum mismatch");

  return data;
};

Base58Check.checksum = function(buffer) {
  return sha256sha256(buffer).slice(0, 4);
};

Base58Check.encode = function(buf) {
  if (!Buffer.isBuffer(buf))
    throw new Error('Input must be a buffer');
  var checkedBuf = Buffer.alloc(buf.length + 4);
  var hash = Base58Check.checksum(buf);
  buf.copy(checkedBuf);
  hash.copy(checkedBuf, buf.length);
  return Base58.encode(checkedBuf);
};

Base58Check.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Base58Check.prototype.fromString = function(str) {
  var buf = Base58Check.decode(str);
  this.buf = buf;
  return this;
};

Base58Check.prototype.toBuffer = function() {
  return this.buf;
};

Base58Check.prototype.toString = function() {
  return Base58Check.encode(this.buf);
};

module.exports = Base58Check;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 268:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
const errors = __webpack_require__(115);
var BufferWriter = __webpack_require__(93);
var buffer = __webpack_require__(2);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);
var Script = __webpack_require__(104);
var Sighash = __webpack_require__(181);
var Output = __webpack_require__(161);

var MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;
var DEFAULT_SEQNUMBER = MAXINT;
var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;
var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
const SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);
const SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);
const SEQUENCE_LOCKTIME_MASK = 0xffff;
const SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds
const SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits 


function Input(params) {
  if (!(this instanceof Input)) {
    return new Input(params);
  }
  if (params) {
    return this._fromObject(params);
  }
}

Input.MAXINT = MAXINT;
Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
Input.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;

Object.defineProperty(Input.prototype, 'script', {
  configurable: false,
  enumerable: true,
  get: function() {
    if (this.isNull()) {
      return null;
    }
    if (!this._script) {
      this._script = new Script(this._scriptBuffer);
      this._script._isInput = true;
    }
    return this._script;
  }
});

Input.fromObject = function(obj) {
  $.checkArgument(_.isObject(obj));
  var input = new Input();
  return input._fromObject(obj);
};

Input.prototype._fromObject = function(params) {
  var prevTxId;
  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {
    prevTxId = Buffer.from(params.prevTxId, 'hex');
  } else {
    prevTxId = params.prevTxId;
  }
  this.witnesses = [];
  this.output = params.output ?
    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;
  this.prevTxId = prevTxId || params.txidbuf;
  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;
  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ?
    (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;
  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {
    throw new errors.Transaction.Input.MissingScript();
  }
  this.setScript(params.scriptBuffer || params.script);
  return this;
};

Input.prototype.toObject = Input.prototype.toJSON = function toObject() {
  var obj = {
    prevTxId: this.prevTxId.toString('hex'),
    outputIndex: this.outputIndex,
    sequenceNumber: this.sequenceNumber,
    script: this._scriptBuffer.toString('hex'),
  };
  // add human readable form if input contains valid script
  if (this.script) {
    obj.scriptString = this.script.toString();
  }
  if (this.output) {
    obj.output = this.output.toObject();
  }
  return obj;
};

Input.fromBufferReader = function(br) {
  var input = new Input();
  input.prevTxId = br.readReverse(32);
  input.outputIndex = br.readUInt32LE();
  input._scriptBuffer = br.readVarLengthBuffer();
  input.sequenceNumber = br.readUInt32LE();
  // TODO: return different classes according to which input it is
  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.
  return input;
};

Input.prototype.toBufferWriter = function(writer) {
  if (!writer) {
    writer = new BufferWriter();
  }
  writer.writeReverse(this.prevTxId);
  writer.writeUInt32LE(this.outputIndex);
  var script = this._scriptBuffer;
  writer.writeVarintNum(script.length);
  writer.write(script);
  writer.writeUInt32LE(this.sequenceNumber);
  return writer;
};

Input.prototype.setScript = function(script) {
  this._script = null;
  if (script instanceof Script) {
    this._script = script;
    this._script._isInput = true;
    this._scriptBuffer = script.toBuffer();
  } else if (JSUtil.isHexa(script)) {
    // hex string script
    this._scriptBuffer = Buffer.from(script, 'hex');
  } else if (_.isString(script)) {
    // human readable string script
    this._script = new Script(script);
    this._script._isInput = true;
    this._scriptBuffer = this._script.toBuffer();
  } else if (BufferUtil.isBuffer(script)) {
    // buffer script
    this._scriptBuffer = Buffer.from(script);
  } else {
    throw new TypeError('Invalid argument type: script');
  }
  return this;
};

/**
 * Retrieve signatures for the provided PrivateKey.
 *
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key to use when signing
 * @param {number} inputIndex - the index of this input in the provided transaction
 * @param {number} sigType - defaults to Signature.SIGHASH_ALL
 * @param {Buffer} addressHash - if provided, don't calculate the hash of the
 *     public key associated with the private key provided
 * @abstract
 */
Input.prototype.getSignatures = function() {
  throw new errors.AbstractMethodInvoked(
    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +
    ' for input: ' + JSON.stringify(this)
  );
};

Input.prototype.getSatoshisBuffer = function() {
  $.checkState(this.output instanceof Output);
  $.checkState(this.output._satoshisBN);
  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();
};


Input.prototype.isFullySigned = function() {
  throw new errors.AbstractMethodInvoked('Input#isFullySigned');
};

Input.prototype.isFinal = function() {
  return this.sequenceNumber !== Input.MAXINT;
};

Input.prototype.addSignature = function() {
  throw new errors.AbstractMethodInvoked('Input#addSignature');
};

Input.prototype.clearSignatures = function() {
  throw new errors.AbstractMethodInvoked('Input#clearSignatures');
};

Input.prototype.hasWitnesses = function() {
  if (this.witnesses && this.witnesses.length > 0) {
    return true;
  }
  return false;
};

Input.prototype.getWitnesses = function() {
  return this.witnesses;
};

Input.prototype.setWitnesses = function(witnesses) {
  this.witnesses = witnesses;
};

Input.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signingMethod = signingMethod || 'ecdsa';
  signature.signature.nhashtype = signature.sigtype;
  return Sighash.verify(
    transaction,
    signature.signature,
    signature.publicKey,
    signature.inputIndex,
    this.output.script,
    signingMethod
  );
};

/**
 * @returns true if this is a coinbase input (represents no input)
 */
Input.prototype.isNull = function() {
  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&
    this.outputIndex === 0xffffffff;
};

Input.prototype._estimateSize = function() {
  return this.toBufferWriter().toBuffer().length;
};


/**
 * Sets sequence number so that transaction is not valid until the desired seconds
 *  since the transaction is mined
 *
 * @param {Number} time in seconds
 * @return {Transaction} this
 */
Input.prototype.lockForSeconds = function(seconds) {
  $.checkArgument(_.isNumber(seconds));
  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {
    throw new errors.Transaction.Input.LockTimeRange();
  }
  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));

  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 
  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;
  return this;
};

/**
 * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined
 *
 * @param {Number} height
 * @return {Transaction} this
 */
Input.prototype.lockUntilBlockHeight = function(heightDiff) {
  $.checkArgument(_.isNumber(heightDiff));
  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {
    throw new errors.Transaction.Input.BlockHeightOutOfRange();
  }
  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0
  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0
  this.sequenceNumber = heightDiff ;
  return this;
};


/**
 *  Returns a semantic version of the input's sequence nLockTime.
 *  @return {Number|Date}
 *  If sequence lock is disabled  it returns null,
 *  if is set to block height lock, returns a block height (number)
 *  else it returns a Date object.
 */
Input.prototype.getLockTime = function() {
  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
    return null;
  }

  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {
    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);
    return seconds;
  } else {
    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;
    return blockHeight;
  }
};




module.exports = Input;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 269:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var inherits = __webpack_require__(9);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);

var PublicKey = __webpack_require__(139);
var errors = __webpack_require__(115);
var Signature = __webpack_require__(103);

/**
 * @desc
 * Wrapper around Signature with fields related to signing a transaction specifically
 *
 * @param {Object|string|TransactionSignature} arg
 * @constructor
 */
function TransactionSignature(arg) {
  if (!(this instanceof TransactionSignature)) {
    return new TransactionSignature(arg);
  }
  if (arg instanceof TransactionSignature) {
    return arg;
  }
  if (_.isObject(arg)) {
    return this._fromObject(arg);
  }
  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');
}
inherits(TransactionSignature, Signature);

TransactionSignature.prototype._fromObject = function(arg) {
  this._checkObjectArgs(arg);
  this.publicKey = new PublicKey(arg.publicKey);
  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');
  this.outputIndex = arg.outputIndex;
  this.inputIndex = arg.inputIndex;
  this.signature = (arg.signature instanceof Signature) ? arg.signature :
                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :
                     Signature.fromString(arg.signature);
  this.sigtype = arg.sigtype;
  return this;
};

TransactionSignature.prototype._checkObjectArgs = function(arg) {
  $.checkArgument(PublicKey(arg.publicKey), 'publicKey');
  $.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex');
  $.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex');
  $.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number');
  $.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number');
  $.checkArgument(arg.signature, 'signature');
  $.checkArgument(arg.prevTxId, 'prevTxId');
  $.checkState(arg.signature instanceof Signature ||
               BufferUtil.isBuffer(arg.signature) ||
               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');
  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||
               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');
  $.checkArgument(arg.sigtype, 'sigtype');
  $.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number');
};

/**
 * Serializes a transaction to a plain JS object
 * @return {Object}
 */
TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {
  return {
    publicKey: this.publicKey.toString(),
    prevTxId: this.prevTxId.toString('hex'),
    outputIndex: this.outputIndex,
    inputIndex: this.inputIndex,
    signature: this.signature.toString(),
    sigtype: this.sigtype
  };
};

/**
 * Builds a TransactionSignature from an object
 * @param {Object} object
 * @return {TransactionSignature}
 */
TransactionSignature.fromObject = function(object) {
  $.checkArgument(object);
  return new TransactionSignature(object);
};

module.exports = TransactionSignature;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 27:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/apple-wallet-ng/dist/index.js
var dist = __webpack_require__(792);
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);

// EXTERNAL MODULE: ./node_modules/@ionic-native/clipboard/index.js
var clipboard = __webpack_require__(320);

// EXTERNAL MODULE: ./node_modules/@ionic-native/device/index.js
var device = __webpack_require__(171);

// EXTERNAL MODULE: ./node_modules/fcm-ng/dist/index.js
var fcm_ng_dist = __webpack_require__(321);
var fcm_ng_dist_default = /*#__PURE__*/__webpack_require__.n(fcm_ng_dist);

// EXTERNAL MODULE: ./node_modules/@ionic-native/file/index.js
var file = __webpack_require__(189);

// EXTERNAL MODULE: ./node_modules/@ionic-native/fingerprint-aio/index.js
var fingerprint_aio = __webpack_require__(793);

// EXTERNAL MODULE: ./node_modules/@ionic-native/launch-review/index.js
var launch_review = __webpack_require__(794);

// EXTERNAL MODULE: ./node_modules/@ionic-native/qr-scanner/index.js
var qr_scanner = __webpack_require__(795);

// EXTERNAL MODULE: ./node_modules/@ionic-native/screen-orientation/index.js
var screen_orientation = __webpack_require__(782);

// EXTERNAL MODULE: ./node_modules/@ionic-native/social-sharing/index.js
var social_sharing = __webpack_require__(147);

// EXTERNAL MODULE: ./node_modules/@ionic-native/splash-screen/index.js
var splash_screen = __webpack_require__(250);

// EXTERNAL MODULE: ./node_modules/@ionic-native/status-bar/index.js
var status_bar = __webpack_require__(319);

// EXTERNAL MODULE: ./node_modules/@ionic-native/toast/index.js
var toast = __webpack_require__(1381);

// EXTERNAL MODULE: ./node_modules/@ionic-native/vibration/index.js
var vibration = __webpack_require__(796);

// EXTERNAL MODULE: ./node_modules/@ionic-native/user-agent/index.js
var user_agent = __webpack_require__(783);

// EXTERNAL MODULE: ./src/providers/action-sheet/action-sheet.ts
var action_sheet = __webpack_require__(30);

// EXTERNAL MODULE: ./src/providers/address-book/address-book.ts
var address_book = __webpack_require__(164);

// EXTERNAL MODULE: ./src/providers/address/address.ts
var address = __webpack_require__(97);

// EXTERNAL MODULE: ./src/providers/analytics/analytics.ts
var analytics = __webpack_require__(68);

// EXTERNAL MODULE: ./src/providers/app-identity/app-identity.ts
var app_identity = __webpack_require__(227);

// EXTERNAL MODULE: ./src/providers/app/app.ts
var app = __webpack_require__(23);

// EXTERNAL MODULE: ./src/providers/apple-wallet/apple-wallet.ts
var apple_wallet = __webpack_require__(944);

// EXTERNAL MODULE: ./src/providers/backup/backup.ts
var backup = __webpack_require__(945);

// EXTERNAL MODULE: ./src/providers/tkcoin-account/tkcoin-account.ts
var tkcoin_account = __webpack_require__(379);

// EXTERNAL MODULE: ./src/providers/tkcoin-card/tkcoin-card.ts
var tkcoin_card = __webpack_require__(208);

// EXTERNAL MODULE: ./src/providers/tkcoin-id/tkcoin-id.ts
var tkcoin_id = __webpack_require__(380);

// EXTERNAL MODULE: ./src/providers/tkcoin/tkcoin.ts
var tkcoin = __webpack_require__(207);

// EXTERNAL MODULE: ./src/providers/buy-crypto/buy-crypto.ts
var buy_crypto = __webpack_require__(288);

// EXTERNAL MODULE: ./src/providers/bwc-error/bwc-error.ts
var bwc_error = __webpack_require__(45);

// EXTERNAL MODULE: ./src/providers/bwc/bwc.ts
var bwc = __webpack_require__(46);

// EXTERNAL MODULE: ./src/providers/changelly/changelly.ts
var changelly = __webpack_require__(229);

// EXTERNAL MODULE: ./src/providers/clipboard/clipboard.ts
var clipboard_clipboard = __webpack_require__(230);

// EXTERNAL MODULE: ./src/providers/coinbase/coinbase.ts
var coinbase = __webpack_require__(165);

// EXTERNAL MODULE: ./src/providers/confetti/confetti.ts
var confetti = __webpack_require__(946);

// EXTERNAL MODULE: ./src/providers/config/config.ts
var config = __webpack_require__(11);

// EXTERNAL MODULE: ./src/providers/currency/currency.ts + 2 modules
var currency = __webpack_require__(24);

// EXTERNAL MODULE: ./src/providers/derivation-path-helper/derivation-path-helper.ts
var derivation_path_helper = __webpack_require__(206);

// EXTERNAL MODULE: ./src/providers/directory/directory.ts
var directory = __webpack_require__(947);

// EXTERNAL MODULE: ./src/providers/dom/dom.ts
var dom = __webpack_require__(225);

// EXTERNAL MODULE: ./src/providers/download/download.ts
var download = __webpack_require__(492);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./src/providers/incoming-data/incoming-data.ts
var incoming_data = __webpack_require__(126);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/persistence/persistence.ts + 3 modules
var persistence = __webpack_require__(20);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// CONCATENATED MODULE: ./src/providers/dynamic-links/dynamic-links.ts








let dynamic_links_DynamicLinksProvider = class DynamicLinksProvider {
    constructor(logger, events, FCMPlugin, incomingDataProvider, platformProvider, persistenceProvider) {
        this.logger = logger;
        this.events = events;
        this.FCMPlugin = FCMPlugin;
        this.incomingDataProvider = incomingDataProvider;
        this.platformProvider = platformProvider;
        this.persistenceProvider = persistenceProvider;
        this.logger.debug('DynamicLinksProvider initialized');
    }
    init() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            let dynLink;
            dynLink = this.platformProvider.isIOS
                ? yield this.onDynamicLink()
                : yield this.getDynamicLink();
            this.logger.debug('Firebase Dynamic Link Data: ', JSON.stringify(dynLink));
            if (dynLink && dynLink.deepLink)
                this.processDeepLink(dynLink.deepLink);
        });
    }
    getDynamicLink() {
        return new Promise(resolve => {
            this.FCMPlugin.getDynamicLink().subscribe(data => {
                if (data && data.deepLink && data.newInstall)
                    this.persistenceProvider.setDynamicLink(data.deepLink);
                resolve(data);
            });
        });
    }
    onDynamicLink() {
        return this.FCMPlugin.onDynamicLink();
    }
    createDynamicLink(params) {
        return this.FCMPlugin.createDynamicLink(params);
    }
    processDeepLink(deepLink) {
        const view = this.incomingDataProvider.getParameterByName('view', deepLink) ||
            'DynamicLink';
        const stateParams = { deepLink: true };
        const nextView = {
            name: view,
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
};
dynamic_links_DynamicLinksProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [logger["a" /* Logger */],
        ionic_angular["f" /* Events */],
        fcm_ng_dist["FCMNG"],
        incoming_data["a" /* IncomingDataProvider */],
        platform["a" /* PlatformProvider */],
        persistence["b" /* PersistenceProvider */]])
], dynamic_links_DynamicLinksProvider);

//# sourceMappingURL=dynamic-links.js.map
// EXTERNAL MODULE: ./src/providers/email-notifications/email-notifications.ts
var email_notifications = __webpack_require__(291);

// EXTERNAL MODULE: ./src/providers/errors/errors.ts
var errors = __webpack_require__(41);

// EXTERNAL MODULE: ./src/providers/exchange-crypto/exchange-crypto.ts
var exchange_crypto = __webpack_require__(382);

// EXTERNAL MODULE: ./src/providers/external-link/external-link.ts
var external_link = __webpack_require__(21);

// EXTERNAL MODULE: ./src/providers/fee/fee.ts
var fee = __webpack_require__(148);

// EXTERNAL MODULE: ./src/providers/feedback/feedback.ts
var feedback = __webpack_require__(948);

// EXTERNAL MODULE: ./src/providers/filter/filter.ts
var filter = __webpack_require__(287);

// EXTERNAL MODULE: ./src/providers/gift-card/gift-card.ts + 1 modules
var gift_card = __webpack_require__(89);

// EXTERNAL MODULE: ./src/providers/home-integrations/home-integrations.ts
var home_integrations = __webpack_require__(79);

// EXTERNAL MODULE: ./src/providers/in-app-browser/in-app-browser.ts
var in_app_browser = __webpack_require__(381);

// EXTERNAL MODULE: ./src/providers/in-app-browser/card.ts
var card = __webpack_require__(290);

// EXTERNAL MODULE: ./src/providers/invoice/invoice.ts
var invoice = __webpack_require__(949);

// EXTERNAL MODULE: ./src/providers/key/key.ts
var key = __webpack_require__(98);

// EXTERNAL MODULE: ./src/providers/language-loader/language-loader.ts
var language_loader = __webpack_require__(950);

// EXTERNAL MODULE: ./src/providers/language/language.ts
var language = __webpack_require__(226);

// EXTERNAL MODULE: ./src/providers/location/location.ts
var location_location = __webpack_require__(383);

// EXTERNAL MODULE: ./src/providers/logs/logs.ts
var logs = __webpack_require__(377);

// EXTERNAL MODULE: ./src/providers/electron/electron.ts
var electron = __webpack_require__(322);

// EXTERNAL MODULE: ./src/providers/merchant/merchant.ts + 1 modules
var merchant = __webpack_require__(386);

// EXTERNAL MODULE: ./src/providers/on-going-process/on-going-process.ts
var on_going_process = __webpack_require__(32);

// EXTERNAL MODULE: ./src/providers/paypro/paypro.ts
var paypro = __webpack_require__(185);

// EXTERNAL MODULE: ./src/providers/popup/popup.ts
var popup = __webpack_require__(25);

// EXTERNAL MODULE: ./src/providers/profile/profile.ts + 1 modules
var profile = __webpack_require__(17);

// EXTERNAL MODULE: ./src/providers/push-notifications/push-notifications.ts
var push_notifications = __webpack_require__(143);

// EXTERNAL MODULE: ./src/providers/rate/rate.ts
var rate = __webpack_require__(78);

// EXTERNAL MODULE: ./src/providers/replace-parameters/replace-parameters.ts
var replace_parameters = __webpack_require__(119);

// EXTERNAL MODULE: ./src/providers/scan/scan.ts
var scan = __webpack_require__(494);

// EXTERNAL MODULE: ./src/providers/simplex/simplex.ts
var simplex = __webpack_require__(228);

// EXTERNAL MODULE: ./src/providers/tab/tab.ts
var tab = __webpack_require__(953);

// EXTERNAL MODULE: ./src/providers/theme/theme.ts
var theme = __webpack_require__(56);

// EXTERNAL MODULE: ./src/providers/time/time.ts
var time = __webpack_require__(209);

// EXTERNAL MODULE: ./src/providers/touchid/touchid.ts
var touchid = __webpack_require__(205);

// EXTERNAL MODULE: ./src/providers/tx-confirm-notification/tx-confirm-notification.ts
var tx_confirm_notification = __webpack_require__(495);

// EXTERNAL MODULE: ./src/providers/tx-format/tx-format.ts
var tx_format = __webpack_require__(85);

// EXTERNAL MODULE: ./src/providers/wallet/wallet.ts
var wallet = __webpack_require__(31);

// EXTERNAL MODULE: ./src/providers/wallet-connect/wallet-connect.ts
var wallet_connect = __webpack_require__(496);

// EXTERNAL MODULE: ./src/providers/wyre/wyre.ts
var wyre = __webpack_require__(289);

// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/http.js
var http = __webpack_require__(51);

// CONCATENATED MODULE: ./src/providers/release/release.ts





let ReleaseProvider = class ReleaseProvider {
    constructor(http, appProvider, logger) {
        this.http = http;
        this.appProvider = appProvider;
        this.logger = logger;
        this.latestReleaseAPIUrl = 'https://bws.tkcoin.org/bws/api/latest-version';
        this.appVersion = this.appProvider.info.version;
    }
    getLatestAppVersion() {
        return new Promise(resolve => {
            this.http.get(this.latestReleaseAPIUrl).subscribe(data => {
                return resolve(data);
            });
        });
    }
    getCurrentAppVersion() {
        return this.appVersion;
    }
    verifyTagFormat(tag) {
        var regex = /^v?\d+\.\d+\.\d+$/i;
        return regex.exec(tag);
    }
    formatTagNumber(tag) {
        var formattedNumber = tag.replace(/^v/i, '').split('.');
        return {
            major: +formattedNumber[0],
            minor: +formattedNumber[1],
            patch: +formattedNumber[2]
        };
    }
    newReleaseAvailable(latestVersion) {
        const currentVersion = this.getCurrentAppVersion();
        if (!this.verifyTagFormat(latestVersion) ||
            !this.verifyTagFormat(currentVersion)) {
            this.logger.error(`Cannot verify the format of version tag. latestVersion ${latestVersion} - currentVersion ${currentVersion}`);
            return false;
        }
        let current = this.formatTagNumber(currentVersion);
        let latest = this.formatTagNumber(latestVersion);
        if (latest.major > current.major) {
            this.logger.debug('Major version is available');
            return true;
        }
        return false;
    }
};
ReleaseProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [http["a" /* HttpClient */],
        app["a" /* AppProvider */],
        logger["a" /* Logger */]])
], ReleaseProvider);

//# sourceMappingURL=release.js.map
// EXTERNAL MODULE: ./src/providers/new-feature-data/new-feature-data.ts
var new_feature_data = __webpack_require__(969);

// EXTERNAL MODULE: ./src/providers/card-phases/card-phases.ts
var card_phases = __webpack_require__(970);

// CONCATENATED MODULE: ./src/providers/index.ts
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "g", function() { return dist["AppleWalletNg"]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "o", function() { return clipboard["a" /* Clipboard */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "v", function() { return device["a" /* Device */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "F", function() { return fcm_ng_dist["FCMNG"]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "I", function() { return file["a" /* File */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "K", function() { return fingerprint_aio["a" /* FingerprintAIO */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "U", function() { return launch_review["a" /* LaunchReview */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_7", function() { return qr_scanner["a" /* QRScanner */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_12", function() { return screen_orientation["a" /* ScreenOrientation */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_14", function() { return social_sharing["a" /* SocialSharing */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_15", function() { return splash_screen["a" /* SplashScreen */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_16", function() { return status_bar["a" /* StatusBar */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_24", function() { return toast["a" /* Toast */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_29", function() { return vibration["a" /* Vibration */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_28", function() { return user_agent["a" /* UserAgent */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "a", function() { return action_sheet["a" /* ActionSheetProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "b", function() { return address_book["a" /* AddressBookProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "c", function() { return address["a" /* AddressProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "d", function() { return analytics["a" /* AnalyticsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "e", function() { return app_identity["a" /* AppIdentityProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "f", function() { return app["a" /* AppProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "h", function() { return apple_wallet["a" /* AppleWalletProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "i", function() { return backup["a" /* BackupProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_17", function() { return tkcoin_account["a" /* TKCoinAccountProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_18", function() { return tkcoin_card["a" /* TKCoinCardProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_19", function() { return tkcoin_id["a" /* TKCoinIdProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_20", function() { return tkcoin["a" /* TKCoinProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "j", function() { return buy_crypto["a" /* BuyCryptoProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "k", function() { return bwc_error["a" /* BwcErrorProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "l", function() { return bwc["a" /* BwcProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "n", function() { return changelly["a" /* ChangellyProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "p", function() { return clipboard_clipboard["a" /* ClipboardProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "q", function() { return coinbase["a" /* CoinbaseProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "r", function() { return confetti["a" /* ConfettiProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "s", function() { return config["a" /* ConfigProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "t", function() { return currency["b" /* CurrencyProvider */]; });
/* unused concated harmony import Coin */
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, false, function() { return currency["a" /* Coin */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "u", function() { return derivation_path_helper["a" /* DerivationPathHelperProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "w", function() { return directory["a" /* DirectoryProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "x", function() { return dom["a" /* DomProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "y", function() { return download["a" /* DownloadProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "z", function() { return dynamic_links_DynamicLinksProvider; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "B", function() { return email_notifications["a" /* EmailNotificationsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "C", function() { return errors["a" /* ErrorsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "D", function() { return exchange_crypto["a" /* ExchangeCryptoProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "E", function() { return external_link["a" /* ExternalLinkProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "G", function() { return fee["a" /* FeeProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "H", function() { return feedback["a" /* FeedbackProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "J", function() { return filter["a" /* FilterProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "L", function() { return gift_card["a" /* GiftCardProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "M", function() { return home_integrations["a" /* HomeIntegrationsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "O", function() { return in_app_browser["a" /* InAppBrowserProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "N", function() { return card["a" /* IABCardProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "P", function() { return incoming_data["a" /* IncomingDataProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Q", function() { return invoice["a" /* InvoiceProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "R", function() { return key["a" /* KeyProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "S", function() { return language_loader["a" /* LanguageLoader */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "T", function() { return language["a" /* LanguageProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "V", function() { return location_location["a" /* LocationProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "W", function() { return logger["a" /* Logger */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "X", function() { return logs["a" /* LogsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "A", function() { return electron["a" /* ElectronProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Y", function() { return merchant["a" /* MerchantProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_0", function() { return on_going_process["a" /* OnGoingProcessProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_1", function() { return paypro["a" /* PayproProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_2", function() { return persistence["b" /* PersistenceProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_3", function() { return platform["a" /* PlatformProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_4", function() { return popup["a" /* PopupProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_5", function() { return profile["a" /* ProfileProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_6", function() { return push_notifications["a" /* PushNotificationsProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_8", function() { return rate["b" /* RateProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_10", function() { return replace_parameters["a" /* ReplaceParametersProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_11", function() { return scan["a" /* ScanProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_13", function() { return simplex["a" /* SimplexProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_21", function() { return tab["a" /* TabProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_22", function() { return theme["a" /* ThemeProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_23", function() { return time["a" /* TimeProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_25", function() { return touchid["a" /* TouchIdProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_26", function() { return tx_confirm_notification["a" /* TxConfirmNotificationProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_27", function() { return tx_format["a" /* TxFormatProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_31", function() { return wallet["a" /* WalletProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_30", function() { return wallet_connect["a" /* WalletConnectProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_32", function() { return wyre["a" /* WyreProvider */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_9", function() { return ReleaseProvider; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Z", function() { return new_feature_data["a" /* NewFeatureData */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "m", function() { return card_phases["a" /* CardPhasesProvider */]; });
// import { from } from 'rxjs/observable/from';
/* Native modules */















/* Providers */






































































//# sourceMappingURL=index.js.map

/***/ }),

/***/ 270:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var Address = __webpack_require__(142);
var Base58Check = __webpack_require__(271);
var BN = __webpack_require__(75);
var JSUtil = __webpack_require__(60);
var Networks = __webpack_require__(200);
var Point = __webpack_require__(217);
var PublicKey = __webpack_require__(141);
var Random = __webpack_require__(362);
var $ = __webpack_require__(36);

/**
 * Instantiate a PrivateKey from a BN, Buffer and WIF.
 *
 * @example
 * ```javascript
 * // generate a new random key
 * var key = PrivateKey();
 *
 * // get the associated address
 * var address = key.toAddress();
 *
 * // encode into wallet export format
 * var exported = key.toWIF();
 *
 * // instantiate from the exported (and saved) private key
 * var imported = PrivateKey.fromWIF(exported);
 * ```
 *
 * @param {string} data - The encoded data in various formats
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {PrivateKey} A new valid instance of an PrivateKey
 * @constructor
 */
function PrivateKey(data, network) {
  /* jshint maxstatements: 20 */
  /* jshint maxcomplexity: 8 */

  if (!(this instanceof PrivateKey)) {
    return new PrivateKey(data, network);
  }
  if (data instanceof PrivateKey) {
    return data;
  }

  var info = this._classifyArguments(data, network);

  // validation
  if (!info.bn || info.bn.cmp(new BN(0)) === 0){
    throw new TypeError('Number can not be equal to zero, undefined, null or false');
  }
  if (!info.bn.lt(Point.getN())) {
    throw new TypeError('Number must be less than N');
  }
  if (typeof(info.network) === 'undefined') {
    throw new TypeError('Must specify the network ("livenet" or "testnet")');
  }

  JSUtil.defineImmutable(this, {
    bn: info.bn,
    compressed: info.compressed,
    network: info.network
  });

  Object.defineProperty(this, 'publicKey', {
    configurable: false,
    enumerable: true,
    get: this.toPublicKey.bind(this)
  });

  return this;

};

/**
 * Internal helper to instantiate PrivateKey internal `info` object from
 * different kinds of arguments passed to the constructor.
 *
 * @param {*} data
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @return {Object}
 */
PrivateKey.prototype._classifyArguments = function(data, network) {
  /* jshint maxcomplexity: 10 */
  var info = {
    compressed: true,
    network: network ? Networks.get(network) : Networks.defaultNetwork
  };

  // detect type of data
  if (_.isUndefined(data) || _.isNull(data)){
    info.bn = PrivateKey._getRandomBN();
  } else if (data instanceof BN) {
    info.bn = data;
  } else if (data instanceof Buffer || data instanceof Uint8Array) {
    info = PrivateKey._transformBuffer(data, network);
  } else if (data.bn && data.network){
    info = PrivateKey._transformObject(data);
  } else if (!network && Networks.get(data)) {
    info.bn = PrivateKey._getRandomBN();
    info.network = Networks.get(data);
  } else if (typeof(data) === 'string'){
    if (JSUtil.isHexa(data)) {
      info.bn = new BN(Buffer.from(data, 'hex'));
    } else {
      info = PrivateKey._transformWIF(data, network);
    }
  } else {
    throw new TypeError('First argument is an unrecognized data type.');
  }
  return info;
};

/**
 * Internal function to get a random Big Number (BN)
 *
 * @returns {BN} A new randomly generated BN
 * @private
 */
PrivateKey._getRandomBN = function(){
  var condition;
  var bn;
  do {
    var privbuf = Random.getRandomBuffer(32);
    bn = BN.fromBuffer(privbuf);
    condition = bn.lt(Point.getN());
  } while (!condition);
  return bn;
};

/**
 * Internal function to transform a WIF Buffer into a private key
 *
 * @param {Buffer} buf - An WIF string
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformBuffer = function(buf, network) {

  var info = {};

  if (buf.length === 32) {
    return PrivateKey._transformBNBuffer(buf, network);
  }

  info.network = Networks.get(buf[0], 'privatekey');

  if (!info.network) {
    throw new Error('Invalid network');
  }

  if (network && info.network !== Networks.get(network)) {
    throw new TypeError('Private key network mismatch');
  }

  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
    info.compressed = true;
  } else if (buf.length === 1 + 32) {
    info.compressed = false;
  } else {
    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');
  }

  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));

  return info;
};

/**
 * Internal function to transform a BN buffer into a private key
 *
 * @param {Buffer} buf
 * @param {Network|string=} network - a {@link Network} object, or a string with the network name
 * @returns {object} an Object with keys: bn, network, and compressed
 * @private
 */
PrivateKey._transformBNBuffer = function(buf, network) {
  var info = {};
  info.network = Networks.get(network) || Networks.defaultNetwork;
  info.bn = BN.fromBuffer(buf);
  info.compressed = false;
  return info;
};

/**
 * Internal function to transform a WIF string into a private key
 *
 * @param {string} buf - An WIF string
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformWIF = function(str, network) {
  return PrivateKey._transformBuffer(Base58Check.decode(str), network);
};

/**
 * Instantiate a PrivateKey from a Buffer with the DER or WIF representation
 *
 * @param {Buffer} arg
 * @param {Network} network
 * @return {PrivateKey}
 */
PrivateKey.fromBuffer = function(arg, network) {
  return new PrivateKey(arg, network);
};

/**
 * Internal function to transform a JSON string on plain object into a private key
 * return this.
 *
 * @param {string} json - A JSON string or plain object
 * @returns {Object} An object with keys: bn, network and compressed
 * @private
 */
PrivateKey._transformObject = function(json) {
  var bn = new BN(json.bn, 'hex');
  var network = Networks.get(json.network);
  return {
    bn: bn,
    network: network,
    compressed: json.compressed
  };
};

/**
 * Instantiate a PrivateKey from a WIF string
 *
 * @param {string} str - The WIF encoded private key string
 * @returns {PrivateKey} A new valid instance of PrivateKey
 */
PrivateKey.fromString = PrivateKey.fromWIF = function(str) {
  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');
  return new PrivateKey(str);
};

/**
 * Instantiate a PrivateKey from a plain JavaScript object
 *
 * @param {Object} obj - The output from privateKey.toObject()
 */
PrivateKey.fromObject = function(obj) {
  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');
  return new PrivateKey(obj);
};

/**
 * Instantiate a PrivateKey from random bytes
 *
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {PrivateKey} A new valid instance of PrivateKey
 */
PrivateKey.fromRandom = function(network) {
  var bn = PrivateKey._getRandomBN();
  return new PrivateKey(bn, network);
};

/**
 * Check if there would be any errors when initializing a PrivateKey
 *
 * @param {string} data - The encoded data in various formats
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {null|Error} An error if exists
 */

PrivateKey.getValidationError = function(data, network) {
  var error;
  try {
    /* jshint nonew: false */
    new PrivateKey(data, network);
  } catch (e) {
    error = e;
  }
  return error;
};

/**
 * Check if the parameters are valid
 *
 * @param {string} data - The encoded data in various formats
 * @param {string=} network - Either "livenet" or "testnet"
 * @returns {Boolean} If the private key is would be valid
 */
PrivateKey.isValid = function(data, network){
  if (!data) {
    return false;
  }
  return !PrivateKey.getValidationError(data, network);
};

/**
 * Will output the PrivateKey encoded as hex string
 *
 * @returns {string}
 */
PrivateKey.prototype.toString = function() {
  return this.toBuffer().toString('hex');
};

/**
 * Will output the PrivateKey to a WIF string
 *
 * @returns {string} A WIP representation of the private key
 */
PrivateKey.prototype.toWIF = function() {
  var network = this.network;
  var compressed = this.compressed;

  var buf;
  if (compressed) {
    buf = Buffer.concat([Buffer.from([network.privatekey]),
                         this.bn.toBuffer({size: 32}),
                         Buffer.from([0x01])]);
  } else {
    buf = Buffer.concat([Buffer.from([network.privatekey]),
                         this.bn.toBuffer({size: 32})]);
  }

  return Base58Check.encode(buf);
};

/**
 * Will return the private key as a BN instance
 *
 * @returns {BN} A BN instance of the private key
 */
PrivateKey.prototype.toBigNumber = function(){
  return this.bn;
};

/**
 * Will return the private key as a BN buffer
 *
 * @returns {Buffer} A buffer of the private key
 */
PrivateKey.prototype.toBuffer = function(){
  return this.bn.toBuffer({size: 32});
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Will return the private key as a BN buffer without leading zero padding
 *
 * @returns {Buffer} A buffer of the private key
 */
PrivateKey.prototype.toBufferNoPadding = function() {
  return this.bn.toBuffer();
};

/**
 * Will return the corresponding public key
 *
 * @returns {PublicKey} A public key generated from the private key
 */
PrivateKey.prototype.toPublicKey = function(){
  if (!this._pubkey) {
    this._pubkey = PublicKey.fromPrivateKey(this);
  }
  return this._pubkey;
};

/**
 * Will return an address for the private key
 * @param {Network=} network - optional parameter specifying
 * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'
 * the desired network for the address
 *
 * @returns {Address} An address generated from the private key
 */
PrivateKey.prototype.toAddress = function(network, type) {
  var pubkey = this.toPublicKey();
  return Address.fromPublicKey(pubkey, network || this.network, type);
};

/**
 * @returns {Object} A plain object representation
 */
PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {
  return {
    bn: this.bn.toString('hex'),
    compressed: this.compressed,
    network: this.network.toString()
  };
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Private key
 */
PrivateKey.prototype.inspect = function() {
  var uncompressed = !this.compressed ? ', uncompressed' : '';
  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';
};

module.exports = PrivateKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 271:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var Base58 = __webpack_require__(359);
var buffer = __webpack_require__(2);
var sha256sha256 = __webpack_require__(76).sha256sha256;

var Base58Check = function Base58Check(obj) {
  if (!(this instanceof Base58Check))
    return new Base58Check(obj);
  if (Buffer.isBuffer(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  } else if (obj) {
    this.set(obj);
  }
};

Base58Check.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this;
};

Base58Check.validChecksum = function validChecksum(data, checksum) {
  if (_.isString(data)) {
    data = Buffer.from(Base58.decode(data));
  }
  if (_.isString(checksum)) {
    checksum =  Buffer.from(Base58.decode(checksum));
  }
  if (!checksum) {
    checksum = data.slice(-4);
    data = data.slice(0, -4);
  }
  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');
};

Base58Check.decode = function(s) {
  if (typeof s !== 'string')
    throw new Error('Input must be a string');

  var buf = Buffer.from(Base58.decode(s));

  if (buf.length < 4)
    throw new Error("Input string too short");

  var data = buf.slice(0, -4);
  var csum = buf.slice(-4);

  var hash = sha256sha256(data);
  var hash4 = hash.slice(0, 4);

  if (csum.toString('hex') !== hash4.toString('hex'))
    throw new Error("Checksum mismatch");

  return data;
};

Base58Check.checksum = function(buffer) {
  return sha256sha256(buffer).slice(0, 4);
};

Base58Check.encode = function(buf) {
  if (!Buffer.isBuffer(buf))
    throw new Error('Input must be a buffer');
  var checkedBuf = Buffer.alloc(buf.length + 4);
  var hash = Base58Check.checksum(buf);
  buf.copy(checkedBuf);
  hash.copy(checkedBuf, buf.length);
  return Base58.encode(checkedBuf);
};

Base58Check.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Base58Check.prototype.fromString = function(str) {
  var buf = Base58Check.decode(str);
  this.buf = buf;
  return this;
};

Base58Check.prototype.toBuffer = function() {
  return this.buf;
};

Base58Check.prototype.toString = function() {
  return Base58Check.encode(this.buf);
};

module.exports = Base58Check;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 272:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
const errors = __webpack_require__(116);
var BufferWriter = __webpack_require__(94);
var buffer = __webpack_require__(2);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);
var Script = __webpack_require__(106);
var Sighash = __webpack_require__(182);
var Output = __webpack_require__(163);

var MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;
var DEFAULT_SEQNUMBER = MAXINT;
var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;
var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
const SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);
const SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);
const SEQUENCE_LOCKTIME_MASK = 0xffff;
const SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds
const SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits 


function Input(params) {
  if (!(this instanceof Input)) {
    return new Input(params);
  }
  if (params) {
    return this._fromObject(params);
  }
}

Input.MAXINT = MAXINT;
Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
Input.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;

Object.defineProperty(Input.prototype, 'script', {
  configurable: false,
  enumerable: true,
  get: function() {
    if (this.isNull()) {
      return null;
    }
    if (!this._script) {
      this._script = new Script(this._scriptBuffer);
      this._script._isInput = true;
    }
    return this._script;
  }
});

Input.fromObject = function(obj) {
  $.checkArgument(_.isObject(obj));
  var input = new Input();
  return input._fromObject(obj);
};

Input.prototype._fromObject = function(params) {
  var prevTxId;
  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {
    prevTxId = Buffer.from(params.prevTxId, 'hex');
  } else {
    prevTxId = params.prevTxId;
  }
  this.witnesses = [];
  this.output = params.output ?
    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;
  this.prevTxId = prevTxId || params.txidbuf;
  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;
  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ?
    (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;
  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {
    throw new errors.Transaction.Input.MissingScript();
  }
  this.setScript(params.scriptBuffer || params.script);
  return this;
};

Input.prototype.toObject = Input.prototype.toJSON = function toObject() {
  var obj = {
    prevTxId: this.prevTxId.toString('hex'),
    outputIndex: this.outputIndex,
    sequenceNumber: this.sequenceNumber,
    script: this._scriptBuffer.toString('hex'),
  };
  // add human readable form if input contains valid script
  if (this.script) {
    obj.scriptString = this.script.toString();
  }
  if (this.output) {
    obj.output = this.output.toObject();
  }
  return obj;
};

Input.fromBufferReader = function(br) {
  var input = new Input();
  input.prevTxId = br.readReverse(32);
  input.outputIndex = br.readUInt32LE();
  input._scriptBuffer = br.readVarLengthBuffer();
  input.sequenceNumber = br.readUInt32LE();
  // TODO: return different classes according to which input it is
  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.
  return input;
};

Input.prototype.toBufferWriter = function(writer) {
  if (!writer) {
    writer = new BufferWriter();
  }
  writer.writeReverse(this.prevTxId);
  writer.writeUInt32LE(this.outputIndex);
  var script = this._scriptBuffer;
  writer.writeVarintNum(script.length);
  writer.write(script);
  writer.writeUInt32LE(this.sequenceNumber);
  return writer;
};

Input.prototype.setScript = function(script) {
  this._script = null;
  if (script instanceof Script) {
    this._script = script;
    this._script._isInput = true;
    this._scriptBuffer = script.toBuffer();
  } else if (JSUtil.isHexa(script)) {
    // hex string script
    this._scriptBuffer = Buffer.from(script, 'hex');
  } else if (_.isString(script)) {
    // human readable string script
    this._script = new Script(script);
    this._script._isInput = true;
    this._scriptBuffer = this._script.toBuffer();
  } else if (BufferUtil.isBuffer(script)) {
    // buffer script
    this._scriptBuffer = Buffer.from(script);
  } else {
    throw new TypeError('Invalid argument type: script');
  }
  return this;
};

/**
 * Retrieve signatures for the provided PrivateKey.
 *
 * @param {Transaction} transaction - the transaction to be signed
 * @param {PrivateKey} privateKey - the private key to use when signing
 * @param {number} inputIndex - the index of this input in the provided transaction
 * @param {number} sigType - defaults to Signature.SIGHASH_ALL
 * @param {Buffer} addressHash - if provided, don't calculate the hash of the
 *     public key associated with the private key provided
 * @abstract
 */
Input.prototype.getSignatures = function() {
  throw new errors.AbstractMethodInvoked(
    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +
    ' for input: ' + JSON.stringify(this)
  );
};

Input.prototype.getSatoshisBuffer = function() {
  $.checkState(this.output instanceof Output);
  $.checkState(this.output._satoshisBN);
  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();
};


Input.prototype.isFullySigned = function() {
  throw new errors.AbstractMethodInvoked('Input#isFullySigned');
};

Input.prototype.isFinal = function() {
  return this.sequenceNumber !== Input.MAXINT;
};

Input.prototype.addSignature = function() {
  throw new errors.AbstractMethodInvoked('Input#addSignature');
};

Input.prototype.clearSignatures = function() {
  throw new errors.AbstractMethodInvoked('Input#clearSignatures');
};

Input.prototype.hasWitnesses = function() {
  if (this.witnesses && this.witnesses.length > 0) {
    return true;
  }
  return false;
};

Input.prototype.getWitnesses = function() {
  return this.witnesses;
};

Input.prototype.setWitnesses = function(witnesses) {
  this.witnesses = witnesses;
};

Input.prototype.isValidSignature = function(transaction, signature, signingMethod) {
  // FIXME: Refactor signature so this is not necessary
  signingMethod = signingMethod || 'ecdsa';
  signature.signature.nhashtype = signature.sigtype;
  return Sighash.verify(
    transaction,
    signature.signature,
    signature.publicKey,
    signature.inputIndex,
    this.output.script,
    signingMethod
  );
};

/**
 * @returns true if this is a coinbase input (represents no input)
 */
Input.prototype.isNull = function() {
  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&
    this.outputIndex === 0xffffffff;
};

Input.prototype._estimateSize = function() {
  return this.toBufferWriter().toBuffer().length;
};


/**
 * Sets sequence number so that transaction is not valid until the desired seconds
 *  since the transaction is mined
 *
 * @param {Number} time in seconds
 * @return {Transaction} this
 */
Input.prototype.lockForSeconds = function(seconds) {
  $.checkArgument(_.isNumber(seconds));
  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {
    throw new errors.Transaction.Input.LockTimeRange();
  }
  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));

  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 
  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;
  return this;
};

/**
 * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined
 *
 * @param {Number} height
 * @return {Transaction} this
 */
Input.prototype.lockUntilBlockHeight = function(heightDiff) {
  $.checkArgument(_.isNumber(heightDiff));
  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {
    throw new errors.Transaction.Input.BlockHeightOutOfRange();
  }
  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0
  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0
  this.sequenceNumber = heightDiff ;
  return this;
};


/**
 *  Returns a semantic version of the input's sequence nLockTime.
 *  @return {Number|Date}
 *  If sequence lock is disabled  it returns null,
 *  if is set to block height lock, returns a block height (number)
 *  else it returns a Date object.
 */
Input.prototype.getLockTime = function() {
  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
    return null;
  }

  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {
    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);
    return seconds;
  } else {
    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;
    return blockHeight;
  }
};




module.exports = Input;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 273:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var inherits = __webpack_require__(9);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);

var PublicKey = __webpack_require__(141);
var errors = __webpack_require__(116);
var Signature = __webpack_require__(105);

/**
 * @desc
 * Wrapper around Signature with fields related to signing a transaction specifically
 *
 * @param {Object|string|TransactionSignature} arg
 * @constructor
 */
function TransactionSignature(arg) {
  if (!(this instanceof TransactionSignature)) {
    return new TransactionSignature(arg);
  }
  if (arg instanceof TransactionSignature) {
    return arg;
  }
  if (_.isObject(arg)) {
    return this._fromObject(arg);
  }
  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');
}
inherits(TransactionSignature, Signature);

TransactionSignature.prototype._fromObject = function(arg) {
  this._checkObjectArgs(arg);
  this.publicKey = new PublicKey(arg.publicKey);
  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');
  this.outputIndex = arg.outputIndex;
  this.inputIndex = arg.inputIndex;
  this.signature = (arg.signature instanceof Signature) ? arg.signature :
                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :
                     Signature.fromString(arg.signature);
  this.sigtype = arg.sigtype;
  return this;
};

TransactionSignature.prototype._checkObjectArgs = function(arg) {
  $.checkArgument(PublicKey(arg.publicKey), 'publicKey');
  $.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex');
  $.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex');
  $.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number');
  $.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number');
  $.checkArgument(arg.signature, 'signature');
  $.checkArgument(arg.prevTxId, 'prevTxId');
  $.checkState(arg.signature instanceof Signature ||
               BufferUtil.isBuffer(arg.signature) ||
               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');
  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||
               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');
  $.checkArgument(arg.sigtype, 'sigtype');
  $.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number');
};

/**
 * Serializes a transaction to a plain JS object
 * @return {Object}
 */
TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {
  return {
    publicKey: this.publicKey.toString(),
    prevTxId: this.prevTxId.toString('hex'),
    outputIndex: this.outputIndex,
    inputIndex: this.inputIndex,
    signature: this.signature.toString(),
    sigtype: this.sigtype
  };
};

/**
 * Builds a TransactionSignature from an object
 * @param {Object} object
 * @return {TransactionSignature}
 */
TransactionSignature.fromObject = function(object) {
  $.checkArgument(object);
  return new TransactionSignature(object);
};

module.exports = TransactionSignature;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 286:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return InfoSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__ = __webpack_require__(930);





let InfoSheetComponent = class InfoSheetComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(externalLinkProvider) {
        super();
        this.externalLinkProvider = externalLinkProvider;
    }
    ngAfterViewInit() {
        this.infoSheetTemplate.onDismiss.subscribe(option => {
            this.dismiss(option);
        });
    }
    openInBrowser(url) {
        this.externalLinkProvider.open(url);
        this.dismiss();
    }
    optionClicked(option) {
        this.dismiss(option);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */])
], InfoSheetComponent.prototype, "infoSheetTemplate", void 0);
InfoSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'info-sheet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/info-sheet/info-sheet.html"*/'<action-sheet>\n  <div class="info-container" [ngSwitch]="sheetType">\n    <info-sheet-template *ngSwitchCase="\'address-copied\'" type="success">\n      <span sheet-title-text>{{\'Copied {coin} address\' | translate: {coin: params.coin | uppercase }\n        }}</span>\n      <span sheet-text class="text-address">{{params.address}}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-needed-with-activity\'" type="info">\n      <span sheet-title-text translate>Needs Backup</span>\n      <span sheet-text translate>\n        Congratulations! It looks like you\'ve recently received money. It\'s highly advised that you verify your recovery phrase so that your funds can be recovered in case your phone was lost or stolen.\n      </span>\n      <span sheet-button-text translate>Continue</span>\n      <span sheet-second-button-text translate>Not right now</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'miner-fee-notice\'" type="warning">\n      <span sheet-title-text translate>Miner Fee Notice</span>\n      <span sheet-text>\n        {{\'Because you are sending the maximum amount contained in this wallet, the {coinName} miner fee ({fee} {coin}) will be deducted from the total.  {msg}\' | translate: {coinName: params.coinName, fee: params.fee, coin:params.coin, msg: params.msg} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'speed-up-notice\'" type="warning">\n      <span sheet-title-text translate>Miner Fee Notice</span>\n      <span sheet-text>\n        {{\'Because you are speeding up this transaction, the {coinName} miner fee ({fee} {coin}) will be deducted from the total.\' | translate: {coinName: params.coinName, fee: params.fee, coin:params.coin} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'insufficient-funds\'" type="danger">\n      <span sheet-title-text translate>Not enough funds</span>\n      <span sheet-text>\n        {{ \'You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals. You can also try with a lower amount or send max.\' | translate }}\n      </span>\n      <span sheet-button-text translate>Change Amount</span>\n      <span sheet-second-button-text translate>Send Max</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'import-no-wallet-warning\'" type="warning">\n      <span sheet-title-text translate>We couldn\'t find your wallet!</span>\n      <span sheet-text>\n        {{ \'There are no records of your wallet on our servers. If you are importing a BIP44 compatible wallet from a 3rd party you can continue to recreate it. If you wallet is not BIP44 compatible, you will not be able to access its funds.\' | translate }}\n      </span>\n      <span sheet-button-text translate>Go Back</span>\n      <span sheet-second-button-text translate>Continue Anyway</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'default-error\'" type="danger">\n      <span sheet-title-text>{{params.title}}</span>\n      <span sheet-text>{{params.msg}}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-later-warning\'" type="warning">\n      <span sheet-title-text translate>Are you sure?</span>\n      <span sheet-text translate>\n        Receiving funds will be temporarily disabled until you can verify your key has been stored away securely. You can always complete this later.\n      </span>\n      <span sheet-button-text translate>I\'M SURE</span>\n      <span sheet-second-button-text translate>GO BACK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-ready\'" type="success">\n      <span sheet-title-text>{{\'Your {walletType} wallet is backed up!\' | translate : {walletType: params.walletType} }}</span>\n      <span sheet-text translate>\n        Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-safeguard-warning\'" type="info">\n      <span sheet-title-text translate>Recovery Key</span>\n      <span sheet-text translate>\n        Your recovery key is composed of 12 randomly selected words. Please carefully write down each word in the order it appears.\n      </span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'sensitive-info\'" type="warning">\n      <span sheet-title-text translate>Sensitive Data</span>\n      <span sheet-text translate>\n        The information you are about to share/export may contain sensitive data such us wallet IDs, addresses, balances, etc. Please be sure you trust the person or entity with whom you are sharing this information.\n      </span>\n      <span sheet-button-text translate>I understand</span>\n      <span sheet-second-button-text translate>Go Back</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copy-to-clipboard\'" type="success">\n      <span sheet-title-text translate>Copied to Clipboard</span>\n      <span sheet-text>{{params?.msg}}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copied-gift-card-claim-code\'" type="success">\n      <span sheet-title-text style="word-break: break-all;">{{\'Copied: {claimCode}\' | translate: params }}</span>\n      <span sheet-text>\n        <redeem-instructions [cardConfig]="params.cardConfig" [params]="params"></redeem-instructions>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'linkEthWallet\'" type="{{ params.wallets[0] ? \'info\' : \'warning\' }}">\n      <span *ngIf="params.wallets && params.wallets.length > 0" sheet-title-text translate>Select an Ethereum Wallet</span>\n      <span *ngIf="!params.wallets[0]" sheet-title-text translate>Ethereum wallet required</span>\n      <span *ngIf="params.wallets && params.wallets.length > 0 && !params.isEthMultisig" sheet-text translate>Which Ethereum wallet would you like this token to use for transaction costs?</span>\n      <span *ngIf="params.wallets && params.wallets.length > 0 && params.isEthMultisig" sheet-text translate>Which Ethereum wallet would you like this multisig wallet to use for transaction costs?</span>\n\n      <span *ngIf="!params.wallets[0] && !params.isEthMultisig" sheet-text translate>\n        In order to create a token wallet, an Ethereum (ETH) wallet is required. Please create an ETH wallet first. Only one {{ params.token.name }} wallet is allowed per ETH wallet.\n      </span>\n      <span *ngIf="!params.wallets[0] && params.isEthMultisig" sheet-text translate>\n        In order to create this multisig wallet, an Ethereum (ETH) wallet with enough funds is required.\n      </span>\n\n      <span sheet-text>\n        <div style="margin-top: 20px" *ngIf="params.wallets && params.wallets.length > 0">\n          <ion-list class="bp-list">\n            <div *ngFor="let wallet of params.wallets">\n              <wallet-item-content [wallet]="wallet" (click)="optionClicked(wallet)"></wallet-item-content>\n            </div>\n          </ion-list>\n        </div>\n      </span>\n\n      <span sheet-button-text *ngIf="params.wallets[0]" translate>GO BACK</span>\n      <span sheet-button-text *ngIf="!params.wallets[0]" translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copied-invoice-url\'" type="{{ params.error ? \'danger\' : \'success\' }}">\n      <span *ngIf="!params.error" sheet-title-text class="truncate">\n        <span translate>Copied</span>: {{params.invoiceUrl}}\n      </span>\n      <span *ngIf="params.error" sheet-title-text class="truncate">\n        <span translate>Error</span>: {{params.error}}\n      </span>\n      <span sheet-text>\n        <redeem-instructions [cardConfig]="params.cardConfig" [params]="params"></redeem-instructions>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n      <span sheet-button-text class="sheet-btn-invoice" translate (click)="openInBrowser(params.invoiceUrl)" style="float: right;" item-end>OPEN IN BROWSER\n      </span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'archive-all-gift-cards\'" type="warning">\n      <span sheet-title-text>{{\'Archive All {brand} Gift Cards?\' | translate: params }}</span>\n      <span sheet-text>{{\'Have you redeemed all of your {brand} Gift Cards? Archived gift cards will still be accessible in settings.\' | translate: params }}</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'archive-gift-card\'" type="warning">\n      <span sheet-title-text translate>Archive this Card?</span>\n      <span sheet-text translate>Have you redeemed the entire balance of this gift card?</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'hide-gift-card-discount-item\'" type="warning">\n      <span sheet-title-text translate>Hide discount?</span>\n      <span sheet-text translate>Would you like to hide this gift card discount?</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'gift-card-archived\'" type="success">\n      <span sheet-title-text translate>Card Archived</span>\n      <span sheet-text translate>You can continue to view your archived cards here if you need to access them.</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'activation-fee-included\'" type="info">\n      <span sheet-title-text translate>Activation Fee</span>\n      <span sheet-text>{{\'{displayName} gift cards contain an additional activation fee of {fee} {currency}.\' | translate: params }}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'gift-cards-unavailable\'" type="danger">\n      <span sheet-title-text translate>Temporarily Unavailable</span>\n      <span sheet-text translate>Gift card purchases are temporarily unavailable. Please try again later.</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'below-minimum-gift-card-amount\'" type="danger">\n      <span sheet-title-text translate>Below Minimum Amount</span>\n      <span sheet-text>{{\'The purchase amount must be at least {minAmount} {currency}. Please modify your amount.\' | translate: params }}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'above-maximum-gift-card-amount\'" type="danger">\n      <span sheet-title-text translate>Purchase Limit Reached</span>\n      <span sheet-text>\n        {{\'The purchase amount is limited to {maxAmount} {currency} per day. Please modify your amount.\' | translate:params }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'legacy-address-info\'" type="info">\n      <span sheet-title-text>{{\'{appName} BCH wallets use the CashAddr format by default\' | translate: {appName:params.appName} }}</span>\n      <span sheet-text translate>\n        If you need to send to "old" addresses (like the one you just pasted), and you are SURE those are BCH addresses, you can "translate" them to the corresponding address in CashAddr format.\n      </span>\n      <span sheet-button-text translate>Translate address</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'appreciate-review\'" type="love">\n      <span sheet-title-text translate>We appreciate your review</span>\n      <span sheet-text translate>\n        5-star ratings help us get TKCoin Wallet into more hands, and more users means more resources can be committed to the app!\n      </span>\n      <span sheet-button-text>{{\'Continue to {storeName}\' | translate: {storeName: params?.storeName}\n        }}</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'payment-request\'" type="info">\n      <span sheet-title-text translate>Payment Request info</span>\n      <span sheet-text>\n        {{\'Share this QR code to receive {amount} in your wallet {name}.\' | translate: {amount: params.amount, name:params.name} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'payment-method-changed\'" type="warning">\n      <span sheet-title-text translate>Payment method updated</span>\n      <span *ngIf="params.reason == \'coin\'" sheet-text>\n        {{\'Only the payment methods supported to buy {coin} with {currency} will be shown.\' | translate: {coin: params.coin | uppercase, currency:params.currency | uppercase} }}\n      </span>\n      <span *ngIf="params.reason == \'country\'" sheet-text>\n        {{\'SEPA Bank Transfer purchases are not supported outside the European Union.\' | translate: {coin: params.coin | uppercase, currency:params.currency | uppercase} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'one-phone-country\'" type="info">\n      <span sheet-title-text translate>{{params.countryCode === \'US\' ? \'U.S.\' : params.countryCode}} Phone Required</span>\n      <span sheet-text>\n        {{\'Only a {name} phone number can be used for this purchase.\' | translate: {name:params.country.name} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'print-required\'" type="info">\n      <span sheet-title-text translate>Printed Gift Card Required</span>\n      <span sheet-text>\n        {{\'{displayName} requires you to present a printed gift card at redemption.\' | translate: params }} <br />\n        <br />\n        You will be able to print this gift card upon completing your purchase.\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'in-app-notification\'" type="success">\n      <span sheet-title-text>{{params.title}}</span>\n      <span sheet-text>{{params.body}}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'request-feature\'" type="info">\n      <span sheet-title-text translate>Request a new feature</span>\n      <span sheet-text translate>\n        If you need immediate help with a problem you are having, then get help by contacting our support team.\n      </span>\n      <span sheet-button-text translate>Get help</span>\n      <span sheet-second-button-text translate>Request feature</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'report-issue\'" type="info">\n      <span sheet-title-text translate>Report an issue</span>\n      <span sheet-text translate>\n        Found something broken? Please report it as a bug. If you need immediate help with a problem you are having, then get help by contacting our support team.\n      </span>\n      <span sheet-button-text translate>Get help</span>\n      <span sheet-second-button-text translate>Report issue</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'new-key\'" type="warning">\n      <span sheet-title-text translate>Store this key separately</span>\n      <span sheet-text translate>\n        This is a new 12-word key that manages its own set of wallets. It is unrelated to any 12 word key you may have previously created. Store and manage it accordingly.\n      </span>\n      <span sheet-button-text translate>Learn More</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'bch-legacy-warning-1\'" type="warning">\n      <span sheet-title-text translate>Warning!</span>\n      <span sheet-text translate>\n        Legacy address types in Bitcoin Cash are OBSOLETE. Only use this feature if you are required to provide a legacy address to the sending party\n      </span>\n      <span sheet-button-text translate>I Understand</span>\n      <span sheet-second-button-text translate>Cancel</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'bch-legacy-warning-2\'" type="warning">\n      <span sheet-title-text translate>Warning!</span>\n      <span sheet-text translate>\n        Sending BTC to a Bitcoin Cash legacy address will result on permanent lost of funds. This feature is only for advanced users.\n      </span>\n      <span sheet-second-button-text translate>Cancel</span>\n      <span sheet-button-text translate>Show me the legacy address</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'wrong-encrypt-password\'" type="danger">\n      <span sheet-title-text translate>Wrong password</span>\n      <span sheet-text>\n        <span translate>Forgot your password?</span>\n        <ul>\n          <li translate>\n            Try entering any passwords you may have set in the past\n          </li>\n          <li translate>\n            Remember there are no special requirements for the password (numbers, symbols, etc.)\n          </li>\n          <li translate>\n            Keep in mind your encrypt password is not the 12-word recovery phrase\n          </li>\n          <li translate>\n            You can always reset your encrypt password on your key settings under the option <b>Clear Encrypt Password</b> using your 12 words recovery phrase\n          </li>\n        </ul>\n      </span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'speed-up-tx\'" type="warning">\n      <span sheet-title-text translate>Transaction still unconfirmed</span>\n      <span sheet-text translate>\n        This transaction is taking longer than usual to confirm. You can try to speed it up by using a higher fee.\n      </span>\n      <span sheet-button-text translate>Speed up transaction</span>\n      <span sheet-second-button-text translate>View details</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'rbf-tx\'" type="danger">\n      <span sheet-title-text translate>RBF transaction</span>\n      <span sheet-text>\n        <span translate>Be careful. Until it confirms, the transaction could be replaced/redirected by the sender. You can try to speed it up by using a higher fee.</span>\n        <a class="label-tip-link" (click)="openInBrowser(\'https://support.tkcoin.org/hc/en-us/articles/360028824532-Why-can-t-I-pay-a-TKCoin-invoice-using-RBF-\')" translate>Read more</a>\n      </span>\n      <span sheet-button-text translate>Speed up transaction</span>\n      <span sheet-second-button-text translate>View details</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'unconfirmed-inputs\'" type="danger">\n      <span sheet-title-text translate>Unconfirmed inputs</span>\n      <span sheet-text translate>\n        Be careful. Some inputs of this transaction have no confirmations. Please wait until they are confirmed.\n      </span>\n      <span sheet-second-button-text translate>View details</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'subtotal-amount\'" type="info">\n      <span sheet-title-text>{{ \'Subtotal\' | translate }}</span>\n      <span sheet-text>\n        {{ \'For TKCoin invoices and gift cards the subtotal amount is the product or service amount plus network costs.\' | translate }}\n        <a class="label-tip-link" (click)="openInBrowser(\'https://support.tkcoin.org/hc/en-us/articles/115002990803-What-is-the-Network-Cost-fee-on-TKCoin-invoices-and-why-is-TKCoin-charging-it\')" translate>Read more</a>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'total-amount\'" type="info">\n      <span sheet-title-text>{{ \'Total\' | translate }}</span>\n      <span sheet-text>\n        {{ \'The total amount is the subtotal amount plus transaction fees.\' | translate }}\n        <a class="label-tip-link" (click)="openInBrowser(\'https://support.tkcoin.org/hc/en-us/articles/115003393863-What-are-bitcoin-miner-fees-\')" translate>Read more</a>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'no-wallets-available\'" type="info">\n      <span sheet-title-text translate>No wallets available</span>\n      <span sheet-text>\n        <span translate>What could have happened?</span>\n        <ul>\n          <li translate>\n            There are no wallets with enough funds to make the payment\n          </li>\n          <li translate>\n            Part or the entirety of the funds in your wallet/s are unconfirmed\n          </li>\n          <li translate>Your wallet is testnet</li>\n        </ul>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'recovery-phrase-length\'" type="warning">\n      <span sheet-title-text translate>Something went wrong</span>\n      <span sheet-text>\n        <span translate>What could have happened?</span>\n        <ul>\n          <li translate>You have entered the phrase without spaces</li>\n          <li translate>The recovery phrase is invalid</li>\n          <li *ngIf="params.wordListLength === 1">\n            {{\'You have only entered {wordListLength} word, please follow the recommendations provided\' | translate: params }}\n          </li>\n          <li *ngIf="params.wordListLength !== 1">\n            {{\'You have only entered {wordListLength} words, please follow the recommendations provided\' | translate: params }}\n          </li>\n        </ul>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'no-wallets-error\'" type="warning">\n      <span sheet-title-text translate>No wallet available</span>\n      <span sheet-text>\n        {{\'You do not have a {coin} wallet able to receive funds. If you decide to create it, remember it needs to be backed up.\' | translate: {coin: params.coin ? params.coin : \'\'} }}\n      </span>\n      <span sheet-button-text translate>Create Wallet</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'wyre-error\'" type="warning">\n      <span sheet-title-text translate>Payment Error</span>\n      <span sheet-text>\n        <span translate>There was an error with the payment process through Wyre.</span>\n      </span>\n      <span sheet-button-text translate>Visit Help Center</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'protect-money\'" type="safeguard">\n      <span sheet-title-text translate>Protect your money</span>\n      <span sheet-text translate>\n        First, lets ensure no one can easily access your crypto funds when youre away from your device by adding biometric security.\n      </span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'pincode-info\'" type="safeguard">\n      <span sheet-title-text translate>Maybe a pincode instead?</span>\n      <span sheet-text translate>\n        A pincode will ensure no one can easily access your crypto funds when you\'re away from your device.\n      </span>\n      <span sheet-button-text translate>Continue</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'key-verification-required\'" type="info">\n      <span sheet-title-text translate>Key verification required</span>\n      <span sheet-text translate>\n        In order to begin purchasing and receiving cryptocurrencies you will need to verify your key. This could take up to 3 minutes long to complete.\n      </span>\n      <span sheet-button-text translate>VERIFY NOW</span>\n      <span sheet-second-button-text translate>DO THIS LATER</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'encrypt-password-warning\'" type="warning">\n      <span sheet-title-text translate>Are you sure?</span>\n      <span sheet-text translate>\n        Without encrypting your wallet, a thief or another app on this device could potentially access your money.\n      </span>\n      <span sheet-button-text translate>I\'M SURE</span>\n      <span sheet-second-button-text translate>GO BACK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'auth-required\'" type="warning">\n      <span sheet-title-text translate>Connect Your TKCoin ID</span>\n      <span sheet-text>\n        To complete this payment, please login with your TKCoin ID.\n      </span>\n      <span sheet-button-text translate>CONTINUE</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'verification-required\'" type="warning">\n      <span sheet-title-text translate>Verification Required</span>\n      <span sheet-text>\n        To complete this payment, a verified account is required.\n      </span>\n      <span sheet-button-text translate>CONTINUE</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'incorrect-recovery-prhase\'" type="danger">\n      <span sheet-title-text translate>Incorrect Recovery Phrase</span>\n      <span sheet-text>\n        The recovery phrase you provided was incorrect. Lets review that you have written down the correct words in the correct order.\n      </span>\n      <span sheet-button-text translate>TRY AGAIN</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'correct-recovery-prhase\'" type="success">\n      <span sheet-title-text translate>Perfect!</span>\n      <span sheet-text>\n        In order to protect your funds from being accessible to hackers and thieves, store this recovery phrase in a safe and secure place.\n      </span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'unsupported-alt-currency\'" type="{{ params.error ? \'danger\' : \'warning\' }}">\n      <span sheet-title-text translate>{{ params.error ? \'Error\' : \'Warning!\' }}</span>\n      <span sheet-text translate>\n        {{params.name}} ({{params.isoCode}}) is no longer supported. Please select another alternative currency.\n      </span>\n      <span sheet-button-text translate *ngIf="params.error">GOT IT</span>\n      <span sheet-button-text translate *ngIf="!params.error">CONTINUE</span>\n      <span sheet-second-button-text translate *ngIf="!params.error">DO THIS LATER</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'custom-fee-warning\'" type="warning">\n      <span sheet-title-text translate>Warning!</span>\n      <span sheet-text>\n        The fee you are using is lower than the Super Economy level, we do not recommend doing this as the transaction will take very long to confirm or may never do it. You can continue at your own responsibility.\n      </span>\n      <span sheet-button-text translate>Change Miner Fee</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'send-max-min-amount\'" type="danger">\n      <span sheet-title-text translate>Error</span>\n      <span sheet-text>\n        <span translate>As the estimated miner fee to complete the transaction is {{params.fee}} {{params.coin}}, the maximum spendable amount of your wallet is {{params.amount}} {{params.coin}} which is lower than the minimum allowed by the exchange: {{params.minAmount}} {{params.coin}}</span>\n        <span *ngIf="params.msg">{{params.msg}}</span>\n      </span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'min-amount-allowed\'" type="danger">\n      <span sheet-title-text translate>Error</span>\n      <span sheet-text>\n        <span translate>The amount entered is lower than the minimum allowed: {{params.minAmount}} {{params.coin}}</span>\n      </span>\n      <span sheet-button-text translate>Use Min Amount</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'max-amount-allowed\'" type="danger">\n      <span sheet-title-text translate>Error</span>\n      <span sheet-text>\n        <span translate>The amount entered is greater than the maximum allowed: {{params.maxAmount}} {{params.coin}}</span>\n      </span>\n      <span sheet-button-text translate>Use Max Amount</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n  </div>\n</action-sheet>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/info-sheet/info-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], InfoSheetComponent);

const INFO_SHEET_COMPONENTS = [InfoSheetComponent, __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */]];
/* harmony export (immutable) */ __webpack_exports__["a"] = INFO_SHEET_COMPONENTS;

//# sourceMappingURL=info-sheet.js.map

/***/ }),

/***/ 287:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FilterProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let FilterProvider = class FilterProvider {
    constructor(decimalPipe, logger) {
        this.decimalPipe = decimalPipe;
        this.logger = logger;
        this.logger.debug('FilterProvider initialized');
        this.formats = {
            CURRENCY_SYM: '$',
            DECIMAL_SEP: '.',
            GROUP_SEP: ','
        };
    }
    formatFiatAmount(amount) {
        let value;
        let sep;
        let group;
        let intValue;
        let floatValue;
        let finalValue;
        value = this.decimalPipe.transform(amount);
        if (!value)
            return 0;
        sep = value.indexOf(this.formats.DECIMAL_SEP);
        group = value.indexOf(this.formats.GROUP_SEP);
        if (amount >= 0) {
            if (group > 0) {
                if (sep < 0) {
                    return value;
                }
                intValue = value.substring(0, sep);
                floatValue = parseFloat(value.substring(sep));
                floatValue = floatValue.toFixed(2);
                floatValue = floatValue.toString().substring(1);
                finalValue = intValue + floatValue;
                return finalValue;
            }
            else {
                value = parseFloat(value);
                return value.toFixed(2);
            }
        }
        return 0;
    }
};
FilterProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], FilterProvider);

//# sourceMappingURL=filter.js.map

/***/ }),

/***/ 288:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyCryptoProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__simplex_simplex__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__wyre_wyre__ = __webpack_require__(289);





// providers






let BuyCryptoProvider = class BuyCryptoProvider {
    constructor(http, configProvider, homeIntegrationsProvider, logger, translate, simplexProvider, wyreProvider, platformProvider) {
        this.http = http;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.translate = translate;
        this.simplexProvider = simplexProvider;
        this.wyreProvider = wyreProvider;
        this.platformProvider = platformProvider;
        // private baseUrl: string = 'http://localhost:3232/bws/api'; // testing
        this.baseUrl = 'https://bws.tkcoin.org/bws/api';
        this.logger.debug('BuyCrypto Provider initialized');
        this.exchangeCoinsSupported = __WEBPACK_IMPORTED_MODULE_4_lodash__["union"](this.simplexProvider.supportedCoins, this.wyreProvider.supportedCoins);
        this.paymentMethodsAvailable = {
            applePay: {
                label: this.translate.instant('Apple Pay'),
                method: 'applePay',
                imgSrc: 'assets/img/buy-crypto/apple-pay-logo.svg',
                supportedExchanges: {
                    simplex: true,
                    wyre: true
                },
                enabled: this.platformProvider.isIOS
            },
            sepaBankTransfer: {
                label: this.translate.instant('SEPA Bank Transfer'),
                method: 'sepaBankTransfer',
                imgSrc: 'assets/img/buy-crypto/icon-bank.svg',
                supportedExchanges: {
                    simplex: true,
                    wyre: false
                },
                enabled: true
            },
            creditCard: {
                label: this.translate.instant('Credit Card'),
                method: 'creditCard',
                imgSrc: 'assets/img/buy-crypto/icon-creditcard.svg',
                supportedExchanges: {
                    simplex: true,
                    wyre: false
                },
                enabled: true
            },
            debitCard: {
                label: this.translate.instant('Debit Card'),
                method: 'debitCard',
                imgSrc: 'assets/img/buy-crypto/icon-debitcard.svg',
                supportedExchanges: {
                    simplex: true,
                    wyre: true
                },
                enabled: true
            }
        };
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'buycrypto',
            title: this.translate.instant('Buy Crypto'),
            icon: 'assets/img/icon-coins.svg',
            showIcon: true,
            logo: null,
            logoWidth: '110',
            background: 'linear-gradient(to bottom,rgba(60, 63, 69, 1) 0,rgba(45, 47, 51, 1) 100%)',
            page: 'CryptoSettingsPage',
            show: !!this.configProvider.get().showIntegration['buycrypto'],
            type: 'exchange'
        });
    }
    isCurrencySupported(exchange, currency) {
        switch (exchange) {
            case 'simplex':
                return __WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.simplexProvider.supportedFiatAltCurrencies, currency.toUpperCase());
            case 'wyre':
                return __WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.wyreProvider.supportedFiatAltCurrencies, currency.toUpperCase());
            default:
                return false;
        }
    }
    isCoinSupported(exchange, coin) {
        switch (exchange) {
            case 'simplex':
                return __WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.simplexProvider.supportedCoins, coin);
            case 'wyre':
                return __WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.wyreProvider.supportedCoins, coin);
            default:
                return false;
        }
    }
    isPaymentMethodSupported(exchange, paymentMethod, coin, currency) {
        return (paymentMethod.supportedExchanges[exchange] &&
            this.isCoinSupported(exchange, coin) &&
            this.isCurrencySupported(exchange, currency));
    }
    getPaymentRequests() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const [simplexPaymentRequests, wyrePaymentRequests] = yield Promise.all([
                this.simplexProvider.getSimplex(),
                this.wyreProvider.getWyre()
            ]);
            return {
                simplexPaymentRequests: __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](simplexPaymentRequests),
                wyrePaymentRequests: __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](wyrePaymentRequests)
            };
        });
    }
    getExchangeCoinsSupported(exchange) {
        switch (exchange) {
            case 'simplex':
                return this.simplexProvider.supportedCoins;
            case 'wyre':
                return this.wyreProvider.supportedCoins;
            default:
                // return all supported coins
                return this.exchangeCoinsSupported;
        }
    }
    isPromotionActive(promo) {
        return new Promise(resolve => {
            this.getActiveBuyCryptoPromotions()
                .then(data => {
                if (!data)
                    return resolve(false);
                switch (promo) {
                    case 'simplexPromotion202002':
                        return resolve(data.simplexPromotion202002);
                    default:
                        return resolve(false);
                }
            })
                .catch(err => {
                this.logger.error(`Error trying isPromotionActive: ${promo}. Setting false.`);
                this.logger.error(err);
                return resolve(false);
            });
        });
    }
    getActiveBuyCryptoPromotions() {
        return new Promise((resolve, reject) => {
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/json'
            });
            this.logger.debug('Asking BWS for active promotions');
            this.http
                .get(this.baseUrl + '/v1/services', {
                headers
            })
                .subscribe((data) => {
                this.logger.debug('Active promotions: ', data);
                if (data && data.buyCrypto)
                    return resolve(data.buyCrypto);
                return reject('No active promotions for buy crypto');
            }, err => {
                return reject(err);
            });
        });
    }
};
BuyCryptoProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__simplex_simplex__["a" /* SimplexProvider */],
        __WEBPACK_IMPORTED_MODULE_10__wyre_wyre__["a" /* WyreProvider */],
        __WEBPACK_IMPORTED_MODULE_8__platform_platform__["a" /* PlatformProvider */]])
], BuyCryptoProvider);

//# sourceMappingURL=buy-crypto.js.map

/***/ }),

/***/ 289:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WyreProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__rate_rate__ = __webpack_require__(78);





// providers



const URI_DEV = 'https://api.testwyre.com';
const URI_PROD = 'https://api.sendwyre.com';
let WyreProvider = class WyreProvider {
    constructor(http, logger, persistenceProvider, rateProvider) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.rateProvider = rateProvider;
        this.env = __WEBPACK_IMPORTED_MODULE_4__environments__["a" /* default */].name == 'development' ? 'sandbox' : 'production';
        this.logger.debug('WyreProvider initialized - env: ' + this.env);
        this.uri = __WEBPACK_IMPORTED_MODULE_4__environments__["a" /* default */].name == 'development' ? URI_DEV : URI_PROD;
        this.supportedFiatAltCurrencies = ['AUD', 'CAD', 'EUR', 'GBP', 'USD'];
        this.supportedCoins = [
            'btc',
            'eth',
            'usdc',
            'gusd',
            'pax',
            'busd',
            'dai',
            'wbtc'
        ];
        this.fiatAmountLimits = {
            min: 20,
            max: 1000
        };
    }
    getSupportedFiatAltCurrencies() {
        return this.supportedFiatAltCurrencies;
    }
    getRates() {
        const url = this.uri + '/v3/rates';
        const headers = {
            'Content-Type': 'application/json'
        };
        // as: DIVISOR, MULTIPLIER, or PRICED
        const params = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["d" /* HttpParams */]().set('as', 'PRICED');
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers, params }).subscribe(data => {
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    getCountries() {
        const url = this.uri + '/v3/widget/countries';
        const headers = {
            'Content-Type': 'application/json'
        };
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    getFiatCurrencyLimits(fiatCurrency, coin, country) {
        let min, max;
        if (!country || country != 'US') {
            min = 20;
            max = 1000;
        }
        else {
            min = 20;
            max = 500;
        }
        this.fiatAmountLimits.min = this.calculateFiatRate(min, fiatCurrency, coin);
        this.fiatAmountLimits.max = this.calculateFiatRate(max, fiatCurrency, coin);
        return this.fiatAmountLimits;
    }
    calculateFiatRate(amount, fiatCurrency, cryptoCurrency) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](['USD'], fiatCurrency)) {
            return amount;
        }
        const rateFromFiat = this.rateProvider.fromFiat(amount, 'USD', cryptoCurrency);
        return +this.rateProvider
            .toFiat(rateFromFiat, fiatCurrency, cryptoCurrency)
            .toFixed(2);
    }
    getLimits() {
        const url = this.uri + '/v3/limits';
        const headers = {
            'Content-Type': 'application/json'
        };
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    walletOrderQuotation(wallet, data) {
        data.env = this.env;
        return wallet.wyreWalletOrderQuotation(data);
    }
    walletOrderReservation(wallet, data) {
        data.env = this.env;
        return wallet.wyreWalletOrderReservation(data);
    }
    getWyreUrlParams(wallet) {
        const data = {
            env: this.env
        };
        return wallet.wyreUrlParams(data);
    }
    getWalletOrderDetails(orderId) {
        const url = this.uri + '/v3/orders/' + orderId;
        const headers = {
            'Content-Type': 'application/json'
        };
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    getTransfer(transferId) {
        const url = this.uri + '/v2/transfer/' + transferId + '/track';
        const headers = {
            'Content-Type': 'application/json'
        };
        return new Promise((resolve, reject) => {
            this.http.get(url, { headers }).subscribe(data => {
                return resolve(data);
            }, err => {
                return reject(err);
            });
        });
    }
    saveWyre(data, opts) {
        const env = this.env;
        data.created_on = Date.now();
        return this.persistenceProvider.getWyre(env).then(oldData => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](oldData)) {
                oldData = JSON.parse(oldData);
            }
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            let inv = oldData ? oldData : {};
            inv[data.orderId] = data;
            if (opts && (opts.error || opts.status)) {
                inv[data.orderId] = __WEBPACK_IMPORTED_MODULE_3_lodash__["assign"](inv[data.orderId], opts);
            }
            if (opts && opts.remove) {
                if (inv[data.transferId])
                    delete inv[data.transferId];
                if (inv[data.orderId])
                    delete inv[data.orderId];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setWyre(env, inv);
            return Promise.resolve();
        });
    }
    getWyre() {
        const env = this.env;
        return this.persistenceProvider.getWyre(env);
    }
};
WyreProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_7__rate_rate__["b" /* RateProvider */]])
], WyreProvider);

//# sourceMappingURL=wyre.js.map

/***/ }),

/***/ 290:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IABCardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_bitauth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__app_identity_app_identity__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__apple_wallet_apple_wallet__ = __webpack_require__(944);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__tkcoin_id_tkcoin_id__ = __webpack_require__(380);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__in_app_browser__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__theme_theme__ = __webpack_require__(56);
























const LOADING_WRAPPER_TIMEOUT = 0;
const IAB_LOADING_INTERVAL = 1000;
const IAB_LOADING_ATTEMPTS = 20;
let IABCardProvider = class IABCardProvider {
    constructor(payproProvider, logger, events, tkcoinIdProvider, configProvider, appIdentityProvider, persistenceProvider, actionSheetProvider, iab, translate, profileProvider, onGoingProcess, http, externalLinkProvider, themeProvider, appProvider, appleWalletProvider, platform, device, analyticsProvider) {
        this.payproProvider = payproProvider;
        this.logger = logger;
        this.events = events;
        this.tkcoinIdProvider = tkcoinIdProvider;
        this.configProvider = configProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.persistenceProvider = persistenceProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.iab = iab;
        this.translate = translate;
        this.profileProvider = profileProvider;
        this.onGoingProcess = onGoingProcess;
        this.http = http;
        this.externalLinkProvider = externalLinkProvider;
        this.themeProvider = themeProvider;
        this.appProvider = appProvider;
        this.appleWalletProvider = appleWalletProvider;
        this.platform = platform;
        this.device = device;
        this.analyticsProvider = analyticsProvider;
        this._isHidden = true;
        this._pausedState = false;
        this.user = new __WEBPACK_IMPORTED_MODULE_7_rxjs__["BehaviorSubject"]({});
        this.user$ = this.user.asObservable();
        this._IABLoaded = new __WEBPACK_IMPORTED_MODULE_7_rxjs__["ReplaySubject"]();
        this.IABLoaded$ = this._IABLoaded.asObservable();
    }
    setNetwork(network) {
        this.NETWORK = network;
        this.BITPAY_API_URL =
            this.NETWORK == 'livenet'
                ? 'https://tkcoin.org'
                : 'https://test.tkcoin.org';
        this.logger.log(`card provider initialized with ${this.NETWORK}`);
    }
    get ref() {
        return this.cardIAB_Ref;
    }
    get isHidden() {
        return this._isHidden;
    }
    get isVisible() {
        return !this._isHidden;
    }
    init() {
        this.logger.debug('IABCardProvider initialized');
        this.cardIAB_Ref = this.iab.refs.card;
        this.IABLoaded$.subscribe(() => (this.IABReady = true));
        this.cardIAB_Ref.events$.subscribe((event) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.log(`EVENT FIRED ${JSON.stringify(event.data.message)}`);
            switch (event.data.message) {
                case 'IABLoaded':
                    this._IABLoaded.next(true);
                    break;
                case 'IABError':
                case 'log':
                    this.logger.debug(event.data.log);
                    break;
                /*
                 *
                 * Handles paying for the card. The IAB generates the invoice id and passes it back here. This method then launches the payment experience.
                 *  TODO pass the user back to the the IAB when purchase is completed
                 * */
                case 'purchaseAttempt':
                    this.purchaseAttempt(event);
                    break;
                /*
                 *
                 * This handles the TKCoin ID pairing and retrieves user data. It also passes it to the behavior subject.
                 *
                 * */
                case 'pairing':
                    this.pairing(event);
                    break;
                /*
                 *
                 * This handles keeping the IAB session storage in sync with the IAB
                 *
                 * */
                case 'syncCardState':
                    this.syncCardState(event);
                    break;
                /*
                 *
                 * Closes the IAB
                 *
                 * */
                case 'close':
                    this.hide();
                    break;
                /*
                 *
                 * Balance update - added this to ensure balances are in sync between the index view and IAB
                 *
                 * */
                case 'balanceUpdate':
                    this.balanceUpdate(event);
                    break;
                /*
                 *
                 * IAB Ready event
                 *
                 * */
                case 'ready':
                    this.events.publish('IABReady');
                    break;
                /*
                 *
                 * Sets User location
                 *
                 * */
                case 'setUserLocation':
                    const { country } = event.data.params;
                    this.events.publish('IABReady', country);
                    if (country) {
                        this.persistenceProvider.setUserLocation(country);
                    }
                    break;
                /*
                 *
                 * Open external link from the IAB
                 *
                 * */
                case 'openLink':
                    const { url } = event.data.params;
                    this.externalLinkProvider.open(url);
                    break;
                case 'navigateToCardTabPage':
                    this.events.publish('IncomingDataRedir', {
                        name: 'CardsPage'
                    });
                    break;
                case 'topup':
                    this.topUp(event);
                    break;
                /*
                 *
                 * This signs graph queries from the IAB then sends it back. The actual request is made from inside the IAB.
                 *
                 * */
                case 'signRequest':
                    this.signRequest(event);
                    break;
                /*
                 *
                 * Fetch cards and update persistence
                 *
                 * */
                case 'addCard':
                    this.getCards();
                    break;
                /*
                 *
                 * From IAB settings toggle hide and show of cards
                 *
                 * */
                case 'showHide':
                    this.toggleShow(event);
                    break;
                case 'buyCrypto':
                    const nextView = {
                        name: 'AmountPage',
                        params: {
                            fromBuyCrypto: true,
                            nextPage: 'CryptoOrderSummaryPage',
                            currency: this.configProvider.get().wallet.settings
                                .alternativeIsoCode
                        },
                        callback: () => {
                            this.hide();
                        }
                    };
                    this.events.publish('IncomingDataRedir', nextView);
                    break;
                case 'getAppVersion':
                    this.sendMessage({
                        message: 'getAppVersion',
                        payload: this.appProvider.info.version
                    });
                    break;
                case 'isDarkModeEnabled':
                    this.sendMessage({
                        message: 'isDarkModeEnabled',
                        payload: this.themeProvider.isDarkModeEnabled()
                    });
                    break;
                case 'updateWalletStatus':
                    this.updateWalletStatus();
                    break;
                case 'hasWalletWithFunds':
                    const hasWalletWithFunds = this.profileProvider.hasWalletWithFunds(12, 'USD');
                    this.sendMessage({
                        message: 'hasWalletWithFunds',
                        payload: hasWalletWithFunds
                    });
                    break;
                case 'checkProvisioningAvailability':
                    this.checkProvisioningAvailability();
                    break;
                case 'startAddPaymentPass':
                    this.startAddPaymentPass(event);
                    break;
                case 'completeAddPaymentPass':
                    this.completeAddPaymentPass(event);
                    break;
                case 'fbLogEvent':
                    this.logEvent(event);
                    break;
                case 'getVirtualImage': {
                    const { url, id } = event.data.params;
                    cordova.plugin.http.sendRequest(url, {
                        method: 'get',
                        responseType: 'arraybuffer'
                    }, ({ data }) => {
                        const base64Image = Buffer.from(data, 'binary').toString('base64');
                        const fullImageString = `data:image/jpg;base64, ${base64Image}`;
                        this.sendMessage({
                            message: 'virtualImageFetchComplete',
                            payload: { id, fullImageString }
                        });
                    }, ({ error }) => {
                        this.sendMessage({
                            message: 'virtualImageFetchComplete',
                            payload: { id, error }
                        });
                    });
                    break;
                }
                default:
                    break;
            }
        }));
    }
    checkAppleWallet(cards) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            return Promise.all(cards.map((card) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                if (card.cardType === 'virtual') {
                    const { isInWallet, isInWatch } = yield this.appleWalletProvider.checkPairedDevicesBySuffix(card.lastFourDigits);
                    return Object.assign({}, card, { isInWallet,
                        isInWatch });
                }
                return card;
            })));
        });
    }
    logEvent(event) {
        const { eventName, params } = event.data.params;
        this.analyticsProvider.logEvent(eventName, params);
    }
    getAppIdentity() {
        return new Promise((resolve, reject) => {
            this.appIdentityProvider.getIdentity(this.NETWORK, (err, appIdentity) => {
                if (err) {
                    reject(err);
                }
                resolve(appIdentity);
            });
        });
    }
    apiCall(json) {
        return new Promise((resolve, reject) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                const { priv, pub } = yield this.getAppIdentity();
                const url = `${this.BITPAY_API_URL}/api/v2/graphql`;
                const dataToSign = `${url}${JSON.stringify(json)}`;
                const signedData = __WEBPACK_IMPORTED_MODULE_4_bitauth__["sign"](dataToSign, priv);
                const headers = {
                    'x-identity': pub,
                    'x-signature': signedData
                };
                // appending the double /api/v2/graphql here is required as theres a quirk around using the api v2 middleware to reprocess graph requests
                const { data } = yield this.http
                    .post(`${url}/api/v2/graphql`, json, { headers })
                    .toPromise()
                    .catch(err => {
                    this.logger.error(`CARD FETCH ERROR  ${JSON.stringify(err)}`);
                    return reject(err);
                });
                resolve(data);
            }
            catch (err) {
                this.logger.error(err);
                reject(err);
            }
        }));
    }
    getCards() {
        return new Promise((resolve) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.log(`CARD - start get cards from network - ${this.NETWORK}`);
            this.events.publish('isFetchingDebitCards', true);
            const token = yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            if (!token) {
                return resolve();
            }
            const query = `
        query START_GET_CARDS($token:String!) {
          user:tkcoinUser(token:$token) {
            cards:debitCards {
              token,
              id,
              pagingSupport,
              currency {
                name
                code
                symbol
                precision
                decimals
              },
              lastFourDigits,
              provider,
              brand,
              status,
              disabled,
              activationDate,
              cardType,
              cardBalance,
            }
          }
        }
      `;
            const json = {
                query,
                variables: { token }
            };
            const data = yield this.apiCall(json);
            if (data && data.user && data.user.cards) {
                let cards = data.user.cards;
                const user = yield this.persistenceProvider.getTKCoinIdUserInfo(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                for (let card of cards) {
                    if (card.provider === 'galileo') {
                        yield this.persistenceProvider.setReachedCardLimit(true);
                        this.events.publish('reachedCardLimit');
                        break;
                    }
                }
                let currentCards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                cards = cards.map(c => {
                    // @ts-ignore
                    let { hide } = (currentCards || []).find(currentCard => currentCard.eid === c.id) || {};
                    if (c.disabled || ['lost', 'stolen', 'canceled'].includes(c.status)) {
                        hide = true;
                    }
                    return Object.assign({}, c, { hide, currencyMeta: c.currency, currency: c.currency.code, eid: c.id });
                });
                if (cards.length < 1) {
                    return resolve();
                }
                this.sortCards(cards, ['virtual', 'physical'], 'cardType');
                this.sortCards(cards, ['galileo', 'firstView'], 'provider');
                yield this.persistenceProvider.setBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK], user.email, cards);
                try {
                    this.ref.executeScript({
                        code: `sessionStorage.setItem(
                  'cards',
                  ${JSON.stringify(JSON.stringify(cards))}
                  )`
                    }, () => this.logger.log('added cards'));
                }
                catch (err) {
                    this.logger.log(JSON.stringify(err));
                }
                this.events.publish('isFetchingDebitCards', false);
                this.events.publish('updateCards', cards);
                this.logger.log('CARD - success retrieved cards');
                resolve(cards);
            }
        }));
    }
    getBalances() {
        return new Promise((resolve) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.log(`CARD - start getBalance from network - ${this.NETWORK}`);
            this.events.publish('isFetchingDebitCards', true);
            const token = yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            if (!token) {
                return resolve();
            }
            const query = `
        query START_GET_CARDS($token:String!) {
          user:tkcoinUser(token:$token) {
            cards:debitCards {
              id,
              cardBalance,
            }
          }
        }
      `;
            const json = {
                query,
                variables: { token }
            };
            const data = yield this.apiCall(json);
            if (data && data.user && data.user.cards) {
                const updatedCardBalances = data.user.cards;
                const currentCards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                const user = yield this.persistenceProvider.getTKCoinIdUserInfo(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                const updatedCards = currentCards.map(card => {
                    const { cardBalance } = updatedCardBalances.find(cb => cb.id === card.id);
                    return cardBalance ? Object.assign({}, card, { cardBalance }) : card;
                });
                yield this.persistenceProvider.setBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK], user.email, updatedCards);
                try {
                    this.ref.executeScript({
                        code: `sessionStorage.setItem(
                  'cards',
                  ${JSON.stringify(JSON.stringify(updatedCards))}
                  )`
                    }, () => {
                        this.sendMessage({ message: 'updatedBalances' });
                    });
                }
                catch (err) {
                    this.logger.log(JSON.stringify(err));
                }
                this.events.publish('updateCards', updatedCards);
                this.logger.log('CARD - success updated card balances');
                resolve(updatedCards);
            }
        }));
    }
    sortCards(cards, order, key) {
        const orderBy = (p) => order.indexOf(p) + 1 || order.length + 1;
        cards.sort((a, b) => {
            if (orderBy(a[key]) > orderBy(b[key])) {
                return 1;
            }
            if (orderBy(a[key]) < orderBy(b[key])) {
                return -1;
            }
            return 0;
        });
    }
    balanceUpdate(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let cards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            const { id, balance } = event.data.params;
            cards = cards.map(c => {
                if (c.eid === id) {
                    return Object.assign({}, c, { cardBalance: balance });
                }
                return c;
            });
            const user = yield this.persistenceProvider.getTKCoinIdUserInfo(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            // adding this for possible race conditions
            if (cards.length < 1) {
                return;
            }
            yield this.persistenceProvider.setBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK], user.email, cards);
            this.events.publish('updateCards', cards);
        });
    }
    updateCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.getCards();
            setTimeout(() => {
                this.events.publish('updateCards');
            });
        });
    }
    syncCardState(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let { cards } = event.data.params;
            const user = yield this.persistenceProvider.getTKCoinIdUserInfo(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            if (!cards.length) {
                return;
            }
            // safety for cardBalance
            if (!cards.some(c => c.cardBalance)) {
                const currentCards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                cards = cards.map(c => {
                    const currentCard = currentCards.find(cc => cc.id === c.id);
                    return Object.assign({}, c, { cardBalance: currentCard && currentCard.cardBalance });
                });
            }
            yield this.persistenceProvider.setBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK], user.email, cards);
            this.logger.log('CARD synced state');
        });
    }
    signRequest(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                const token = yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                const { query, variables, name } = event.data.params;
                const json = {
                    query,
                    variables: Object.assign({}, variables, { token })
                };
                this.appIdentityProvider.getIdentity(this.NETWORK, (err, appIdentity) => {
                    if (err) {
                        return;
                    }
                    const url = `${this.BITPAY_API_URL}/`;
                    const dataToSign = `${url}${JSON.stringify(json)}`;
                    const signedData = __WEBPACK_IMPORTED_MODULE_4_bitauth__["sign"](dataToSign, appIdentity.priv);
                    const headers = {
                        'x-identity': appIdentity.pub,
                        'x-signature': signedData
                    };
                    this.cardIAB_Ref.executeScript({
                        code: `window.postMessage('${JSON.stringify({
                            url,
                            headers,
                            json,
                            name
                        })}', '*')`
                    }, () => this.logger.log(`card - signed request -> ${name}`));
                });
            }
            catch (err) { }
        });
    }
    graphRequest(request) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                request = Object.assign({}, request, { query: request.query.replace(/\r?\n|\r/g, '') });
                const token = yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
                const { query, variables } = request;
                const json = {
                    query,
                    variables: Object.assign({}, variables, { token })
                };
                const { priv, pub } = yield this.tkcoinIdProvider.getAppIdentity();
                let url = `https://tkcoin.org/`;
                const dataToSign = `${url}${JSON.stringify(json)}`;
                const signedData = __WEBPACK_IMPORTED_MODULE_4_bitauth__["sign"](dataToSign, priv);
                const headers = [signedData, pub];
                return this.appleWalletProvider.graphRequest(headers, JSON.stringify(json));
            }
            catch (err) {
                this.logger.error(`graph request failed ${err}`);
            }
        });
    }
    purchaseAttempt(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const { invoiceId } = event.data.params;
            this.logger.debug('Incoming-data: Handling tkcoin invoice');
            try {
                const details = yield this.payproProvider.getPayProOptions(`${this.BITPAY_API_URL}/i/${invoiceId}`);
                let hasWallets = {};
                let availableWallets = [];
                for (const option of details.paymentOptions) {
                    const fundedWallets = this.profileProvider.getWallets({
                        coin: option.currency.toLowerCase(),
                        network: option.network,
                        minAmount: option.estimatedAmount
                    });
                    if (fundedWallets.length === 0) {
                        option.disabled = true;
                    }
                    else {
                        hasWallets[option.currency.toLowerCase()] = fundedWallets.length;
                        availableWallets.push(option);
                    }
                }
                const stateParams = {
                    payProOptions: details,
                    walletCardRedir: true,
                    hasWallets
                };
                let nextView = {
                    name: 'SelectInvoicePage',
                    params: stateParams
                };
                this.events.publish('IncomingDataRedir', nextView);
            }
            catch (err) {
                this.events.publish('incomingDataError', err);
                this.logger.error(err);
            }
            this.hide();
        });
    }
    toggleShow(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.events.publish('showHideUpdate', 'inProgress');
            let cards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            if (cards.length < 1) {
                return;
            }
            const { hide, provider, id } = event.data.params;
            cards = cards.map(c => {
                if ((provider === 'galileo' && c.provider === provider) || c.id === id) {
                    return Object.assign({}, c, { hide });
                }
                return c;
            });
            const user = yield this.persistenceProvider.getTKCoinIdUserInfo(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            yield this.persistenceProvider.setBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK], user.email, cards);
            try {
                this.ref.executeScript({
                    code: `sessionStorage.setItem(
                  'cards',
                  ${JSON.stringify(JSON.stringify(cards))}
                  )`
                }, () => this.logger.log('added cards'));
            }
            catch (err) {
                this.logger.log(JSON.stringify(err));
            }
            this.logger.log('CARD - showHideUpdate - complete');
            this.events.publish('showHideUpdate', 'complete');
        });
    }
    topUp(event) {
        const { id, currency } = event.data.params;
        let nextView = {
            name: 'AmountPage',
            params: {
                nextPage: 'TKCoinCardTopUpPage',
                currency,
                id,
                card: 'v2'
            }
        };
        this.events.publish('IncomingDataRedir', nextView);
        this.hide();
    }
    pairing(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const { params, params: { withNotification, dashboardRedirect, paymentUrl } } = event.data;
            // set the overall app loading state
            this.onGoingProcess.set('connectingTKCoinId');
            yield this.persistenceProvider.removeAllTKCoinAccounts(__WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["a" /* Network */][this.NETWORK]);
            // generates pairing token and also fetches user basic info and caches both
            this.tkcoinIdProvider.generatePairingToken(params, (user) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                if (user) {
                    this.sendMessage({ message: 'pairingSuccess' });
                    this.logger.log(`pairing success -> ${JSON.stringify(user)}`);
                    // publish to correct window
                    this.events.publish('TKCoinId/Connected');
                    // if with notification -> connect your tkcoin id in settings or pairing from personal dashboard
                    if (withNotification) {
                        // resets inappbrowser connect state
                        this.cardIAB_Ref.executeScript({
                            code: `window.postMessage(${JSON.stringify({
                                message: 'reset'
                            })}, '*')`
                        }, () => this.logger.log(`card -> reset iab state`));
                        // pairing notification
                        const infoSheet = this.actionSheetProvider.createInfoSheet('in-app-notification', {
                            title: 'TKCoin ID',
                            body: this.translate.instant('TKCoin ID successfully connected.')
                        });
                        if (dashboardRedirect) {
                            this.events.publish('IncomingDataRedir', {
                                name: 'CardsPage'
                            });
                            infoSheet.onDidDismiss(() => {
                                this.loadingWrapper(() => {
                                    this.sendMessage({ message: 'loadDashboard' });
                                    this.show();
                                });
                            });
                        }
                        // paymentUrl - so pass to unlock context
                        if (paymentUrl) {
                            infoSheet.onDidDismiss(() => {
                                this.events.publish('unlockInvoice', paymentUrl);
                            });
                        }
                        yield infoSheet.present();
                        // close in app browser
                        this.hide();
                    }
                    // publish new user
                    this.user.next(user);
                    if (!paymentUrl) {
                        // fetch new cards
                        const cards = yield this.getCards();
                        this.events.publish('updateCards');
                        this.events.publish('CardAdvertisementUpdate', {
                            status: 'connected',
                            cards
                        });
                    }
                    // clear out loading state
                    setTimeout(() => {
                        this.onGoingProcess.clear();
                    }, 300);
                }
            }), (err) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                this.logger.error(`pairing error -> ${err}`);
                this.sendMessage({ message: 'pairingFailed' });
                // clear out loading state
                this.onGoingProcess.clear();
                // close in app browser
                if (withNotification) {
                    const errorSheet = this.actionSheetProvider.createInfoSheet('default-error', {
                        title: 'TKCoin ID',
                        msg: 'Uh oh, something went wrong please try again.'
                    });
                    if (dashboardRedirect) {
                        errorSheet.onDidDismiss(() => {
                            this.sendMessage({ message: 'pairingOnly' });
                            this.show();
                        });
                    }
                    yield errorSheet.present();
                    this.hide();
                }
            }));
        });
    }
    setTheme() {
        let message = 'isDarkModeEnabled';
        this.sendMessage({
            message,
            payload: { theme: this.themeProvider.isDarkModeEnabled() }
        });
    }
    sendMessage(message, cb) {
        const script = {
            code: `window.postMessage(${JSON.stringify(Object.assign({}, message))}, '*')`
        };
        this.cardIAB_Ref.executeScript(script, cb);
    }
    hide() {
        if (this.cardIAB_Ref) {
            this.sendMessage({ message: 'iabHiding' });
            this.cardIAB_Ref.hide();
            this._isHidden = true;
        }
    }
    show(disableLoadingScreen) {
        if (this.cardIAB_Ref) {
            let message = 'iabOpening';
            if (disableLoadingScreen) {
                message = `${message}?enableLoadingScreen`;
            }
            this.setTheme();
            this.sendMessage({ message });
            this.cardIAB_Ref.show();
            this._isHidden = false;
        }
    }
    loadingWrapper(cb) {
        // wrapping in a setTimeout to smooth out initial iab animation
        const wrappedCb = () => setTimeout(cb, LOADING_WRAPPER_TIMEOUT);
        if (this.IABReady) {
            wrappedCb();
        }
        else {
            this.onGoingProcess.set('generalAwaiting');
            let attempts = 0;
            const interval = setInterval(() => {
                if (attempts >= IAB_LOADING_ATTEMPTS) {
                    clear();
                    this.actionSheetProvider
                        .createInfoSheet('default-error', {
                        title: 'BitPay Card',
                        msg: 'Uh oh, something went wrong please try again later.'
                    })
                        .present();
                }
                attempts++;
            }, IAB_LOADING_INTERVAL);
            const subscription = this.IABLoaded$.subscribe(() => {
                wrappedCb();
                clear();
            });
            const clear = () => {
                clearInterval(interval);
                this.onGoingProcess.clear();
                subscription && subscription.unsubscribe();
            };
        }
    }
    pause() {
        this._pausedState = this.isVisible;
        this.hide();
    }
    resume() {
        if (this._pausedState) {
            if (this.cardIAB_Ref) {
                this.cardIAB_Ref.show();
                this._isHidden = false;
            }
        }
        this._pausedState = false;
    }
    hasFirstView() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const cards = yield this.persistenceProvider.getBitpayDebitCards(this.NETWORK);
            const hasFirstView = cards && !!cards.find(c => c.provider === 'firstView');
            this.logger.log(`CARD - has first view cards = ${hasFirstView}`);
            if (this.cardIAB_Ref) {
                this.cardIAB_Ref.executeScript({
                    code: `sessionStorage.setItem(
                  'hasFirstView',
                  ${hasFirstView}
                  )`
                }, () => this.logger.log('added cards'));
            }
            return hasFirstView;
        });
    }
    updateWalletStatus() {
        let wallets = this.profileProvider.wallet;
        if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](wallets)) {
            this.events.publish('Local/HomeBalance');
            return;
        }
        this.logger.debug('Fetching All Wallets and Updating Total Balance');
        wallets = __WEBPACK_IMPORTED_MODULE_6_lodash__["filter"](this.profileProvider.wallet, w => {
            return !w.hidden;
        });
        __WEBPACK_IMPORTED_MODULE_6_lodash__["each"](wallets, wallet => {
            this.events.publish('Local/WalletFocus', {
                walletId: wallet.id,
                force: true
            });
        });
    }
    checkProvisioningAvailability() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                // check if current ios version supports apple wallet
                const isAvailable = yield this.appleWalletProvider.available();
                let payload = {
                    isAvailable
                };
                if (!isAvailable) {
                    this.logger.log('appleWallet - startAddPaymentPass - not available');
                    payload = Object.assign({}, payload, { error: `ios version (${this.device.version}) does not support apple wallet` });
                }
                this.sendMessage({
                    message: 'setProvisioningAvailability',
                    payload
                });
            }
            catch (err) {
                this.logger.error(`appleWallet - checkProvisioningAvailability - ${err}`);
                this.sendMessage({
                    message: 'setProvisioningAvailability',
                    payload: {
                        isAvailable: false,
                        error: err
                    }
                });
            }
        });
    }
    startAddPaymentPass(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            /* FROM CARD IAB
             * data - cardholderName, primaryAccountSuffix
             * id - card Id
             * */
            this.logger.debug(`appleWallet - startAddPaymentPass - ${JSON.stringify(event)}`);
            const { data, id } = event.data.params;
            // for testing purposes
            try {
                const result = yield this.appleWalletProvider.checkPairedDevicesBySuffix(data.cardSuffix);
                this.logger.debug(`MDES ${JSON.stringify(result)}`);
            }
            catch (err) {
                this.logger.error(`MDES checkCard${JSON.stringify(err)}`);
            }
            // ios handler
            if (this.platform.is('ios')) {
                try {
                    this.hide();
                    const { data: certs } = yield this.appleWalletProvider.startAddPaymentPass(data);
                    this.logger.debug('appleWallet - startAddPaymentPass - success');
                    this.logger.debug(JSON.stringify(certs));
                    const mdesCertOnlyFlag = yield this.persistenceProvider.getTempMdesCertOnlyFlag();
                    if (mdesCertOnlyFlag === 'bypassed')
                        return;
                    const { certificateLeaf: cert1, certificateSubCA: cert2, nonce, nonceSignature } = certs || {};
                    const request = {
                        query: `
            mutation START_CREATE_PROVISIONING_REQUEST($token:String!, $csrf:String, $cardId:String!, $input:ProvisionInputType!) {
              user:tkcoinUser(token:$token, csrf:$csrf) {
                card:debitCard(cardId:$cardId) {
                  provisioningData:createProvisioningRequest(input:$input) {
                    activationData,
                    encryptedPassData,
                    wrappedKey
                  }
                }
              }
            }
          `,
                        variables: {
                            cardId: id,
                            input: {
                                walletProvider: 'apple',
                                cert1,
                                cert2,
                                nonce,
                                nonceSignature
                            }
                        }
                    };
                    this.logger.debug(`appleWallet - start token graph call`);
                    this.logger.debug(`MDES- req ${JSON.stringify(request)}`);
                    const res = yield this.graphRequest(request);
                    this.logger.debug(JSON.stringify(res));
                    yield this.completeAddPaymentPass({ res, id });
                }
                catch (err) {
                    this.logger.error(`appleWallet - startAddPaymentPassError - ${JSON.stringify(err)}`);
                    this.logger.error(JSON.stringify(err, Object.getOwnPropertyNames(err)));
                }
            }
        });
    }
    completeAddPaymentPass({ res, id }) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            /* FROM CARD IAB
             * data - activationData, encryptedPassData, wrappedKey
             * id - card Id
             * */
            this.logger.debug(`appleWallet - completeAddPaymentPass - ${JSON.stringify(res)}`);
            const { user: { card: { provisioningData } } } = res.data;
            if (!provisioningData)
                return;
            const { wrappedKey: ephemeralPublicKey, activationData, encryptedPassData } = provisioningData || {};
            try {
                const res = yield this.appleWalletProvider.completeAddPaymentPass({
                    activationData,
                    encryptedPassData,
                    ephemeralPublicKey
                });
                const payload = res === 'success'
                    ? { id }
                    : { id, error: 'completeAddPaymentPass failed' };
                this.sendMessage({
                    message: 'completeAddPaymentPass',
                    payload
                });
                yield new Promise(res => setTimeout(res, 300));
                this.cardIAB_Ref.show();
            }
            catch (err) {
                this.logger.error(`appleWallet - completeAddPaymentPass - ${err}`);
                this.sendMessage({
                    message: 'completeAddPaymentPass',
                    payload: {
                        id,
                        error: 'completeAddPaymentPass failed'
                    }
                });
                yield new Promise(res => setTimeout(res, 300));
                this.cardIAB_Ref.show();
            }
        });
    }
};
IABCardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_13__paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_12__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_15__tkcoin_id_tkcoin_id__["a" /* TKCoinIdProvider */],
        __WEBPACK_IMPORTED_MODULE_11__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_22__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_8__action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_16__in_app_browser__["a" /* InAppBrowserProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_14__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_21__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_17__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_20__external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_23__theme_theme__["a" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_19__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_10__apple_wallet_apple_wallet__["a" /* AppleWalletProvider */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_18__analytics_analytics__["a" /* AnalyticsProvider */]])
], IABCardProvider);

//# sourceMappingURL=card.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2).Buffer))

/***/ }),

/***/ 291:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmailNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);



// providers




let EmailNotificationsProvider = class EmailNotificationsProvider {
    constructor(configProvider, profileProvider, walletProvider, logger) {
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.logger.debug('EmailNotificationsProvider initialized');
    }
    updateEmail(opts) {
        opts = opts || {};
        if (!opts.email)
            return;
        this.configProvider.set({
            emailFor: null,
            emailNotifications: {
                enabled: opts.enabled,
                email: opts.enabled ? opts.email : null
            }
        });
        setTimeout(() => {
            const opts = {
                showHidden: true
            };
            let wallets = this.profileProvider.getWallets(opts);
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
    getEmailIfEnabled(config) {
        config = config ? config : this.configProvider.get();
        if (config.emailNotifications) {
            if (!config.emailNotifications.enabled)
                return;
            if (config.emailNotifications.email)
                return config.emailNotifications.email;
        }
        if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](config.emailFor))
            return;
        // Backward compatibility
        let emails = __WEBPACK_IMPORTED_MODULE_6_lodash__["values"](config.emailFor);
        for (var i = 0; i < emails.length; i++) {
            if (emails[i] !== null && typeof emails[i] !== 'undefined') {
                return emails[i];
            }
        }
    }
    init() {
        let config = this.configProvider.get();
        if (config.emailNotifications && config.emailNotifications.enabled) {
            // If email already set
            if (config.emailNotifications.email)
                return;
            var currentEmail = this.getEmailIfEnabled(config);
            this.updateEmail({
                enabled: currentEmail ? true : false,
                email: currentEmail
            });
        }
    }
};
EmailNotificationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_5__wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], EmailNotificationsProvider);

//# sourceMappingURL=email-notifications.js.map

/***/ }),

/***/ 296:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__backup_game_backup_game__ = __webpack_require__(972);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logs_logs__ = __webpack_require__(377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(17);





// pages

// providers










let BackupKeyPage = class BackupKeyPage {
    constructor(navCtrl, navParams, logger, profileProvider, bwcErrorProvider, translate, actionSheetProvider, keyProvider, errorsProvider, popupProvider, platformProvider, logsProvider, appProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.errorsProvider = errorsProvider;
        this.popupProvider = popupProvider;
        this.platformProvider = platformProvider;
        this.logsProvider = logsProvider;
        this.appProvider = appProvider;
        this.keyId = this.navParams.data.keyId;
        this.walletGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.credentialsEncrypted = this.walletGroup.isPrivKeyEncrypted;
    }
    ionViewDidEnter() {
        if (!this.walletGroup.canSign) {
            this.showNoRecoveryPhraseError();
            return;
        }
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            let keys;
            try {
                keys = this.keyProvider.get(this.keyId, password);
            }
            catch (err) {
                const title = 'Your wallet is in a corrupt state. Please contact support and share the logs provided.';
                let message;
                try {
                    message =
                        err instanceof Error ? err.toString() : JSON.stringify(err);
                }
                catch (error) {
                    message = 'Unknown error';
                }
                this.popupProvider.ionicAlert(title, message).then(() => {
                    // Share logs
                    const platform = this.platformProvider.isCordova
                        ? this.platformProvider.isAndroid
                            ? 'android'
                            : 'ios'
                        : 'desktop';
                    this.logsProvider.get(this.appProvider.info.nameCase, platform);
                });
            }
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](keys)) {
                this.logger.warn('Empty keys');
            }
            this.credentialsEncrypted = false;
            this.keys = keys;
            if (!this.keys || !this.keys.mnemonic) {
                this.showNoRecoveryPhraseError();
                return;
            }
            this.showSafeguardMessage();
            this.setFlow();
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                const title = this.translate.instant('Could not decrypt wallet');
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
                }
            }
            this.navCtrl.pop();
        });
    }
    showNoRecoveryPhraseError() {
        const title = this.translate.instant('Wallet recovery phrase not available');
        let err = this.translate.instant('You can still export it from "Export Wallet" option.');
        this.showErrorInfoSheet(err, title);
        this.navCtrl.pop();
        this.logger.warn('no mnemonics');
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.warn('Could not get keys:', err);
        this.errorsProvider.showDefaultError(err, infoSheetTitle);
    }
    goToBackupGame() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__backup_game_backup_game__["a" /* BackupGamePage */], {
            words: this.mnemonicWords,
            keys: this.keys,
            keyId: this.keyId,
            isOnboardingFlow: this.navParams.data.isOnboardingFlow
        });
    }
    setFlow() {
        if (!this.keys)
            return;
        let words = this.keys.mnemonic;
        this.mnemonicWords = words.split(/[\u3000\s]+/);
        this.wordToShow = 0;
    }
    showSafeguardMessage() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-safeguard-warning');
        infoSheet.present();
    }
    nextWord() {
        this.wordToShow++;
    }
    previousWord() {
        this.wordToShow--;
    }
};
BackupKeyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-backup-key',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/backup/backup-key/backup-key.html"*/'<wide-header-page title="{{\'Recovery Phrase\' | translate}}">\n  <div page-content>\n    <div class="key-container" *ngIf="walletGroup.canSign && mnemonicWords && mnemonicWords[0]">\n      <div class="word-container">\n        <div class="word-title" translate>Write down each word.</div>\n        <div class="word">\n          <span>{{mnemonicWords[wordToShow]}}</span>\n        </div>\n        <div class="word-number">\n          {{wordToShow + 1}} / {{mnemonicWords.length}}\n        </div>\n      </div>\n    </div>\n    <div class="bottom-absolute" [ngClass]="{\'right-align\': wordToShow == 0}" *ngIf="walletGroup.canSign && mnemonicWords && mnemonicWords[0]">\n      <button *ngIf="wordToShow > 0" ion-button clear class="button-left" [disabled]="credentialsEncrypted" (click)="previousWord()">\n        {{\'Previous\' | translate}}\n      </button>\n      <button *ngIf="wordToShow < mnemonicWords.length - 1" ion-button clear class="button-right" [disabled]="credentialsEncrypted" (click)="nextWord()">\n        {{\'Next\' | translate}}\n      </button>\n      <button *ngIf="wordToShow == mnemonicWords.length - 1" ion-button clear class="button-right" [disabled]="credentialsEncrypted" (click)="goToBackupGame()">\n        {{\'Continue\' | translate}}\n      </button>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/backup/backup-key/backup-key.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logs_logs__["a" /* LogsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */]])
], BackupKeyPage);

//# sourceMappingURL=backup-key.js.map

/***/ }),

/***/ 297:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DisclaimerPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_in_app_browser_card__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_tabs_tabs__ = __webpack_require__(501);




// Providers





// Pages

let DisclaimerPage = class DisclaimerPage {
    constructor(navCtrl, logger, externalLinkProvider, persistenceProvider, translate, iabCardProvider, events, platform, appProvider) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.iabCardProvider = iabCardProvider;
        this.events = events;
        this.platform = platform;
        this.appProvider = appProvider;
        this.appName = this.appProvider.info.nameCase;
        this.accepted = {
            first: false,
            second: false
        };
        this.terms = {
            accepted: false
        };
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: DisclaimerPage');
        this.initializeBackButtonHandler();
    }
    ionViewWillLeave() {
        this.unregisterBackButtonAction && this.unregisterBackButtonAction();
    }
    selectTerms() {
        this.terms.accepted = !this.terms.accepted;
    }
    openDisclaimer() {
        let url = 'https://tkcoin.org/legal/terms-of-use/#wallet-terms-of-use';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Wallet Terms of Use');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    confirm() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.persistenceProvider.setDisclaimerAccepted();
        this.persistenceProvider.setOnboardingFlowFlag('enabled');
        this.persistenceProvider.getCardFastTrackEnabled().then(context => {
            if (context) {
                setTimeout(() => {
                    this.iabCardProvider.show();
                    this.iabCardProvider.sendMessage({
                        message: 'debitCardOrder',
                        payload: context
                    });
                }, 200);
                this.persistenceProvider.setCardExperimentFlag('enabled');
                setTimeout(() => {
                    this.events.publish('experimentUpdateStart');
                    setTimeout(() => {
                        this.events.publish('experimentUpdateComplete');
                    }, 300);
                }, 400);
            }
        });
        this.navCtrl.setRoot(__WEBPACK_IMPORTED_MODULE_9__pages_tabs_tabs__["a" /* TabsPage */]).then(_ => {
            this.navCtrl.popToRoot();
        });
    }
    initializeBackButtonHandler() {
        this.unregisterBackButtonAction = this.platform.registerBackButtonAction(() => { });
    }
    acceptTerm(term) {
        this.accepted[term] = !this.accepted[term];
    }
};
DisclaimerPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-disclaimer',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/disclaimer/disclaimer.html"*/'<wide-header-page title="{{ \'Two things you should know\' | translate }}" hideBackButton="true">\n  <div page-content class="disclaimer-wrapper">\n    <ion-list class="checkbox-list" no-lines>\n      <div class="term-container" (click)="acceptTerm(\'first\')">\n        <ion-item>\n          <ion-checkbox [(ngModel)]="accepted.first"></ion-checkbox>\n        </ion-item>\n        <div class="term-title">\n          {{\'Your funds are in your custody\' | translate}}\n        </div>\n        <div class="term-note">\n          {{\'I understand that my funds are held and controlled securely on this device, not by a company.\' | translate}}\n        </div>\n      </div>\n      <div class="term-container" (click)="acceptTerm(\'second\')" *ngIf="accepted.first">\n        <ion-item>\n          <ion-checkbox [(ngModel)]="accepted.second"></ion-checkbox>\n        </ion-item>\n        <div class="term-title">\n          {{\'{appName} cannot recover your funds for you if you lose your recovery key\' | translate:{appName: appName} }}\n        </div>\n        <div class="term-note">\n          {{\'I understand that if this app is moved to another device or deleted, my crypto funds can only be recovered with my recovery phrase.\' | translate}}\n        </div>\n      </div>\n    </ion-list>\n  </div>\n  <div footer-content *ngIf="accepted.first && accepted.second" class="disclaimer-footer">\n    <ion-list class="checkbox-list checkbox-list-terms" no-lines>\n      <div class="term-container bg-none" (click)="selectTerms()">\n        <ion-item>\n          <ion-checkbox [(ngModel)]="terms.accepted"></ion-checkbox>\n        </ion-item>\n        <div class="term-note">\n          {{\'I have read, understood, and agree with the Terms of Use.\' | translate}}\n        </div>\n      </div>\n    </ion-list>\n    <button ion-button clear color="primary" class="button-standard no-margin-bottom" (click)="openDisclaimer()">\n      {{\'View complete Terms of Use\' | translate}}\n    </button>\n    <button ion-button class="button-standard" (click)="confirm()" [disabled]="!accepted.first || !accepted.second || !terms.accepted">\n      {{\'Confirm & Finish\' | translate}}\n    </button>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/disclaimer/disclaimer.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_in_app_browser_card__["a" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */]])
], DisclaimerPage);

//# sourceMappingURL=disclaimer.js.map

/***/ }),

/***/ 298:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JoinWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__wallet_details_wallet_details__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_clipboard_clipboard__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(31);






// Pages



// Providers












let JoinWalletPage = class JoinWalletPage {
    constructor(bwcErrorProvider, bwcProvider, configProvider, form, navCtrl, navParams, derivationPathHelperProvider, onGoingProcessProvider, profileProvider, walletProvider, logger, translate, events, pushNotificationsProvider, clipboardProvider, modalCtrl, errorsProvider, actionSheetProvider) {
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.form = form;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.clipboardProvider = clipboardProvider;
        this.modalCtrl = modalCtrl;
        this.errorsProvider = errorsProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.updateCodeHandler = data => {
            if (this.coin.toLowerCase() == 'eth') {
                this.joinForm.controls['invitationCode'].setValue(data.value);
            }
            else {
                const invitationCode = data.value.replace('copay:', '');
                this.onQrCodeScannedJoin(invitationCode);
            }
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.defaults = this.configProvider.getDefaults();
        this.showAdvOpts = false;
        this.keyId = this.navParams.data.keyId;
        this.coin = this.navParams.data.coin;
        this.regex = /^[0-9A-HJ-NP-Za-km-z]{70,80}$/; // For invitationCode
        this.joinForm = this.form.group({
            walletName: [null],
            myName: [null],
            invitationCode: [null],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [null]
        });
        if (this.coin === 'eth') {
            this.joinForm.get('walletName').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
            this.joinForm.controls['walletName'].setValue(this.translate.instant('ETH Multisig'));
            this.joinForm.get('invitationCode').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
        }
        else {
            this.joinForm.get('myName').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
            this.joinForm
                .get('invitationCode')
                .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].pattern(this.regex)]);
        }
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
        this.events.subscribe('Local/JoinScan', this.updateCodeHandler);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: JoinWalletPage');
    }
    ionViewWillEnter() {
        if (this.navParams.data.url) {
            let data = this.navParams.data.url;
            data = data.replace('copay:', '');
            this.onQrCodeScannedJoin(data);
        }
        if (this.coin.toLowerCase() == 'eth' && !this.pairedWallet) {
            this.showPairedWalletSelector();
        }
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/JoinScan', this.updateCodeHandler);
    }
    showPairedWalletSelector() {
        this.isOpenSelector = true;
        const eligibleWallets = this.keyId
            ? this.profileProvider.getWalletsFromGroup({
                keyId: this.keyId,
                coin: 'eth',
                m: 1,
                n: 1
            })
            : [];
        const walletSelector = this.actionSheetProvider.createInfoSheet('linkEthWallet', {
            wallets: eligibleWallets,
            isEthMultisig: true
        });
        walletSelector.present();
        walletSelector.onDidDismiss(pairedWallet => {
            this.isOpenSelector = false;
            if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](pairedWallet)) {
                this.pairedWallet = pairedWallet;
            }
        });
    }
    onQrCodeScannedJoin(data) {
        if (this.regex.test(data)) {
            this.joinForm.controls['invitationCode'].setValue(data);
            this.processInvitation(data);
        }
        else {
            this.errorsProvider.showDefaultError(this.translate.instant('Invalid data'), this.translate.instant('Error'));
        }
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.joinForm.get('recoveryPhrase').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
        }
        else {
            this.joinForm.get('recoveryPhrase').setValidators(null);
        }
        this.joinForm.controls['recoveryPhrase'].setValue(null);
        this.joinForm.controls['selectedSeed'].setValue(seed);
        this.processInvitation(this.joinForm.value.invitationCode);
    }
    setDerivationPath(network) {
        const path = network == 'testnet'
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.joinForm.controls['derivationPath'].setValue(path);
    }
    processInvitation(invitation) {
        if (this.regex.test(invitation)) {
            this.logger.info('Processing invitation code...');
            let walletData;
            try {
                walletData = this.bwcProvider.parseSecret(invitation);
                this.coin = walletData.coin;
                this.derivationPathForTestnet = this.derivationPathHelperProvider.defaultTestnet;
                this.derivationPathByDefault =
                    this.coin == 'bch'
                        ? this.derivationPathHelperProvider.defaultBCH
                        : this.derivationPathHelperProvider.defaultBTC;
                this.setDerivationPath(walletData.network);
                this.logger.info('Correct invitation code for ' + walletData.network);
            }
            catch (ex) {
                this.logger.warn('Error parsing invitation: ' + ex);
            }
        }
    }
    createAndBindMultisigWallet(pairedWallet, multisigEthInfo) {
        this.profileProvider
            .createMultisigEthWallet(pairedWallet, multisigEthInfo)
            .then(multisigWallet => {
            // store preferences for the paired eth wallet
            this.walletProvider.updateRemotePreferences(pairedWallet);
            this.navCtrl.popToRoot({ animate: false }).then(() => {
                if (multisigWallet) {
                    setTimeout(() => {
                        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                            walletId: multisigWallet.credentials.walletId
                        });
                    }, 1000);
                }
            });
        });
    }
    setOptsAndJoin() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.coin === 'eth') {
                const multisigContractAddress = this.joinForm.value.invitationCode;
                const walletName = this.joinForm.value.walletName;
                const ownerAddress = yield this.walletProvider.getAddress(this.pairedWallet, false);
                let contractInfo;
                try {
                    contractInfo = yield this.walletProvider.getMultisigContractInfo(this.pairedWallet, {
                        multisigContractAddress
                    });
                }
                catch (error) {
                    this.logger.error('Multisig contract address not found', error.message);
                }
                if (!contractInfo) {
                    // show error multisig contract not found
                    const title = this.translate.instant('Error');
                    const subtitle = this.translate.instant('Multisig contract address not found.');
                    this.errorsProvider.showDefaultError(subtitle, title);
                }
                else if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["includes"](contractInfo.owners, ownerAddress)) {
                    // show error multisig contract wrong owner
                    const title = this.translate.instant('Error');
                    const subtitle = this.translate.instant('The ethereum paired wallet you choose does not belong to this contract');
                    this.errorsProvider.showDefaultError(subtitle, title);
                }
                else {
                    const m = contractInfo.owners.length;
                    const n = Number(contractInfo.required);
                    this.createAndBindMultisigWallet(this.pairedWallet, {
                        multisigContractAddress,
                        walletName,
                        n,
                        m
                    });
                }
                return;
            }
            const opts = {
                keyId: this.keyId,
                secret: this.joinForm.value.invitationCode,
                myName: this.joinForm.value.myName,
                bwsurl: this.joinForm.value.bwsURL,
                coin: this.coin
            };
            const setSeed = this.joinForm.value.selectedSeed == 'set';
            if (setSeed) {
                const words = this.joinForm.value.recoveryPhrase;
                if (words.indexOf(' ') == -1 &&
                    words.indexOf('prv') == 1 &&
                    words.length > 108) {
                    opts.extendedPrivateKey = words;
                }
                else {
                    opts.mnemonic = words;
                }
                const derivationPath = this.joinForm.value.derivationPath;
                opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
                opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
                opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
                // set opts.useLegacyPurpose
                if (this.derivationPathHelperProvider.parsePath(derivationPath).purpose ==
                    "44'") {
                    opts.useLegacyPurpose = true;
                    this.logger.debug('Using 44 for Multisig');
                }
                // set opts.useLegacyCoinType
                if (this.coin == 'bch' &&
                    this.derivationPathHelperProvider.parsePath(derivationPath).coinCode ==
                        "0'") {
                    opts.useLegacyCoinType = true;
                    this.logger.debug('Using 0 for BCH creation');
                }
                if (!opts.networkName ||
                    !opts.derivationStrategy ||
                    !Number.isInteger(opts.account)) {
                    const title = this.translate.instant('Error');
                    const subtitle = this.translate.instant('Invalid derivation path');
                    this.errorsProvider.showDefaultError(subtitle, title);
                    return;
                }
                if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.joinForm.value.derivationPath, this.coin)) {
                    const title = this.translate.instant('Error');
                    const subtitle = this.translate.instant('Invalid derivation path for selected coin');
                    this.errorsProvider.showDefaultError(subtitle, title);
                    return;
                }
            }
            if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
                this.errorsProvider.showDefaultError(subtitle, title);
                return;
            }
            this.join(opts);
        });
    }
    join(opts) {
        this.onGoingProcessProvider.set('joiningWallet');
        opts['keyId'] = this.keyId;
        this.profileProvider
            .joinWallet(opts)
            .then(wallet => {
            this.clipboardProvider.clearClipboardIfValidData(['JoinWallet']);
            this.onGoingProcessProvider.clear();
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            this.navCtrl.popToRoot({ animate: false }).then(() => {
                setTimeout(() => {
                    if (wallet.isComplete()) {
                        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                            walletId: wallet.credentials.walletId
                        });
                    }
                    else {
                        const copayerModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__["a" /* CopayersPage */], {
                            walletId: wallet.credentials.walletId
                        }, {
                            cssClass: 'wallet-details-modal'
                        });
                        copayerModal.present();
                    }
                }, 1000);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            const title = this.translate.instant('Error');
            this.errorsProvider.showDefaultError(this.bwcErrorProvider.msg(err), title);
            return;
        });
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__scan_scan__["a" /* ScanPage */], { fromJoin: true });
    }
};
JoinWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-join-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/join-wallet/join-wallet.html"*/'<wide-header-page title="{{\'Join Shared Wallet\' | translate}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="setOptsAndJoin()" [disabled]="!joinForm.valid" ion-button>\n      <span translate>Join</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <button class="linked-wallet" *ngIf="coin === \'eth\'" ion-item (click)="showPairedWalletSelector()" detail-none>\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Linked to</span>\n        </div>\n      </ion-label>\n\n      <ion-note item-end>\n        <ion-row align-items-center class="wallet" *ngIf="pairedWallet">\n          <ion-col>\n            <coin-icon [coin]="pairedWallet.coin" [network]="pairedWallet.network"></coin-icon>\n          </ion-col>\n\n          <ion-col>\n            <span class="note-container ellipsis">{{pairedWallet.name}}</span>\n          </ion-col>\n        </ion-row>\n\n        <ion-row align-items-center class="wallet" *ngIf="!pairedWallet">\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </ion-row>\n      </ion-note>\n    </button>\n\n    <form [formGroup]="joinForm">\n      <ion-item *ngIf="coin !== \'eth\'">\n        <ion-label floating>{{\'Your name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="myName"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="coin === \'eth\'">\n        <ion-label floating>{{\'Wallet name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="walletName"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label floating>{{\'Wallet invitation\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="invitationCode" (ionChange)="processInvitation(joinForm.value.invitationCode)"></ion-input>\n\n        <ion-icon *ngIf="coin !== \'eth\' && joinForm.controls[\'invitationCode\'].status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n\n        <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n      </ion-item>\n\n      <button *ngIf="coin !== \'eth\'" ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n        <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n        <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n      </button>\n\n      <div *ngIf="showAdvOpts" padding-bottom>\n        <ion-item *ngIf="coin !== \'eth\'">\n          <ion-label floating>Wallet Service URL</ion-label>\n          <ion-input type="text" formControlName="bwsURL"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="!keyId">\n          <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n          <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(joinForm.value.selectedSeed)">\n            <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n          </ion-select>\n        </ion-item>\n\n        <ion-item *ngIf="joinForm.value.selectedSeed == \'set\' && !keyId">\n          <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="joinForm.value.selectedSeed == \'set\' && !keyId">\n          <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="derivationPath"></ion-input>\n        </ion-item>\n      </div>\n    </form>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/join-wallet/join-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */]])
], JoinWalletPage);

//# sourceMappingURL=join-wallet.js.map

/***/ }),

/***/ 299:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(25);





// Providers





let CoinbasePage = class CoinbasePage {
    constructor(coinbaseProvider, popupProvider, navCtrl, externalLinkProvider, platformProvider, onGoingProcessProvider, navParams, translate, formBuilder, viewCtrl) {
        this.coinbaseProvider = coinbaseProvider;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.platformProvider = platformProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.navParams = navParams;
        this.translate = translate;
        this.formBuilder = formBuilder;
        this.viewCtrl = viewCtrl;
        this.pendingTransactions = { data: {} };
        this.oauthCodeForm = this.formBuilder.group({
            code: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required])
            ]
        });
        this.isElectron = this.platformProvider.isElectron;
        this.showOauthForm = false;
    }
    ionViewWillEnter() {
        this.hasCredentials = !!this.coinbaseProvider.oauthUrl;
        if (!this.hasCredentials)
            return;
        if (this.navParams.data.code) {
            this.submitOauthCode(this.navParams.data.code);
        }
        else if (this.coinbaseProvider.isLinked()) {
            this.backToWalletTabs();
        }
    }
    backToWalletTabs() {
        setTimeout(() => {
            this.navCtrl.popToRoot().then(_ => {
                this.navCtrl.parent.select(1);
            });
        }, 600);
    }
    openAuthenticateWindow() {
        this.showOauthForm = true;
        if (!this.isElectron) {
            if (this.navParams.data.isOnboardingFlow) {
                this.navCtrl.remove(this.viewCtrl.index - 1).then(() => {
                    this.viewCtrl.dismiss();
                });
            }
            this.externalLinkProvider.open(this.coinbaseProvider.oauthUrl);
        }
        else {
            const { remote } = window.require('electron');
            const BrowserWindow = remote.BrowserWindow;
            const win = new BrowserWindow({
                alwaysOnTop: true,
                center: true,
                webPreferences: {
                    contextIsolation: false,
                    nodeIntegration: false,
                    worldSafeExecuteJavaScript: true
                }
            });
            win.once('ready-to-show', () => {
                win.show();
                win.focus();
            });
            win.loadURL(this.coinbaseProvider.oauthUrl);
            win.webContents.on('did-finish-load', () => {
                const title = win.webContents.getTitle();
                if (title.indexOf('Coinbase') == -1) {
                    this.submitOauthCode(title);
                    win.close();
                }
            });
        }
    }
    submitOauthCode(code) {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider
            .linkAccount(code)
            .then(_ => {
            this.onGoingProcessProvider.clear();
            this.backToWalletTabs();
        })
            .catch(e => {
            this.onGoingProcessProvider.clear();
            this.popupProvider.ionicAlert(this.translate.instant('Error connecting to Coinbase'), e);
            if (!this.isElectron) {
                let previousView = this.navCtrl.getPrevious();
                this.navCtrl.removeView(previousView);
            }
        });
    }
    openSignupWindow() {
        let url = this.coinbaseProvider.signupUrl;
        let optIn = true;
        let title = this.translate.instant('Sign Up for Coinbase');
        let message = this.translate.instant('This will open Coinbase.com, where you can create an account.');
        let okText = this.translate.instant('Go to Coinbase');
        let cancelText = this.translate.instant('Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openSupportWindow() {
        let url = this.coinbaseProvider.supportUrl;
        let optIn = true;
        let title = this.translate.instant('Coinbase Support');
        let message = this.translate.instant('You can email support@coinbase.com for direct support, or you can view their help center.');
        let okText = this.translate.instant('Open Help Center');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
CoinbasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img src="assets/img/coinbase/coinbase-logo.png" width="70">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          <img src="assets/img/coinbase/coinbase-logo.png" width="150">\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <div *ngIf="hasCredentials" class="center-header">\n      <div padding text-center>\n        <div *ngIf="!showOauthForm" translate>Manage your Coinbase account, check balances, deposit and withdraw funds between wallets.</div>\n        <div *ngIf="showOauthForm" translate>If you have trouble, contact Coinbase support for direct assistance.</div>\n        <button margin-top *ngIf="!showOauthForm" ion-button class="button-standard" (click)="openAuthenticateWindow()" translate>Connect Coinbase Account</button>\n        <button margin *ngIf="!showOauthForm" ion-button clear small color="dark" (click)="openSignupWindow()" translate>Sign Up for Coinbase &rarr;</button>\n      </div>\n      <div *ngIf="showOauthForm" margin>\n        <form [formGroup]="oauthCodeForm" (ngSubmit)="submitOauthCode(oauthCodeForm.value.code)">\n          <ion-label stacked><span translate>OAuth Code</span></ion-label>\n          <ion-input type="text" formControlName="code" [value]="oauthCodeForm.value.code" placeholder="{{\'Enter OAuth Code\'}}" required></ion-input>\n          <button ion-button class="button-standard" type="submit" [disabled]="!oauthCodeForm.valid" translate>Connect Coinbase Account</button>\n        </form>\n        <button margin-top ion-button block clear small color="dark" (click)="openSupportWindow()">\n          <span translate>Coinbase Support</span> &rarr;\n        </button>\n      </div>\n    </div>\n    <div *ngIf="!hasCredentials" text-center translate>\n      Missing Credentials\n    </div>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["t" /* ViewController */]])
], CoinbasePage);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 30:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionSheetProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_choose_fee_level_choose_fee_level__ = __webpack_require__(797);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_email_component_email_component__ = __webpack_require__(928);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_encrypt_password_encrypt_password__ = __webpack_require__(929);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_incoming_data_menu_incoming_data_menu__ = __webpack_require__(931);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_info_sheet_info_sheet__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_memo_component_memo_component__ = __webpack_require__(932);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_miner_fee_warning_miner_fee_warning__ = __webpack_require__(933);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_needs_backup_needs_backup__ = __webpack_require__(934);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_options_sheet_options_sheet__ = __webpack_require__(935);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_phone_sheet_phone_sheet__ = __webpack_require__(936);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__components_wallet_receive_wallet_receive__ = __webpack_require__(939);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_wallet_selector_wallet_selector__ = __webpack_require__(940);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__components_wallet_tab_options_wallet_tab_options__ = __webpack_require__(941);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_dom_dom__ = __webpack_require__(225);
















let ActionSheetProvider = class ActionSheetProvider {
    constructor(domProvider) {
        this.domProvider = domProvider;
    }
    createOptionsSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_10__components_options_sheet_options_sheet__["a" /* OptionsSheetComponent */], type, params).instance;
    }
    createIncomingDataMenu(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_5__components_incoming_data_menu_incoming_data_menu__["a" /* IncomingDataMenuComponent */], null, params).instance;
    }
    createInfoSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_6__components_info_sheet_info_sheet__["b" /* InfoSheetComponent */], type, params)
            .instance;
    }
    createMemoComponent(memo) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_7__components_memo_component_memo_component__["a" /* MemoComponent */], null, { memo })
            .instance;
    }
    createEmailComponent() {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_3__components_email_component_email_component__["a" /* EmailComponent */]).instance;
    }
    createPhoneSheet(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_11__components_phone_sheet_phone_sheet__["a" /* PhoneSheet */], null, params).instance;
    }
    createWalletSelector(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_13__components_wallet_selector_wallet_selector__["a" /* WalletSelectorComponent */], null, params).instance;
    }
    createWalletReceive(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_12__components_wallet_receive_wallet_receive__["a" /* WalletReceiveComponent */], null, params).instance;
    }
    createNeedsBackup() {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_9__components_needs_backup_needs_backup__["a" /* NeedsBackupComponent */], null)
            .instance;
    }
    createChooseFeeLevel(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_2__components_choose_fee_level_choose_fee_level__["a" /* ChooseFeeLevelComponent */], null, params).instance;
    }
    createWalletTabOptions(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_14__components_wallet_tab_options_wallet_tab_options__["a" /* WalletTabOptionsComponent */], null, params).instance;
    }
    createEncryptPasswordComponent() {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_4__components_encrypt_password_encrypt_password__["a" /* EncryptPasswordComponent */])
            .instance;
    }
    createMinerFeeWarningComponent() {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_8__components_miner_fee_warning_miner_fee_warning__["a" /* MinerFeeWarningComponent */])
            .instance;
    }
    setupSheet(componentType, sheetType, params) {
        const sheet = this.domProvider.appendComponentToBody(componentType);
        sheet.instance.componentRef = sheet;
        sheet.instance.sheetType = sheetType;
        sheet.instance.params = params;
        return sheet;
    }
};
ActionSheetProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__providers_dom_dom__["a" /* DomProvider */]])
], ActionSheetProvider);

//# sourceMappingURL=action-sheet.js.map

/***/ }),

/***/ 300:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_vibration__ = __webpack_require__(796);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);









let PinModalPage = class PinModalPage {
    constructor(configProvider, logger, platform, navParams, persistenceProvider, vibration, viewCtrl, platformProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.platform = platform;
        this.navParams = navParams;
        this.persistenceProvider = persistenceProvider;
        this.vibration = vibration;
        this.viewCtrl = viewCtrl;
        this.platformProvider = platformProvider;
        this.ATTEMPT_LIMIT = 3;
        this.ATTEMPT_LOCK_OUT_TIME = 2 * 60;
        this.currentAttempts = 0;
        this.currentPin = '';
        this.firstPinEntered = '';
        this.confirmingPin = false;
        this.action = '';
        this.disableButtons = false;
        this.expires = '';
        this.incorrect = false;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.action = this.navParams.get('action');
        this.isCordova = this.platformProvider.isCordova;
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            this.checkIfLocked();
        }
    }
    ionViewWillEnter() {
        this.onPauseSubscription = this.platform.pause.subscribe(() => {
            this.lockReleaseTimeout.unref();
            this.countDown.unref();
            this.currentPin = this.firstPinEntered = '';
        });
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.disableButtons = true;
            setTimeout(() => {
                this.checkIfLocked();
            }, 1000);
        });
    }
    ionViewWillLeave() {
        this.onPauseSubscription.unsubscribe();
        this.onResumeSubscription.unsubscribe();
    }
    checkIfLocked() {
        this.persistenceProvider.getLockStatus().then((isLocked) => {
            if (!isLocked) {
                this.disableButtons = false;
                return;
            }
            if (this.action === 'checkPin') {
                this.showLockTimer();
                this.setLockRelease();
            }
        });
    }
    close(cancelClicked) {
        if (this.countDown) {
            clearInterval(this.countDown);
        }
        this.unregister();
        this.viewCtrl.dismiss(cancelClicked);
    }
    newEntry(value) {
        if (this.disableButtons)
            return;
        if (value === 'delete') {
            return this.delete();
        }
        this.incorrect = false;
        this.currentPin = this.currentPin + value;
        if (!this.isComplete())
            return;
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            setTimeout(() => {
                this.checkIfCorrect();
            }, 100);
        }
        if (this.action === 'pinSetUp') {
            setTimeout(() => {
                if (!this.confirmingPin) {
                    this.confirmingPin = true;
                    this.firstPinEntered = this.currentPin;
                    this.currentPin = '';
                }
                else if (this.firstPinEntered === this.currentPin)
                    this.save();
                else {
                    this.firstPinEntered = this.currentPin = '';
                    this.incorrect = true;
                    this.confirmingPin = false;
                    this.shakeCode();
                }
            }, 100);
        }
    }
    checkAttempts() {
        this.currentAttempts += 1;
        this.logger.info('Attempts to unlock:', this.currentAttempts);
        this.incorrect = true;
        if (this.currentAttempts == this.ATTEMPT_LIMIT &&
            this.action !== 'lockSetUp') {
            this.countDown = this.lockReleaseTimeout = null;
            this.currentAttempts = 0;
            this.persistenceProvider.setLockStatus('locked');
            this.showLockTimer();
            this.setLockRelease();
        }
        else {
            this.disableButtons = null;
        }
    }
    showLockTimer() {
        this.disableButtons = true;
        if (this.countDown) {
            this.incorrect = false;
            this.countDown.ref();
            return;
        }
        const bannedUntil = Math.floor(Date.now() / 1000) + this.ATTEMPT_LOCK_OUT_TIME;
        this.countDown = setInterval(() => {
            const now = Math.floor(Date.now() / 1000);
            const totalSecs = bannedUntil - now;
            // totalSecs should never be negative
            if (totalSecs < 0) {
                this.resetClock();
                return;
            }
            const m = Math.floor(totalSecs / 60);
            const s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        }, 1000);
    }
    setLockRelease() {
        if (this.lockReleaseTimeout) {
            this.lockReleaseTimeout.ref();
            return;
        }
        this.lockReleaseTimeout = setTimeout(() => {
            this.resetClock();
        }, this.ATTEMPT_LOCK_OUT_TIME * 1000);
    }
    resetClock() {
        clearInterval(this.countDown);
        this.expires = this.disableButtons = null;
        this.currentPin = this.firstPinEntered = '';
        this.incorrect = false;
        this.persistenceProvider.removeLockStatus();
    }
    delete() {
        if (this.disableButtons)
            return;
        this.currentPin = this.currentPin.substring(0, this.currentPin.length - 1);
    }
    isComplete() {
        if (this.currentPin.length < 4)
            return false;
        if (this.action != 'pinSetUp')
            this.disableButtons = true;
        return true;
    }
    save() {
        const lock = { method: 'pin', value: this.currentPin, bannedUntil: null };
        this.configProvider.set({ lock });
        this.close();
    }
    checkIfCorrect() {
        const config = this.configProvider.get();
        const pinValue = config.lock && config.lock.value;
        if (pinValue == this.currentPin) {
            if (this.action === 'checkPin' || this.action === 'lockSetUp') {
                this.close();
            }
        }
        else {
            this.currentPin = '';
            this.checkAttempts();
            this.shakeCode();
        }
    }
    shakeCode() {
        this.pinCode.animate('shake');
        this.vibration.vibrate(100);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__["a" /* Animate */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__["a" /* Animate */])
], PinModalPage.prototype, "pinCode", void 0);
PinModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-pin',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/pin/pin-modal/pin-modal.html"*/'<ion-header>\n  <ion-navbar transparent>\n    <ion-buttons right>\n      <button (click)="close(true)" ion-button color="primary" *ngIf="(action === \'pinSetUp\' || action === \'lockSetUp\') && isCordova">\n        {{\'Cancel\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce fullscreen>\n  <div class="pin-header">\n    <div class="title">\n      <div *ngIf="!disableButtons">\n        <span class="message" *ngIf="!confirmingPin && !incorrect" translate>Please enter your PIN</span>\n        <span class="message" *ngIf="confirmingPin && !incorrect" translate>Confirm your PIN</span>\n        <span class="message" *ngIf="incorrect" translate>Incorrect PIN, try again.</span>\n      </div>\n      <div *ngIf="disableButtons">\n        <span class="message" *ngIf="expires" translate>Try again in {{expires}}</span>\n      </div>\n    </div>\n  </div>\n  <div class="code-wrapper">\n    <pin-dots [pin]="currentPin" animate></pin-dots>\n    <pin-pad (keystroke)="newEntry($event)" type="pin"></pin-pad>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/pin/pin-modal/pin-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_vibration__["a" /* Vibration */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */]])
], PinModalPage);

//# sourceMappingURL=pin-modal.js.map

/***/ }),

/***/ 31:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_text_encoding__ = __webpack_require__(1948);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_text_encoding___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_text_encoding__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__filter_filter__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__language_language__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__logs_logs__ = __webpack_require__(377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__touchid_touchid__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__tx_format_tx_format__ = __webpack_require__(85);






// Providers



















let WalletProvider = WalletProvider_1 = class WalletProvider {
    constructor(logger, bwcProvider, txFormatProvider, configProvider, currencyProvider, persistenceProvider, bwcErrorProvider, rateProvider, filter, popupProvider, onGoingProcessProvider, touchidProvider, events, feeProvider, translate, addressProvider, languageProvider, keyProvider, platformProvider, logsProvider, appProvider) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.txFormatProvider = txFormatProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.persistenceProvider = persistenceProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.rateProvider = rateProvider;
        this.filter = filter;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.touchidProvider = touchidProvider;
        this.events = events;
        this.feeProvider = feeProvider;
        this.translate = translate;
        this.addressProvider = addressProvider;
        this.languageProvider = languageProvider;
        this.keyProvider = keyProvider;
        this.platformProvider = platformProvider;
        this.logsProvider = logsProvider;
        this.appProvider = appProvider;
        // Ratio low amount warning (fee/amount) in incoming TX
        this.LOW_AMOUNT_RATIO = 0.15;
        // Ratio of "many utxos" warning in total balance (fee/amount)
        this.TOTAL_LOW_WARNING_RATIO = 0.3;
        this.WALLET_STATUS_MAX_TRIES = 5;
        this.WALLET_STATUS_DELAY_BETWEEN_TRIES = 1.6 * 1000;
        this.SOFT_CONFIRMATION_LIMIT = 12;
        this.SAFE_CONFIRMATIONS = 6;
        this.DEFAULT_RBF_SEQNUMBER = 0xffffffff;
        this.errors = this.bwcProvider.getErrors();
        this.logger.debug('WalletProvider initialized');
        this.isPopupOpen = false;
    }
    invalidateCache(wallet) {
        if (wallet.cachedStatus)
            wallet.cachedStatus.isValid = false;
        if (wallet.completeHistory)
            wallet.completeHistoryIsValid = false;
        if (wallet.cachedActivity)
            wallet.cachedActivity.isValid = false;
    }
    fetchStatus(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            const walletId = wallet.id;
            const processPendingTxps = status => {
                const txps = status.pendingTxps;
                const now = Math.floor(Date.now() / 1000);
                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txps, tx => {
                    tx = this.txFormatProvider.processTx(wallet.coin, tx);
                    // no future transactions...
                    if (tx.createdOn > now)
                        tx.createdOn = now;
                    tx.wallet = wallet;
                    if (!tx.wallet) {
                        this.logger.error('no wallet at txp?');
                        return;
                    }
                    const action = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](tx.actions, {
                        copayerId: tx.wallet.copayerId
                    });
                    if ((!action || action.type === 'failed') && tx.status == 'pending') {
                        tx.pendingForUs = true;
                    }
                    if (action && action.type == 'accept') {
                        tx.statusForUs = 'accepted';
                    }
                    else if (action && action.type == 'reject') {
                        tx.statusForUs = 'rejected';
                    }
                    else {
                        tx.statusForUs = 'pending';
                    }
                    if (!tx.deleteLockTime)
                        tx.canBeRemoved = true;
                });
                wallet.pendingTxps = txps;
            };
            const cacheBalance = (wallet, balance) => {
                if (!balance)
                    return;
                const configGet = this.configProvider.get();
                const config = configGet.wallet;
                const cache = wallet.cachedStatus;
                // Address with Balance
                cache.balanceByAddress = balance.byAddress;
                // Total wallet balance is same regardless of 'spend unconfirmed funds' setting.
                cache.totalBalanceSat = balance.totalAmount;
                // Spend unconfirmed funds
                if (config.spendUnconfirmed) {
                    cache.lockedBalanceSat = balance.lockedAmount;
                    cache.availableBalanceSat = balance.availableAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendMax;
                    cache.pendingAmount = 0;
                    cache.spendableAmount = balance.totalAmount - balance.lockedAmount;
                }
                else {
                    cache.lockedBalanceSat = balance.lockedConfirmedAmount;
                    cache.availableBalanceSat = balance.availableConfirmedAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendConfirmedMax;
                    cache.pendingAmount =
                        balance.totalAmount - balance.totalConfirmedAmount;
                    cache.spendableAmount =
                        balance.totalConfirmedAmount - balance.lockedAmount;
                }
                // Selected unit
                cache.unitToSatoshi = this.currencyProvider.getPrecision(wallet.coin).unitToSatoshi;
                cache.satToUnit = 1 / cache.unitToSatoshi;
                // STR
                cache.totalBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.totalBalanceSat);
                cache.lockedBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.lockedBalanceSat);
                cache.availableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.availableBalanceSat);
                cache.spendableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.spendableAmount);
                cache.pendingBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.pendingAmount);
                cache.alternativeName = config.settings.alternativeName;
                cache.alternativeIsoCode = config.settings.alternativeIsoCode;
                this.rateProvider
                    .whenRatesAvailable(wallet.coin)
                    .then(() => {
                    const availableBalanceAlternative = this.rateProvider.toFiat(cache.availableBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const totalBalanceAlternative = this.rateProvider.toFiat(cache.totalBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const pendingBalanceAlternative = this.rateProvider.toFiat(cache.pendingAmount, cache.alternativeIsoCode, wallet.coin);
                    const lockedBalanceAlternative = this.rateProvider.toFiat(cache.lockedBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const spendableBalanceAlternative = this.rateProvider.toFiat(cache.spendableAmount, cache.alternativeIsoCode, wallet.coin);
                    const alternativeConversionRate = this.rateProvider.toFiat(100000000, cache.alternativeIsoCode, wallet.coin);
                    cache.availableBalanceAlternative = this.filter.formatFiatAmount(availableBalanceAlternative);
                    cache.totalBalanceAlternative = this.filter.formatFiatAmount(totalBalanceAlternative);
                    cache.pendingBalanceAlternative = this.filter.formatFiatAmount(pendingBalanceAlternative);
                    cache.lockedBalanceAlternative = this.filter.formatFiatAmount(lockedBalanceAlternative);
                    cache.spendableBalanceAlternative = this.filter.formatFiatAmount(spendableBalanceAlternative);
                    cache.alternativeConversionRate = this.filter.formatFiatAmount(alternativeConversionRate);
                    cache.alternativeBalanceAvailable = true;
                    cache.isRateAvailable = true;
                })
                    .catch(err => {
                    this.logger.warn('Could not get rates: ', err);
                });
            };
            const isStatusCached = () => {
                return wallet.cachedStatus && wallet.cachedStatus.isValid;
            };
            const cacheStatus = (status) => {
                if (status.wallet && status.wallet.scanStatus == 'running')
                    return;
                wallet.cachedStatus = status || {};
                const cache = wallet.cachedStatus;
                cache.statusUpdatedOn = Date.now();
                cache.isValid = true;
                cache.email = status.preferences ? status.preferences.email : null;
                cacheBalance(wallet, status.balance);
            };
            const checkAndUpdateAdddress = () => {
                // Check address
                this.isAddressUsed(wallet, wallet.cachedStatus.balance.byAddress).then(used => {
                    const isSingleAddress = wallet.cachedStatus.wallet &&
                        wallet.cachedStatus.wallet.singleAddress;
                    if (used && !isSingleAddress) {
                        this.logger.debug('Current Wallet address used. Creating new');
                        // Force new address
                        this.getAddress(wallet, true).catch(err => {
                            this.logger.warn('Failed to create address: ', err);
                        });
                    }
                });
            };
            const hasMeet = (s1, s2) => {
                let diff = false;
                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](s1, (v, k) => {
                    if (s2[k] == v)
                        diff = true;
                    else
                        this.logger.debug(`Status condition not meet: ${k} is ${s2[k]} not ${v}`);
                });
                return diff;
            };
            const doFetchStatus = (tries = 0) => {
                return new Promise((resolve, reject) => {
                    if (isStatusCached() && !opts.force && !opts.until) {
                        this.logger.debug('Status cache hit for ' + wallet.id);
                        // This will update exchange rates
                        cacheStatus(wallet.cachedStatus);
                        if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                            checkAndUpdateAdddress();
                        }
                        processPendingTxps(wallet.cachedStatus);
                        return resolve(wallet.cachedStatus);
                    }
                    tries = tries || 0;
                    const { token, multisigEthInfo } = wallet.credentials;
                    wallet.getStatus({
                        tokenAddress: token ? token.address : '',
                        multisigContractAddress: multisigEthInfo
                            ? multisigEthInfo.multisigContractAddress
                            : '',
                        network: wallet.network
                    }, (err, status) => {
                        if (err) {
                            if (err instanceof this.errors.NOT_AUTHORIZED) {
                                return reject('WALLET_NOT_REGISTERED');
                            }
                            return reject(err);
                        }
                        if (opts.until) {
                            if (!hasMeet(opts.until, status.balance) &&
                                tries < this.WALLET_STATUS_MAX_TRIES) {
                                this.logger.debug('Retrying update... ' +
                                    walletId +
                                    ' Try:' +
                                    tries +
                                    ' until:', opts.until);
                                return setTimeout(() => {
                                    return resolve(doFetchStatus(++tries));
                                }, this.WALLET_STATUS_DELAY_BETWEEN_TRIES * tries);
                            }
                            else {
                                this.logger.debug('# Got Wallet Status for: ' + wallet.id + ' after meeting:', opts.until);
                            }
                        }
                        else {
                            this.logger.debug('# Got Wallet Status for: ' + wallet.id);
                        }
                        processPendingTxps(status);
                        cacheStatus(status);
                        wallet.scanning =
                            status.wallet && status.wallet.scanStatus == 'running';
                        return resolve(status);
                    });
                });
            };
            /* ========== Start =========== */
            if (opts.until && hasMeet(opts.until, wallet.cachedStatus.balance)) {
                this.logger.debug('Status change already meet: ' + wallet.credentials.walletName);
                return resolve(wallet.cachedStatus);
            }
            if (WalletProvider_1.statusUpdateOnProgress[wallet.id] && !opts.until) {
                this.logger.info('!! Status update already on progress for: ' +
                    wallet.credentials.walletName);
                return reject('INPROGRESS');
            }
            WalletProvider_1.statusUpdateOnProgress[wallet.id] = true;
            doFetchStatus()
                .then(status => {
                WalletProvider_1.statusUpdateOnProgress[wallet.id] = false;
                resolve(status);
            })
                .catch(err => {
                WalletProvider_1.statusUpdateOnProgress[wallet.id] = false;
                return reject(err);
            });
        });
    }
    getWalletTotalBalanceAlternative(balanceSat, coin, isoCode) {
        const balance = this.rateProvider.toFiat(balanceSat, isoCode, coin);
        return balance ? balance.toFixed(2) : '0.00';
    }
    getWalletTotalBalanceAlternativeLastDay(balanceSat, coin, isoCode, lastDayRatesArray) {
        const balanceLastDay = this.rateProvider.toFiat(balanceSat, isoCode, coin, {
            customRate: lastDayRatesArray[coin]
        });
        return balanceLastDay ? balanceLastDay.toFixed(2) : '0.00';
    }
    calcTotalAmount(wallet, isoCode, lastDayRatesArray) {
        const statusWallet = wallet.cachedStatus;
        let walletTotalBalanceAlternative = 0;
        let walletTotalBalanceAlternativeLastDay = 0;
        if (wallet.network === 'livenet' &&
            !wallet.hidden &&
            !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](statusWallet)) {
            const balance = wallet.coin === 'xrp'
                ? statusWallet.availableBalanceSat
                : statusWallet.totalBalanceSat;
            walletTotalBalanceAlternativeLastDay = parseFloat(this.getWalletTotalBalanceAlternativeLastDay(balance, wallet.coin, isoCode, lastDayRatesArray));
            walletTotalBalanceAlternative = parseFloat(this.getWalletTotalBalanceAlternative(balance, wallet.coin, isoCode));
        }
        return {
            walletTotalBalanceAlternative,
            walletTotalBalanceAlternativeLastDay
        };
    }
    getTotalAmount(wallets, lastDayRatesArray) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const isoCode = this.configProvider.get().wallet.settings.alternativeIsoCode || 'USD';
            const totalAmountArray = [];
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](wallets, wallet => {
                totalAmountArray.push(this.calcTotalAmount(wallet, isoCode, lastDayRatesArray));
            });
            const totalBalanceAlternative = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](__WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](totalAmountArray), b => b.walletTotalBalanceAlternative).toFixed(2);
            const totalBalanceAlternativeLastDay = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](__WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](totalAmountArray), b => b.walletTotalBalanceAlternativeLastDay).toFixed(2);
            const difference = parseFloat(totalBalanceAlternative.replace(/,/g, '')) -
                parseFloat(totalBalanceAlternativeLastDay.replace(/,/g, ''));
            const totalBalanceChange = (difference * 100) /
                parseFloat(totalBalanceAlternative.replace(/,/g, ''));
            return {
                totalBalanceAlternativeIsoCode: isoCode,
                totalBalanceAlternative,
                totalBalanceChange: totalBalanceChange || 0
            };
        });
    }
    // Check address
    isAddressUsed(wallet, byAddress) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getLastAddress(wallet.id)
                .then(addr => {
                const used = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](byAddress, {
                    address: addr
                });
                return resolve(used);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getAddressView(coin, network, address) {
        if (coin != 'bch')
            return address;
        const protoAddr = this.getProtoAddress(coin, network, address);
        return protoAddr;
    }
    getProtoAddress(coin, network, address) {
        const proto = this.getProtocolHandler(coin, network);
        const protoAddr = proto + ':' + address;
        return protoAddr;
    }
    getAddress(wallet, forceNew) {
        return new Promise((resolve, reject) => {
            let walletId = wallet.id;
            const { token, multisigEthInfo } = wallet.credentials;
            if (multisigEthInfo && multisigEthInfo.multisigContractAddress) {
                return resolve(multisigEthInfo.multisigContractAddress);
            }
            if (token) {
                walletId = wallet.id.replace(`-${token.address}`, '');
            }
            this.persistenceProvider
                .getLastAddress(walletId)
                .then((addr) => {
                if (addr) {
                    // prevent to show legacy address
                    const isBchLegacy = wallet.coin == 'bch' && addr.match(/^[CHmn]/);
                    const isValid = this.addressProvider.isValid(addr);
                    if (!forceNew && !isBchLegacy && isValid)
                        return resolve(addr);
                }
                if (!wallet.isComplete())
                    return reject(this.bwcErrorProvider.msg('WALLET_NOT_COMPLETE'));
                if (wallet.needsBackup) {
                    return reject(this.bwcErrorProvider.msg('WALLET_NEEDS_BACKUP'));
                }
                this.createAddress(wallet)
                    .then(_addr => {
                    this.persistenceProvider
                        .storeLastAddress(walletId, _addr)
                        .then(() => {
                        return resolve(_addr);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createAddress(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.info('Creating address for wallet:', wallet.id);
            wallet.createAddress({}, (err, addr) => {
                if (err) {
                    let prefix = this.translate.instant('Could not create address');
                    if (err instanceof this.errors.MAIN_ADDRESS_GAP_REACHED ||
                        (err.message && err.message == 'MAIN_ADDRESS_GAP_REACHED')) {
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Server Error'));
                        prefix = null;
                        if (!this.isPopupOpen) {
                            this.isPopupOpen = true;
                            this.popupProvider
                                .ionicAlert(null, this.bwcErrorProvider.msg('MAIN_ADDRESS_GAP_REACHED'))
                                .then(() => {
                                this.isPopupOpen = false;
                            });
                        }
                        wallet.getMainAddresses({
                            reverse: true,
                            limit: 1
                        }, (err, addr) => {
                            if (err)
                                return reject(err);
                            return resolve(addr[0].address);
                        });
                    }
                    else {
                        const msg = this.bwcErrorProvider.msg(err, prefix);
                        return reject(msg);
                    }
                }
                else if (!this.addressProvider.isValid(addr.address)) {
                    this.logger.error('Invalid address generated: ', addr.address);
                    const msg = 'INVALID_ADDRESS';
                    return reject(msg);
                }
                else {
                    return resolve(addr.address);
                }
            });
        });
    }
    getSavedTxs(walletId) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxHistory(walletId)
                .then(txs => {
                let localTxs = [];
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txs)) {
                    return resolve(localTxs);
                }
                localTxs = txs;
                return resolve(__WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](localTxs));
            })
                .catch((err) => {
                return reject(err);
            });
        });
    }
    fetchTxsFromServer(wallet, skip, endingTxid, limit) {
        return new Promise((resolve, reject) => {
            let res = [];
            const result = {
                res,
                shouldContinue: res.length >= limit
            };
            const { token, multisigEthInfo } = wallet.credentials;
            wallet.getTxHistory({
                skip,
                limit,
                tokenAddress: token ? token.address : '',
                multisigContractAddress: multisigEthInfo
                    ? multisigEthInfo.multisigContractAddress
                    : ''
            }, (err, txsFromServer) => {
                if (err)
                    return reject(err);
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txsFromServer))
                    return resolve(result);
                res = __WEBPACK_IMPORTED_MODULE_4_lodash__["takeWhile"](txsFromServer, tx => {
                    return tx.txid != endingTxid;
                });
                result.res = res;
                result.shouldContinue = res.length >= limit;
                return resolve(result);
            });
        });
    }
    clearWalletCache(wallet) {
        return new Promise(resolve => {
            const config = this.configProvider.get();
            const defaults = this.configProvider.getDefaults();
            const bws_url = (config.bwsFor && config.bwsFor[wallet.id]) || defaults.bws.url;
            this.bwcProvider
                .getClient(JSON.stringify(wallet.credentials), {
                bwsurl: bws_url
            })
                .clearCache(err => {
                if (err)
                    resolve(false);
                return resolve(true);
            });
        });
    }
    updateLocalTxHistory(wallet, progressFn, opts = {}) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            const FIRST_LIMIT = 5;
            const LIMIT = 100;
            let requestLimit = FIRST_LIMIT;
            const walletId = wallet.credentials.walletId;
            WalletProvider_1.progressFn[walletId] = progressFn || (() => { });
            let foundLimitTx = [];
            const fixTxsUnit = (txs) => {
                if (!txs || !txs[0] || !txs[0].amountStr)
                    return;
                const cacheCoin = txs[0].amountStr.split(' ')[1];
                if (cacheCoin == 'bits') {
                    this.logger.debug('Fixing Tx Cache Unit to: ' + wallet.coin);
                    __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                        tx.amountStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.amount);
                        tx.feeStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.fees);
                    });
                }
            };
            if (WalletProvider_1.historyUpdateOnProgress[wallet.id]) {
                this.logger.debug('!! History update already on progress for: ' + wallet.id);
                if (progressFn) {
                    WalletProvider_1.progressFn[walletId] = progressFn;
                }
                return reject('HISTORY_IN_PROGRESS'); // no callback call yet.
            }
            this.logger.debug('Updating Transaction History for ' + wallet.credentials.walletName);
            WalletProvider_1.historyUpdateOnProgress[wallet.id] = true;
            this.getSavedTxs(walletId)
                .then(txsFromLocal => {
                fixTxsUnit(txsFromLocal);
                const confirmedTxs = this.removeAndMarkSoftConfirmedTx(txsFromLocal);
                const endingTxid = confirmedTxs[0] ? confirmedTxs[0].txid : null;
                const endingTs = confirmedTxs[0] ? confirmedTxs[0].time : null;
                // First update
                WalletProvider_1.progressFn[walletId](txsFromLocal, 0);
                wallet.completeHistory = txsFromLocal;
                // send update
                this.events.publish('Local/WalletHistoryUpdate', {
                    walletId: wallet.id,
                    complete: false
                });
                const getNewTxs = (newTxs, skip, tries = 0) => {
                    return new Promise((resolve, reject) => {
                        this.fetchTxsFromServer(wallet, skip, endingTxid, requestLimit)
                            .then((result) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                            const res = result.res;
                            const shouldContinue = result.shouldContinue
                                ? result.shouldContinue
                                : false;
                            const _newTxs = yield this.processNewTxs(wallet, __WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](res));
                            newTxs = newTxs.concat(_newTxs);
                            WalletProvider_1.progressFn[walletId](newTxs.concat(txsFromLocal), newTxs.length);
                            skip = skip + requestLimit;
                            this.logger.debug('Syncing TXs for:' +
                                walletId +
                                '. Got:' +
                                newTxs.length +
                                ' Skip:' +
                                skip, ' EndingTxid:', endingTxid, ' Continue:', shouldContinue);
                            // TODO Dirty <HACK>
                            // do not sync all history, just looking for a single TX.
                            if (opts.limitTx) {
                                foundLimitTx = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](newTxs.concat(txsFromLocal), {
                                    txid: opts.limitTx
                                });
                                if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](foundLimitTx)) {
                                    this.logger.debug('Found limitTX: ' + opts.limitTx);
                                    return resolve([foundLimitTx]);
                                }
                            }
                            // </HACK>
                            if (!shouldContinue) {
                                this.logger.debug('Finished Sync: New / soft confirmed Txs: ' +
                                    newTxs.length);
                                return resolve(newTxs);
                            }
                            requestLimit = LIMIT;
                            return getNewTxs(newTxs, skip).then(txs => {
                                resolve(txs);
                            });
                        }))
                            .catch(err => {
                            if (err instanceof this.errors.CONNECTION_ERROR ||
                                (err.message && err.message.match(/5../))) {
                                if (tries > 1)
                                    return reject(err);
                                return setTimeout(() => {
                                    return resolve(getNewTxs(newTxs, skip, ++tries));
                                }, 2000 + 3000 * tries);
                            }
                            else {
                                return reject(err);
                            }
                        });
                    });
                };
                getNewTxs([], 0)
                    .then(txs => {
                    const array = __WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](txs.concat(confirmedTxs));
                    const newHistory = __WEBPACK_IMPORTED_MODULE_4_lodash__["uniqBy"](array, x => {
                        return x.txid;
                    });
                    const updateNotes = () => {
                        return new Promise((resolve, reject) => {
                            if (!endingTs)
                                return resolve();
                            // this.logger.debug('Syncing notes from: ' + endingTs);
                            wallet.getTxNotes({
                                minTs: endingTs
                            }, (err, notes) => {
                                if (err) {
                                    this.logger.warn('Could not get TxNotes: ', err);
                                    return reject(err);
                                }
                                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](notes, note => {
                                    // this.logger.debug('Note for ' + note.txid);
                                    __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](newHistory, (tx) => {
                                        if (tx.txid == note.txid) {
                                            // this.logger.debug(
                                            //  '...updating note for ' + note.txid
                                            // );
                                            tx.note = note;
                                        }
                                    });
                                });
                                return resolve();
                            });
                        });
                    };
                    const updateLowAmount = txs => {
                        if (!opts.lowAmount)
                            return;
                        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                            tx.lowAmount = tx.amount < opts.lowAmount;
                        });
                    };
                    if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                        this.getLowAmount(wallet).then(fee => {
                            opts.lowAmount = fee;
                            updateLowAmount(txs);
                        });
                    }
                    updateNotes()
                        .then(() => {
                        // <HACK>
                        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](foundLimitTx)) {
                            this.logger.debug('Tx history read until limitTx: ' + opts.limitTx);
                            return resolve(newHistory);
                        }
                        // </HACK>
                        const historyToSave = JSON.stringify(newHistory);
                        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                            tx.recent = true;
                        });
                        // Final update
                        if (walletId == wallet.credentials.walletId) {
                            wallet.completeHistory = newHistory;
                        }
                        return this.persistenceProvider
                            .setTxHistory(walletId, historyToSave)
                            .then(() => {
                            this.logger.debug('History sync & saved for ' +
                                wallet.id +
                                ' Txs: ' +
                                newHistory.length);
                            return resolve();
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    processNewTxs(wallet, txs) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const now = Math.floor(Date.now() / 1000);
            const txHistoryUnique = {};
            const ret = [];
            wallet.hasUnsafeConfirmed = false;
            for (let tx of txs) {
                tx = this.txFormatProvider.processTx(wallet.coin, tx);
                // no future transactions...
                if (tx.time > now)
                    tx.time = now;
                if (tx.confirmations === 0 && (wallet.coin === 'btc' || wallet.coin === 'edu' || wallet.coin === 'tik')) {
                    const coins = yield this.getCoinsForTx(wallet, tx.txid);
                    tx.isRBF = __WEBPACK_IMPORTED_MODULE_4_lodash__["some"](coins.inputs, input => {
                        return (input.sequenceNumber &&
                            input.sequenceNumber < this.DEFAULT_RBF_SEQNUMBER - 1);
                    });
                    tx.hasUnconfirmedInputs = __WEBPACK_IMPORTED_MODULE_4_lodash__["some"](coins.inputs, input => {
                        return input.mintHeight < 0;
                    });
                }
                if (tx.confirmations >= this.SAFE_CONFIRMATIONS) {
                    tx.safeConfirmed = this.SAFE_CONFIRMATIONS + '+';
                }
                else {
                    tx.safeConfirmed = false;
                    wallet.hasUnsafeConfirmed = true;
                }
                if (tx.note) {
                    delete tx.note.encryptedEditedByName;
                    delete tx.note.encryptedBody;
                }
                if (!txHistoryUnique[tx.txid]) {
                    ret.push(tx);
                    txHistoryUnique[tx.txid] = true;
                }
                else {
                    this.logger.debug('Ignoring duplicate TX in history: ' + tx.txid);
                }
            }
            return Promise.resolve(ret);
        });
    }
    removeAndMarkSoftConfirmedTx(txs) {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](txs, tx => {
            if (tx.confirmations >= this.SOFT_CONFIRMATION_LIMIT)
                return tx;
            tx.recent = true;
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getLowAmount(wallet) {
        return new Promise((resolve, reject) => {
            this.getMinFee(wallet)
                .then(fee => {
                const minFee = fee;
                return resolve(minFee / this.LOW_AMOUNT_RATIO);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getMinFee(wallet, nbOutputs) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeLevels(wallet.coin, wallet.network)
                .then(data => {
                const normalLevelRate = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](data.levels, level => {
                    return level.level === 'normal';
                });
                const lowLevelRate = (normalLevelRate.feePerKb / 1000).toFixed(0);
                const size = this.getEstimatedTxSize(wallet, nbOutputs);
                return resolve(size * parseInt(lowLevelRate, 10));
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // These 2 functions were taken from
    // https://github.com/tkcoin/bitcore-wallet-service/blob/master/lib/model/txproposal.js#L243
    getEstimatedSizeForSingleInput(wallet) {
        switch (wallet.credentials.addressType) {
            case 'P2PKH':
                return 147;
            default:
            case 'P2SH':
                return wallet.m * 72 + wallet.n * 36 + 44;
        }
    }
    getEstimatedTxSize(wallet, nbOutputs, nbInputs) {
        // Note: found empirically based on all multisig P2SH inputs and within m & n allowed limits.
        nbOutputs = nbOutputs ? nbOutputs : 2; // Assume 2 outputs
        const safetyMargin = 0.02;
        const overhead = 4 + 4 + 9 + 9;
        const inputSize = this.getEstimatedSizeForSingleInput(wallet);
        const outputSize = 34;
        nbInputs = nbInputs ? nbInputs : 1; // Assume 1 input
        const size = overhead + inputSize * nbInputs + outputSize * nbOutputs;
        return parseInt((size * (1 + safetyMargin)).toFixed(0), 10);
    }
    getTxNote(wallet, txid) {
        return new Promise((resolve, reject) => {
            wallet.getTxNote({
                txid
            }, (err, note) => {
                if (err)
                    return reject(err);
                return resolve(note);
            });
        });
    }
    editTxNote(wallet, args) {
        return new Promise((resolve, reject) => {
            wallet.editTxNote(args, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getTxp(wallet, txpid) {
        return new Promise((resolve, reject) => {
            wallet.getTx(txpid, (err, txp) => {
                if (err)
                    return reject(err);
                return resolve(txp);
            });
        });
    }
    getMultisigContractInstantiationInfo(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getMultisigContractInstantiationInfo(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getMultisigContractInfo(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getMultisigContractInfo(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    isHistoryCached(wallet) {
        return wallet.completeHistory && wallet.completeHistoryIsValid;
    }
    getTx(wallet, txid) {
        return new Promise((resolve, reject) => {
            const finish = list => {
                const tx = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](list, {
                    txid
                });
                if (!tx)
                    return reject('Could not get transaction');
                return tx;
            };
            if (this.isHistoryCached(wallet)) {
                const tx = finish(wallet.completeHistory);
                return resolve(tx);
            }
            else {
                const opts = {
                    limitTx: txid
                };
                this.fetchTxHistory(wallet, null, opts)
                    .then(txHistory => {
                    const tx = finish(txHistory);
                    return resolve(tx);
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    fetchTxHistory(wallet, progressFn, opts = {}) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            if (!wallet.isComplete())
                return resolve();
            if (this.isHistoryCached(wallet) && !opts.force) {
                this.logger.debug('Returning cached history for ' + wallet.id);
                return resolve(wallet.completeHistory);
            }
            this.updateLocalTxHistory(wallet, progressFn, opts)
                .then(txs => {
                WalletProvider_1.historyUpdateOnProgress[wallet.id] = false;
                if (opts.limitTx) {
                    return resolve(txs);
                }
                wallet.completeHistoryIsValid = true;
                return resolve(wallet.completeHistory);
            })
                .catch(err => {
                if (err != 'HISTORY_IN_PROGRESS') {
                    WalletProvider_1.historyUpdateOnProgress[wallet.id] = false;
                    this.logger.warn('!! Could not update history for ', wallet.id, err);
                }
                return reject(err);
            });
        });
    }
    createTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.createTxProposal(txp, (err, createdTxp) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction created');
                    return resolve(createdTxp);
                }
            });
        });
    }
    publishTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.publishTxProposal({
                txp
            }, (err, publishedTx) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction published');
                    return resolve(publishedTx);
                }
            });
        });
    }
    signTx(wallet, txp, password) {
        return new Promise((resolve, reject) => {
            if (!wallet || !txp)
                return reject('MISSING_PARAMETER');
            const rootPath = wallet.getRootPath();
            let signatures;
            try {
                signatures = this.keyProvider.sign(wallet.credentials.keyId, rootPath, txp, password);
            }
            catch (err) {
                const title = 'Your wallet is in a corrupt state. Please contact support and share the logs provided';
                let message;
                try {
                    message = err instanceof Error ? err.toString() : JSON.stringify(err);
                }
                catch (error) {
                    message = 'Unknown error';
                }
                this.popupProvider.ionicAlert(title, message).then(() => {
                    // Share logs
                    const platform = this.platformProvider.isCordova
                        ? this.platformProvider.isAndroid
                            ? 'android'
                            : 'ios'
                        : 'desktop';
                    this.logsProvider.get(this.appProvider.info.nameCase, platform);
                });
            }
            try {
                wallet.pushSignatures(txp, signatures, (err, signedTxp) => {
                    if (err) {
                        this.logger.error('Transaction signed err: ', err);
                        return reject(err);
                    }
                    return resolve(signedTxp);
                });
            }
            catch (e) {
                this.logger.error('Error at pushSignatures:', e);
                return reject(e);
            }
        });
    }
    broadcastTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            if (txp.status != 'accepted')
                return reject('TX_NOT_ACCEPTED');
            wallet.broadcastTxProposal(txp, (err, broadcastedTxp, memo) => {
                if (err) {
                    if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isArrayBuffer"](err)) {
                        const enc = new __WEBPACK_IMPORTED_MODULE_5_text_encoding___default.a.TextDecoder();
                        err = enc.decode(err);
                        this.removeTx(wallet, txp);
                        return reject(err);
                    }
                    else {
                        return reject(err);
                    }
                }
                this.logger.info('Transaction broadcasted: ', broadcastedTxp.txid);
                if (memo)
                    this.logger.info('Memo: ', memo);
                return resolve(broadcastedTxp);
            });
        });
    }
    rejectTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.rejectTxProposal(txp, null, (err, rejectedTxp) => {
                if (err)
                    return reject(err);
                this.logger.debug('Transaction rejected');
                return resolve(rejectedTxp);
            });
        });
    }
    removeTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.removeTxProposal(txp, err => {
                if (err)
                    return reject(this.bwcErrorProvider.msg(err));
                this.logger.debug('Transaction removed');
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve();
            });
        });
    }
    // updates local and remote prefs for 1 wallet
    updateRemotePreferencesFor(client, prefs) {
        return new Promise((resolve, reject) => {
            client.preferences = client.preferences || {};
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](prefs)) {
                __WEBPACK_IMPORTED_MODULE_4_lodash__["assign"](client.preferences, prefs);
            }
            this.logger.debug('Saving remote preferences', client.credentials.walletName, JSON.stringify(client.preferences));
            client.savePreferences(client.preferences, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not save preferences on the server')));
                    return reject(err);
                }
                return resolve();
            });
        });
    }
    updateRemotePreferences(clients) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isArray"](clients))
            clients = [clients];
        // Set current preferences
        const config = this.configProvider.get();
        const prefs = {
            email: config.emailNotifications.email,
            language: this.languageProvider.getCurrent(),
            unit: 'btc' // deprecated
        };
        let updates = [];
        clients.forEach(c => {
            if (this.currencyProvider.isERCToken(c.credentials.coin) ||
                c.credentials.multisigEthInfo)
                return;
            updates.push(this.updateRemotePreferencesFor(c, prefs));
        });
        return Promise.all(updates);
    }
    startScan(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.info('Scanning wallet ' + wallet.id);
            if (!wallet.isComplete())
                return reject('Wallet incomplete: ' + wallet.name);
            wallet.scanning = true;
            wallet.startScan({
                includeCopayerBranches: true
            }, err => {
                if (err)
                    return reject(err);
                return resolve();
            });
        });
    }
    clearTxHistory(wallet) {
        this.invalidateCache(wallet);
        this.persistenceProvider.removeTxHistory(wallet.id);
        this.clearWalletCache(wallet)
            .then(() => {
            this.logger.info(`TxHistory cache cleared from server for: ${wallet.id}`);
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    expireAddress(walletId) {
        return new Promise((resolve, reject) => {
            this.logger.info('Cleaning Address ' + walletId);
            this.persistenceProvider
                .clearLastAddress(walletId)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getMainAddresses(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.reverse = true;
            wallet.getMainAddresses(opts, (err, addresses) => {
                if (err)
                    return reject(err);
                return resolve(addresses);
            });
        });
    }
    getBalance(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getBalance(opts, (err, resp) => {
                if (err)
                    return reject(err);
                return resolve(resp);
            });
        });
    }
    getLowUtxos(wallet) {
        return new Promise((resolve, reject) => {
            wallet.getUtxos({
                coin: wallet.coin
            }, (err, resp) => {
                if (err || !resp || !resp.length)
                    return reject(err ? err : 'No UTXOs');
                this.getMinFee(wallet, resp.length)
                    .then(fee => {
                    const minFee = fee;
                    const balance = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](resp, 'satoshis');
                    // for 2 outputs
                    this.getLowAmount(wallet)
                        .then(fee => {
                        const lowAmount = fee;
                        const lowUtxos = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](resp, x => {
                            return x.satoshis < lowAmount;
                        });
                        const totalLow = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](lowUtxos, 'satoshis');
                        return resolve({
                            allUtxos: resp || [],
                            lowUtxos: lowUtxos || [],
                            totalLow,
                            warning: minFee / balance > this.TOTAL_LOW_WARNING_RATIO,
                            minFee
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            });
        });
    }
    getUtxos(wallet) {
        return new Promise((resolve, reject) => {
            wallet.getUtxos({
                coin: wallet.coin
            }, (err, resp) => {
                if (err || !resp || !resp.length)
                    return reject(err ? err : 'No UTXOs');
                return resolve(resp);
            });
        });
    }
    getCoinsForTx(wallet, txId) {
        return new Promise((resolve, reject) => {
            wallet.getCoinsForTx({
                coin: wallet.coin,
                network: wallet.network,
                txId
            }, (err, resp) => {
                if (err)
                    return reject(err);
                return resolve(resp);
            });
        });
    }
    reject(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.rejectTx(wallet, txp)
                .then(txpr => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve(txpr);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    onlyPublish(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.publishTx(wallet, txp)
                .then(() => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve();
            })
                .catch(err => {
                return reject(this.bwcErrorProvider.msg(err));
            });
        });
    }
    prepare(wallet) {
        return new Promise((resolve, reject) => {
            this.touchidProvider
                .checkWallet(wallet)
                .then(() => {
                this.keyProvider
                    .handleEncryptedWallet(wallet.credentials.keyId)
                    .then((password) => {
                    return resolve(password);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    signAndBroadcast(wallet, publishedTxp, password) {
        return new Promise((resolve, reject) => {
            this.onGoingProcessProvider.set('signingTx');
            let expected = wallet.cachedStatus.balance.totalAmount -
                publishedTxp.amount -
                publishedTxp.fee;
            this.signTx(wallet, publishedTxp, password)
                .then(signedTxp => {
                this.invalidateCache(wallet);
                if (signedTxp.status == 'accepted') {
                    this.onGoingProcessProvider.set('broadcastingTx');
                    this.broadcastTx(wallet, signedTxp)
                        .then(broadcastedTxp => {
                        this.events.publish('Local/TxAction', {
                            walletId: wallet.id,
                            until: { totalAmount: expected }
                        });
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(this.bwcErrorProvider.msg(err));
                    });
                }
                else {
                    this.events.publish('Local/TxAction', {
                        walletId: wallet.id
                    });
                    return resolve(signedTxp);
                }
            })
                .catch(err => {
                const msg = err && err.message
                    ? err.message
                    : this.translate.instant('The payment was created but could not be completed. Please try again from home screen');
                this.logger.error('Sign error: ' + msg);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id,
                    until: { totalAmount: expected }
                });
                return reject(msg);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            // Already published?
            if (txp.status == 'pending') {
                this.prepare(wallet)
                    .then((password) => {
                    this.signAndBroadcast(wallet, txp, password)
                        .then(broadcastedTxp => {
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
            else {
                this.prepare(wallet)
                    .then((password) => {
                    this.onGoingProcessProvider.set('sendingTx');
                    this.publishTx(wallet, txp)
                        .then(publishedTxp => {
                        this.signAndBroadcast(wallet, publishedTxp, password)
                            .then(broadcastedTxp => {
                            return resolve(broadcastedTxp);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    signMultipleTxps(wallet, txps) {
        [].concat(txps);
        const promises = [];
        return this.prepare(wallet).then((password) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txps, txp => {
                promises.push(this.signAndBroadcast(wallet, txp, password).catch(error => {
                    this.logger.error(error);
                    return error;
                }));
            });
            return Promise.all(promises);
        }));
    }
    getEncodedWalletInfo(wallet, password) {
        return new Promise((resolve, reject) => {
            if (!wallet.credentials.keyId) {
                return resolve();
            }
            const derivationPath = this.keyProvider.getBaseAddressDerivationPath(wallet.credentials.keyId, {
                account: wallet.account,
                coin: wallet.coin,
                n: wallet.n,
                network: wallet.network
            });
            const encodingType = {
                mnemonic: 1,
                xpriv: 2,
                xpub: 3
            };
            let info = {};
            const keys = this.getKeysWithPassword(wallet, password);
            if (!keys || (!keys.mnemonic && !keys.xPrivKey))
                return reject(this.translate.instant('Exporting via QR not supported for this wallet'));
            if (keys.mnemonic) {
                info = {
                    type: encodingType.mnemonic,
                    data: keys.mnemonic
                };
            }
            else {
                info = {
                    type: encodingType.xpriv,
                    data: keys.xPrivKey
                };
            }
            const mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(wallet.credentials.keyId);
            return resolve(info.type +
                '|' +
                info.data +
                '|' +
                wallet.credentials.network.toLowerCase() +
                '|' +
                derivationPath +
                '|' +
                mnemonicHasPassphrase +
                '|' +
                wallet.coin);
        });
    }
    getKeysWithPassword(wallet, password) {
        try {
            return this.keyProvider.get(wallet.credentials.keyId, password);
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    setTouchId(walletsArray, enabled) {
        const opts = {
            touchIdFor: {}
        };
        walletsArray.forEach(wallet => {
            opts.touchIdFor[wallet.id] = enabled;
        });
        const promise = this.touchidProvider.checkWallet(walletsArray[0]);
        return promise.then(() => {
            this.configProvider.set(opts);
            return Promise.resolve();
        });
    }
    getKeys(wallet) {
        return new Promise((resolve, reject) => {
            this.prepare(wallet)
                .then((password) => {
                let keys;
                try {
                    keys = this.getKeysWithPassword(wallet, password);
                }
                catch (e) {
                    return reject(e);
                }
                return resolve(keys);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getMnemonicAndPassword(wallet) {
        return new Promise((resolve, reject) => {
            this.prepare(wallet)
                .then((password) => {
                let keys;
                try {
                    keys = this.getKeysWithPassword(wallet, password);
                }
                catch (e) {
                    return reject(e);
                }
                const mnemonic = keys.mnemonic;
                return resolve({ mnemonic, password });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getSendMaxInfo(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getSendMaxInfo(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getEstimateGas(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getEstimateGas(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getProtocolHandler(coin, network = 'livenet') {
        return this.currencyProvider.getProtocolPrefix(coin, network);
    }
    copyCopayers(wallet, newWallet) {
        return new Promise((resolve, reject) => {
            let walletPrivKey = this.bwcProvider
                .getBitcore()
                .PrivateKey.fromString(wallet.credentials.walletPrivKey);
            let copayer = 1;
            let i = 0;
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](wallet.credentials.publicKeyRing, item => {
                let name = item.copayerName || 'copayer ' + copayer++;
                newWallet._doJoinWallet(newWallet.credentials.walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, {
                    coin: newWallet.credentials.coin
                }, (err) => {
                    // Ignore error is copayer already in wallet
                    if (err && !(err instanceof this.errors.COPAYER_IN_WALLET))
                        return reject(err);
                    if (++i == wallet.credentials.publicKeyRing.length)
                        return resolve();
                });
            });
        });
    }
};
WalletProvider.progressFn = {};
WalletProvider.statusUpdateOnProgress = {};
WalletProvider.historyUpdateOnProgress = {};
WalletProvider = WalletProvider_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_16__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_24__tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_10__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_19__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_8__bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_22__rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_13__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_21__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_18__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_23__touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_12__fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_15__language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_14__key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_20__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_17__logs_logs__["a" /* LogsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__app_app__["a" /* AppProvider */]])
], WalletProvider);

var WalletProvider_1;
//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ 32:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnGoingProcessProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);






let OnGoingProcessProvider = class OnGoingProcessProvider {
    constructor(loadingCtrl, logger, translate) {
        this.loadingCtrl = loadingCtrl;
        this.logger = logger;
        this.translate = translate;
        this.logger.debug('OnGoingProcessProvider initialized');
        // TODO GET - CLEAR - CHECK DecimalPipe for FILTER WITH TRANSLATE
        this.ongoingProcess = [];
    }
    getProcessNames() {
        const processNames = {
            broadcastingTx: this.translate.instant('Broadcasting transaction...'),
            calculatingFee: this.translate.instant('Calculating fee...'),
            calculatingSendMax: this.translate.instant('Calculating send max...'),
            connectingChangelly: this.translate.instant('Connecting to Changelly...'),
            connectingCoinbase: this.translate.instant('Connecting to Coinbase...'),
            creatingTx: this.translate.instant('Creating transaction...'),
            creatingWallet: this.translate.instant('Creating Wallet...'),
            creatingEthMultisigWallet: this.translate.instant('Creating ETH multisig wallet. Please wait...'),
            deletingWallet: this.translate.instant('Deleting Wallet...'),
            extractingWalletInfo: this.translate.instant('Extracting Wallet information...'),
            fetchingPayPro: this.translate.instant('Fetching payment information...'),
            fetchingPayProOptions: this.translate.instant('Fetching payment options...'),
            generatingCSV: this.translate.instant('Generating .csv file...'),
            gettingFeeLevels: this.translate.instant('Getting fee levels...'),
            importingWallet: this.translate.instant('Importing Wallet...'),
            joiningWallet: this.translate.instant('Joining Wallet...'),
            rejectTx: this.translate.instant('Rejecting payment proposal...'),
            removeTx: this.translate.instant('Deleting payment proposal...'),
            retrievingInputs: this.translate.instant('Retrieving inputs information...'),
            scanning: this.translate.instant('Scanning Wallet funds...'),
            sendingTx: this.translate.instant('Sending transaction...'),
            signingTx: this.translate.instant('Signing transaction...'),
            sweepingWallet: this.translate.instant('Sweeping Wallet...'),
            validatingWords: this.translate.instant('Validating recovery phrase...'),
            loadingTxInfo: this.translate.instant('Loading transaction info...'),
            sendingFeedback: this.translate.instant('Sending feedback...'),
            generatingNewAddress: this.translate.instant('Generating new address...'),
            sendingByEmail: this.translate.instant('Preparing addresses...'),
            sending2faCode: this.translate.instant('Sending 2FA code...'),
            buyingBitcoin: this.translate.instant('Buying Bitcoin...'),
            sellingBitcoin: this.translate.instant('Selling Bitcoin...'),
            fetchingTKCoinAccount: this.translate.instant('Fetching TKCoin Account...'),
            fetchingTKCoinCards: this.translate.instant('Fetching BitPay Cards...'),
            updatingGiftCards: this.translate.instant('Updating Gift Cards...'),
            updatingGiftCard: this.translate.instant('Updating Gift Card...'),
            cancelingGiftCard: this.translate.instant('Canceling Gift Card...'),
            creatingGiftCard: this.translate.instant('Creating Gift Card...'),
            buyingGiftCard: this.translate.instant('Buying Gift Card...'),
            topup: this.translate.instant('Top up in progress...'),
            duplicatingWallet: this.translate.instant('Duplicating wallet...'),
            connectingTKCoinId: this.translate.instant('Connecting TKCoin ID...'),
            processingOrderReservation: this.translate.instant('Processing order reservation...'),
            payingWithCoinbase: this.translate.instant('Paying with a Coinbase Account...'),
            generalAwaiting: this.translate.instant("Just a second, we're setting a few things up.")
        };
        return processNames;
    }
    clear() {
        this.ongoingProcess = [];
        try {
            this.loading.dismiss();
        }
        catch (e) {
            // No problem
            this.logger.warn('no active on-going-process. No problem.', e);
        }
        this.loading = null;
        this.logger.debug('ongoingProcess clear');
    }
    pause() {
        this.pausedOngoingProcess = this.ongoingProcess;
        this.clear();
    }
    resume() {
        this.ongoingProcess = this.pausedOngoingProcess;
        __WEBPACK_IMPORTED_MODULE_4_lodash__["forEach"](this.pausedOngoingProcess, v => {
            this.set(v);
            return;
        });
        this.pausedOngoingProcess = [];
    }
    set(processName) {
        this.logger.debug('ongoingProcess active: ', processName);
        this.ongoingProcess.push(processName);
        let showName = this.getProcessNames()[processName] || processName;
        if (!this.loading) {
            this.loading = this.loadingCtrl.create();
        }
        this.loading.setContent(showName);
        this.loading.present();
    }
};
OnGoingProcessProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* LoadingController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], OnGoingProcessProvider);

//# sourceMappingURL=on-going-process.js.map

/***/ }),

/***/ 322:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElectronProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);



let ElectronProvider = class ElectronProvider {
    constructor(logger) {
        this.logger = logger;
        this.logger.debug('ElectronProvider initialized');
    }
    readFromClipboard() {
        const { clipboard } = window.require('electron');
        return clipboard.readText();
    }
    writeToClipboard(text) {
        const { clipboard } = window.require('electron');
        return clipboard.writeText(text);
    }
    clearClipboard() {
        const { clipboard } = window.require('electron');
        clipboard.clear();
    }
    openExternalLink(url) {
        const { shell } = window.require('electron');
        return shell.openExternal(url);
    }
};
ElectronProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], ElectronProvider);

//# sourceMappingURL=electron.js.map

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errors = __webpack_require__(115);
var _ = __webpack_require__(1);

module.exports = {
  checkState: function(condition, message) {
    if (!condition) {
      throw new errors.InvalidState(message);
    }
  },
  checkArgument: function(condition, argumentName, message, docsPath) {
    if (!condition) {
      throw new errors.InvalidArgument(argumentName, message, docsPath);
    }
  },
  checkArgumentType: function(argument, type, argumentName) {
    argumentName = argumentName || '(unknown name)';
    if (_.isString(type)) {
      if (type === 'Buffer') {
        var buffer = __webpack_require__(2); // './buffer' fails on cordova & RN
        if (!buffer.Buffer.isBuffer(argument)) {
          throw new errors.InvalidArgumentType(argument, type, argumentName);
        }
      } else if (typeof argument !== type) {
        throw new errors.InvalidArgumentType(argument, type, argumentName);
      }
    } else {
      if (!(argument instanceof type)) {
        throw new errors.InvalidArgumentType(argument, type.name, argumentName);
      }
    }
  }
};


/***/ }),

/***/ 350:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

var educore = module.exports;

// module information
educore.version = 'v' + __webpack_require__(1492).version;
educore.versionGuard = function(version) {
  if (version !== undefined) {
    var message = 'More than one instance of bitcore-lib-edu found. ' +
      'Please make sure to require bitcore-lib-edu and check that submodules do' +
      ' not also include their own bitcore-lib-edu dependency.';
    throw new Error(message);
  }
};
educore.versionGuard(global._educore);
global._educore = educore.version;

// crypto
educore.crypto = {};
educore.crypto.BN = __webpack_require__(73);
educore.crypto.ECDSA = __webpack_require__(351);
educore.crypto.Hash = __webpack_require__(74);
educore.crypto.Random = __webpack_require__(355);
educore.crypto.Point = __webpack_require__(216);
educore.crypto.Signature = __webpack_require__(103);

// encoding
educore.encoding = {};
educore.encoding.Base58 = __webpack_require__(352);
educore.encoding.Base58Check = __webpack_require__(267);
educore.encoding.BufferReader = __webpack_require__(160);
educore.encoding.BufferWriter = __webpack_require__(93);
educore.encoding.Varint = __webpack_require__(1500);

// utilities
educore.util = {};
educore.util.buffer = __webpack_require__(48);
educore.util.js = __webpack_require__(59);
educore.util.preconditions = __webpack_require__(35);

// errors thrown by the library
educore.errors = __webpack_require__(115);

// main bitcoin library
educore.Address = __webpack_require__(140);
educore.Block = __webpack_require__(1501);
educore.MerkleBlock = __webpack_require__(860);
educore.BlockHeader = __webpack_require__(356);
educore.HDPrivateKey = __webpack_require__(861);
educore.HDPublicKey = __webpack_require__(862);
educore.Message = __webpack_require__(1503);
educore.Networks = __webpack_require__(199);
educore.Opcode = __webpack_require__(460);
educore.PrivateKey = __webpack_require__(266);
educore.PublicKey = __webpack_require__(139);
educore.Script = __webpack_require__(104);
educore.Transaction = __webpack_require__(353);
educore.URI = __webpack_require__(1504);
educore.Unit = __webpack_require__(463);

// dependencies, subject to change
educore.deps = {};
educore.deps.bnjs = __webpack_require__(15);
educore.deps.bs58 = __webpack_require__(91);
educore.deps.Buffer = Buffer;
educore.deps.elliptic = __webpack_require__(54);
educore.deps._ = __webpack_require__(1);

// Internal usage, exposed for testing/advanced tweaking
educore.Transaction.sighash = __webpack_require__(181);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(2).Buffer))

/***/ }),

/***/ 351:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(73);
var Point = __webpack_require__(216);
var Signature = __webpack_require__(103);
var PublicKey = __webpack_require__(139);
var Random = __webpack_require__(355);
var Hash = __webpack_require__(74);
var BufferUtil = __webpack_require__(48);
var _ = __webpack_require__(1);
var $ = __webpack_require__(35);

var ECDSA = function ECDSA(obj) {
  if (!(this instanceof ECDSA)) {
    return new ECDSA(obj);
  }
  if (obj) {
    this.set(obj);
  }
};

/* jshint maxcomplexity: 9 */
ECDSA.prototype.set = function(obj) {
  this.hashbuf = obj.hashbuf || this.hashbuf;
  this.endian = obj.endian || this.endian; //the endianness of hashbuf
  this.privkey = obj.privkey || this.privkey;
  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
  this.sig = obj.sig || this.sig;
  this.k = obj.k || this.k;
  this.verified = obj.verified || this.verified;
  return this;
};

ECDSA.prototype.privkey2pubkey = function() {
  this.pubkey = this.privkey.toPublicKey();
};

ECDSA.prototype.calci = function() {
  for (var i = 0; i < 4; i++) {
    this.sig.i = i;
    var Qprime;
    try {
      Qprime = this.toPublicKey();
    } catch (e) {
      console.error(e);
      continue;
    }

    if (Qprime.point.eq(this.pubkey.point)) {
      this.sig.compressed = this.pubkey.compressed;
      return this;
    }
  }

  this.sig.i = undefined;
  throw new Error('Unable to find valid recovery factor');
};

ECDSA.fromString = function(str) {
  var obj = JSON.parse(str);
  return new ECDSA(obj);
};

ECDSA.prototype.randomK = function() {
  var N = Point.getN();
  var k;
  do {
    k = BN.fromBuffer(Random.getRandomBuffer(32));
  } while (!(k.lt(N) && k.gt(BN.Zero)));
  this.k = k;
  return this;
};


// https://tools.ietf.org/html/rfc6979#section-3.2
ECDSA.prototype.deterministicK = function(badrs) {
  /* jshint maxstatements: 25 */
  // if r or s were invalid when this function was used in signing,
  // we do not want to actually compute r, s here for efficiency, so,
  // we can increment badrs. explained at end of RFC 6979 section 3.2
  if (_.isUndefined(badrs)) {
    badrs = 0;
  }
  var v = Buffer.alloc(32);
  v.fill(0x01);
  var k = Buffer.alloc(32);
  k.fill(0x00);
  var x = this.privkey.bn.toBuffer({
    size: 32
  });
  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf
  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);
  v = Hash.sha256hmac(v, k);
  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);
  v = Hash.sha256hmac(v, k);
  v = Hash.sha256hmac(v, k);
  var T = BN.fromBuffer(v);
  var N = Point.getN();

  // also explained in 3.2, we must ensure T is in the proper range (0, N)
  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {
    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);
    v = Hash.sha256hmac(v, k);
    v = Hash.sha256hmac(v, k);
    T = BN.fromBuffer(v);
  }

  this.k = T;
  return this;
};

// Information about public key recovery:
// https://bitcointalk.org/index.php?topic=6430.0
// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k
ECDSA.prototype.toPublicKey = function() {
  /* jshint maxstatements: 25 */
  var i = this.sig.i;
  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));

  var e = BN.fromBuffer(this.hashbuf);
  var r = this.sig.r;
  var s = this.sig.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  var n = Point.getN();
  var G = Point.getG();

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = Point.fromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.mul(n);

  if (!nR.isInfinity()) {
    throw new Error('nR is not a valid curve point');
  }

  // Compute -e from e
  var eNeg = e.neg().umod(n);

  // 1.6.1 Compute Q = r^-1 (sR - eG)
  // Q = r^-1 (sR + -eG)
  var rInv = r.invm(n);

  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);
  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);

  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);

  return pubkey;
};

ECDSA.prototype.sigError = function() {
  /* jshint maxstatements: 25 */
  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
    return 'hashbuf must be a 32 byte buffer';
  }

  var r = this.sig.r;
  var s = this.sig.s;
  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {
    return 'r and s not in range';
  }

  var e = BN.fromBuffer(this.hashbuf, this.endian ? {
    endian: this.endian
  } : undefined);
  var n = Point.getN();
  var sinv = s.invm(n);
  var u1 = sinv.mul(e).umod(n);
  var u2 = sinv.mul(r).umod(n);

  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);
  if (p.isInfinity()) {
    return 'p is infinity';
  }

  if (p.getX().umod(n).cmp(r) !== 0) {
    return 'Invalid signature';
  } else {
    return false;
  }
};

ECDSA.toLowS = function(s) {
  //enforce low s
  //see BIP 62, "low S values in signatures"
  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
    s = Point.getN().sub(s);
  }
  return s;
};

ECDSA.prototype._findSignature = function(d, e) {
  var N = Point.getN();
  var G = Point.getG();
  // try different values of k until r, s are valid
  var badrs = 0;
  var k, Q, r, s;
  do {
    if (!this.k || badrs > 0) {
      this.deterministicK(badrs);
    }
    badrs++;
    k = this.k;
    Q = G.mul(k);
    r = Q.x.umod(N);
    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);
  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);

  s = ECDSA.toLowS(s);
  return {
    s: s,
    r: r
  };

};

ECDSA.prototype.sign = function() {
  var hashbuf = this.hashbuf;
  var privkey = this.privkey;
  var d = privkey.bn;

  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));
  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));

  var e = BN.fromBuffer(hashbuf, this.endian ? {
    endian: this.endian
  } : undefined);

  var obj = this._findSignature(d, e);
  obj.compressed = this.pubkey.compressed;

  this.sig = new Signature(obj);
  return this;
};

ECDSA.prototype.signRandomK = function() {
  this.randomK();
  return this.sign();
};

ECDSA.prototype.toString = function() {
  var obj = {};
  if (this.hashbuf) {
    obj.hashbuf = this.hashbuf.toString('hex');
  }
  if (this.privkey) {
    obj.privkey = this.privkey.toString();
  }
  if (this.pubkey) {
    obj.pubkey = this.pubkey.toString();
  }
  if (this.sig) {
    obj.sig = this.sig.toString();
  }
  if (this.k) {
    obj.k = this.k.toString();
  }
  return JSON.stringify(obj);
};

ECDSA.prototype.verify = function() {
  if (!this.sigError()) {
    this.verified = true;
  } else {
    this.verified = false;
  }
  return this;
};

ECDSA.sign = function(hashbuf, privkey, endian) {
  return ECDSA().set({
    hashbuf: hashbuf,
    endian: endian,
    privkey: privkey
  }).sign().sig;
};

ECDSA.verify = function(hashbuf, sig, pubkey, endian) {
  return ECDSA().set({
    hashbuf: hashbuf,
    endian: endian,
    sig: sig,
    pubkey: pubkey
  }).verify().verified;
};

module.exports = ECDSA;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 352:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var bs58 = __webpack_require__(91);
var buffer = __webpack_require__(2);

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');

var Base58 = function Base58(obj) {
  /* jshint maxcomplexity: 8 */
  if (!(this instanceof Base58)) {
    return new Base58(obj);
  }
  if (Buffer.isBuffer(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  } else if (obj) {
    this.set(obj);
  }
};

Base58.validCharacters = function validCharacters(chars) {
  if (buffer.Buffer.isBuffer(chars)) {
    chars = chars.toString();
  }
  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));
};

Base58.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this;
};

Base58.encode = function(buf) {
  if (!buffer.Buffer.isBuffer(buf)) {
    throw new Error('Input should be a buffer');
  }
  return bs58.encode(buf);
};

Base58.decode = function(str) {
  if (typeof str !== 'string') {
    throw new Error('Input should be a string');
  }
  return Buffer.from(bs58.decode(str));
};

Base58.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Base58.prototype.fromString = function(str) {
  var buf = Base58.decode(str);
  this.buf = buf;
  return this;
};

Base58.prototype.toBuffer = function() {
  return this.buf;
};

Base58.prototype.toString = function() {
  return Base58.encode(this.buf);
};

module.exports = Base58;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 353:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(461);

module.exports.Input = __webpack_require__(462);
module.exports.Output = __webpack_require__(161);
module.exports.UnspentOutput = __webpack_require__(859);
module.exports.Signature = __webpack_require__(269);
module.exports.Sighash = __webpack_require__(181);
module.exports.SighashWitness = __webpack_require__(354);


/***/ }),

/***/ 354:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/* jshint maxparams:5 */

var Signature = __webpack_require__(103);
var Script = __webpack_require__(104);
var Output = __webpack_require__(161);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var BN = __webpack_require__(73);
var Hash = __webpack_require__(74);
var ECDSA = __webpack_require__(351);
var $ = __webpack_require__(35);
var _ = __webpack_require__(1);

/**
 * Returns a buffer of length 32 bytes with the hash that needs to be signed
 * for witness programs as defined by:
 * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki
 *
 * @name Signing.sighash
 * @param {Transaction} transaction the transaction to sign
 * @param {number} sighashType the type of the hash
 * @param {number} inputNumber the input index for the signature
 * @param {Buffer} scriptCode
 * @param {Buffer} satoshisBuffer
 */
var sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {
  /* jshint maxstatements: 50 */

  var hashPrevouts;
  var hashSequence;
  var hashOutputs;

  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
    var buffers = [];
    for (var n = 0; n < transaction.inputs.length; n++) {
      var input = transaction.inputs[n];
      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();
      buffers.push(prevTxIdBuffer);
      var outputIndexBuffer = Buffer.alloc(4);
      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);
      buffers.push(outputIndexBuffer);
    }
    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));
  }

  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&
      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {

    var sequenceBuffers = [];
    for (var m = 0; m < transaction.inputs.length; m++) {
      var sequenceBuffer = Buffer.alloc(4);
      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);
      sequenceBuffers.push(sequenceBuffer);
    }
    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));
  }

  var outputWriter = new BufferWriter();
  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {
    for (var p = 0; p < transaction.outputs.length; p++) {
      transaction.outputs[p].toBufferWriter(outputWriter);
    }
    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());
  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
    transaction.outputs[inputNumber].toBufferWriter(outputWriter);
    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());
  }

  // Version
  var writer = new BufferWriter();
  writer.writeUInt32LE(transaction.version);

  // Input prevouts/nSequence (none/all, depending on flags)
  writer.write(hashPrevouts);
  writer.write(hashSequence);

  // The input being signed (replacing the scriptSig with scriptCode + amount)
  // The prevout may already be contained in hashPrevout, and the nSequence
  // may already be contain in hashSequence.
  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();
  writer.write(outpointId);
  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);

  writer.write(scriptCode);

  writer.write(satoshisBuffer);

  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);

  // Outputs (none/one/all, depending on flags)
  writer.write(hashOutputs);

  // Locktime
  writer.writeUInt32LE(transaction.nLockTime);

  // Sighash type
  writer.writeInt32LE(sighashType);

  return Hash.sha256sha256(writer.toBuffer());

};

/**
 * Create a signature
 *
 * @name Signing.sign
 * @param {Transaction} transaction
 * @param {PrivateKey} privateKey
 * @param {number} sighash
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {Signature}
 */
function sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';
  var sig;

  if (signingMethod === 'ecdsa') {
    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);
    sig = ECDSA.sign(hashbuf, privateKey).set({
      nhashtype: sighashType
    });
    return sig;
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * Verify a signature
 *
 * @name Signing.verify
 * @param {Transaction} transaction
 * @param {Signature} signature
 * @param {PublicKey} publicKey
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {boolean}
 */
function verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
  $.checkArgument(!_.isUndefined(transaction));
  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
  signingMethod = signingMethod || 'ecdsa';

  if (signingMethod === 'ecdsa') {
    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);
    return ECDSA.verify(hashbuf, signature, publicKey);
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * @namespace Signing
 */
module.exports = {
  sighash: sighash,
  sign: sign,
  verify: verify
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 355:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

function Random() {
}

/* secure random bytes that sometimes throws an error due to lack of entropy */
Random.getRandomBuffer = function(size) {
  if (process.browser)
    return Random.getRandomBufferBrowser(size);
  else
    return Random.getRandomBufferNode(size);
};

Random.getRandomBufferNode = function(size) {
  var crypto = __webpack_require__(52);
  return crypto.randomBytes(size);
};

Random.getRandomBufferBrowser = function(size) {
  if (!window.crypto && !window.msCrypto)
    throw new Error('window.crypto not available');

  if (window.crypto && window.crypto.getRandomValues)
    var crypto = window.crypto;
  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer
    var crypto = window.msCrypto;
  else
    throw new Error('window.crypto.getRandomValues not available');

  var bbuf = new Uint8Array(size);
  crypto.getRandomValues(bbuf);
  var buf = Buffer.from(bbuf);

  return buf;
};

/* insecure random bytes, but it never fails */
Random.getPseudoRandomBuffer = function(size) {
  var b32 = 0x100000000;
  var b = Buffer.alloc(size);
  var r;

  for (var i = 0; i <= size; i++) {
    var j = Math.floor(i / 4);
    var k = i - j * 4;
    if (k === 0) {
      r = Math.random() * b32;
      b[i] = r & 0xff;
    } else {
      b[i] = (r = r >>> 8) & 0xff;
    }
  }

  return b;
};

module.exports = Random;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40), __webpack_require__(2).Buffer))

/***/ }),

/***/ 356:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BN = __webpack_require__(73);
var BufferUtil = __webpack_require__(48);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var Hash = __webpack_require__(74);
var JSUtil = __webpack_require__(59);
var $ = __webpack_require__(35);

var GENESIS_BITS = 0x1d00ffff;

/**
 * Instantiate a BlockHeader from a Buffer, JSON object, or Object with
 * the properties of the BlockHeader
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {BlockHeader} - An instance of block header
 * @constructor
 */
var BlockHeader = function BlockHeader(arg) {
  if (!(this instanceof BlockHeader)) {
    return new BlockHeader(arg);
  }
  var info = BlockHeader._from(arg);
  this.version = info.version;
  this.prevHash = info.prevHash;
  this.merkleRoot = info.merkleRoot;
  this.time = info.time;
  this.timestamp = info.time;
  this.bits = info.bits;
  this.nonce = info.nonce;

  if (info.hash) {
    $.checkState(
      this.hash === info.hash,
      'Argument object hash property does not match block hash.'
    );
  }

  return this;
};

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block header data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
BlockHeader._from = function _from(arg) {
  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = BlockHeader._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    info = BlockHeader._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for BlockHeader');
  }
  return info;
};

/**
 * @param {Object} - A JSON string
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader._fromObject = function _fromObject(data) {
  $.checkArgument(data, 'data is required');
  var prevHash = data.prevHash;
  var merkleRoot = data.merkleRoot;
  if (_.isString(data.prevHash)) {
    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));
  }
  if (_.isString(data.merkleRoot)) {
    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));
  }
  var info = {
    hash: data.hash,
    version: data.version,
    prevHash: prevHash,
    merkleRoot: merkleRoot,
    time: data.time,
    timestamp: data.time,
    bits: data.bits,
    nonce: data.nonce
  };
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromObject = function fromObject(obj) {
  var info = BlockHeader._fromObject(obj);
  return new BlockHeader(info);
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromRawBlock = function fromRawBlock(data) {
  if (!BufferUtil.isBuffer(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader(data);
  br.pos = BlockHeader.Constants.START_OF_HEADER;
  var info = BlockHeader._fromBufferReader(br);
  return new BlockHeader(info);
};

/**
 * @param {Buffer} - A buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromBuffer = function fromBuffer(buf) {
  var info = BlockHeader._fromBufferReader(BufferReader(buf));
  return new BlockHeader(info);
};

/**
 * @param {string} - A hex encoded buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromString = function fromString(str) {
  var buf = Buffer.from(str, 'hex');
  return BlockHeader.fromBuffer(buf);
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader._fromBufferReader = function _fromBufferReader(br) {
  var info = {};
  info.version = br.readInt32LE();
  info.prevHash = br.read(32);
  info.merkleRoot = br.read(32);
  info.time = br.readUInt32LE();
  info.bits = br.readUInt32LE();
  info.nonce = br.readUInt32LE();
  return info;
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromBufferReader = function fromBufferReader(br) {
  var info = BlockHeader._fromBufferReader(br);
  return new BlockHeader(info);
};

/**
 * @returns {Object} - A plain object of the BlockHeader
 */
BlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {
  return {
    hash: this.hash,
    version: this.version,
    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),
    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce
  };
};

/**
 * @returns {Buffer} - A Buffer of the BlockHeader
 */
BlockHeader.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @returns {string} - A hex encoded string of the BlockHeader
 */
BlockHeader.prototype.toString = function toString() {
  return this.toBuffer().toString('hex');
};

/**
 * @param {BufferWriter} - An existing instance BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader
 */
BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.writeInt32LE(this.version);
  bw.write(this.prevHash);
  bw.write(this.merkleRoot);
  bw.writeUInt32LE(this.time);
  bw.writeUInt32LE(this.bits);
  bw.writeUInt32LE(this.nonce);
  return bw;
};

/**
 * Returns the target difficulty for this block
 * @param {Number} bits
 * @returns {BN} An instance of BN with the decoded difficulty bits
 */
BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {
  bits = bits || this.bits;

  var target = new BN(bits & 0xffffff);
  var mov = 8 * ((bits >>> 24) - 3);
  while (mov-- > 0) {
    target = target.mul(new BN(2));
  }
  return target;
};

/**
 * @link https://en.bitcoin.it/wiki/Difficulty
 * @return {Number}
 */
BlockHeader.prototype.getDifficulty = function getDifficulty() {
  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));
  var currentTargetBN = this.getTargetDifficulty();

  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
  var decimalPos = difficultyString.length - 8;
  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);

  return parseFloat(difficultyString);
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
BlockHeader.prototype._getHash = function hash() {
  var buf = this.toBuffer();
  return Hash.sha256sha256(buf);
};

var idProperty = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function() {
    if (!this._id) {
      this._id = BufferReader(this._getHash()).readReverse().toString('hex');
    }
    return this._id;
  },
  set: _.noop
};
Object.defineProperty(BlockHeader.prototype, 'id', idProperty);
Object.defineProperty(BlockHeader.prototype, 'hash', idProperty);

/**
 * @returns {Boolean} - If timestamp is not too far in the future
 */
BlockHeader.prototype.validTimestamp = function validTimestamp() {
  var currentTime = Math.round(new Date().getTime() / 1000);
  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {
    return false;
  }
  return true;
};

/**
 * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty
 */
BlockHeader.prototype.validProofOfWork = function validProofOfWork() {
  var pow = new BN(this.id, 'hex');
  var target = this.getTargetDifficulty();

  if (pow.cmp(target) > 0) {
    return false;
  }
  return true;
};

/**
 * @returns {string} - A string formatted for the console
 */
BlockHeader.prototype.inspect = function inspect() {
  return '<BlockHeader ' + this.id + '>';
};

BlockHeader.Constants = {
  START_OF_HEADER: 8, // Start buffer position in raw block data
  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future
  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

module.exports = BlockHeader;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 357:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

var tikcore = module.exports;

// module information
tikcore.version = 'v' + __webpack_require__(1505).version;
tikcore.versionGuard = function(version) {
  if (version !== undefined) {
    var message = 'More than one instance of bitcore-lib-edu found. ' +
      'Please make sure to require bitcore-lib-edu and check that submodules do' +
      ' not also include their own bitcore-lib-edu dependency.';
    throw new Error(message);
  }
};
tikcore.versionGuard(global._tikcore);
global._tikcore = tikcore.version;

// crypto
tikcore.crypto = {};
tikcore.crypto.BN = __webpack_require__(75);
tikcore.crypto.ECDSA = __webpack_require__(358);
tikcore.crypto.Hash = __webpack_require__(76);
tikcore.crypto.Random = __webpack_require__(362);
tikcore.crypto.Point = __webpack_require__(217);
tikcore.crypto.Signature = __webpack_require__(105);

// encoding
tikcore.encoding = {};
tikcore.encoding.Base58 = __webpack_require__(359);
tikcore.encoding.Base58Check = __webpack_require__(271);
tikcore.encoding.BufferReader = __webpack_require__(162);
tikcore.encoding.BufferWriter = __webpack_require__(94);
tikcore.encoding.Varint = __webpack_require__(1513);

// utilities
tikcore.util = {};
tikcore.util.buffer = __webpack_require__(49);
tikcore.util.js = __webpack_require__(60);
tikcore.util.preconditions = __webpack_require__(36);

// errors thrown by the library
tikcore.errors = __webpack_require__(116);

// main bitcoin library
tikcore.Address = __webpack_require__(142);
tikcore.Block = __webpack_require__(1514);
tikcore.MerkleBlock = __webpack_require__(865);
tikcore.BlockHeader = __webpack_require__(363);
tikcore.HDPrivateKey = __webpack_require__(866);
tikcore.HDPublicKey = __webpack_require__(867);
tikcore.Message = __webpack_require__(1516);
tikcore.Networks = __webpack_require__(200);
tikcore.Opcode = __webpack_require__(464);
tikcore.PrivateKey = __webpack_require__(270);
tikcore.PublicKey = __webpack_require__(141);
tikcore.Script = __webpack_require__(106);
tikcore.Transaction = __webpack_require__(360);
tikcore.URI = __webpack_require__(1517);
tikcore.Unit = __webpack_require__(467);

// dependencies, subject to change
tikcore.deps = {};
tikcore.deps.bnjs = __webpack_require__(15);
tikcore.deps.bs58 = __webpack_require__(91);
tikcore.deps.Buffer = Buffer;
tikcore.deps.elliptic = __webpack_require__(54);
tikcore.deps._ = __webpack_require__(1);

// Internal usage, exposed for testing/advanced tweaking
tikcore.Transaction.sighash = __webpack_require__(182);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(2).Buffer))

/***/ }),

/***/ 358:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(75);
var Point = __webpack_require__(217);
var Signature = __webpack_require__(105);
var PublicKey = __webpack_require__(141);
var Random = __webpack_require__(362);
var Hash = __webpack_require__(76);
var BufferUtil = __webpack_require__(49);
var _ = __webpack_require__(1);
var $ = __webpack_require__(36);

var ECDSA = function ECDSA(obj) {
  if (!(this instanceof ECDSA)) {
    return new ECDSA(obj);
  }
  if (obj) {
    this.set(obj);
  }
};

/* jshint maxcomplexity: 9 */
ECDSA.prototype.set = function(obj) {
  this.hashbuf = obj.hashbuf || this.hashbuf;
  this.endian = obj.endian || this.endian; //the endianness of hashbuf
  this.privkey = obj.privkey || this.privkey;
  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
  this.sig = obj.sig || this.sig;
  this.k = obj.k || this.k;
  this.verified = obj.verified || this.verified;
  return this;
};

ECDSA.prototype.privkey2pubkey = function() {
  this.pubkey = this.privkey.toPublicKey();
};

ECDSA.prototype.calci = function() {
  for (var i = 0; i < 4; i++) {
    this.sig.i = i;
    var Qprime;
    try {
      Qprime = this.toPublicKey();
    } catch (e) {
      console.error(e);
      continue;
    }

    if (Qprime.point.eq(this.pubkey.point)) {
      this.sig.compressed = this.pubkey.compressed;
      return this;
    }
  }

  this.sig.i = undefined;
  throw new Error('Unable to find valid recovery factor');
};

ECDSA.fromString = function(str) {
  var obj = JSON.parse(str);
  return new ECDSA(obj);
};

ECDSA.prototype.randomK = function() {
  var N = Point.getN();
  var k;
  do {
    k = BN.fromBuffer(Random.getRandomBuffer(32));
  } while (!(k.lt(N) && k.gt(BN.Zero)));
  this.k = k;
  return this;
};


// https://tools.ietf.org/html/rfc6979#section-3.2
ECDSA.prototype.deterministicK = function(badrs) {
  /* jshint maxstatements: 25 */
  // if r or s were invalid when this function was used in signing,
  // we do not want to actually compute r, s here for efficiency, so,
  // we can increment badrs. explained at end of RFC 6979 section 3.2
  if (_.isUndefined(badrs)) {
    badrs = 0;
  }
  var v = Buffer.alloc(32);
  v.fill(0x01);
  var k = Buffer.alloc(32);
  k.fill(0x00);
  var x = this.privkey.bn.toBuffer({
    size: 32
  });
  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf
  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);
  v = Hash.sha256hmac(v, k);
  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);
  v = Hash.sha256hmac(v, k);
  v = Hash.sha256hmac(v, k);
  var T = BN.fromBuffer(v);
  var N = Point.getN();

  // also explained in 3.2, we must ensure T is in the proper range (0, N)
  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {
    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);
    v = Hash.sha256hmac(v, k);
    v = Hash.sha256hmac(v, k);
    T = BN.fromBuffer(v);
  }

  this.k = T;
  return this;
};

// Information about public key recovery:
// https://bitcointalk.org/index.php?topic=6430.0
// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k
ECDSA.prototype.toPublicKey = function() {
  /* jshint maxstatements: 25 */
  var i = this.sig.i;
  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));

  var e = BN.fromBuffer(this.hashbuf);
  var r = this.sig.r;
  var s = this.sig.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  var n = Point.getN();
  var G = Point.getG();

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = Point.fromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.mul(n);

  if (!nR.isInfinity()) {
    throw new Error('nR is not a valid curve point');
  }

  // Compute -e from e
  var eNeg = e.neg().umod(n);

  // 1.6.1 Compute Q = r^-1 (sR - eG)
  // Q = r^-1 (sR + -eG)
  var rInv = r.invm(n);

  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);
  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);

  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);

  return pubkey;
};

ECDSA.prototype.sigError = function() {
  /* jshint maxstatements: 25 */
  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
    return 'hashbuf must be a 32 byte buffer';
  }

  var r = this.sig.r;
  var s = this.sig.s;
  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {
    return 'r and s not in range';
  }

  var e = BN.fromBuffer(this.hashbuf, this.endian ? {
    endian: this.endian
  } : undefined);
  var n = Point.getN();
  var sinv = s.invm(n);
  var u1 = sinv.mul(e).umod(n);
  var u2 = sinv.mul(r).umod(n);

  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);
  if (p.isInfinity()) {
    return 'p is infinity';
  }

  if (p.getX().umod(n).cmp(r) !== 0) {
    return 'Invalid signature';
  } else {
    return false;
  }
};

ECDSA.toLowS = function(s) {
  //enforce low s
  //see BIP 62, "low S values in signatures"
  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
    s = Point.getN().sub(s);
  }
  return s;
};

ECDSA.prototype._findSignature = function(d, e) {
  var N = Point.getN();
  var G = Point.getG();
  // try different values of k until r, s are valid
  var badrs = 0;
  var k, Q, r, s;
  do {
    if (!this.k || badrs > 0) {
      this.deterministicK(badrs);
    }
    badrs++;
    k = this.k;
    Q = G.mul(k);
    r = Q.x.umod(N);
    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);
  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);

  s = ECDSA.toLowS(s);
  return {
    s: s,
    r: r
  };

};

ECDSA.prototype.sign = function() {
  var hashbuf = this.hashbuf;
  var privkey = this.privkey;
  var d = privkey.bn;

  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));
  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));

  var e = BN.fromBuffer(hashbuf, this.endian ? {
    endian: this.endian
  } : undefined);

  var obj = this._findSignature(d, e);
  obj.compressed = this.pubkey.compressed;

  this.sig = new Signature(obj);
  return this;
};

ECDSA.prototype.signRandomK = function() {
  this.randomK();
  return this.sign();
};

ECDSA.prototype.toString = function() {
  var obj = {};
  if (this.hashbuf) {
    obj.hashbuf = this.hashbuf.toString('hex');
  }
  if (this.privkey) {
    obj.privkey = this.privkey.toString();
  }
  if (this.pubkey) {
    obj.pubkey = this.pubkey.toString();
  }
  if (this.sig) {
    obj.sig = this.sig.toString();
  }
  if (this.k) {
    obj.k = this.k.toString();
  }
  return JSON.stringify(obj);
};

ECDSA.prototype.verify = function() {
  if (!this.sigError()) {
    this.verified = true;
  } else {
    this.verified = false;
  }
  return this;
};

ECDSA.sign = function(hashbuf, privkey, endian) {
  return ECDSA().set({
    hashbuf: hashbuf,
    endian: endian,
    privkey: privkey
  }).sign().sig;
};

ECDSA.verify = function(hashbuf, sig, pubkey, endian) {
  return ECDSA().set({
    hashbuf: hashbuf,
    endian: endian,
    sig: sig,
    pubkey: pubkey
  }).verify().verified;
};

module.exports = ECDSA;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 359:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var bs58 = __webpack_require__(91);
var buffer = __webpack_require__(2);

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');

var Base58 = function Base58(obj) {
  /* jshint maxcomplexity: 8 */
  if (!(this instanceof Base58)) {
    return new Base58(obj);
  }
  if (Buffer.isBuffer(obj)) {
    var buf = obj;
    this.fromBuffer(buf);
  } else if (typeof obj === 'string') {
    var str = obj;
    this.fromString(str);
  } else if (obj) {
    this.set(obj);
  }
};

Base58.validCharacters = function validCharacters(chars) {
  if (buffer.Buffer.isBuffer(chars)) {
    chars = chars.toString();
  }
  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));
};

Base58.prototype.set = function(obj) {
  this.buf = obj.buf || this.buf || undefined;
  return this;
};

Base58.encode = function(buf) {
  if (!buffer.Buffer.isBuffer(buf)) {
    throw new Error('Input should be a buffer');
  }
  return bs58.encode(buf);
};

Base58.decode = function(str) {
  if (typeof str !== 'string') {
    throw new Error('Input should be a string');
  }
  return Buffer.from(bs58.decode(str));
};

Base58.prototype.fromBuffer = function(buf) {
  this.buf = buf;
  return this;
};

Base58.prototype.fromString = function(str) {
  var buf = Base58.decode(str);
  this.buf = buf;
  return this;
};

Base58.prototype.toBuffer = function() {
  return this.buf;
};

Base58.prototype.toString = function() {
  return Base58.encode(this.buf);
};

module.exports = Base58;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errors = __webpack_require__(116);
var _ = __webpack_require__(1);

module.exports = {
  checkState: function(condition, message) {
    if (!condition) {
      throw new errors.InvalidState(message);
    }
  },
  checkArgument: function(condition, argumentName, message, docsPath) {
    if (!condition) {
      throw new errors.InvalidArgument(argumentName, message, docsPath);
    }
  },
  checkArgumentType: function(argument, type, argumentName) {
    argumentName = argumentName || '(unknown name)';
    if (_.isString(type)) {
      if (type === 'Buffer') {
        var buffer = __webpack_require__(2); // './buffer' fails on cordova & RN
        if (!buffer.Buffer.isBuffer(argument)) {
          throw new errors.InvalidArgumentType(argument, type, argumentName);
        }
      } else if (typeof argument !== type) {
        throw new errors.InvalidArgumentType(argument, type, argumentName);
      }
    } else {
      if (!(argument instanceof type)) {
        throw new errors.InvalidArgumentType(argument, type.name, argumentName);
      }
    }
  }
};


/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(465);

module.exports.Input = __webpack_require__(466);
module.exports.Output = __webpack_require__(163);
module.exports.UnspentOutput = __webpack_require__(864);
module.exports.Signature = __webpack_require__(273);
module.exports.Sighash = __webpack_require__(182);
module.exports.SighashWitness = __webpack_require__(361);


/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/* jshint maxparams:5 */

var Signature = __webpack_require__(105);
var Script = __webpack_require__(106);
var Output = __webpack_require__(163);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var BN = __webpack_require__(75);
var Hash = __webpack_require__(76);
var ECDSA = __webpack_require__(358);
var $ = __webpack_require__(36);
var _ = __webpack_require__(1);

/**
 * Returns a buffer of length 32 bytes with the hash that needs to be signed
 * for witness programs as defined by:
 * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki
 *
 * @name Signing.sighash
 * @param {Transaction} transaction the transaction to sign
 * @param {number} sighashType the type of the hash
 * @param {number} inputNumber the input index for the signature
 * @param {Buffer} scriptCode
 * @param {Buffer} satoshisBuffer
 */
var sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {
  /* jshint maxstatements: 50 */

  var hashPrevouts;
  var hashSequence;
  var hashOutputs;

  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
    var buffers = [];
    for (var n = 0; n < transaction.inputs.length; n++) {
      var input = transaction.inputs[n];
      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();
      buffers.push(prevTxIdBuffer);
      var outputIndexBuffer = Buffer.alloc(4);
      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);
      buffers.push(outputIndexBuffer);
    }
    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));
  }

  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&
      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {

    var sequenceBuffers = [];
    for (var m = 0; m < transaction.inputs.length; m++) {
      var sequenceBuffer = Buffer.alloc(4);
      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);
      sequenceBuffers.push(sequenceBuffer);
    }
    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));
  }

  var outputWriter = new BufferWriter();
  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {
    for (var p = 0; p < transaction.outputs.length; p++) {
      transaction.outputs[p].toBufferWriter(outputWriter);
    }
    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());
  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
    transaction.outputs[inputNumber].toBufferWriter(outputWriter);
    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());
  }

  // Version
  var writer = new BufferWriter();
  writer.writeUInt32LE(transaction.version);

  // Input prevouts/nSequence (none/all, depending on flags)
  writer.write(hashPrevouts);
  writer.write(hashSequence);

  // The input being signed (replacing the scriptSig with scriptCode + amount)
  // The prevout may already be contained in hashPrevout, and the nSequence
  // may already be contain in hashSequence.
  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();
  writer.write(outpointId);
  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);

  writer.write(scriptCode);

  writer.write(satoshisBuffer);

  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);

  // Outputs (none/one/all, depending on flags)
  writer.write(hashOutputs);

  // Locktime
  writer.writeUInt32LE(transaction.nLockTime);

  // Sighash type
  writer.writeInt32LE(sighashType);

  return Hash.sha256sha256(writer.toBuffer());

};

/**
 * Create a signature
 *
 * @name Signing.sign
 * @param {Transaction} transaction
 * @param {PrivateKey} privateKey
 * @param {number} sighash
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {Signature}
 */
function sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
  signingMethod = signingMethod || 'ecdsa';
  var sig;

  if (signingMethod === 'ecdsa') {
    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);
    sig = ECDSA.sign(hashbuf, privateKey).set({
      nhashtype: sighashType
    });
    return sig;
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * Verify a signature
 *
 * @name Signing.verify
 * @param {Transaction} transaction
 * @param {Signature} signature
 * @param {PublicKey} publicKey
 * @param {number} inputIndex
 * @param {Script} subscript
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @return {boolean}
 */
function verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
  $.checkArgument(!_.isUndefined(transaction));
  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
  signingMethod = signingMethod || 'ecdsa';

  if (signingMethod === 'ecdsa') {
    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);
    return ECDSA.verify(hashbuf, signature, publicKey);
  }
  throw new Error("signingMethod not supported ", signingMethod);
}

/**
 * @namespace Signing
 */
module.exports = {
  sighash: sighash,
  sign: sign,
  verify: verify
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 362:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

function Random() {
}

/* secure random bytes that sometimes throws an error due to lack of entropy */
Random.getRandomBuffer = function(size) {
  if (process.browser)
    return Random.getRandomBufferBrowser(size);
  else
    return Random.getRandomBufferNode(size);
};

Random.getRandomBufferNode = function(size) {
  var crypto = __webpack_require__(52);
  return crypto.randomBytes(size);
};

Random.getRandomBufferBrowser = function(size) {
  if (!window.crypto && !window.msCrypto)
    throw new Error('window.crypto not available');

  if (window.crypto && window.crypto.getRandomValues)
    var crypto = window.crypto;
  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer
    var crypto = window.msCrypto;
  else
    throw new Error('window.crypto.getRandomValues not available');

  var bbuf = new Uint8Array(size);
  crypto.getRandomValues(bbuf);
  var buf = Buffer.from(bbuf);

  return buf;
};

/* insecure random bytes, but it never fails */
Random.getPseudoRandomBuffer = function(size) {
  var b32 = 0x100000000;
  var b = Buffer.alloc(size);
  var r;

  for (var i = 0; i <= size; i++) {
    var j = Math.floor(i / 4);
    var k = i - j * 4;
    if (k === 0) {
      r = Math.random() * b32;
      b[i] = r & 0xff;
    } else {
      b[i] = (r = r >>> 8) & 0xff;
    }
  }

  return b;
};

module.exports = Random;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40), __webpack_require__(2).Buffer))

/***/ }),

/***/ 363:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BN = __webpack_require__(75);
var BufferUtil = __webpack_require__(49);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var Hash = __webpack_require__(76);
var JSUtil = __webpack_require__(60);
var $ = __webpack_require__(36);

var GENESIS_BITS = 0x1d00ffff;

/**
 * Instantiate a BlockHeader from a Buffer, JSON object, or Object with
 * the properties of the BlockHeader
 *
 * @param {*} - A Buffer, JSON string, or Object
 * @returns {BlockHeader} - An instance of block header
 * @constructor
 */
var BlockHeader = function BlockHeader(arg) {
  if (!(this instanceof BlockHeader)) {
    return new BlockHeader(arg);
  }
  var info = BlockHeader._from(arg);
  this.version = info.version;
  this.prevHash = info.prevHash;
  this.merkleRoot = info.merkleRoot;
  this.time = info.time;
  this.timestamp = info.time;
  this.bits = info.bits;
  this.nonce = info.nonce;

  if (info.hash) {
    $.checkState(
      this.hash === info.hash,
      'Argument object hash property does not match block hash.'
    );
  }

  return this;
};

/**
 * @param {*} - A Buffer, JSON string or Object
 * @returns {Object} - An object representing block header data
 * @throws {TypeError} - If the argument was not recognized
 * @private
 */
BlockHeader._from = function _from(arg) {
  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = BlockHeader._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    info = BlockHeader._fromObject(arg);
  } else {
    throw new TypeError('Unrecognized argument for BlockHeader');
  }
  return info;
};

/**
 * @param {Object} - A JSON string
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader._fromObject = function _fromObject(data) {
  $.checkArgument(data, 'data is required');
  var prevHash = data.prevHash;
  var merkleRoot = data.merkleRoot;
  if (_.isString(data.prevHash)) {
    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));
  }
  if (_.isString(data.merkleRoot)) {
    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));
  }
  var info = {
    hash: data.hash,
    version: data.version,
    prevHash: prevHash,
    merkleRoot: merkleRoot,
    time: data.time,
    timestamp: data.time,
    bits: data.bits,
    nonce: data.nonce
  };
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromObject = function fromObject(obj) {
  var info = BlockHeader._fromObject(obj);
  return new BlockHeader(info);
};

/**
 * @param {Binary} - Raw block binary data or buffer
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromRawBlock = function fromRawBlock(data) {
  if (!BufferUtil.isBuffer(data)) {
    data = Buffer.from(data, 'binary');
  }
  var br = BufferReader(data);
  br.pos = BlockHeader.Constants.START_OF_HEADER;
  var info = BlockHeader._fromBufferReader(br);
  return new BlockHeader(info);
};

/**
 * @param {Buffer} - A buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromBuffer = function fromBuffer(buf) {
  var info = BlockHeader._fromBufferReader(BufferReader(buf));
  return new BlockHeader(info);
};

/**
 * @param {string} - A hex encoded buffer of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromString = function fromString(str) {
  var buf = Buffer.from(str, 'hex');
  return BlockHeader.fromBuffer(buf);
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {Object} - An object representing block header data
 * @private
 */
BlockHeader._fromBufferReader = function _fromBufferReader(br) {
  var info = {};
  info.version = br.readInt32LE();
  info.prevHash = br.read(32);
  info.merkleRoot = br.read(32);
  info.time = br.readUInt32LE();
  info.bits = br.readUInt32LE();
  info.nonce = br.readUInt32LE();
  return info;
};

/**
 * @param {BufferReader} - A BufferReader of the block header
 * @returns {BlockHeader} - An instance of block header
 */
BlockHeader.fromBufferReader = function fromBufferReader(br) {
  var info = BlockHeader._fromBufferReader(br);
  return new BlockHeader(info);
};

/**
 * @returns {Object} - A plain object of the BlockHeader
 */
BlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {
  return {
    hash: this.hash,
    version: this.version,
    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),
    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),
    time: this.time,
    bits: this.bits,
    nonce: this.nonce
  };
};

/**
 * @returns {Buffer} - A Buffer of the BlockHeader
 */
BlockHeader.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @returns {string} - A hex encoded string of the BlockHeader
 */
BlockHeader.prototype.toString = function toString() {
  return this.toBuffer().toString('hex');
};

/**
 * @param {BufferWriter} - An existing instance BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader
 */
BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.writeInt32LE(this.version);
  bw.write(this.prevHash);
  bw.write(this.merkleRoot);
  bw.writeUInt32LE(this.time);
  bw.writeUInt32LE(this.bits);
  bw.writeUInt32LE(this.nonce);
  return bw;
};

/**
 * Returns the target difficulty for this block
 * @param {Number} bits
 * @returns {BN} An instance of BN with the decoded difficulty bits
 */
BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {
  bits = bits || this.bits;

  var target = new BN(bits & 0xffffff);
  var mov = 8 * ((bits >>> 24) - 3);
  while (mov-- > 0) {
    target = target.mul(new BN(2));
  }
  return target;
};

/**
 * @link https://en.bitcoin.it/wiki/Difficulty
 * @return {Number}
 */
BlockHeader.prototype.getDifficulty = function getDifficulty() {
  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));
  var currentTargetBN = this.getTargetDifficulty();

  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
  var decimalPos = difficultyString.length - 8;
  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);

  return parseFloat(difficultyString);
};

/**
 * @returns {Buffer} - The little endian hash buffer of the header
 */
BlockHeader.prototype._getHash = function hash() {
  var buf = this.toBuffer();
  return Hash.sha256sha256(buf);
};

var idProperty = {
  configurable: false,
  enumerable: true,
  /**
   * @returns {string} - The big endian hash buffer of the header
   */
  get: function() {
    if (!this._id) {
      this._id = BufferReader(this._getHash()).readReverse().toString('hex');
    }
    return this._id;
  },
  set: _.noop
};
Object.defineProperty(BlockHeader.prototype, 'id', idProperty);
Object.defineProperty(BlockHeader.prototype, 'hash', idProperty);

/**
 * @returns {Boolean} - If timestamp is not too far in the future
 */
BlockHeader.prototype.validTimestamp = function validTimestamp() {
  var currentTime = Math.round(new Date().getTime() / 1000);
  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {
    return false;
  }
  return true;
};

/**
 * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty
 */
BlockHeader.prototype.validProofOfWork = function validProofOfWork() {
  var pow = new BN(this.id, 'hex');
  var target = this.getTargetDifficulty();

  if (pow.cmp(target) > 0) {
    return false;
  }
  return true;
};

/**
 * @returns {string} - A string formatted for the console
 */
BlockHeader.prototype.inspect = function inspect() {
  return '<BlockHeader ' + this.id + '>';
};

BlockHeader.Constants = {
  START_OF_HEADER: 8, // Start buffer position in raw block data
  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future
  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')
};

module.exports = BlockHeader;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 371:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1588)(__webpack_require__(1589))


/***/ }),

/***/ 377:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LogsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_download_download__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);



// native

// providers


let LogsProvider = class LogsProvider {
    constructor(logger, downloadProvider, socialSharing) {
        this.logger = logger;
        this.downloadProvider = downloadProvider;
        this.socialSharing = socialSharing;
        this.logger.debug('LogsProvider initialized');
    }
    get(app, platform) {
        if (platform != 'desktop')
            this.share(app, platform);
        else
            this.download(app);
    }
    prepareSessionLogs() {
        let log = 'Session Logs.\nBe careful, this could contain sensitive private data\n\n';
        log += '\n\n';
        const weight = 4; // share complete logs
        const logs = __WEBPACK_IMPORTED_MODULE_2_lodash__["sortBy"](this.logger.get(weight), 'timestamp');
        Object.keys(logs).forEach(key => {
            log +=
                '[' +
                    logs[key].timestamp +
                    '][' +
                    logs[key].level +
                    ']' +
                    logs[key].msg +
                    '\n';
        });
        return log;
    }
    download(app) {
        const logs = this.prepareSessionLogs();
        const now = new Date().toISOString();
        const filename = app + '-logs ' + now + '.txt';
        this.downloadProvider.download(logs, filename);
    }
    share(app, platform) {
        const logs = this.prepareSessionLogs();
        const now = new Date().toISOString();
        const subject = app + '-logs ' + now;
        const message = 'Session Logs. Be careful, this could contain sensitive private data';
        const blob = new Blob([logs], { type: 'text/txt' });
        const reader = new FileReader();
        reader.onload = event => {
            const attachment = event.target.result; // <-- data url
            if (platform == 'android') {
                this.shareAndroid(message, subject, attachment);
            }
            else {
                this.shareIOS(message, subject, attachment);
            }
        };
        reader.readAsDataURL(blob);
    }
    shareAndroid(message, subject, attachment) {
        // share via email with attachment is not working correctly in some android versions
        // so instead of shareViaEmail() -> share()
        this.socialSharing.share(message, subject, attachment).catch(err => {
            this.logger.error('socialSharing Error: ', err);
        });
    }
    shareIOS(message, subject, attachment) {
        // Check if sharing via email is supported
        this.socialSharing
            .canShareViaEmail()
            .then(() => {
            this.logger.info('sharing via email is possible');
            this.socialSharing
                .shareViaEmail(message, subject, null, // TO: must be null or an array
            null, // CC: must be null or an array
            null, // BCC: must be null or an array
            attachment // FILES: can be null, a string, or an array
            )
                .then(data => {
                this.logger.info('Email created successfully: ', data);
            })
                .catch(err => {
                this.logger.error('socialSharing Error: ', err);
            });
        })
            .catch(() => {
            this.logger.warn('sharing via email is not possible');
            this.socialSharing
                .share(message, subject, attachment // FILES: can be null, a string, or an array
            )
                .catch(err => {
                this.logger.error('socialSharing Error: ', err);
            });
        });
    }
};
LogsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_download_download__["a" /* DownloadProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__["a" /* SocialSharing */]])
], LogsProvider);

//# sourceMappingURL=logs.js.map

/***/ }),

/***/ 378:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var bitauth;
if (process.browser) {
  bitauth = __webpack_require__(1951);
} else {
  bitauth = __webpack_require__(943);

  // add node-specific encrypt/decrypt
  bitauth.encrypt = __webpack_require__(1952);
  bitauth.decrypt = __webpack_require__(1953);
  bitauth.middleware = __webpack_require__(1954);
}

module.exports = bitauth;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40)))

/***/ }),

/***/ 379:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinAccountProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_identity_app_identity__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__replace_parameters_replace_parameters__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__tkcoin_tkcoin__ = __webpack_require__(207);




// native

// providers








let TKCoinAccountProvider = class TKCoinAccountProvider {
    /*
     * Pair this app with the tkcoin server using the specified pairing data.
     * An app identity will be created if one does not already exist.
     * Pairing data is provided by an input URI provided by the tkcoin server.
     *
     * pairData - data needed to complete the pairing process
     * {
     *   secret: shared pairing secret
     *   email: email address associated with tkcoin account
     *   otp: two-factor one-time use password
     * }
     *
     * pairingReason - text string to be embedded into popup message.  If `null` then the reason
     * message is not shown to the UI.
     *   "To {{reason}} you must pair this app with your TKCoin account ({{email}})."
     *
     * cb - callback after completion
     *   callback(err, paired, apiContext)
     *
     *   err - something unexpected happened which prevented the pairing
     *
     *   paired - boolean indicating whether the pairing was compledted by the user
     *
     *   apiContext - the context needed for making future api calls
     *   {
     *     token: api token for use in future calls
     *     pairData: the input pair data
     *     appIdentity: the identity of this app
     *   }
     */
    constructor(platformProvider, replaceParametersProvider, bitPayProvider, logger, onGoingProcessProvider, popupProvider, persistenceProvider, appIdentityProvider, device, translate) {
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bitPayProvider = bitPayProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.device = device;
        this.translate = translate;
        this.logger.debug('TKCoinAccountProvider initialized');
    }
    pair(pairData, pairingReason, cb) {
        this.checkOtp(pairData, otp => {
            pairData.otp = otp;
            let deviceName = 'Unknown device';
            if (this.platformProvider.isElectron) {
                deviceName = this.platformProvider.getOS().OSName;
            }
            else if (this.platformProvider.isCordova) {
                deviceName = this.device.model;
            }
            let json = {
                method: 'createToken',
                params: {
                    secret: pairData.secret,
                    version: 2,
                    deviceName,
                    code: pairData.otp
                }
            };
            this.onGoingProcessProvider.set('fetchingTKCoinAccount');
            this.bitPayProvider.postAuth(json, data => {
                if (data && data.error) {
                    this.onGoingProcessProvider.clear();
                    return cb(data.error);
                }
                let apiContext = {
                    token: data.data,
                    pairData,
                    appIdentity: data.appIdentity
                };
                this.logger.info('TKCoin service BitAuth create token: SUCCESS');
                this.fetchBasicInfo(apiContext, (err, basicInfo) => {
                    this.onGoingProcessProvider.clear();
                    if (err)
                        return cb(err);
                    let title = this.translate.instant('Add TKCoin Account?');
                    let msg;
                    if (pairingReason) {
                        let reason = pairingReason;
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('To {{reason}} you must first add your TKCoin account - {{email}}'), { reason, email });
                    }
                    else {
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('Add this TKCoin account ({{email}})?'), { email });
                    }
                    let ok = this.translate.instant('Add account');
                    let cancel = this.translate.instant('Go Back');
                    this.popupProvider
                        .ionicConfirm(title, msg, ok, cancel)
                        .then(res => {
                        if (res) {
                            let acctData = {
                                token: apiContext.token,
                                email: pairData.email,
                                givenName: basicInfo.givenName,
                                familyName: basicInfo.familyName
                            };
                            this.setBitpayAccount(acctData);
                            return cb(null, true, apiContext);
                        }
                        else {
                            this.logger.info('User cancelled TKCoin pairing process');
                            return cb(null, false);
                        }
                    });
                });
            }, data => {
                return cb(this._setError('TKCoin service BitAuth create token: ERROR ', data));
            });
        });
    }
    checkOtp(pairData, cb) {
        if (pairData.otp) {
            let msg = this.translate.instant('Enter Two Factor for your TKCoin account');
            this.popupProvider.ionicPrompt(null, msg, null).then(res => {
                cb(res);
            });
        }
        else {
            cb();
        }
    }
    fetchBasicInfo(apiContext, cb) {
        let json = {
            method: 'getBasicInfo'
        };
        // Get basic account information
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error)
                return cb(data.error);
            this.logger.info('TKCoin Account Get Basic Info: SUCCESS');
            return cb(null, data.data);
        }, data => {
            return cb(this._setError('TKCoin Account Error: Get Basic Info', data));
        });
    }
    // Returns account objects as stored.
    getAccountsAsStored(cb) {
        this.persistenceProvider
            .getBitpayAccounts(this.bitPayProvider.getEnvironment().network)
            .then(accounts => {
            return cb(null, accounts);
        })
            .catch(err => {
            return cb(err, []);
        });
    }
    // Returns an array where each element represents an account including all information required for fetching data
    // from the server for each account (apiContext).
    getAccounts(cb) {
        this.getAccountsAsStored((err, accounts) => {
            if (err || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](accounts)) {
                return cb(err, []);
            }
            this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, (err, appIdentity) => {
                if (err) {
                    return cb(err);
                }
                let accountsArray = [];
                __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](Object.keys(accounts), key => {
                    accounts[key].cards = accounts[key].cards;
                    accounts[key].email = key;
                    accounts[key].givenName = accounts[key].givenName || '';
                    accounts[key].familyName = accounts[key].familyName || '';
                    accounts[key].apiContext = {
                        token: accounts[key].token,
                        pairData: {
                            email: key
                        },
                        appIdentity
                    };
                    accountsArray.push(accounts[key]);
                });
                return cb(null, accountsArray);
            });
        });
    }
    setBitpayAccount(account) {
        this.persistenceProvider.setBitpayAccount(this.bitPayProvider.getEnvironment().network, account);
    }
    removeAccount(email, cb) {
        this.persistenceProvider
            .removeBitpayAccount(this.bitPayProvider.getEnvironment().network, email)
            .then(() => {
            return cb();
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        let error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
};
TKCoinAccountProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_12__tkcoin_tkcoin__["a" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_6__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_10__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], TKCoinAccountProvider);

//# sourceMappingURL=tkcoin-account.js.map

/***/ }),

/***/ 380:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinIdProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_bitauth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_identity_app_identity__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__in_app_browser_in_app_browser__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(13);




// providers







let TKCoinIdProvider = class TKCoinIdProvider {
    constructor(http, appIdentityProvider, logger, device, platformProvider, persistenceProvider, iab, events) {
        this.http = http;
        this.appIdentityProvider = appIdentityProvider;
        this.logger = logger;
        this.device = device;
        this.platformProvider = platformProvider;
        this.persistenceProvider = persistenceProvider;
        this.iab = iab;
        this.events = events;
        this.deviceName = 'unknown device';
        this.logger.debug('TKCoinProvider initialized');
        if (this.platformProvider.isElectron) {
            this.deviceName = this.platformProvider.getOS().OSName;
        }
        else if (this.platformProvider.isCordova) {
            this.deviceName = this.device.model;
        }
    }
    setNetwork(network) {
        this.NETWORK = network;
        this.TKCOIN_API_URL =
            this.NETWORK == 'livenet'
                ? 'https://tkcoin.org'
                : 'https://test.tkcoin.org';
        this.logger.log(`tkcoin id provider initialized with ${this.NETWORK}`);
    }
    getEnvironment() {
        return {
            network: this.NETWORK
        };
    }
    generatePairingToken(payload, successCallback, errorCallback) {
        const network = __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.getEnvironment().network];
        this.appIdentityProvider.getIdentity(network, (err, appIdentity) => {
            if (err) {
                alert(err);
                return errorCallback(err);
            }
            const { secret, code } = payload;
            const params = {
                secret,
                version: 2,
                deviceName: this.deviceName
            };
            if (code) {
                params['code'] = code;
            }
            let json = {
                method: 'createToken',
                params
            };
            let dataToSign = JSON.stringify(json['params']);
            let signedData = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
            __WEBPACK_IMPORTED_MODULE_5_bitauth__["verifySignature"](dataToSign, appIdentity.pub, signedData, () => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                json['params'].signature = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
                json['params'].pubkey = appIdentity.pub;
                json['params'] = JSON.stringify(json.params);
                const url = `${this.TKCOIN_API_URL}/api/v2/`;
                let headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]().set('content-type', 'application/json');
                try {
                    const token = yield this.http
                        .post(url, json, { headers })
                        .toPromise();
                    json = {
                        method: 'getBasicInfo',
                        token: token.data
                    };
                    dataToSign = `${url}${token.data}${JSON.stringify(json)}`;
                    signedData = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
                    headers = headers.append('x-identity', appIdentity.pub);
                    headers = headers.append('x-signature', signedData);
                    const user = yield this.http
                        .post(`${url}${token.data}`, json, { headers })
                        .toPromise();
                    if (user) {
                        if (user.error) {
                            errorCallback(user.error);
                            return;
                        }
                        this.logger.debug('TKCoinID: successfully paired');
                        const { data } = user;
                        const { email, familyName, givenName, experiments, incentiveLevel, incentiveLevelId } = data;
                        if (experiments && experiments.includes('NADebitCard')) {
                            this.persistenceProvider.setCardExperimentFlag('enabled');
                            this.events.publish('experimentUpdateStart');
                        }
                        yield Promise.all([
                            this.persistenceProvider.setTKCoinIdPairingToken(network, token.data),
                            this.persistenceProvider.setTKCoinIdUserInfo(network, data),
                            this.persistenceProvider.setBitpayAccount(network, {
                                email,
                                token: token.data,
                                familyName: familyName || '',
                                givenName: givenName || '',
                                incentiveLevel,
                                incentiveLevelId
                            })
                        ]);
                        successCallback(data);
                    }
                }
                catch (err) {
                    alert(JSON.stringify(err));
                    errorCallback(err);
                }
            }), err => {
                errorCallback(err);
            });
        });
    }
    apiCall(method, params = {}, userShopperToken) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const url = `${this.TKCOIN_API_URL}/api/v2/`;
            let token = userShopperToken ||
                (yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.NETWORK]));
            const json = {
                method,
                params: JSON.stringify(params),
                token
            };
            const dataToSign = `${url}${token}${JSON.stringify(json)}`;
            const appIdentity = (yield this.getAppIdentity());
            const signedData = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
            let headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]().set('content-type', 'application/json');
            headers = headers.append('x-identity', appIdentity.pub);
            headers = headers.append('x-signature', signedData);
            const res = yield this.http
                .post(`${url}${token}`, json, { headers })
                .toPromise();
            if (res && res.error) {
                throw new Error(res.error);
            }
            return (res && res.data) || res;
        });
    }
    refreshUserInfo() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.debug('Refreshing user info');
            const userInfo = yield this.apiCall('getBasicInfo');
            const network = __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.getEnvironment().network];
            yield this.persistenceProvider.setTKCoinIdUserInfo(network, userInfo);
        });
    }
    unlockInvoice(invoiceId) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const isPaired = !!(yield this.persistenceProvider.getTKCoinIdPairingToken(__WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.NETWORK]));
            if (!isPaired)
                return 'pairingRequired';
            const tokens = yield this.apiCall('getProductTokens');
            const { token } = tokens.find(t => t.facade === 'userShopper');
            if (!token)
                return 'userShopperNotFound';
            const { meetsRequiredTier } = yield this.apiCall('unlockInvoice', { invoiceId }, token);
            if (!meetsRequiredTier)
                return 'tierNotMet';
            return 'unlockSuccess';
        });
    }
    getAppIdentity() {
        const network = __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.getEnvironment().network];
        return new Promise((resolve, reject) => {
            this.appIdentityProvider.getIdentity(network, (err, appIdentity) => {
                if (err) {
                    return reject(err);
                }
                resolve(appIdentity);
            });
        });
    }
    disconnectTKCoinID(successCallback, errorCallback) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const network = __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["a" /* Network */][this.getEnvironment().network];
            // @ts-ignore
            const user = yield this.persistenceProvider.getTKCoinIdUserInfo(network);
            try {
                yield Promise.all([
                    this.persistenceProvider.removeTKCoinIdPairingToken(network),
                    this.persistenceProvider.removeTKCoinIdUserInfo(network),
                    this.persistenceProvider.removeBitpayAccountV2(network)
                ]);
                this.iab.refs.card.executeScript({
                    code: `window.postMessage(${JSON.stringify({
                        message: 'tkcoinIdDisconnected'
                    })}, '*')`
                }, () => {
                    successCallback();
                });
            }
            catch (err) {
                errorCallback(err);
            }
        });
    }
};
TKCoinIdProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_7__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_8__in_app_browser_in_app_browser__["a" /* InAppBrowserProvider */],
        __WEBPACK_IMPORTED_MODULE_6_ionic_angular__["f" /* Events */]])
], TKCoinIdProvider);

//# sourceMappingURL=tkcoin-id.js.map

/***/ }),

/***/ 381:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InAppBrowserProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(32);








let InAppBrowserProvider = class InAppBrowserProvider {
    constructor(logger, actionSheetProvider, translate, events, onGoingProcess) {
        this.logger = logger;
        this.actionSheetProvider = actionSheetProvider;
        this.translate = translate;
        this.events = events;
        this.onGoingProcess = onGoingProcess;
        // add new refs here
        this.refs = {};
        this.logger.debug('InAppBrowserProvider initialized');
    }
    sendMessageToIAB(ref, message, cb) {
        ref.executeScript({
            code: `window.postMessage(${JSON.stringify(Object.assign({}, message))}, '*')`
        }, cb);
    }
    createIABInstance(refName, config, url, initScript) {
        return new Promise((res, rej) => {
            const ref = cordova.InAppBrowser.open(url, '_blank', config);
            const initCb = () => {
                if (initScript) {
                    // script that executes inside of inappbrowser when loaded
                    ref.executeScript({
                        code: initScript
                    }, () => {
                        ref.removeEventListener('loadstop', initCb);
                        this.logger.debug(`InAppBrowserProvider -> ${refName} executed init script`);
                    });
                }
            };
            ref.addEventListener('loadstop', initCb);
            ref.addEventListener('loaderror', err => {
                this.logger.debug(`InAppBrowserProvider -> ${refName} ${JSON.stringify(err)} load error`);
                ref.error = true;
                ref.show = () => {
                    this.actionSheetProvider
                        .createInfoSheet('default-error', {
                        msg: this.translate.instant('Uh oh something went wrong! Please try again later.'),
                        title: this.translate.instant('Error')
                    })
                        .present();
                };
                this.onGoingProcess.clear();
                rej();
            });
            ref.events$ = new __WEBPACK_IMPORTED_MODULE_4_rxjs_Subject__["Subject"]();
            ref.addEventListener('message', e => ref.events$.next(e));
            this.events.subscribe('iab_message_update', e => ref.events$.next(e));
            // providing two ways to get ref - caching it here and also returning it
            this.refs[refName] = ref;
            res(ref);
        });
    }
};
InAppBrowserProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], InAppBrowserProvider);

//# sourceMappingURL=in-app-browser.js.map

/***/ }),

/***/ 382:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExchangeCryptoProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__changelly_changelly__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__replace_parameters_replace_parameters__ = __webpack_require__(119);




// providers






let ExchangeCryptoProvider = class ExchangeCryptoProvider {
    constructor(changellyProvider, configProvider, currencyProvider, homeIntegrationsProvider, logger, replaceParametersProvider, translate) {
        this.changellyProvider = changellyProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.logger.debug('ExchangeCrypto Provider initialized');
        this.exchangeCoinsSupported = __WEBPACK_IMPORTED_MODULE_3_lodash__["union"](this.changellyProvider.supportedCoins);
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'exchangecrypto',
            title: this.translate.instant('Exchange Crypto'),
            icon: 'assets/img/exchange-crypto/exchange-settings.svg',
            showIcon: true,
            logo: null,
            logoWidth: '110',
            background: 'linear-gradient(to bottom,rgba(60, 63, 69, 1) 0,rgba(45, 47, 51, 1) 100%)',
            page: 'CryptoSettingsPage',
            show: !!this.configProvider.get().showIntegration['exchangecrypto'],
            type: 'exchange'
        });
    }
    getSwapTxs() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const [changellySwapTxs] = yield Promise.all([
                this.changellyProvider.getChangelly()
            ]);
            return {
                changellySwapTxs: __WEBPACK_IMPORTED_MODULE_3_lodash__["values"](changellySwapTxs)
            };
        });
    }
    verifyExcludedUtxos(coin, sendMaxInfo) {
        const warningMsg = [];
        if (sendMaxInfo.utxosBelowFee > 0) {
            const amountBelowFeeStr = sendMaxInfo.amountBelowFee /
                this.currencyProvider.getPrecision(coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr, coin: coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (sendMaxInfo.utxosAboveMaxSize > 0) {
            const amountAboveMaxSizeStr = sendMaxInfo.amountAboveMaxSize /
                this.currencyProvider.getPrecision(coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountAboveMaxSizeStr}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { amountAboveMaxSizeStr, coin: coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
};
ExchangeCryptoProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__changelly_changelly__["a" /* ChangellyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], ExchangeCryptoProvider);

//# sourceMappingURL=exchange-crypto.js.map

/***/ }),

/***/ 383:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocationProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let LocationProvider = class LocationProvider {
    constructor(http, logger) {
        this.http = http;
        this.logger = logger;
        this.logger.debug('LocationProvider initialized');
    }
    getCountry() {
        this.countryPromise = this.countryPromise
            ? this.countryPromise
            : this.http
                .get('https://tkcoin.org/wallet-card/location')
                .map((res) => res.country)
                .toPromise()
                .catch(_ => 'AR');
        return this.countryPromise;
    }
};
LocationProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], LocationProvider);

//# sourceMappingURL=location.js.map

/***/ }),

/***/ 386:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/timer.js
var timer = __webpack_require__(239);
var timer_default = /*#__PURE__*/__webpack_require__.n(timer);

// CONCATENATED MODULE: ./src/providers/color/color.ts
function hexToRGB(h) {
    let r = '0', g = '0', b = '0';
    // 3 digits
    if (h.length == 4) {
        r = '0x' + h[1] + h[1];
        g = '0x' + h[2] + h[2];
        b = '0x' + h[3] + h[3];
        // 6 digits
    }
    else if (h.length == 7) {
        r = '0x' + h[1] + h[2];
        g = '0x' + h[3] + h[4];
        b = '0x' + h[5] + h[6];
    }
    return 'rgb(' + +r + ',' + +g + ',' + +b + ')';
}
function getRgbValues(rgbString) {
    return rgbString
        .replace('rgb(', '')
        .replace(')', '')
        .split(',')
        .map(stringValue => parseInt(stringValue, 10));
}
function getBrightness(hexOrRgbString) {
    // http://www.w3.org/TR/AERT#color-contrast
    const rgbString = hexOrRgbString.startsWith('rgb(')
        ? hexOrRgbString
        : hexToRGB(hexOrRgbString);
    const [r, g, b] = getRgbValues(rgbString);
    return (r * 299 + g * 587 + b * 114) / 1000;
}
function isDark(hexString) {
    const rgbString = hexToRGB(hexString);
    return getBrightness(rgbString) < 80;
}
//# sourceMappingURL=color.js.map
// EXTERNAL MODULE: ./src/providers/directory/directory.ts
var directory_directory = __webpack_require__(947);

// EXTERNAL MODULE: ./src/providers/gift-card/gift-card.ts + 1 modules
var gift_card = __webpack_require__(89);

// CONCATENATED MODULE: ./src/providers/merchant/merchant.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return merchant_MerchantProvider; });
/* unused harmony export buildMerchants */
/* unused harmony export appendFeaturedGiftCardsToPopularBrands */
/* unused harmony export appendCategories */
/* unused harmony export getGiftCardDiscount */
/* harmony export (immutable) */ __webpack_exports__["b"] = getDiscount;
/* harmony export (immutable) */ __webpack_exports__["c"] = getDiscountTextColor;







let merchant_MerchantProvider = class MerchantProvider {
    constructor(directoryProvider, events, giftCardProvider) {
        this.directoryProvider = directoryProvider;
        this.events = events;
        this.giftCardProvider = giftCardProvider;
        this.listenForAuthChanges();
    }
    listenForAuthChanges() {
        const authChangeEvents = [
            'TKCoinId/Connected',
            'TKCoinId/Disconnected',
            'TKCoinId/SettingsChanged',
            'GiftCards/GiftCardPurchased'
        ];
        authChangeEvents.forEach(authChangeEvent => this.events.subscribe(authChangeEvent, () => this.refreshMerchants()));
    }
    refreshMerchants() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield Object(timer["timer"])(1200).toPromise();
            yield this.getMerchants(true);
        });
    }
    fetchMerchants() {
        this.merchantPromise = Promise.all([
            this.directoryProvider.fetchDirectIntegrations(),
            this.giftCardProvider.getAvailableCards(),
            this.directoryProvider.fetchDirectory(),
            this.giftCardProvider.getRecentlyPurchasedBrandNames()
        ]).then(([directIntegrations, availableGiftCardBrands, directory, recentlyPurchasedBrandNames]) => buildMerchants(directIntegrations, availableGiftCardBrands, directory, recentlyPurchasedBrandNames));
        return this.merchantPromise;
    }
    getMerchants(bustCache = false) {
        return this.merchantPromise && !bustCache
            ? this.merchantPromise
            : this.fetchMerchants();
    }
};
merchant_MerchantProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [directory_directory["a" /* DirectoryProvider */],
        ionic_angular["f" /* Events */],
        gift_card["a" /* GiftCardProvider */]])
], merchant_MerchantProvider);

function buildMerchants(directIntegrations = [], availableGiftCardBrands = [], directory, recentlyPurchasedBrandNames) {
    const directIntegrationMerchants = directIntegrations.map(integration => (Object.assign({}, integration, { hasDirectIntegration: true, giftCards: [] })));
    const giftCardMerchants = availableGiftCardBrands.map(cardConfig => ({
        hasDirectIntegration: false,
        name: cardConfig.name,
        displayName: cardConfig.displayName,
        caption: cardConfig.description,
        featured: cardConfig.featured,
        icon: cardConfig.icon,
        link: cardConfig.website,
        displayLink: cardConfig.website,
        tags: cardConfig.tags || [],
        domains: [cardConfig.website].concat(cardConfig.supportedUrls || []),
        theme: cardConfig.brandColor || cardConfig.logoBackgroundColor,
        instructions: cardConfig.description,
        giftCards: [cardConfig]
    }));
    const allMerchants = [
        ...directIntegrationMerchants,
        ...giftCardMerchants
    ];
    const recentlyPurchasedAvailableBrandNames = recentlyPurchasedBrandNames.filter(brandName => allMerchants.some(merchant => merchant.displayName === brandName));
    const fullDirectory = appendFeaturedGiftCardsToPopularBrands(directory, availableGiftCardBrands);
    return allMerchants
        .map(merchant => appendCategories(merchant, fullDirectory, recentlyPurchasedAvailableBrandNames))
        .sort(gift_card["g" /* sortByDisplayName */]);
}
function appendFeaturedGiftCardsToPopularBrands(directory, availableGiftCards = []) {
    const popularBrands = directory.curated.find(curation => curation.name === 'popularBrands');
    const popularAndFeaturedBrands = Object.assign({}, popularBrands, { merchants: [
            ...new Set([
                ...popularBrands.merchants,
                ...availableGiftCards
                    .filter(cardConfig => cardConfig.featured)
                    .map(brand => brand.displayName)
            ])
        ].sort((a, b) => Object(gift_card["g" /* sortByDisplayName */])({ displayName: a }, { displayName: b })) });
    return Object.assign({}, directory, { curated: directory.curated.map(curation => curation.name === 'popularBrands' ? popularAndFeaturedBrands : curation) });
}
function appendCategories(merchant, directory, recentlyPurchasedBrandNames) {
    const baseCurations = directory.curated
        .map((curation, index) => (Object.assign({}, curation, { index, merchantIndex: curation.merchants.indexOf(merchant.displayName) })))
        .filter(curation => curation.merchants.includes(merchant.displayName));
    const curations = recentlyPurchasedBrandNames.includes(merchant.displayName)
        ? [
            {
                displayName: 'Recently Purchased',
                index: -1,
                merchantIndex: recentlyPurchasedBrandNames.indexOf(merchant.displayName),
                merchants: recentlyPurchasedBrandNames,
                name: 'recentlyPurchased'
            },
            ...baseCurations
        ]
        : baseCurations;
    return Object.assign({}, merchant, { categories: directory.categories
            .map((category, index) => (Object.assign({}, category, { index })))
            .filter(category => category.tags.some(tag => merchant.tags.includes(tag))), curations });
}
function getGiftCardDiscount(merchant) {
    const cardConfig = merchant.giftCards[0];
    return cardConfig && cardConfig.discounts && cardConfig.discounts[0];
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function getDiscount(merchant) {
    return merchant.discount || getGiftCardDiscount(merchant);
}
function getDiscountTextColor(merchant, appTheme = 'Light Mode') {
    return merchant.theme === '#ffffff' ||
        merchant.theme === '#000000' ||
        (appTheme === 'Dark Mode' && isDark(merchant.theme))
        ? '#4f6ef7'
        : merchant.theme;
}
//# sourceMappingURL=merchant.js.map

/***/ }),

/***/ 389:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyOnboardingPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let KeyOnboardingPage = class KeyOnboardingPage {
    constructor(viewCtrl) {
        this.viewCtrl = viewCtrl;
    }
    ionViewWillLoad() {
        this.walletGroupOnboardingSlides.lockSwipeToPrev(true);
    }
    slideChanged() {
        // Disable first and last slides bounce
        let currentIndex = this.walletGroupOnboardingSlides.getActiveIndex();
        if (currentIndex == 0)
            this.walletGroupOnboardingSlides.lockSwipeToPrev(true);
        if (currentIndex > 0)
            this.walletGroupOnboardingSlides.lockSwipeToPrev(false);
        if (currentIndex >= 2)
            this.walletGroupOnboardingSlides.lockSwipeToNext(true);
        if (currentIndex < 2)
            this.walletGroupOnboardingSlides.lockSwipeToNext(false);
    }
    nextSlide() {
        this.walletGroupOnboardingSlides.slideNext();
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('walletGroupOnboardingSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* Slides */])
], KeyOnboardingPage.prototype, "walletGroupOnboardingSlides", void 0);
KeyOnboardingPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-key-onboarding',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-onboarding/key-onboarding.html"*/'<ion-content no-bounce>\n  <ion-slides #walletGroupOnboardingSlides (ionSlideDidChange)="slideChanged()" [pager]="!walletGroupOnboardingSlides.isEnd()" class="key-onboarding-slides">\n    <ion-slide>\n      <div class="img-container">\n        <img src="assets/img/wallet-group-tour1.svg" />\n      </div>\n      <div class="slide-info">\n        <div class="info">\n          <div class="title" translate>Your funds, on your device</div>\n          <div class="text" translate>\n            A wallet is like a vault stored on your device containing your crypto funds. Much like a vault, your wallet will only be accessible with the master key.\n          </div>\n        </div>\n      </div>\n    </ion-slide>\n    <ion-slide>\n      <div class="img-container">\n        <img src="assets/img/wallet-group-tour2.svg" />\n      </div>\n      <div class="slide-info">\n        <div class="info">\n          <div class="title" translate>The "Key" to your funds</div>\n          <div class="text" translate>\n            Your wallet master key is a phrase composed of 12 randomly selected words. If you ever lose or damage your device, you can re-gain access to your wallet as long as you have your 12 word master key.\n          </div>\n        </div>\n      </div>\n    </ion-slide>\n    <ion-slide>\n      <div class="img-container">\n        <img src="assets/img/wallet-group-tour3.svg" />\n      </div>\n      <div class="slide-info">\n        <div class="info">\n          <div class="title" translate>Don\'t lose your key!</div>\n          <div class="text" translate>\n            In order to protect your funds from being accessible to hackers and thieves, the Master Key to your wallet must be kept somewhere safe and remain a secret.\n          </div>\n        </div>\n      </div>\n    </ion-slide>\n  </ion-slides>\n</ion-content>\n<ion-footer no-border>\n  <ion-toolbar>\n    <button ion-button class="button-standard" (click)="nextSlide()" *ngIf="walletGroupOnboardingSlides.getActiveIndex() < 2">\n      {{ \'Next\' | translate }}\n    </button>\n    <button ion-button class="button-standard" (click)="close()" *ngIf="walletGroupOnboardingSlides.getActiveIndex() == 2">\n      {{\'I understand\' | translate }}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/key-settings/key-onboarding/key-onboarding.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], KeyOnboardingPage);

//# sourceMappingURL=key-onboarding.js.map

/***/ }),

/***/ 390:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RecoveryKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_backup_backup_key_backup_key__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(297);



// Providers


// Pages


let RecoveryKeyPage = class RecoveryKeyPage {
    constructor(navCtrl, navParams, logger, actionSheetProvider, platform, events) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.actionSheetProvider = actionSheetProvider;
        this.platform = platform;
        this.events = events;
        this.isOnboardingFlow = this.navParams.data.isOnboardingFlow;
        this.hideBackButton =
            this.isOnboardingFlow || this.navParams.data.hideBackButton;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: RecoveryKeyPage');
    }
    ionViewWillEnter() {
        this.initializeBackButtonHandler();
    }
    ionViewWillLeave() {
        this.unregisterBackButtonAction && this.unregisterBackButtonAction();
    }
    goToBackupKey() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__pages_backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId: this.navParams.data.keyId,
            isOnboardingFlow: this.isOnboardingFlow
        });
    }
    showInfoSheet() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-later-warning');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.isOnboardingFlow
                    ? this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */], {
                        keyId: this.navParams.data.keyId
                    })
                    : this.navCtrl.popToRoot().then(() => {
                        this.events.publish('Local/FetchWallets');
                    });
            }
        });
    }
    initializeBackButtonHandler() {
        this.unregisterBackButtonAction = this.platform.registerBackButtonAction(() => {
            this.showInfoSheet();
        });
    }
};
RecoveryKeyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-recovery-key',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/recovery-key/recovery-key.html"*/'<ion-header no-border>\n  <ion-navbar [hideBackButton]="hideBackButton" transparent></ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="recovery-key">\n    <div class="recovery-key-info">\n      <div class="img-container">\n        <img src="assets/img/onboarding/backup-key.svg" />\n      </div>\n      <div class="info">\n        <h3 class="title" translate>How to recover your funds if you lose this device?</h3>\n        <div class="text" translate>If you delete the TKCoin app or lose this device, youll need a recovery key to regain access to your funds.</div>\n      </div>\n    </div>\n  </div>\n</ion-content>\n<ion-footer no-border>\n  <ion-toolbar>\n    <button ion-button class="button-standard no-margin-bottom" (click)="goToBackupKey()">\n      {{\'View my recovery key\' | translate}}\n    </button>\n    <button ion-button clear color="primary" class="button-standard" (click)="showInfoSheet()">\n      {{"Ill do this later" | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/recovery-key/recovery-key.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["f" /* Events */]])
], RecoveryKeyPage);

//# sourceMappingURL=recovery-key.js.map

/***/ }),

/***/ 391:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmCardPurchasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__send_confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__gift_cards_card_details_card_details__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__purchased_cards_purchased_cards__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_clipboard_clipboard__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_wallet_connect_wallet_connect__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_wallet_wallet__ = __webpack_require__(31);







// Pages




// Provider






















let ConfirmCardPurchasePage = class ConfirmCardPurchasePage extends __WEBPACK_IMPORTED_MODULE_8__send_confirm_confirm__["a" /* ConfirmPage */] {
    constructor(analyticsProvider, addressProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, errorsProvider, feeProvider, giftCardProvider, incomingDataProvider, replaceParametersProvider, rateProvider, emailNotificationsProvider, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txConfirmNotificationProvider, txFormatProvider, walletProvider, translate, payproProvider, platformProvider, clipboardProvider, events, coinbaseProvider, appProvider, iabCardProvider, homeIntegrationsProvider, persistenceProvider, WalletConnectProvider, tkcoinIdProvider, merchantProvider) {
        super(addressProvider, analyticsProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, errorsProvider, externalLinkProvider, feeProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, platformProvider, profileProvider, popupProvider, replaceParametersProvider, rateProvider, translate, txConfirmNotificationProvider, txFormatProvider, walletProvider, clipboardProvider, events, coinbaseProvider, appProvider, payproProvider, iabCardProvider, homeIntegrationsProvider, persistenceProvider, WalletConnectProvider);
        this.giftCardProvider = giftCardProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.tkcoinIdProvider = tkcoinIdProvider;
        this.merchantProvider = merchantProvider;
        this.displayNameIncludesGiftCard = false;
        this.configWallet = this.configProvider.get().wallet;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.amount = this.navParams.data.amount;
            this.currency = this.navParams.data.currency;
            this.phone = this.navParams.get('phone');
            this.cardConfig = this.navParams.get('cardConfig');
            this.displayNameIncludesGiftCard = this.cardConfig.displayName
                .toLowerCase()
                .includes('gift card');
            this.onlyIntegers = this.cardConfig.currency === 'JPY';
            this.activationFee = Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["b" /* getActivationFee */])(this.amount, this.cardConfig);
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ConfirmCardPurchasePage');
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.network = this.giftCardProvider.getNetwork();
        const walletOptions = {
            onlyComplete: true,
            network: this.network,
            hasFunds: true
        };
        this.wallets = this.profileProvider.getWallets(Object.assign({}, walletOptions, { minFiatCurrency: { amount: this.amount, currency: this.currency } }));
        const pendingWallets = this.profileProvider.getWallets(Object.assign({}, walletOptions, { minPendingAmount: { amount: this.amount, currency: this.currency } }));
        this.showCoinbase =
            this.homeIntegrationsProvider.shouldShowInHome('coinbase') &&
                this.coinbaseProvider.isLinked();
        this.coinbaseAccounts =
            this.showCoinbase && this.network === 'livenet'
                ? this.coinbaseProvider.getAvailableAccounts(null, {
                    amount: this.amount,
                    currency: this.currency
                })
                : [];
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets) &&
            !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](pendingWallets) &&
            __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseAccounts)) {
            const subtitle = this.translate.instant('You do not have enough confirmed funds to make this payment. Please wait for your pending transactions to confirm.');
            const title = this.translate.instant('Not enough confirmed funds');
            this.errorsProvider.showDefaultError(subtitle, title);
            return;
        }
        else if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets) && __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseAccounts)) {
            this.errorsProvider.showNoWalletsAvailableInfo();
            return;
        }
        this.showWallets(); // Show wallet selector
    }
    logGiftCardPurchaseEvent(isSlideConfirmFinished, transactionCurrency, giftData) {
        if (!isSlideConfirmFinished) {
            this.giftCardProvider.logEvent('giftcards_purchase_start', {
                brand: this.cardConfig.name,
                transactionCurrency
            });
            this.giftCardProvider.logEvent('add_to_cart', {
                brand: this.cardConfig.name,
                category: 'giftCards'
            });
        }
        else {
            this.giftCardProvider.logEvent('giftcards_purchase_finish', {
                brand: this.cardConfig.name,
                transactionCurrency
            });
            this.giftCardProvider.logEvent('set_checkout_option', {
                transactionCurrency,
                checkout_step: 1
            });
            this.giftCardProvider.logEvent('purchase', {
                value: giftData.amount,
                items: [
                    {
                        name: this.cardConfig.name,
                        category: 'giftCards',
                        quantity: 1
                    }
                ]
            });
        }
    }
    cancel() {
        this.navCtrl.popToRoot();
    }
    checkFeeHigh(amount, fee) {
        if (this.isHighFee(amount, fee)) {
            this.showHighFeeSheet();
        }
    }
    openExternalLink(urlKey) {
        let url;
        let title;
        switch (urlKey) {
            case 'networkCost':
                url =
                    'https://support.tkcoin.org/hc/en-us/articles/115002990803-Why-Am-I-Being-Charged-an-Additional-Network-Cost-on-My-TKCoin-Invoice-';
                title = this.translate.instant('Network Cost');
                break;
            case 'minerFee':
                url =
                    'https://support.tkcoin.org/hc/en-us/articles/115003393863-What-are-bitcoin-miner-fees-Why-are-miner-fees-so-high-';
                title = this.translate.instant('Miner Fee');
                break;
        }
        let message = this.translate.instant('This information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, true, title, message, okText, cancelText);
    }
    resetValues() {
        this.totalAmountStr = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.tx = this.message = this.invoiceId = null;
    }
    publishAndSign(wallet, txp) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!wallet.canSign) {
                const err = this.translate.instant('No signing proposal: No private key');
                return Promise.reject(err);
            }
            yield this.walletProvider.publishAndSign(wallet, txp);
            return this.onGoingProcessProvider.clear();
        });
    }
    satToFiat(coin, sat) {
        return this.txFormatProvider.toFiat(coin, sat, this.currencyIsoCode, {
            rates: this.invoiceRates
        });
    }
    setTotalAmount(coin, invoiceFeeSat = 0, networkFeeSat = 0) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const invoiceFee = yield this.satToFiat(coin, invoiceFeeSat);
            this.invoiceFee = Number(invoiceFee);
            const chain = this.currencyProvider.getChain(coin).toLowerCase();
            const networkFee = yield this.satToFiat(chain, networkFeeSat);
            this.networkFee = Number(networkFee);
            this.totalAmount =
                this.amount -
                    this.totalDiscount +
                    this.activationFee +
                    this.invoiceFee +
                    this.networkFee;
        });
    }
    isCryptoCurrencySupported(coin, invoice) {
        return ((invoice['supportedTransactionCurrencies'][coin] &&
            invoice['supportedTransactionCurrencies'][coin].enabled) ||
            false);
    }
    handleCreateInvoiceError(err) {
        let err_title = this.translate.instant('Error creating the invoice');
        let err_msg;
        const errMessage = err && ((err.error && err.error.message) || err.message);
        if ((errMessage && errMessage.match(/suspended/i)) ||
            errMessage === 'Gift card currently unavailable') {
            err_title = this.translate.instant('Service not available');
            err_msg = this.translate.instant(`${this.cardConfig.displayName} gift card purchases are not available at this time. Please try again later.`);
        }
        else if (errMessage) {
            err_msg = errMessage;
        }
        else {
            err_msg = this.translate.instant(`Unable to complete your purchase at this time. Please try again later.`);
        }
        this.refreshCardConfigIfNeeded();
        throw {
            title: err_title,
            message: err_msg
        };
    }
    createInvoice(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const cardOrder = yield this.giftCardProvider
                .createBitpayInvoice(data)
                .catch(err => {
                throw this.handleCreateInvoiceError(err);
            });
            const accessKey = cardOrder && cardOrder.accessKey;
            const totalDiscount = cardOrder && cardOrder.totalDiscount;
            if (!accessKey) {
                throw {
                    message: this.translate.instant('No access key defined')
                };
            }
            const invoice = yield this.giftCardProvider
                .getTKCoinInvoice(cardOrder.invoiceId)
                .catch(() => {
                throw {
                    message: this.translate.instant('Could not get the invoice')
                };
            });
            return { invoice, accessKey, totalDiscount };
        });
    }
    createTx(wallet, invoice, message) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const COIN = wallet.coin.toUpperCase();
            const paymentCode = this.currencyProvider.getPaymentCode(wallet.coin);
            const protocolUrl = invoice.paymentCodes[COIN][paymentCode];
            const payProUrl = this.incomingDataProvider.getPayProUrl(protocolUrl);
            if (!payProUrl) {
                throw {
                    title: this.translate.instant('Error fetching this invoice'),
                    message: this.translate.instant('Invalid URL')
                };
            }
            const address = yield this.walletProvider.getAddress(wallet, false);
            const payload = {
                address
            };
            const details = yield this.payproProvider
                .getPayProDetails({ paymentUrl: payProUrl, coin: wallet.coin, payload })
                .catch(err => {
                throw {
                    title: this.translate.instant('Error fetching this invoice'),
                    message: err
                };
            });
            const { instructions } = details;
            const txp = {
                coin: wallet.coin,
                amount: __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](instructions, 'amount'),
                from: address,
                toAddress: instructions[0].toAddress,
                outputs: [],
                message,
                customData: {
                    giftCardName: this.cardConfig.name,
                    service: 'giftcards'
                },
                payProUrl,
                excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed ? false : true
            };
            for (const instruction of instructions) {
                txp.outputs.push({
                    toAddress: instruction.toAddress,
                    amount: instruction.amount,
                    message: instruction.message,
                    data: instruction.data
                });
            }
            if (wallet.coin === 'xrp' &&
                instructions &&
                instructions[0] &&
                instructions[0].outputs &&
                instructions[0].outputs[0] &&
                instructions[0].outputs[0].invoiceID) {
                txp.invoiceID = instructions[0].outputs[0].invoiceID;
            }
            if (wallet.credentials.token) {
                txp.tokenAddress = wallet.credentials.token.address;
            }
            if (this.wallet.credentials.multisigEthInfo) {
                txp.multisigContractAddress = this.wallet.credentials.multisigEthInfo.multisigContractAddress;
            }
            if (details.requiredFeeRate) {
                const requiredFeeRate = !this.currencyProvider.isUtxoCoin(wallet.coin)
                    ? details.requiredFeeRate
                    : Math.ceil(details.requiredFeeRate * 1000);
                txp.feePerKb = requiredFeeRate;
                this.logger.debug('Using merchant fee rate:' + txp.feePerKb);
            }
            else {
                txp.feeLevel = this.feeProvider.getCoinCurrentFeeLevel(wallet.coin);
            }
            txp['origToAddress'] = txp.toAddress;
            if (wallet.coin && wallet.coin == 'bch') {
                txp.toAddress = this.bitcoreCash.Address(txp.toAddress).toString(true);
                txp.outputs[0].toAddress = txp.toAddress;
            }
            return this.walletProvider.createTx(wallet, txp);
        });
    }
    redeemGiftCard(initialCard) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.set('buyingGiftCard');
            const card = yield this.giftCardProvider
                .createGiftCard(initialCard)
                .catch(() => (Object.assign({}, initialCard, { status: 'FAILURE' })));
            yield this.giftCardProvider.saveGiftCard(card);
            this.onGoingProcessProvider.clear();
            this.logger.debug('Saved new gift card with status: ' + card.status);
            this.logDiscountedPurchase();
            this.events.publish('GiftCards/GiftCardPurchased');
            this.finish(card);
        });
    }
    logDiscountedPurchase() {
        if (!Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["c" /* getPromo */])(this.cardConfig))
            return;
        const params = Object.assign({}, this.giftCardProvider.getPromoEventParams(this.cardConfig), { discounted: Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["f" /* hasVisibleDiscount */])(this.cardConfig) ? true : false });
        this.giftCardProvider.logEvent('purchasedGiftCard', params);
    }
    promptEmail() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!this.cardConfig.emailRequired) {
                const notificationEmail = this.emailNotificationsProvider.getEmailIfEnabled();
                return Promise.resolve(notificationEmail);
            }
            const email = yield this.giftCardProvider.getUserEmail();
            if (email) {
                return Promise.resolve(email);
            }
            return this.setEmail();
        });
    }
    setEmail() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const emailComponent = this.actionSheetProvider.createEmailComponent();
            yield emailComponent.present();
            return new Promise(resolve => {
                emailComponent.onDidDismiss(email => {
                    if (email) {
                        if (!this.giftCardProvider.emailIsValid(email)) {
                            this.throwEmailRequiredError();
                        }
                        this.giftCardProvider.storeEmail(email);
                        resolve(email);
                    }
                    else {
                        this.throwEmailRequiredError();
                    }
                    this.isOpenSelector = false;
                });
            });
        });
    }
    throwEmailRequiredError() {
        const title = this.translate.instant('Error');
        const msg = this.translate.instant('An email address is required for this purchase.');
        this.onGoingProcessProvider.clear();
        this.showErrorInfoSheet(msg, title, true);
        throw new Error('email required');
    }
    initialize(wallet, email) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const COIN = wallet.coin.toUpperCase();
            this.currencyIsoCode = this.currency;
            this.onGoingProcessProvider.set('loadingTxInfo');
            yield this.refreshCardConfigIfNeeded().catch(_ => { });
            const discount = Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["d" /* getVisibleDiscount */])(this.cardConfig);
            const dataSrc = Object.assign({ amount: this.amount, currency: this.currency, discounts: discount ? [discount.code] : [], uuid: wallet.id, email, buyerSelectedTransactionCurrency: COIN, cardName: this.cardConfig.name }, (this.phone && { phone: this.phone }));
            const data = yield this.createInvoice(dataSrc).catch(err => {
                this.onGoingProcessProvider.clear();
                throw this.showErrorInfoSheet(err.message, err.title, true);
            });
            this.invoiceRates = lowercaseKeys(data.invoice.exchangeRates);
            const parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, this.amount, this.currency, { onlyIntegers: this.onlyIntegers, rates: this.invoiceRates });
            this.amountUnitStr = parsedAmount.amountUnitStr;
            const invoice = data.invoice;
            const accessKey = data.accessKey;
            this.totalDiscount = data.totalDiscount || 0;
            const amountSat = invoice.paymentSubtotals[COIN];
            if (!this.isCryptoCurrencySupported(COIN, invoice)) {
                this.onGoingProcessProvider.clear();
                let msg = this.translate.instant('Purchases with this cryptocurrency are not enabled');
                this.showErrorInfoSheet(msg, null, true);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            this.message = this.replaceParametersProvider.replace(this.translate.instant(`{{amountUnitStr}} Gift Card`), { amountUnitStr: this.amountUnitStr });
            const ctxp = yield this.createTx(wallet, invoice, this.message).catch(err => {
                this.onGoingProcessProvider.clear();
                this.resetValues();
                throw this.showErrorInfoSheet(err.message, err.title);
            });
            this.onGoingProcessProvider.clear();
            // Save in memory
            this.tx = ctxp;
            this.invoiceId = invoice.id;
            const now = __WEBPACK_IMPORTED_MODULE_5_moment__().unix() * 1000;
            this.tx.giftData = {
                currency: dataSrc.currency,
                date: now,
                amount: dataSrc.amount,
                uuid: dataSrc.uuid,
                accessKey,
                invoiceId: invoice.id,
                invoiceUrl: invoice.url,
                invoiceTime: invoice.invoiceTime,
                name: this.cardConfig.name
            };
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount || amountSat);
            // Warn: fee too high
            if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                this.checkFeeHigh(Number(amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
            }
            this.setTotalAmount(wallet.coin, invoiceFeeSat, ctxp.fee);
            this.logGiftCardPurchaseEvent(false, COIN, dataSrc);
        });
    }
    initializeCoinbase(account, email) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const COIN = account.currency.code;
            this.currencyIsoCode = this.currency;
            this.onGoingProcessProvider.set('loadingTxInfo');
            yield this.refreshCardConfigIfNeeded().catch(_ => { });
            const discount = Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["d" /* getVisibleDiscount */])(this.cardConfig);
            const dataSrc = Object.assign({ amount: this.amount, currency: this.currency, discounts: discount ? [discount.code] : [], uuid: this.coinbaseProvider.coinbaseData.user.id, email, buyerSelectedTransactionCurrency: COIN, cardName: this.cardConfig.name }, (this.phone && { phone: this.phone }));
            const data = yield this.createInvoice(dataSrc).catch(err => {
                this.onGoingProcessProvider.clear();
                throw this.showErrorInfoSheet(err.message, err.title, true);
            });
            this.invoiceRates = lowercaseKeys(data.invoice.exchangeRates);
            const parsedAmount = this.txFormatProvider.parseAmount(COIN.toLowerCase(), this.amount, this.currency, { onlyIntegers: this.onlyIntegers, rates: this.invoiceRates });
            this.amountUnitStr = parsedAmount.amountUnitStr;
            const invoice = data.invoice;
            const accessKey = data.accessKey;
            this.totalDiscount = data.totalDiscount || 0;
            const amountSat = invoice.paymentSubtotals[COIN];
            if (!this.isCryptoCurrencySupported(COIN, invoice)) {
                this.onGoingProcessProvider.clear();
                let msg = this.translate.instant('Purchases with this cryptocurrency are not enabled');
                this.showErrorInfoSheet(msg, null, true);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            this.message = this.replaceParametersProvider.replace(this.translate.instant(`{{amountUnitStr}} Gift Card`), { amountUnitStr: this.amountUnitStr });
            this.onGoingProcessProvider.clear();
            // Save in memory
            this.tx = {};
            this.invoiceId = invoice.id;
            const now = __WEBPACK_IMPORTED_MODULE_5_moment__().unix() * 1000;
            this.tx.giftData = {
                currency: dataSrc.currency,
                date: now,
                amount: dataSrc.amount,
                uuid: dataSrc.uuid,
                accessKey,
                invoiceId: invoice.id,
                invoiceUrl: invoice.url,
                invoiceTime: invoice.invoiceTime,
                name: this.cardConfig.name
            };
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(COIN.toLowerCase(), amountSat);
            this.setTotalAmount(COIN.toLowerCase());
            this.logGiftCardPurchaseEvent(false, COIN, dataSrc);
        });
    }
    buyConfirm() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!this.tx) {
                this.showErrorInfoSheet(this.translate.instant('Transaction has not been created'));
                return;
            }
            yield this.giftCardProvider.saveGiftCard(Object.assign({}, this.tx.giftData, { status: 'UNREDEEMED' }));
            if (this.wallet) {
                return this.publishAndSign(this.wallet, this.tx)
                    .then(() => {
                    this.redeemGiftCard(this.tx.giftData);
                    this.logGiftCardPurchaseEvent(true, this.wallet.coin.toUpperCase(), this.tx.giftData);
                })
                    .catch((err) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () { return this.handlePurchaseError(err); }));
            }
            else {
                return this.payWithCoinbaseAccount();
            }
        });
    }
    payWithCoinbaseAccount(code) {
        this.onGoingProcessProvider.set('payingWithCoinbase');
        return this.coinbaseProvider
            .payInvoice(this.tx.giftData.invoiceId, this.coinbaseAccount.currency.code, code)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.redeemGiftCard(this.tx.giftData);
            this.logGiftCardPurchaseEvent(true, this.coinbaseAccount.currency.code, this.tx.giftData);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err == '2fa') {
                const message = this.translate.instant('Enter 2-step verification');
                const opts = {
                    type: 'number',
                    enableBackdropDismiss: false
                };
                this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                    if (res === null) {
                        this.showErrorAndBack(this.translate.instant('Missing 2-step verification'));
                        return;
                    }
                    this.payWithCoinbaseAccount(res);
                });
            }
            else {
                this.showErrorAndBack(err);
            }
        });
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
    }
    handlePurchaseError(err) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            yield this.giftCardProvider.saveCard(this.tx.giftData, {
                remove: true
            });
            yield this.walletProvider.removeTx(this.wallet, this.tx);
            const errorMessage = err && err.message;
            const canceledErrors = ['FINGERPRINT_CANCELLED', 'PASSWORD_CANCELLED'];
            if (canceledErrors.indexOf(errorMessage) !== -1) {
                return;
            }
            if (['NO_PASSWORD', 'WRONG_PASSWORD'].indexOf(errorMessage) === -1) {
                this.resetValues();
            }
            this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), this.translate.instant('Could not send transaction'));
        });
    }
    onWalletSelect(option) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (option.isCoinbaseAccount) {
                this.wallet = null;
                this.coinbaseAccount = option.accountSelected;
                const email = this.coinbaseProvider.coinbaseData.user.email;
                yield this.initializeCoinbase(option.accountSelected, email).catch(() => { });
            }
            else {
                this.wallet = option;
                this.coinbaseAccount = null;
                this.isERCToken = this.currencyProvider.isERCToken(this.wallet.coin);
                const email = yield this.promptEmail();
                yield this.initialize(option, email).catch(() => { });
            }
        });
    }
    refreshCardConfig() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.debug('Refreshing cardConfig...');
            this.tkcoinIdProvider.refreshUserInfo();
            const cardMap = yield this.giftCardProvider.getSupportedCardConfigMap(true);
            const oldCardConfig = this.cardConfig;
            this.cardConfig = cardMap[this.cardConfig.name] || oldCardConfig;
            this.logger.debug('Refreshed cardConfig');
            this.merchantProvider.refreshMerchants();
        });
    }
    refreshCardConfigIfNeeded() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const shouldSync = yield this.giftCardProvider.shouldSyncGiftCardPurchasesWithTKCoinId();
            if (shouldSync) {
                this.refreshCardConfig();
            }
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        let coinbaseData = { user: [], availableAccounts: [] };
        if (this.showCoinbase) {
            const minFiatCurrency = { amount: this.amount, currency: this.currency };
            coinbaseData = {
                user: this.coinbaseProvider.coinbaseData.user,
                availableAccounts: this.coinbaseProvider.getAvailableAccounts(null, minFiatCurrency)
            };
        }
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: this.translate.instant('Buy from'),
            coinbaseData
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(option => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](option))
                this.onWalletSelect(option);
            this.isOpenSelector = false;
        });
    }
    finish(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            card.status === 'SUCCESS'
                ? yield this.showCard(card)
                : yield this.showStatusModalAndPrepCard(card);
        });
    }
    showCard(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_9__gift_cards_card_details_card_details__["a" /* CardDetailsPage */], {
                card,
                showConfetti: card.status === 'SUCCESS',
                showCloseButton: true
            });
            yield modal.present();
            yield this.resetNav(card);
        });
    }
    showStatusModalAndPrepCard(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let finishComment;
            let cssClass;
            if (card.status == 'FAILURE') {
                finishComment = this.translate.instant('Your purchase could not be completed.');
                cssClass = 'danger';
            }
            if (card.status == 'PENDING') {
                finishComment = this.translate.instant('Your purchase is pending.');
                cssClass = 'warning';
            }
            let finishText = '';
            const coin = this.wallet
                ? this.wallet.coin
                : this.coinbaseAccount.currency.code.toLowerCase();
            let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_7__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, cssClass, coin }, { showBackdrop: true, enableBackdropDismiss: false });
            yield modal.present();
            yield this.resetNav(card);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__gift_cards_card_details_card_details__["a" /* CardDetailsPage */], { card }, { animate: false });
        });
    }
    resetNav(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            const numActiveCards = yield this.getNumActiveCards();
            if (numActiveCards > 1) {
                yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__purchased_cards_purchased_cards__["b" /* PurchasedCardsPage */], { cardName: card.name }, { animate: false });
            }
        });
    }
    getNumActiveCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const allGiftCards = yield this.giftCardProvider.getPurchasedCards(this.cardConfig.name);
            const currentGiftCards = allGiftCards.filter(c => !c.archived);
            return currentGiftCards.length;
        });
    }
};
ConfirmCardPurchasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'confirm-card-purchase-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/confirm-card-purchase/confirm-card-purchase.html"*/'<wide-header-page title="{{\'Confirm\' | translate}}" [hasSlideButton]="isCordova">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="cancel()" ion-button>{{\'Cancel\' | translate}}</button>\n  </ion-buttons>\n\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item class="confirm-header">\n        <div class="confirm-header__amount">\n          <div class="gift-card-title">\n            {{cardConfig?.displayName}}<span *ngIf="!displayNameIncludesGiftCard">&nbsp;Gift Card</span>\n          </div>\n          <div class="amount-label">\n            <div class="amount">{{amount | formatCurrency:currency}}</div>\n          </div>\n        </div>\n        <img-loader class="card-list-item__icon" [src]="cardConfig?.icon"></img-loader>\n      </ion-item>\n\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label">{{\'SUMMARY\' | translate}}</div>\n        </ion-label>\n      </ion-item>\n\n      <button ion-item detail-none (click)="showWallets()" [ngClass]="{\'not-clickable\': fromWalletDetails}">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Sending from</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <ion-row align-items-center class="wallet" *ngIf="wallet">\n            <ion-col>\n              <coin-icon [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{wallet.name}}</span>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="coinbaseAccount">\n            <ion-col>\n              <ion-icon item-start>\n                <img src="assets/img/coinbase/coinbase-icon.png" width="32">\n              </ion-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{coinbaseAccount.name}}</span>\n            </ion-col>\n          </ion-row>\n\n          <ion-row align-items-center class="wallet" *ngIf="!wallet && !coinbaseAccount">\n            <div translate>Select a wallet</div>\n            <div class="last-item" item-end>\n              <button ion-button clear color="grey" icon-only>\n                <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n                <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n              </button>\n            </div>\n          </ion-row>\n        </ion-note>\n      </button>\n\n      <div class="line-divider"></div>\n\n      <div *ngIf="totalAmountStr">\n        <ion-item>\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Gift Card</span>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="summary-item-detail">\n              <span *ngIf="onlyIntegers">{{amount | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">{{amount | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div *ngIf="!coinbaseAccount" class="line-divider"></div>\n\n        <ion-item *ngIf="activationFee">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Activation Fee</span>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="summary-item-detail">\n              <span *ngIf="onlyIntegers">{{activationFee | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">{{activationFee | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div *ngIf="activationFee" class="line-divider"></div>\n\n        <ion-item *ngIf="totalDiscount">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Discount</span>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="summary-item-detail">\n              <span *ngIf="onlyIntegers">-{{totalDiscount | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">-{{totalDiscount | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div *ngIf="totalDiscount" class="line-divider"></div>\n\n        <ion-item *ngIf="invoiceFee && !coinbaseAccount">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Network cost</span>\n              <ion-icon class="item-img info" (click)="openExternalLink(\'networkCost\')">\n                <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n              </ion-icon>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="summary-item-detail">\n              <span *ngIf="onlyIntegers">{{invoiceFee | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">{{invoiceFee | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div *ngIf="invoiceFee && !coinbaseAccount" class="line-divider"></div>\n\n        <ion-item *ngIf="!coinbaseAccount">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Miner fee</span>\n              <ion-icon class="item-img info" (click)="openExternalLink(\'minerFee\')">\n                <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n              </ion-icon>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="summary-item-detail">\n              <span *ngIf="onlyIntegers">{{networkFee | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">{{networkFee | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div class="summary-line"></div>\n\n        <ion-item>\n          <ion-label>\n            <div class="main-label total-label">TOTAL</div>\n          </ion-label>\n          <ion-note item-end>\n            <div class="total-amount">\n              <span *ngIf="totalAmountStr && !isERCToken; else fiatAmount">{{totalAmountStr}}</span>\n            </div>\n          </ion-note>\n        </ion-item>\n\n        <div class="amount-details">\n          <div class="secondary-note">\n            <div *ngIf="isERCToken; else fiatAmount"></div>\n            <ng-template #fiatAmount>\n              <span *ngIf="totalAmount">\n                <span *ngIf="onlyIntegers">{{totalAmount | number : \'1.0-0\'}}</span>\n                <span *ngIf="!onlyIntegers">{{totalAmount | number : \'1.2-2\'}}</span>\n                {{currencyIsoCode}}\n              </span>\n            </ng-template>\n          </div>\n        </div>\n\n      </div>\n      <ion-item>\n        <card-terms *ngIf="cardConfig" [cardName]="cardConfig.name"></card-terms>\n      </ion-item>\n    </ion-list>\n  </div>\n\n  <div footer-content>\n    <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!((wallet || coinbaseAccount) && totalAmountStr)" buttonText="{{\'Slide to confirm\' | translate}}" [isDogecoin]="wallet && wallet.coin == \'doge\'" (slideDone)="buyConfirm()">\n    </page-slide-to-accept>\n    <ion-toolbar *ngIf="!isCordova">\n      <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!((wallet || coinbaseAccount) && totalAmountStr)">{{\'Confirm\n      purchase\' | translate}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/confirm-card-purchase/confirm-card-purchase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers__["d" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["c" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_12__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["G" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["P" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["_8" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["B" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_24__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["_26" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_30__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_32__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_25__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_17__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_31__providers_wallet_connect_wallet_connect__["a" /* WalletConnectProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["_19" /* TKCoinIdProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers__["Y" /* MerchantProvider */]])
], ConfirmCardPurchasePage);

function lowercaseKeys(obj) {
    return Object.keys(obj).reduce((destination, key) => {
        destination[key.toLowerCase()] = obj[key];
        return destination;
    }, {});
}
//# sourceMappingURL=confirm-card-purchase.js.map

/***/ }),

/***/ 392:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseAccountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_incoming_data_incoming_data__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__coinbase_tx_details_coinbase_tx_details__ = __webpack_require__(981);






// providers







// Page


const TIMEOUT_FOR_REFRESHER = 1000;
let CoinbaseAccountPage = class CoinbaseAccountPage {
    constructor(actionSheetProvider, coinbase, logger, popupProvider, navCtrl, navParams, modalCtrl, profileProvider, translate, incomingDataProvider, themeProvider, onGoingProcessProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.coinbase = coinbase;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.modalCtrl = modalCtrl;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.incomingDataProvider = incomingDataProvider;
        this.themeProvider = themeProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.data = {};
        this.debounceUpdateAll = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.updateAll();
        }), 5000, {
            leading: true
        });
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.id = this.navParams.data.id;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CoinbaseAccountPage');
    }
    ionViewWillEnter() {
        this.backgroundColor = this.themeProvider.getThemeInfo().walletDetailsBackgroundStart;
        this.updateAll();
    }
    updateAll() {
        this.zone.run(() => {
            this.nativeCurrency = this.coinbase.coinbaseData['user']['native_currency'];
            this.coinbase.getAccount(this.id, this.data);
            this.coinbase.getTransactions(this.id, this.data);
        });
    }
    doRefresh(refresher) {
        this.debounceUpdateAll();
        setTimeout(() => {
            refresher.complete();
        }, TIMEOUT_FOR_REFRESHER);
    }
    showErrorAndBack(err) {
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider
            .ionicAlert(this.translate.instant('Error'), err)
            .then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
    }
    getNativeBalance() {
        if (!this.data['account'])
            return null;
        return this.coinbase.getNativeCurrencyBalance(this.data['account'].balance.amount, this.data['account'].balance.currency);
    }
    openTx(tx) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_14__coinbase_tx_details_coinbase_tx_details__["a" /* CoinbaseTxDetailsPage */], { tx });
        modal.present();
    }
    deposit() {
        const account_name = this.data['account'].name;
        const coin = this.data['account'].currency.code.toLowerCase();
        const wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: 'livenet',
            hasFunds: true,
            coin
        });
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](wallets)) {
            this.showError(this.translate.instant('No wallet available to deposit'));
            return;
        }
        const params = {
            wallets,
            selectedWalletId: null,
            title: this.translate.instant('Transfer from')
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(fromWallet => {
            if (!fromWallet)
                return;
            this.onGoingProcessProvider.set('generatingNewAddress');
            this.coinbase
                .getAddress(this.id, this.translate.instant('Transfer from TKCoin') +
                ': ' +
                fromWallet.name)
                .then(data => {
                let toAddress = data.address;
                let destinationTag;
                if (coin == 'xrp' || coin == 'bch') {
                    toAddress = this.incomingDataProvider.extractAddress(data.deposit_uri);
                    const tagParam = /[\?\&]dt=(\d+([\,\.]\d+)?)/i;
                    if (tagParam.exec(data.deposit_uri)) {
                        destinationTag = tagParam.exec(data.deposit_uri)[1];
                    }
                }
                this.onGoingProcessProvider.clear();
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__send_amount_amount__["a" /* AmountPage */], {
                    alternativeCurrency: this.nativeCurrency,
                    coin,
                    walletId: fromWallet.id,
                    fromWalletDetails: true,
                    toAddress,
                    destinationTag,
                    description: this.translate.instant('Deposit to') + ': ' + account_name,
                    recipientType: 'coinbase',
                    fromCoinbase: { accountId: this.id, accountName: account_name }
                });
            });
        });
    }
    withdraw() {
        const coin = this.data['account'].currency.code.toLowerCase();
        const wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            backedUp: true,
            network: 'livenet',
            coin
        });
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](wallets)) {
            this.showError(this.translate.instant('No wallet available to withdraw'));
            return;
        }
        const params = {
            wallets,
            selectedWalletId: null,
            title: this.translate.instant('Transfer to')
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(toWallet => {
            if (!toWallet)
                return;
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__send_amount_amount__["a" /* AmountPage */], {
                id: this.id,
                toWalletId: toWallet.id,
                alternativeCurrency: this.nativeCurrency,
                coin,
                nextPage: 'CoinbaseWithdrawPage',
                description: this.translate.instant('Transfer to TKCoin') + ': ' + toWallet.name
            });
        });
    }
};
CoinbaseAccountPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-account',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-account/coinbase-account.html"*/'<ion-header no-border class="wallet-details-header">\n  <ion-navbar>\n    <ion-title>\n      <div class="header-wallet-name" [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{data?.account?.name}}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea [fixed-scroll-bg-color]="backgroundColor">\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160" [ngStyle]="{\'background\': backgroundColor}">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea" #expandableHeader>\n      <expandable-header-primary class="balance-header">\n        <div class="wallet-name">\n          <ion-icon class="logo" item-start>\n            <img src="assets/img/coinbase/coinbase-icon.png" width="35">\n          </ion-icon>\n          {{data?.account?.name}}\n        </div>\n\n        <div class="balance-content">\n          <div class="balance-str">\n            {{data?.account?.balance.amount | number:\'1.2-8\' }}\n            <span class="balance-coin">\n              {{data?.account?.balance.currency}}\n            </span>\n          </div>\n          <div class="balance-alt-str" *ngIf="getNativeBalance()">\n            {{ getNativeBalance() | currency:\' \':\' \' }} {{ nativeCurrency }}\n          </div>\n        </div>\n      </expandable-header-primary>\n      <expandable-header-footer>\n        <div class="wallet-info">\n          <div class="left-buttons" *ngIf="data?.account?.primary">\n            <span class="square-border">\n              <span translate>PRIMARY</span>\n            </span>\n          </div>\n          <ion-spinner name="crescent" *ngIf="!data || !data?.txs"></ion-spinner>\n        </div>\n        <div class="action-buttons">\n          <button class="button-standard disable-hover" (click)="deposit()" [disabled]="!data?.account?.allow_deposits" ion-button>\n            Deposit\n          </button>\n          <button class="button-standard disable-hover" (click)="withdraw()" [disabled]="!data?.account?.allow_withdrawals || data?.account?.balance.amount <= 0" ion-button>\n            Withdraw\n          </button>\n        </div>\n      </expandable-header-footer>\n    </expandable-header>\n\n    <div class="history-wrapper">\n\n      <!-- Transactions -->\n\n      <div class="prompt-user activity-fix white-card" *ngIf="data && data.txs && data.txs.length == 0">\n        <div class="title-icon larger-icon">\n          <img src="assets/img/ghost-tongue-out.svg">\n        </div>\n        <div class="title-info">\n          <span translate>It\'s a ghost town in here</span>\n        </div>\n        <div class="subtitle-info">\n          <span translate>\n            If you have funds stored on a website then you should move them into a secure wallet... like this one!\n          </span>\n        </div>\n      </div>\n\n      <ion-list *ngIf="data && data.txs && data.txs.length > 0" class="tx-history">\n\n        <ion-item-divider sticky class="tx-history-header">\n          <span translate>Transactions</span>\n        </ion-item-divider>\n\n        <div class="item-wrapper" *ngFor="let tx of data.txs">\n          <button ion-item (click)="openTx(tx)">\n            <div class="tx-date" item-start>\n              <div class="tx-month">\n                {{ tx.created_at | date : \'MMM\' }}\n              </div>\n              <div class="tx-day">\n                {{ tx.created_at | date : \'dd\' }}\n              </div>\n            </div>\n\n            <div class="tx-description" *ngIf="tx.details">\n              {{ tx.details.title }}\n              <span class="tx-subtitle" *ngIf="tx.status != \'pending\'">{{ tx.details.subtitle }}</span>\n              <span class="tx-subtitle" *ngIf="tx.status == \'pending\'" translate>Pending</span>\n            </div>\n\n            <ion-note item-end text-end>\n              <div class="tx-amount">\n                {{ tx.amount.amount | number:\'1.2-8\' }} {{ tx.amount.currency }}\n              </div>\n              <div class="tx-alternative-amount">\n                <span>{{ tx.native_amount.amount }} {{ tx.native_amount.currency }}</span>\n              </div>\n            </ion-note>\n          </button>\n        </div>\n      </ion-list>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-account/coinbase-account.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_theme_theme__["a" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], CoinbaseAccountPage);

//# sourceMappingURL=coinbase-account.js.map

/***/ }),

/***/ 393:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/animations/esm5/animations.js
var animations = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@ionic-native/social-sharing/index.js
var social_sharing = __webpack_require__(147);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/rxjs/Rx.js
var Rx = __webpack_require__(90);
var Rx_default = /*#__PURE__*/__webpack_require__.n(Rx);

// EXTERNAL MODULE: ./node_modules/rxjs/operators.js
var operators = __webpack_require__(133);
var operators_default = /*#__PURE__*/__webpack_require__.n(operators);

// EXTERNAL MODULE: ./src/providers/action-sheet/action-sheet.ts
var action_sheet = __webpack_require__(30);

// EXTERNAL MODULE: ./src/providers/confetti/confetti.ts
var confetti = __webpack_require__(946);

// EXTERNAL MODULE: ./src/providers/external-link/external-link.ts
var external_link = __webpack_require__(21);

// EXTERNAL MODULE: ./src/providers/gift-card/gift-card.ts + 1 modules
var gift_card = __webpack_require__(89);

// CONCATENATED MODULE: ./src/providers/gift-card/gift-card.types.ts
var ClaimCodeType;
(function (ClaimCodeType) {
    ClaimCodeType["barcode"] = "barcode";
    ClaimCodeType["code"] = "code";
    ClaimCodeType["link"] = "link";
})(ClaimCodeType || (ClaimCodeType = {}));
//# sourceMappingURL=gift-card.types.js.map
// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/card-details/printable-card/printable-card.ts
var printable_card = __webpack_require__(982);

// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/card-details/card-details.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return card_details_CardDetailsPage; });














let card_details_CardDetailsPage = class CardDetailsPage {
    constructor(actionSheetProvider, confettiProvider, externalLinkProvider, giftCardProvider, nav, navParams, events, socialSharing, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.confettiProvider = confettiProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.giftCardProvider = giftCardProvider;
        this.nav = nav;
        this.navParams = navParams;
        this.events = events;
        this.socialSharing = socialSharing;
        this.platformProvider = platformProvider;
        this.ClaimCodeType = ClaimCodeType;
        this.updateGiftCardsSubject = new Rx["Subject"]();
        this.bwsEventHandler = (_, type) => {
            if (type == 'NewBlock') {
                this.updateGiftCard();
            }
        };
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.card = this.navParams.get('card');
            this.barcodeData = this.card.barcodeData || this.card.claimCode;
            this.barcodeFormat = getBarcodeFormat(this.card.barcodeFormat);
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.card.name);
        });
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
        this.navParams.get('showConfetti') && this.showConfetti();
        this.updateGiftCardsSubject
            .pipe(Object(operators["debounceTime"])(1000), Object(operators["switchMap"])(() => this.giftCardProvider.updatePendingGiftCards([this.card])))
            .subscribe(card => (this.card = card));
        this.updateGiftCard();
    }
    showConfetti() {
        this.confettiProvider.confetti(this.confetti.nativeElement);
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
        this.updateGiftCardsSubject.unsubscribe();
    }
    updateGiftCard() {
        this.updateGiftCardsSubject.next();
    }
    doRefresh(refresher) {
        this.updateGiftCard();
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
    copyCode(code) {
        this.actionSheetProvider
            .createInfoSheet('copied-gift-card-claim-code', {
            cardConfig: this.cardConfig,
            claimCode: code
        })
            .present();
    }
    showClaimLinkUI() {
        return (this.cardConfig &&
            this.card &&
            (this.cardConfig.defaultClaimCodeType === 'link' ||
                !this.card.claimCode) &&
            this.card.status === 'SUCCESS');
    }
    showBarcode() {
        return (this.cardConfig &&
            this.cardConfig.defaultClaimCodeType === ClaimCodeType.barcode);
    }
    archive() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.giftCardProvider.archiveCard(this.card);
            this.nav.pop();
        });
    }
    unarchive() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.giftCardProvider.unarchiveCard(this.card);
        });
    }
    logRedeemCardEvent(isManuallyClaimed) {
        if (!isManuallyClaimed) {
            this.giftCardProvider.logEvent('giftcards_redeem', {
                brand: this.cardConfig.name,
                usdAmount: this.card.amount
            });
        }
        else {
            this.giftCardProvider.logEvent('giftcards_mark_used', {
                brand: this.cardConfig.name,
                usdAmount: this.card.amount
            });
        }
    }
    hasPin() {
        const legacyCards = [
            'Amazon.com',
            'Amazon.co.jp',
            'Mercado Livre'
        ];
        const shouldHidePin = this.cardConfig && this.cardConfig.hidePin;
        const pin = this.card && this.card.pin;
        return !shouldHidePin && pin && legacyCards.indexOf(this.card.name) === -1
            ? true
            : false;
    }
    openArchiveSheet() {
        this.showInfoSheet('archive-gift-card', () => this.archive());
    }
    showInfoSheet(sheetName, onDidDismiss = () => { }) {
        const sheet = this.actionSheetProvider.createInfoSheet(sheetName);
        sheet.present();
        sheet.onDidDismiss(confirm => {
            if (confirm) {
                const isManuallyClaimed = true;
                this.logRedeemCardEvent(isManuallyClaimed);
                onDidDismiss(confirm);
            }
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    redeem() {
        const redeemUrl = `${this.cardConfig.redeemUrl}${this.card.claimCode}`;
        this.cardConfig.redeemUrl
            ? this.redeemWithUrl(redeemUrl)
            : this.claimManually();
    }
    claimManually() {
        this.cardConfig.printRequired
            ? this.print()
            : this.copyCode(this.card.claimCode);
    }
    redeemWithUrl(redeemUrl) {
        const isManuallyClaimed = false;
        this.logRedeemCardEvent(isManuallyClaimed);
        this.externalLinkProvider.open(redeemUrl);
    }
    print() {
        this.platformProvider.isCordova ? this.printCordova() : window.print();
    }
    printCordova() {
        const image = this.printableCard.getPrintableImage();
        this.platformProvider.isAndroid
            ? this.openExternalLink(this.card.claimLink)
            : this.socialSharing.share(null, 'gift-card', image);
    }
    viewRedemptionCode() {
        this.externalLinkProvider.open(this.card.claimLink);
    }
    showInvoice() {
        this.externalLinkProvider.open(this.card.invoiceUrl);
    }
    shareCode() {
        this.socialSharing.share(this.card.claimLink || this.card.claimCode);
    }
    showMoreOptions() {
        const showShare = this.platformProvider.isCordova &&
            (this.card.claimLink || this.card.claimCode);
        const hidePrint = !this.card.claimLink && this.platformProvider.isAndroid;
        const sheet = this.actionSheetProvider.createOptionsSheet('gift-card-options', {
            card: this.card,
            hidePrint,
            showShare
        });
        sheet.present();
        sheet.onDidDismiss(data => {
            switch (data) {
                case 'archive':
                    return this.openArchiveSheet();
                case 'unarchive':
                    return this.unarchive();
                case 'view-invoice':
                    return this.showInvoice();
                case 'share-code':
                    return this.shareCode();
                case 'print-card':
                    return setTimeout(() => this.print(), 200);
            }
        });
    }
    close() {
        this.nav.pop();
    }
};
tslib_es6["__decorate"]([
    Object(core["ViewChild"])(printable_card["a" /* PrintableCardComponent */]),
    tslib_es6["__metadata"]("design:type", printable_card["a" /* PrintableCardComponent */])
], card_details_CardDetailsPage.prototype, "printableCard", void 0);
tslib_es6["__decorate"]([
    Object(core["ViewChild"])('confetti'),
    tslib_es6["__metadata"]("design:type", core["ElementRef"])
], card_details_CardDetailsPage.prototype, "confetti", void 0);
card_details_CardDetailsPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'card-details-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-details/card-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-buttons left>\n      <button\n        *ngIf="navParams.get(\'showCloseButton\')"\n        class="close-container disable-hover"\n        (click)="close()"\n        ion-button\n      >\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{cardConfig?.displayName}}</ion-title>\n    <ion-buttons right>\n      <button\n        class="option-button"\n        clear\n        (click)="showMoreOptions()"\n        ion-button\n        icon-only\n      >\n        <ion-icon name="ios-more" md="ios-more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce class="gift-card-content">\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <div class="header-extension"></div>\n    <div class="main-content">\n      <div class="balance" (click)="showConfetti()">\n        {{card.amount | formatCurrency:card.currency}}\n      </div>\n      <img-loader\n        class="card-image"\n        src="{{cardConfig?.cardImage}}"\n      ></img-loader>\n      <div #confetti class="confetti-root"></div>\n      <div\n        class="card-info"\n        [ngClass]="{\'has-pin\': hasPin()}"\n        *ngIf="!showClaimLinkUI()"\n      >\n        <div *ngIf="card.claimCode">\n          <div *ngIf="card.status !== \'Canceled\'">\n            <div\n              (click)="copyCode(card.claimCode)"\n              [copy-to-clipboard]="card.claimCode"\n              [hide-toast]="true"\n              tappable\n            >\n              <div class="card-info__title" translate>Claim Code</div>\n              <div class="card-info__body" *ngIf="!showBarcode()">\n                {{card.claimCode}}\n              </div>\n              <ng-container *ngIf="showBarcode()">\n                <ngx-barcode\n                  *ngIf="!card.barcodeImage && barcodeFormat !== \'QR\'"\n                  class="card-info__body"\n                  [bc-value]="barcodeData"\n                  [bc-format]="barcodeFormat"\n                  bc-display-value="false"\n                  bc-element-type="canvas"\n                  bc-height="70"\n                  [bc-width]="1.8"\n                  bc-background="#f7f7f7"\n                  bc-font="Roboto"\n                  bc-text-margin="8"\n                  bc-text-position="bottom"\n                  bc-font-size="20"\n                ></ngx-barcode>\n                <ngx-qrcode\n                  *ngIf="!card.barcodeImage && barcodeFormat === \'QR\'"\n                  hide-toast="true"\n                  [qrc-value]="barcodeData"\n                  qrc-class="aclass"\n                  qrc-errorCorrectionLevel="M"\n                ></ngx-qrcode>\n                <img\n                  *ngIf="card.barcodeImage"\n                  [src]="card.barcodeImage"\n                  class="card-info__body barcode-image"\n                />\n              </ng-container>\n              <div\n                class="card-info__body"\n                [ngClass]="{long: card.claimCode.length > 20 }"\n                *ngIf="showBarcode()"\n              >\n                {{card.claimCode}}\n              </div>\n              <div class="card-info__date" *ngIf="!hasPin()">\n                {{ \'Created {cardDate}\' | translate: { cardDate: card.date |\n                amTimeAgo } }}\n              </div>\n            </div>\n            <div *ngIf="hasPin()">\n              <div class="separator"></div>\n              <div\n                (click)="copyCode(card.pin)"\n                [copy-to-clipboard]="card.pin"\n                [hide-toast]="true"\n                tappable\n              >\n                <div class="card-info__title">Pin</div>\n                <div class="card-info__body pin">{{card.pin}}</div>\n              </div>\n            </div>\n          </div>\n          <div\n            *ngIf="card.status == \'Canceled\'"\n            class="card-info__body"\n            translate\n          >\n            Gift card canceled\n          </div>\n        </div>\n\n        <div *ngIf="!card.claimCode" class="card-info__status-message">\n          <div\n            *ngIf="card.status === \'PENDING\' || card.status === \'invalid\' || card.status === \'expired\'"\n            class="card-info__body"\n            translate\n          >\n            Awaiting payment to confirm\n          </div>\n          <div\n            *ngIf="card.status == \'FAILURE\' || card.status == \'RESEND\'"\n            class="card-info__body"\n            style="font-weight: 400"\n            translate\n          >\n            <div>Claim code not yet available. Please check back later.</div>\n            <div style="margin-top: 20px">\n              If this issue persists for more than 2 hours, please contact\n              TKCoin Support.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div\n        class="card-info__date card-info__date--outside-card-info"\n        *ngIf="hasPin() || showClaimLinkUI()"\n      >\n        Created {{card.date | amTimeAgo}}\n      </div>\n\n      <div class="actions-wrapper" [@preventInitialChildAnimations]>\n        <div\n          class="actions"\n          *ngIf="card.status !== \'PENDING\' && !card.archived && (card.claimCode || card.claimLink)"\n          [@enterAnimation]\n        >\n          <button\n            ion-button\n            *ngIf="!showClaimLinkUI() && cardConfig?.redeemUrl"\n            class="button-standard"\n            (click)="redeem()"\n          >\n            {{\'Redeem Now\' | translate}}\n          </button>\n          <button\n            ion-button\n            *ngIf="!showClaimLinkUI() && !cardConfig?.redeemUrl && cardConfig"\n            class="button-standard"\n            (click)="redeem()"\n            [copy-to-clipboard]="card.claimCode"\n            [hide-toast]="true"\n          >\n            <ng-container *ngIf="!cardConfig.printRequired"\n              >{{\'Copy Code\' | translate}}</ng-container\n            >\n            <ng-container *ngIf="cardConfig.printRequired"\n              >{{\'Print\' | translate}}</ng-container\n            >\n          </button>\n          <button\n            ion-button\n            *ngIf="showClaimLinkUI()"\n            class="button-standard"\n            (click)="viewRedemptionCode()"\n          >\n            {{ cardConfig.redeemButtonText || \'View Redemption Code\' |\n            translate}}\n          </button>\n          <button\n            ion-button\n            class="button-standard button-secondary"\n            (click)="openArchiveSheet()"\n          >\n            {{"I\'ve used this card" | translate}}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <card-terms [cardName]="card.name"></card-terms>\n  </div>\n</ion-content>\n\n<printable-card\n  *ngIf="cardConfig"\n  [card]="card"\n  [cardConfig]="cardConfig"\n></printable-card>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/card-details/card-details.html"*/,
        animations: [
            Object(animations["l" /* trigger */])('enterAnimation', [
                Object(animations["k" /* transition */])(':enter', [
                    Object(animations["j" /* style */])({ opacity: 0 }),
                    Object(animations["e" /* animate */])('400ms 250ms ease', Object(animations["j" /* style */])({ opacity: 1 }))
                ]),
                Object(animations["k" /* transition */])(':leave', [
                    Object(animations["j" /* style */])({ opacity: 1 }),
                    Object(animations["e" /* animate */])('400ms 250ms ease', Object(animations["j" /* style */])({ opacity: 0 }))
                ])
            ]),
            Object(animations["l" /* trigger */])('preventInitialChildAnimations', [
                Object(animations["k" /* transition */])(':enter', [Object(animations["g" /* query */])(':enter', [], { optional: true })])
            ])
        ]
    }),
    tslib_es6["__metadata"]("design:paramtypes", [action_sheet["a" /* ActionSheetProvider */],
        confetti["a" /* ConfettiProvider */],
        external_link["a" /* ExternalLinkProvider */],
        gift_card["a" /* GiftCardProvider */],
        ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        ionic_angular["f" /* Events */],
        social_sharing["a" /* SocialSharing */],
        platform["a" /* PlatformProvider */]])
], card_details_CardDetailsPage);

function getBarcodeFormat(barcodeFormat = '') {
    const lowercaseFormats = ['pharmacode', 'codabar'];
    const supportedFormats = [
        'CODE128',
        'CODE128A',
        'CODE128B',
        'CODE128C',
        'EAN',
        'UPC',
        'EAN8',
        'EAN5',
        'EAN2',
        'CODE39',
        'ITF14',
        'MSI',
        'MSI10',
        'MSI11',
        'MSI1010',
        'MSI1110',
        'QR',
        ...lowercaseFormats
    ];
    const normalizedFormat = lowercaseFormats.includes(barcodeFormat.toLowerCase())
        ? barcodeFormat.toLowerCase()
        : barcodeFormat.replace(/\s/g, '').toUpperCase();
    return supportedFormats.includes(normalizedFormat)
        ? normalizedFormat
        : 'CODE128';
}
//# sourceMappingURL=card-details.js.map

/***/ }),

/***/ 394:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./src/providers/index.ts + 2 modules
var providers = __webpack_require__(27);

// EXTERNAL MODULE: ./src/providers/gift-card/gift-card.ts + 1 modules
var gift_card = __webpack_require__(89);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/buy-card/buy-card.ts
var buy_card = __webpack_require__(395);

// EXTERNAL MODULE: ./src/pages/integrations/gift-cards/card-details/card-details.ts + 1 modules
var card_details = __webpack_require__(393);

// EXTERNAL MODULE: ./src/providers/merchant/merchant.ts + 1 modules
var merchant = __webpack_require__(386);

// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/purchased-cards/card-list-item/card-list-item.ts





let card_list_item_CardListItemComponent = class CardListItemComponent {
    constructor(giftCardProvider, themeProvider) {
        this.giftCardProvider = giftCardProvider;
        this.themeProvider = themeProvider;
        this.type = 'catalog';
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.cardConfig =
                this.config ||
                    (this.merchant && this.merchant.giftCards[0]) ||
                    (this.card &&
                        (yield this.giftCardProvider.getCardConfig(this.card.name)));
            this.currency =
                (this.card && this.card.currency) ||
                    (this.cardConfig && this.cardConfig.currency);
            this.displayName = this.merchant
                ? this.merchant.displayName
                : this.cardConfig.displayName;
            this.discount = this.merchant && Object(merchant["b" /* getDiscount */])(this.merchant);
            this.discountTextColor =
                this.merchant &&
                    Object(merchant["c" /* getDiscountTextColor */])(this.merchant, this.themeProvider.getCurrentAppTheme());
            this.icon =
                (this.cardConfig && this.cardConfig.icon) ||
                    (this.merchant && this.merchant.icon);
        });
    }
};
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], card_list_item_CardListItemComponent.prototype, "card", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", String)
], card_list_item_CardListItemComponent.prototype, "type", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], card_list_item_CardListItemComponent.prototype, "config", void 0);
tslib_es6["__decorate"]([
    Object(core["Input"])(),
    tslib_es6["__metadata"]("design:type", Object)
], card_list_item_CardListItemComponent.prototype, "merchant", void 0);
card_list_item_CardListItemComponent = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'card-list-item',
        template: `
    <button ion-item class="card-list-item">
      <ion-icon item-start>
        <img-loader
          *ngIf="!merchant || !merchant.hasDirectIntegration"
          class="card-list-item__icon"
          [ngClass]="{ archived: card?.archived && type === 'purchased' }"
          [src]="icon"
          [fallbackAsPlaceholder]="true"
          [fallbackUrl]="giftCardProvider.fallbackIcon"
        ></img-loader>
        <div
          *ngIf="merchant && merchant.hasDirectIntegration"
          class="card-list-item__icon"
        >
          <img [src]="icon" />
        </div>
      </ion-icon>
      <ion-label>
        <div
          class="card-list-item__label ellipsis"
          *ngIf="type !== 'purchased'"
        >
          {{ displayName }}
        </div>
        <div *ngIf="type === 'purchased'">
          <div class="card-list-item__label">
            {{ card.amount | formatCurrency: card.currency }}
          </div>
          <ion-note class="card-list-item__note">{{
            card.date | amTimeAgo
          }}</ion-note>
        </div>
        <div *ngIf="type === 'catalog' && (cardConfig || merchant)">
          <div *ngIf="discount">
            <ion-note
              class="card-list-item__note discount ellipsis"
              [ngStyle]="{ color: discountTextColor }"
            >
              <gift-card-discount-text
                [cardConfig]="cardConfig"
                [merchant]="merchant"
                [discount]="discount"
              >
              </gift-card-discount-text>
            </ion-note>
          </div>
          <div *ngIf="!discount">
            <ion-note class="card-list-item__note ellipsis" *ngIf="!cardConfig">
              {{ merchant.caption }}
            </ion-note>
            <ion-note
              class="card-list-item__note"
              *ngIf="cardConfig && !cardConfig.supportedAmounts"
            >
              {{ cardConfig.minAmount | formatCurrency: currency:0 }} 
              {{ cardConfig.maxAmount | formatCurrency: currency:0 }}
            </ion-note>
            <ion-note
              class="card-list-item__note ellipsis"
              *ngIf="cardConfig && cardConfig.supportedAmounts"
            >
              <span
                *ngFor="
                  let amount of cardConfig.supportedAmounts;
                  let last = last
                "
              >
                {{ amount | formatCurrency: currency:'minimal'
                }}<span *ngIf="!last">,</span>
              </span>
            </ion-note>
          </div>
        </div>
      </ion-label>
    </button>
  `
    }),
    tslib_es6["__metadata"]("design:paramtypes", [gift_card["a" /* GiftCardProvider */],
        providers["_22" /* ThemeProvider */]])
], card_list_item_CardListItemComponent);

//# sourceMappingURL=card-list-item.js.map
// CONCATENATED MODULE: ./src/pages/integrations/gift-cards/purchased-cards/purchased-cards.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return purchased_cards_PurchasedCardsPage; });









let purchased_cards_PurchasedCardsPage = class PurchasedCardsPage {
    constructor(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams) {
        this.actionSheetProvider = actionSheetProvider;
        this.giftCardProvider = giftCardProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
    }
    ngOnInit() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const cardName = this.navParams.get('cardName');
            this.cardConfig = yield this.giftCardProvider.getCardConfig(cardName);
            yield this.getCards();
            this.listenForUpdates();
            this.giftCardProvider.refreshActiveGiftCards();
        });
    }
    ionViewDidLoad() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('Loaded: PurchasedCardsPage');
        });
    }
    listenForUpdates() {
        this.giftCardProvider.cardUpdates$.subscribe(card => this.updateCard(card));
    }
    updateCard(card) {
        this.allGiftCards = this.allGiftCards.map(oldCard => oldCard.invoiceId === card.invoiceId ? card : oldCard);
        this.setGiftCards(this.allGiftCards);
    }
    addCard() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.navCtrl.push(buy_card["a" /* BuyCardPage */], { cardConfig: this.cardConfig });
        });
    }
    archive() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const archiveSheet = this.actionSheetProvider.createInfoSheet('archive-all-gift-cards', { brand: this.cardConfig.displayName });
            archiveSheet.present();
            archiveSheet.onDidDismiss((confirm) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                yield this.navCtrl.pop();
                this.giftCardProvider.archiveAllCards(this.cardConfig.name);
            }));
        });
    }
    getCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.giftCardProvider
                .getPurchasedCards(this.cardConfig.name)
                .then(cards => this.setGiftCards(cards))
                .catch(err => this.logger.error(err));
            this.giftCardProvider.updatePendingGiftCards(this.currentGiftCards);
        });
    }
    setGiftCards(allCards) {
        this.allGiftCards = allCards;
        this.currentGiftCards = allCards.filter(gc => !gc.archived);
        this.archivedGiftCards = allCards.filter(gc => gc.archived);
    }
    goToCardDetails(card) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.navCtrl.push(card_details["a" /* CardDetailsPage */], { card });
            this.currentGiftCards.length === 1 && this.removePageFromHistory();
        });
    }
    removePageFromHistory() {
        const startIndex = this.navCtrl.getActive().index - 1;
        this.navCtrl.remove(startIndex, 1);
    }
};
purchased_cards_PurchasedCardsPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'purchased-cards-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/purchased-cards/purchased-cards.html"*/'<wide-header-page title="{{cardConfig?.displayName}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="archive()" ion-button>\n      {{\'Archive\' | translate}}\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item-divider *ngIf="currentGiftCards && currentGiftCards.length">{{\'Current Cards\' | translate}}\n        <button clear item-right ion-button class="settings-list bp-list__divider-button" (click)="addCard()">\n          <ion-icon ios="md-add" md="md-add"></ion-icon>\n        </button>\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of currentGiftCards" [card]="card" (click)="goToCardDetails(card)" type="purchased"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/purchased-cards/purchased-cards.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [providers["a" /* ActionSheetProvider */],
        gift_card["a" /* GiftCardProvider */],
        logger["a" /* Logger */],
        ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */]])
], purchased_cards_PurchasedCardsPage);

const PURCHASED_CARDS_PAGE_COMPONENTS = [
    purchased_cards_PurchasedCardsPage,
    card_list_item_CardListItemComponent
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PURCHASED_CARDS_PAGE_COMPONENTS;

//# sourceMappingURL=purchased-cards.js.map

/***/ }),

/***/ 395:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__phone_phone__ = __webpack_require__(983);








let BuyCardPage = class BuyCardPage {
    constructor(actionSheetProvider, nav, navParams, zone) {
        this.actionSheetProvider = actionSheetProvider;
        this.nav = nav;
        this.navParams = navParams;
        this.zone = zone;
        this.printAlertShown = false;
        this.hasVisibleDiscount = false;
        this.hasPromotion = false;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.cardConfig = this.navParams.get('cardConfig');
            this.hasVisibleDiscount = Object(__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["f" /* hasVisibleDiscount */])(this.cardConfig);
            this.hasPromotion = Object(__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["e" /* hasPromotion */])(this.cardConfig);
        });
    }
    ionViewWillEnter() {
        if (this.cardConfig.printRequired && !this.printAlertShown) {
            this.printAlertShown = true;
            this.actionSheetProvider
                .createInfoSheet('print-required', {
                displayName: this.cardConfig.displayName
            })
                .present();
        }
    }
    cancel() {
        this.nav.pop();
    }
    enterAmount() {
        this.nav.push(__WEBPACK_IMPORTED_MODULE_5__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'ConfirmCardPurchasePage',
            cardConfig: this.cardConfig,
            cardName: this.cardConfig.name,
            currency: this.cardConfig.currency,
            fixedUnit: true,
            onlyIntegers: this.cardConfig.currency === 'JPY' || this.cardConfig.integersOnly
        });
    }
    onAmountChange(amount) {
        this.zone.run(() => (this.amount = amount));
    }
    onAmountClick() {
        if (this.cardConfig.supportedAmounts) {
            return;
        }
        this.enterAmount();
    }
    continue() {
        const data = {
            amount: this.amount,
            cardConfig: this.cardConfig,
            cardName: this.cardConfig.name,
            currency: this.cardConfig.currency
        };
        const page = this.cardConfig.mobilePaymentsSupported
            ? __WEBPACK_IMPORTED_MODULE_7__phone_phone__["a" /* PhonePage */]
            : __WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */];
        this.nav.push(page, data);
    }
    checkForActivationFee() {
        const activationFee = Object(__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["b" /* getActivationFee */])(this.amount, this.cardConfig);
        return activationFee > 0
            ? this.showActivationFeeSheet(activationFee)
            : this.continue();
    }
    showActivationFeeSheet(fee) {
        const sheet = this.actionSheetProvider.createInfoSheet('activation-fee-included', {
            currency: this.cardConfig.currency,
            displayName: this.cardConfig.displayName,
            fee
        });
        this.zone.run(() => sheet.present());
        sheet.onDidDismiss(ok => ok && this.continue());
    }
    next() {
        this.cardConfig && this.cardConfig.supportedAmounts
            ? this.checkForActivationFee()
            : this.enterAmount();
    }
};
BuyCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'buy-card-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/buy-card/buy-card.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{\'Buy {displayName} Gift Card\' | translate: { displayName: cardConfig?.displayName } }}\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce class="gift-card-content">\n  <div class="wrapper">\n    <div class="amount-box">\n      <div>\n        <img-loader class="card-image" src="{{cardConfig?.cardImage}}">\n        </img-loader>\n      </div>\n      <amount-picker *ngIf="cardConfig" [currency]="cardConfig.currency"\n        [supportedAmounts]="cardConfig.supportedAmounts" (amountChange)="onAmountChange($event)"\n        (click)="onAmountClick()"></amount-picker>\n      <div class="discount-header" *ngIf="hasVisibleDiscount">\n        <img src="assets/img/tags-stack.svg">\n        <div>Save <gift-card-discount-text [cardConfig]="cardConfig" [discount]="cardConfig.discounts[0]"\n            [numberOnly]="true">\n          </gift-card-discount-text> off your purchase</div>\n      </div>\n      <div class="discount-header" *ngIf="!hasVisibleDiscount && hasPromotion">\n        {{cardConfig.promotions[0].shortDescription}}\n      </div>\n    </div>\n    <div class="buy-box">\n      <card-description class="buy-box__description" [cardConfig]="cardConfig"></card-description>\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <button ion-button full class="button-footer" (click)="next()">\n      <ng-container *ngIf="cardConfig?.supportedAmounts">{{\'Continue\' | translate}}</ng-container>\n      <ng-container *ngIf="!cardConfig?.supportedAmounts">{{\'Enter Amount\' | translate}}</ng-container>\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/buy-card/buy-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]])
], BuyCardPage);

//# sourceMappingURL=buy-card.js.map

/***/ }),

/***/ 396:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__add_wallet_add_wallet__ = __webpack_require__(499);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_select_currency_select_currency__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);



// pages



// providers

let AddPage = class AddPage {
    constructor(navCtrl, logger, navParams) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.navParams = navParams;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddPage');
        this.keyId = this.navParams.data.keyId;
        this.isZeroState = this.navParams.data.isZeroState;
    }
    goToAddWalletPage(isShared, isJoin) {
        if (this.navParams.data.isMultipleSeed) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__add_wallet_add_wallet__["a" /* AddWalletPage */], {
                isCreate: true,
                isMultipleSeed: true,
                isShared,
                url: this.navParams.data.url
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_select_currency_select_currency__["a" /* SelectCurrencyPage */], {
                isShared,
                isJoin,
                isZeroState: this.isZeroState && !isShared,
                keyId: this.keyId,
                url: this.navParams.data.url
            });
        }
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
    goBack() {
        this.navCtrl.pop();
    }
};
AddPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-add',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/add.html"*/'<wide-header-page title="{{isZeroState ? (\'Create Key\' | translate) : (\'Add Wallet\'  | translate) }}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button class="list-button" ion-item (click)="goToAddWalletPage()">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/wallet.svg" />\n        </ion-icon>\n        <div class="item-title">{{isZeroState ? (\'New Key\' | translate) : (\'Simple Wallet\' | translate) }}</div>\n        <span class="item-subtitle" translate>Quick and easy setup</span>\n      </button>\n      <!-- TODO FIX HIDE SHARED WALLET OPTIONS\n      <button class="list-button" ion-item (click)="goToAddWalletPage(true)">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/multi-device.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Shared Wallet</div>\n        <span class="item-subtitle" translate>Requires multiple devices (most secure)</span>\n      </button>\n      <button class="list-button" ion-item (click)="goToAddWalletPage(false, true)">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/multi-user.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Join Shared Wallet</div>\n        <span class="item-subtitle" translate>Requires invitation to join</span>\n      </button>\n      -->\n      <button class="list-button" ion-item (click)="goToImportWallet()">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/import.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Import Wallet</div>\n        <span class="item-subtitle" translate>Recover your wallet using your passphrase</span>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/add.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */]])
], AddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 397:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimplexPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__simplex_details_simplex_details__ = __webpack_require__(988);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_simplex_simplex__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__ = __webpack_require__(56);




// Pages

// Proviers





let SimplexPage = class SimplexPage {
    constructor(analyticsProvider, logger, externalLinkProvider, modalCtrl, navParams, simplexProvider, themeProvider) {
        this.analyticsProvider = analyticsProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.simplexProvider = simplexProvider;
        this.themeProvider = themeProvider;
    }
    ionViewDidLoad() {
        this.paymentRequests = [];
        this.logger.info('Loaded: SimplexPage');
    }
    ionViewWillEnter() {
        this.init();
    }
    init() {
        this.loading = true;
        this.simplexProvider
            .getSimplex()
            .then(simplexData => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.navParams.data) &&
                this.navParams.data.paymentId &&
                simplexData[this.navParams.data.paymentId]) {
                simplexData[this.navParams.data.paymentId].status =
                    this.navParams.data.success === 'true' ? 'success' : 'failed';
                this.simplexProvider
                    .saveSimplex(simplexData[this.navParams.data.paymentId], null)
                    .then(() => {
                    if (this.navParams.data.userId) {
                        this.analyticsProvider.logEvent('buy_crypto_payment_success', {
                            exchange: 'simplex',
                            userId: this.navParams.data.userId
                        });
                    }
                })
                    .catch(() => {
                    this.logger.warn('Could not update payment request status');
                });
            }
            const paymentRequests = {};
            Object.assign(paymentRequests, simplexData);
            this.paymentRequests = Object.values(paymentRequests);
            this.loading = false;
        })
            .catch(err => {
            this.loading = false;
            if (err)
                this.logger.error(err);
        });
    }
    openSimplexModal(paymentRequestData) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__simplex_details_simplex_details__["a" /* SimplexDetailsPage */], {
            paymentRequestData
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.init();
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
SimplexPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-simplex',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/simplex/simplex.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img width="110" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/simplex/logo-simplex-color.svg\' : \'assets/img/simplex/logo-simplex-dm.png\'" alt="Simplex" class="simplex-logo">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <div>\n          <expandable-header-primary>\n            <img margin-left width="130" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/simplex/logo-simplex-color.svg\' : \'assets/img/simplex/logo-simplex-dm.png\'" alt="Simplex">\n          </expandable-header-primary>\n        </div>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list" *ngIf="paymentRequests && paymentRequests.length > 0">\n      <ion-item-divider>{{\'Payment Requests\' | translate}}\n        <ion-spinner item-end name="crescent" *ngIf="loading"></ion-spinner>\n      </ion-item-divider>\n      <button ion-item *ngFor="let paymentRequest of paymentRequests | orderBy : [\'-created_on\']" (click)="openSimplexModal(paymentRequest)">\n        <ion-label>\n          <div class="ellipsis">{{paymentRequest.fiat_total_amount }} {{ paymentRequest.fiat_total_amount_currency }}</div>\n          <div class="status">\n            <span class="assertive" *ngIf="paymentRequest.status == \'failed\'" translate>Payment request rejected</span>\n            <span class="balanced" *ngIf="paymentRequest.status == \'success\'" translate>Payment request approved</span>\n            <span class="royal" *ngIf="paymentRequest.status == \'paymentRequestSent\'" translate>Attempted payment request</span>\n          </div>\n        </ion-label>\n        <div item-content text-end>\n          <div class="text-bold">{{ paymentRequest.crypto_amount | number:\'1.0-6\'}} {{ paymentRequest.coin }}</div>\n          <div class="date calm">{{paymentRequest.created_on | amTimeAgo}}</div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <div class="simplex-problems">\n      <span translate>Having problems with Simplex?</span>\n      <br>\n      <a (click)="openExternalLink(\'https://www.simplex.com/support/\')" translate>\n        Contact the Simplex support team.\n      </a>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/simplex/simplex.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_simplex_simplex__["a" /* SimplexProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__["a" /* ThemeProvider */]])
], SimplexPage);

//# sourceMappingURL=simplex.js.map

/***/ }),

/***/ 398:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChangellyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__changelly_details_changelly_details__ = __webpack_require__(991);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_changelly_changelly__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_theme_theme__ = __webpack_require__(56);



// Pages

// Proviers




let ChangellyPage = class ChangellyPage {
    constructor(logger, externalLinkProvider, modalCtrl, changellyProvider, themeProvider) {
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.modalCtrl = modalCtrl;
        this.changellyProvider = changellyProvider;
        this.themeProvider = themeProvider;
    }
    ionViewDidLoad() {
        this.swapTxs = [];
        this.logger.info('Loaded: ChangellyPage');
    }
    ionViewWillEnter() {
        this.init();
    }
    init() {
        this.loading = true;
        this.changellyProvider
            .getChangelly()
            .then(changellyData => {
            const swapTxs = {};
            Object.assign(swapTxs, changellyData);
            this.swapTxs = Object.values(swapTxs);
            this.loading = false;
        })
            .catch(err => {
            this.loading = false;
            if (err)
                this.logger.error(err);
        });
    }
    openChangellyModal(swapTxData) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__changelly_details_changelly_details__["a" /* ChangellyDetailsPage */], {
            swapTxData
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.init();
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
ChangellyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-changelly',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img width="110" src="assets/img/exchange-crypto/changelly-vector-logo{{themeProvider.isDarkModeEnabled() ? \'-dark\' : \'\'}}.svg" alt="Changelly" class="changelly-logo">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <div>\n          <expandable-header-primary>\n            <img margin-left width="130" src="assets/img/exchange-crypto/changelly-vector-logo{{themeProvider.isDarkModeEnabled() ? \'-dark\' : \'\'}}.svg" alt="Changelly">\n          </expandable-header-primary>\n        </div>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list" *ngIf="swapTxs && swapTxs.length > 0">\n      <ion-item-divider>{{\'Transactions\' | translate}}\n        <ion-spinner item-end name="crescent" *ngIf="loading"></ion-spinner>\n      </ion-item-divider>\n      <button ion-item *ngFor="let swapTx of swapTxs | orderBy : [\'-date\']" (click)="openChangellyModal(swapTx)">\n        <ion-label>\n          <div class="ellipsis">{{swapTx.amountFrom  | number:\'1.0-6\' }} {{ swapTx.coinFrom | uppercase }}</div>\n          <div class="status">\n            <span [ngClass]="{balanced: [\'finished\', \'refunded\'].includes(swapTx.status), assertive: [\'failed\', \'expired\'].includes(swapTx.status), energized: [\'waiting\', \'confirming\', \'exchanging\', \'sending\', \'hold\'].includes(swapTx.status)}" *ngIf="swapTx.status" translate>{{ swapTx.status | titlecase }}</span>\n          </div>\n        </ion-label>\n        <div item-content text-end>\n          <div class="text-bold">{{ swapTx.amountTo | number:\'1.0-6\'}} {{ swapTx.coinTo | uppercase }}</div>\n          <div class="date calm">{{ swapTx.date | amTimeAgo }}</div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <div class="changelly-problems">\n      <span translate>Having problems with Changelly?</span>\n      <br>\n      <a (click)="openExternalLink(\'https://support.changelly.com/en/support/home\')" translate>\n        Contact the Changelly support team.\n      </a>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_changelly_changelly__["a" /* ChangellyProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_theme_theme__["a" /* ThemeProvider */]])
], ChangellyPage);

//# sourceMappingURL=changelly.js.map

/***/ }),

/***/ 399:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js
var esm5_forms = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./src/providers/address-book/address-book.ts
var address_book = __webpack_require__(164);

// EXTERNAL MODULE: ./src/providers/address/address.ts
var address = __webpack_require__(97);

// EXTERNAL MODULE: ./src/providers/app/app.ts
var app = __webpack_require__(23);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger_logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/popup/popup.ts
var popup = __webpack_require__(25);

// CONCATENATED MODULE: ./src/validators/address.ts
class AddressValidator {
    constructor(addressProvider) {
        AddressValidator.addressProvider = addressProvider;
    }
    isValid(control) {
        return AddressValidator.addressProvider.isValid(control.value)
            ? null
            : { 'Invalid Address': true };
    }
}
//# sourceMappingURL=address.js.map
// EXTERNAL MODULE: ./src/pages/scan/scan.ts
var scan = __webpack_require__(129);

// CONCATENATED MODULE: ./src/pages/settings/addressbook/add/add.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return add_AddressbookAddPage; });




// providers





// validators


let add_AddressbookAddPage = class AddressbookAddPage {
    constructor(navCtrl, navParams, events, ab, addressProvider, appProvider, formBuilder, logger, popupProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.events = events;
        this.ab = ab;
        this.addressProvider = addressProvider;
        this.appProvider = appProvider;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.updateAddressHandler = data => {
            if (this.destinationTagregex.test(data.value) &&
                this.addressBookAdd.value.address &&
                this.getCoinAndNetwork() &&
                this.getCoinAndNetwork().coin === 'xrp') {
                this.addressBookAdd.controls['tag'].setValue(data.value);
            }
            else {
                this.addressBookAdd.controls['address'].setValue(this.parseAddress(data.value));
            }
        };
        this.destinationTagregex = /^[0-9]{1,}$/;
        this.addressBookAdd = this.formBuilder.group({
            name: [
                '',
                esm5_forms["h" /* Validators */].compose([esm5_forms["h" /* Validators */].minLength(1), esm5_forms["h" /* Validators */].required])
            ],
            email: ['', this.emailOrEmpty],
            address: [
                '',
                esm5_forms["h" /* Validators */].compose([
                    esm5_forms["h" /* Validators */].required,
                    new AddressValidator(this.addressProvider).isValid
                ])
            ],
            tag: ['', esm5_forms["h" /* Validators */].pattern(this.destinationTagregex)]
        });
        if (this.navParams.data.addressbookEntry) {
            this.addressBookAdd.controls['address'].setValue(this.navParams.data.addressbookEntry);
        }
        this.appName = this.appProvider.info.nameCase;
        this.events.subscribe('Local/AddressScan', this.updateAddressHandler);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddressbookAddPage');
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScan', this.updateAddressHandler);
    }
    emailOrEmpty(control) {
        return control.value === '' ? null : esm5_forms["h" /* Validators */].email(control);
    }
    save() {
        this.addressBookAdd.controls['address'].setValue(this.parseAddress(this.addressBookAdd.value.address));
        this.ab
            .add(this.addressBookAdd.value)
            .then(() => {
            this.navCtrl.pop();
        })
            .catch(err => {
            this.popupProvider.ionicAlert('Error', err);
        });
    }
    parseAddress(str) {
        return this.addressProvider.extractAddress(str);
    }
    openScanner() {
        this.navCtrl.push(scan["a" /* ScanPage */], { fromAddressbook: true });
    }
    getCoinAndNetwork() {
        return this.addressProvider.getCoinAndNetwork(this.addressBookAdd.value.address);
    }
};
add_AddressbookAddPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-addressbook-add',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/add/add.html"*/'<wide-header-page title="{{\'New contact\'|translate}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="save()" ion-button [disabled]="addressBookAdd.invalid">\n      <span translate>Add</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n\n    <form [formGroup]="addressBookAdd">\n      <ion-item>\n        <ion-label stacked>{{ \'Name\' | translate }}</ion-label>\n        <ion-input formControlName="name" type="text"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{ \'Email (optional)\' | translate }}</ion-label>\n        <ion-input formControlName="email" type="email"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Address\' | translate }}</ion-label>\n        <ion-input formControlName="address" type="text" [value]="addressBookAdd.value.address" address-validator></ion-input>\n\n        <ion-icon *ngIf="addressBookAdd.controls[\'address\'].status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n        <ion-icon *ngIf="addressBookAdd.value.address && addressBookAdd.controls[\'address\'].status == \'INVALID\'" class="check fail" name="ios-close-circle" item-right></ion-icon>\n\n        <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n      </ion-item>\n\n      <ion-item *ngIf="addressBookAdd.value.address && getCoinAndNetwork() && getCoinAndNetwork().coin === \'xrp\'">\n        <ion-label stacked>{{ \'Destination Tag\' | translate }}</ion-label>\n        <ion-input formControlName="tag" type="number" [value]="addressBookAdd.value.tag"></ion-input>\n\n        <ion-icon *ngIf="addressBookAdd.value.tag && addressBookAdd.controls[\'tag\'].status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n        <ion-icon *ngIf="addressBookAdd.value.tag && addressBookAdd.controls[\'tag\'].status == \'INVALID\'" class="check fail" name="ios-close-circle" item-right></ion-icon>\n\n        <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n      </ion-item>\n      <label-tip type="info" header="no-header" *ngIf="addressBookAdd.value.address && getCoinAndNetwork() && getCoinAndNetwork().coin === \'xrp\'">\n        <div label-tip-body>\n          <span translate>TKCoin cannot validate the destination tag. Before sending XRP please double-check the destination tag with the receiver, if not valid it may result in the permanent loss of the funds.</span>\n        </div>\n      </label-tip>\n\n      <label-tip type="danger" header="no-header" *ngIf="addressBookAdd.value.address && addressBookAdd.controls[\'address\'].status == \'INVALID\'">\n        <div label-tip-body>\n          <span>{{\'This field only accepts addresses supported by {appName} Wallet\' | translate:{appName: appName} }}</span>\n        </div>\n      </label-tip>\n    </form>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/add/add.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [ionic_angular["m" /* NavController */],
        ionic_angular["n" /* NavParams */],
        ionic_angular["f" /* Events */],
        address_book["a" /* AddressBookProvider */],
        address["a" /* AddressProvider */],
        app["a" /* AppProvider */],
        esm5_forms["a" /* FormBuilder */],
        logger_logger["a" /* Logger */],
        popup["a" /* PopupProvider */]])
], add_AddressbookAddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 400:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinCardIntroPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_scan_scan__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tkcoin_account_tkcoin_account__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_tkcoin_card_tkcoin_card__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__tkcoin_card__ = __webpack_require__(505);





// providers
// pages








let TKCoinCardIntroPage = class TKCoinCardIntroPage {
    constructor(translate, actionSheetCtrl, navParams, bitPayAccountProvider, popupProvider, bitPayCardProvider, navCtrl, externalLinkProvider, persistenceProvider, iabCardProvider, scanProvider, themeProvider) {
        this.translate = translate;
        this.actionSheetCtrl = actionSheetCtrl;
        this.navParams = navParams;
        this.bitPayAccountProvider = bitPayAccountProvider;
        this.popupProvider = popupProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.persistenceProvider = persistenceProvider;
        this.iabCardProvider = iabCardProvider;
        this.scanProvider = scanProvider;
        this.themeProvider = themeProvider;
        this.scannerHasPermission = false;
        this.updateCapabilities();
        this.persistenceProvider.getCardExperimentFlag().then(status => {
            this.cardExperimentEnabled = status === 'enabled';
        });
        this.persistenceProvider
            .getNetwork()
            .then(network => (this.network = network));
    }
    ionViewWillEnter() {
        if (this.navParams.data.secret) {
            let pairData = {
                secret: this.navParams.data.secret,
                email: this.navParams.data.email,
                otp: this.navParams.data.otp
            };
            let pairingReason = this.translate.instant('add your TKCoin Visa card(s)');
            this.bitPayAccountProvider.pair(pairData, pairingReason, (err, paired, apiContext) => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error pairing TKCoin Account'), err);
                    return;
                }
                if (paired) {
                    this.bitPayCardProvider.sync(apiContext, (err, cards) => {
                        if (err) {
                            this.popupProvider.ionicAlert(this.translate.instant('Error updating Debit Cards'), err);
                            return;
                        }
                        // Fixes mobile navigation
                        setTimeout(() => {
                            if (cards[0]) {
                                this.navCtrl
                                    .push(__WEBPACK_IMPORTED_MODULE_12__tkcoin_card__["a" /* TKCoinCardPage */], { id: cards[0].id }, { animate: false })
                                    .then(() => {
                                    let previousView = this.navCtrl.getPrevious();
                                    this.navCtrl.removeView(previousView);
                                });
                            }
                        }, 200);
                    });
                }
            });
        }
        this.bitPayAccountProvider.getAccounts((err, accounts) => {
            if (err) {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            }
            this.accounts = accounts;
        });
        if (!this.scannerHasPermission) {
            this.authorizeCamera();
        }
    }
    ionViewDidEnter() {
        this.persistenceProvider
            .getTKCoinIdPairingToken(this.network)
            .then(token => (this.bitPayIdConnected = !!token));
        this.iabCardProvider.updateWalletStatus();
        this.bitPayCardProvider.logEvent('legacycard_view_setup', {});
        this.ready = true;
    }
    updateCapabilities() {
        const capabilities = this.scanProvider.getCapabilities();
        this.scannerHasPermission = capabilities.hasPermission;
    }
    authorizeCamera() {
        this.scanProvider
            .initialize() // prompt for authorization by initializing scanner
            .then(() => this.scanProvider.pausePreview()) // release camera resources from scanner
            .then(() => this.updateCapabilities()); // update component state
    }
    openExchangeRates() {
        // TODO FIX
        let url = 'https://tkcoin.org/exchange-rates';
        this.externalLinkProvider.open(url);
    }
    bitPayCardInfo() {
        // TODO FIX
        let url = 'https://tkcoin.org/visa/faq';
        this.externalLinkProvider.open(url);
    }
    orderTKCoinCard(path) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const root = this.network === 'livenet' ? 'tkcoin.org' : 'test.tkcoin.org';
            let url = `https://${root}/wallet-card?context=${path}`;
            if (this.themeProvider.isDarkModeEnabled()) {
                url += '&darkMode=true';
            }
            if (this.bitPayIdConnected) {
                const user = yield this.persistenceProvider.getTKCoinIdUserInfo(this.network);
                url += `&email=${user.email}`;
            }
            this.iabCardProvider.loadingWrapper(() => {
                this.externalLinkProvider.open(url);
                setTimeout(() => {
                    this.navCtrl.pop();
                }, 300);
            });
        });
    }
    connectTKCoinCard() {
        this.bitPayCardProvider.logEvent('legacycard_connect', {});
        if (this.accounts.length == 0) {
            this.startPairTKCoinAccount();
        }
        else {
            this.showAccountSelector();
        }
    }
    startPairTKCoinAccount() {
        this.navCtrl.popToRoot({ animate: false }); // Back to Root
        let url = 'https://tkcoin.org/visa/dashboard/add-to-tkcoin-wallet-confirm';
        this.externalLinkProvider.open(url);
    }
    showAccountSelector() {
        let options = [];
        __WEBPACK_IMPORTED_MODULE_4_lodash__["forEach"](this.accounts, account => {
            options.push({
                text: (account.givenName || account.familyName) +
                    ' (' +
                    account.email +
                    ')',
                handler: () => {
                    this.onAccountSelect(account);
                }
            });
        });
        // Add account
        options.push({
            text: this.translate.instant('Add account'),
            handler: () => {
                this.onAccountSelect();
            }
        });
        // Cancel
        options.push({
            text: this.translate.instant('Cancel'),
            role: 'cancel'
        });
        let actionSheet = this.actionSheetCtrl.create({
            title: this.translate.instant('From TKCoin account'),
            buttons: options
        });
        actionSheet.present();
    }
    onAccountSelect(account) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isUndefined"](account)) {
            this.startPairTKCoinAccount();
        }
        else {
            this.bitPayCardProvider.sync(account.apiContext, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    return;
                }
                this.navCtrl.pop();
            });
        }
    }
};
TKCoinCardIntroPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tkcoin-card-intro',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-intro/tkcoin-card-intro.html"*/'<ion-header no-border>\n  <ion-navbar>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="tkcoinCard-header" [class.tkcoinCard-header--new]="cardExperimentEnabled">\n    <div class="tkcoinCard-img">\n      <img src="assets/img/tkcoin-card/tkcoin-card-mc-angled.svg" />\n    </div>\n  </div>\n  <div class="tkcoinCard-content">\n    <div>\n      <div class="title">\n        <span translate>Fund it. Spend it.</span>\n        <br>\n        <span translate>Live on crypto.</span>\n      </div>\n      <p translate>The fastest, easiest way to turn your crypto into dollars for shopping. Load funds in the TKCoin App and spend in minutes.</p>\n    </div>\n\n    <div>\n      <div class="tkcoinCard-item">\n        <div class="tkcoinCard-item-header">\n          <img src="assets/img/tkcoin-card/tkcoin-card-intro-1.svg" />\n          <div class="tkcoinCard-item-title" translate>Instant Reloads*</div>\n        </div>\n        <p>\n        <span translate>Reload your balance with no conversion fees* and spend.</span>\n        Powered by our competitive <a (click)="openExchangeRates()">exchange rates</a>\n        </p>\n      </div>\n      <div class="tkcoinCard-item">\n        <div class="tkcoinCard-item-header">\n          <img src="assets/img/tkcoin-card/tkcoin-card-intro-2.svg" />\n          <div class="tkcoinCard-item-title" translate>Flexibility</div>\n        </div>\n        <p translate>Designed for people who want to live life on crypto. View your balance, request a new PIN, and reload instantly all within the TKCoin App.</p>\n      </div>\n      <div class="tkcoinCard-item">\n        <div class="tkcoinCard-item-header">\n          <img src="assets/img/tkcoin-card/tkcoin-card-intro-3.svg" />\n          <div class="tkcoinCard-item-title" translate>Enhanced Security</div>\n        </div>\n        <p translate>Includes EMV chip and options to lock your card and control how you spend.</p>\n      </div>\n      <div class="tkcoinCard-item">\n        <div class="tkcoinCard-item-header">\n          <img src="assets/img/tkcoin-card/tkcoin-card-intro-4.svg" />\n          <div class="tkcoinCard-item-title" translate>Worldwide</div>\n        </div>\n        <p translate>Ready to use in millions of locations around the world. Pay with contactless, PIN or simply withdraw cash from any compatible ATM.</p>\n      </div>\n      <div class="tkcoinCard__agreement">\n        *Network fees and miner fees may apply.<br><br>\n        BY USING THIS CARD YOU AGREE WITH THE TERMS AND CONDITIONS OF THE CARDHOLDER AGREEMENT AND FEE SCHEDULE, IF ANY. This card is issued by Metropolitan Commercial Bank (Member FDIC) pursuant to a license from Mastercard International Incorporated. Metropolitan Commercial Bank and Metropolitan are registered trademarks of Metropolitan Commercial Bank 2014.<br><br>\n        Mastercard is a registered trademark, and the circles design is a trademark of Mastercard International Incorporated.\n      </div>\n\n    </div>\n  </div>\n</ion-content>\n\n  <ion-footer *ngIf="ready">\n    <ion-toolbar>\n\n      <ng-container *ngIf="bitPayIdConnected else notConnected">\n        <button ion-button class="button-standard button-primary" (click)="orderTKCoinCard(\'login\')">\n          {{\'Sign Up\' | translate}}\n        </button>\n      </ng-container>\n\n      <ng-template #notConnected>\n        <button ion-button class="button-standard button-primary" (click)="orderTKCoinCard(\'createAccount\')">\n          {{\'Sign Up\' | translate}}\n        </button>\n        <div class="tkcoinCard__link-button" (click)="orderTKCoinCard(\'login\')">\n          {{\'I already have an account\' | translate}}\n        </div>\n      </ng-template>\n\n    </ion-toolbar>\n  </ion-footer>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-intro/tkcoin-card-intro.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_8__providers_scan_scan__["a" /* ScanProvider */]]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tkcoin_account_tkcoin_account__["a" /* TKCoinAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_tkcoin_card_tkcoin_card__["a" /* TKCoinCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_scan_scan__["a" /* ScanProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__["a" /* ThemeProvider */]])
], TKCoinCardIntroPage);

//# sourceMappingURL=tkcoin-card-intro.js.map

/***/ }),

/***/ 41:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);


// providers


let ErrorsProvider = class ErrorsProvider {
    constructor(actionSheetProvider, logger) {
        this.actionSheetProvider = actionSheetProvider;
        this.logger = logger;
        this.logger.debug('ErrorsProvider initialized');
    }
    showWrongEncryptPasswordError() {
        this.logger.warn('Wrong encrypt password');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('wrong-encrypt-password');
        errorInfoSheet.present();
    }
    showDefaultError(err, infoSheetTitle, dismissFunction) {
        if (!err)
            return;
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(dismissFunction);
    }
    showNoWalletsAvailableInfo(dismissFunction) {
        this.logger.warn('No wallets available');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('no-wallets-available');
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(dismissFunction);
    }
    showNoWalletError(coin, dismissFunction) {
        this.logger.warn('No wallets able to receive funds');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('no-wallets-error', { coin });
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(dismissFunction);
    }
};
ErrorsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], ErrorsProvider);

//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 45:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcErrorProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);



let BwcErrorProvider = class BwcErrorProvider {
    constructor(translate) {
        this.translate = translate;
    }
    msg(err, prefix) {
        if (!err)
            return 'Unknown error';
        const name = err.name
            ? err.name === 'Error'
                ? err.message
                : err.name.replace(/^bwc.Error/g, '')
            : err;
        let body = '';
        prefix = prefix || '';
        switch (name) {
            case 'INPUT_NOT_FOUND':
                body = this.translate.instant("We could not find one or more inputs for your transaction on the blockchain. Make sure you're not trying to use unconfirmed change");
                break;
            case 'UNCONFIRMED_INPUTS_NOT_ACCEPTED':
                body = this.translate.instant('This invoice does not accept unconfirmed inputs.');
                break;
            case 'INVOICE_NOT_AVAILABLE':
                body = this.translate.instant('The invoice is no available');
                break;
            case 'INVOICE_EXPIRED':
                body = this.translate.instant('This invoice is no longer accepting payments');
                break;
            case 'UNABLE_TO_PARSE_PAYMENT':
                body = this.translate.instant('We were unable to parse your payment. Please try again or contact your wallet provider');
                break;
            case 'NO_TRASACTION':
                body = this.translate.instant('Your request did not include a transaction. Please try again or contact your wallet provider');
                break;
            case 'INVALID_TX_FORMAT':
                body = this.translate.instant('Your transaction was an in an invalid format, it must be a hexadecimal string. Contact your wallet provider');
                break;
            case 'UNABLE_TO_PARSE_TX':
                body = this.translate.instant('We were unable to parse the transaction you sent. Please try again or contact your wallet provider');
                break;
            case 'WRONG_ADDRESS':
                body = this.translate.instant('The transaction you sent does not have any output to the address on the invoice');
                break;
            case 'WRONG_AMOUNT':
                body = this.translate.instant('The amount on the transaction does not match the amount requested. This payment will not be accepted');
                break;
            case 'NOT_ENOUGH_FEE':
                body = this.translate.instant('Transaction fee is below the current minimum threshold');
                break;
            case 'BTC_NOT_BCH':
                body = this.translate.instant('This invoice is priced in BTC, not BCH. Please try with a BTC wallet instead');
                break;
            case 'INVALID_BACKUP':
                body = this.translate.instant('Wallet Recovery Phrase is invalid');
                break;
            case 'WALLET_DOES_NOT_EXIST':
                body = this.translate.instant('Wallet not registered at the wallet service. Recreate it from "Create Wallet" using "Advanced Options" to set your recovery phrase');
                break;
            case 'MISSING_PRIVATE_KEY':
                body = this.translate.instant('Missing private keys to sign');
                break;
            case 'ENCRYPTED_PRIVATE_KEY':
                body = this.translate.instant('Private key is encrypted, cannot sign');
                break;
            case 'SERVER_COMPROMISED':
                body = this.translate.instant('Server response could not be verified');
                break;
            case 'COULD_NOT_BUILD_TRANSACTION':
                body = this.translate.instant('Could not build transaction');
                break;
            case 'INSUFFICIENT_FUNDS':
                body = this.translate.instant('Insufficient funds');
                break;
            case 'MAINTENANCE_ERROR':
                body = this.translate.instant('Bitcore Wallet Service is under maintenance. Please check https://status.tkcoin.org/.');
                break;
            case 'CONNECTION_ERROR':
                body = this.translate.instant('Network error');
                break;
            case 'NOT_FOUND':
                body = this.translate.instant('Wallet service not found');
                break;
            case 'ECONNRESET_ERROR':
                body = this.translate.instant('Connection reset by peer');
                break;
            case 'BAD_RESPONSE_CODE':
                body = this.translate.instant('The request could not be understood by the server');
                break;
            case 'WALLET_ALREADY_EXISTS':
                body = this.translate.instant('Wallet already exists');
                break;
            case 'COPAYER_IN_WALLET':
                body = this.translate.instant('Copayer already in this wallet');
                break;
            case 'WALLET_FULL':
                body = this.translate.instant('Wallet is full');
                break;
            case 'WALLET_NOT_FOUND':
                body = this.translate.instant('Wallet not found');
                break;
            case 'INSUFFICIENT_FUNDS_FOR_FEE':
                body = this.translate.instant('Insufficient funds for fee');
                break;
            case 'INSUFFICIENT_ETH_FEE':
                body = this.translate.instant('Your linked ETH wallet does not have enough ETH for fee');
                break;
            case 'LOCKED_FUNDS':
                body = this.translate.instant('Funds are locked by pending spend proposals');
                break;
            case 'LOCKED_ETH_FEE':
                body = this.translate.instant('Your ETH linked wallet funds are locked by pending spend proposals');
                break;
            case 'COPAYER_VOTED':
                body = this.translate.instant('Copayer already voted on this spend proposal');
                break;
            case 'NOT_AUTHORIZED':
                body = this.translate.instant('Not authorized');
                break;
            case 'TX_ALREADY_BROADCASTED':
                body = this.translate.instant('Transaction already broadcasted');
                break;
            case 'TX_CANNOT_CREATE':
                body = this.translate.instant('Locktime in effect. Please wait to create a new spend proposal');
                break;
            case 'TX_CANNOT_REMOVE':
                body = this.translate.instant('Locktime in effect. Please wait to remove this spend proposal');
                break;
            case 'TX_NOT_ACCEPTED':
                body = this.translate.instant('Spend proposal is not accepted');
                break;
            case 'TX_NOT_FOUND':
                body = this.translate.instant('Spend proposal not found');
                break;
            case 'TX_NOT_PENDING':
                body = this.translate.instant('The spend proposal is not pending');
                break;
            case 'UPGRADE_NEEDED':
                body = this.translate.instant('Please upgrade the app to perform this action');
                break;
            case 'BAD_SIGNATURES':
                body = this.translate.instant('Signatures rejected by server');
                break;
            case 'COPAYER_DATA_MISMATCH':
                body = this.translate.instant('Copayer data mismatch');
                break;
            case 'DUST_AMOUNT':
                body = this.translate.instant('Amount below minimum allowed');
                break;
            case 'INCORRECT_ADDRESS_NETWORK':
                body = this.translate.instant('Incorrect network address');
                break;
            case 'COPAYER_REGISTERED':
                body = this.translate.instant('Key already associated with an existing wallet');
                break;
            case 'INVALID_ADDRESS':
                body = this.translate.instant('Invalid address');
                break;
            case 'MAIN_ADDRESS_GAP_REACHED':
                body = this.translate.instant('Empty addresses limit reached. New addresses cannot be generated.');
                break;
            case 'WALLET_LOCKED':
                body = this.translate.instant('Wallet is locked');
                break;
            case 'WALLET_NOT_COMPLETE':
                body = this.translate.instant('Wallet is not complete');
                break;
            case 'WALLET_NEEDS_BACKUP':
                body = this.translate.instant('Wallet needs backup');
                break;
            case 'MISSING_PARAMETER':
                body = this.translate.instant('Missing parameter');
                break;
            case 'NO_PASSWORD':
                body = this.translate.instant('No password');
                break;
            case 'WRONG_PASSWORD':
                body = this.translate.instant('Wrong password');
                break;
            case 'EXCEEDED_DAILY_LIMIT':
                body = this.translate.instant('Exceeded daily limit of $500 per user');
                break;
            case 'ERROR':
                body = err.message || err.error;
                break;
            default:
                body = err.message || name;
                break;
        }
        var msg = prefix + (prefix ? ': ' : '') + body;
        return msg;
    }
};
BwcErrorProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], BwcErrorProvider);

//# sourceMappingURL=bwc-error.js.map

/***/ }),

/***/ 46:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client__ = __webpack_require__(798);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client__);




let BwcProvider = class BwcProvider {
    constructor(logger) {
        this.logger = logger;
        this.parseSecret = __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.parseSecret;
        this.Client = __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a;
        this.logger.debug('BwcProvider initialized');
    }
    getBitcore() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Bitcore;
    }
    getBitcoreEdu() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.BitcoreEdu;
    }
    getBitcoreTik() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.BitcoreTik;
    }
    getBitcoreCash() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.BitcoreCash;
    }
    getBitcoreDoge() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.BitcoreDoge;
    }
    getCore() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Core;
    }
    getErrors() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.errors;
    }
    getSJCL() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.sjcl;
    }
    getUtils() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Utils;
    }
    getKey() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Key;
    }
    getPayProV2() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.PayProV2;
    }
    upgradeCredentialsV1(x) {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.upgradeCredentialsV1(x);
    }
    upgradeMultipleCredentialsV1(x) {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.upgradeMultipleCredentialsV1(x);
    }
    getClient(walletData, opts) {
        opts = opts || {};
        // note opts use `bwsurl` all lowercase;
        let bwc = new __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a({
            baseUrl: opts.bwsurl || 'https://bws.tkcoin.org/bws/api',
            verbose: opts.verbose,
            timeout: 100000,
            transports: ['polling'],
            bp_partner: opts.bp_partner,
            bp_partner_version: opts.bp_partner_version
        });
        if (walletData)
            bwc.fromString(walletData);
        return bwc;
    }
};
BwcProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], BwcProvider);

//# sourceMappingURL=bwc.js.map

/***/ }),

/***/ 460:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);

function Opcode(num) {
  if (!(this instanceof Opcode)) {
    return new Opcode(num);
  }

  var value;

  if (_.isNumber(num)) {
    value = num;
  } else if (_.isString(num)) {
    value = Opcode.map[num];
  } else {
    throw new TypeError('Unrecognized num type: "' + typeof(num) + '" for Opcode');
  }

  JSUtil.defineImmutable(this, {
    num: value
  });

  return this;
}

Opcode.fromBuffer = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return new Opcode(Number('0x' + buf.toString('hex')));
};

Opcode.fromNumber = function(num) {
  $.checkArgument(_.isNumber(num));
  return new Opcode(num);
};

Opcode.fromString = function(str) {
  $.checkArgument(_.isString(str));
  var value = Opcode.map[str];
  if (typeof value === 'undefined') {
    throw new TypeError('Invalid opcodestr');
  }
  return new Opcode(value);
};

Opcode.prototype.toHex = function() {
  return this.num.toString(16);
};

Opcode.prototype.toBuffer = function() {
  return Buffer.from(this.toHex(), 'hex');
};

Opcode.prototype.toNumber = function() {
  return this.num;
};

Opcode.prototype.toString = function() {
  var str = Opcode.reverseMap[this.num];
  if (typeof str === 'undefined') {
    throw new Error('Opcode does not have a string representation');
  }
  return str;
};

Opcode.smallInt = function(n) {
  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');
  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');
  if (n === 0) {
    return Opcode('OP_0');
  }
  return new Opcode(Opcode.map.OP_1 + n - 1);
};

Opcode.map = {
  // push value
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,

  // control
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,

  // stack ops
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,

  // splice ops
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,

  // bit logic
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,

  // numeric
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,

  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,

  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,

  OP_WITHIN: 165,

  // crypto
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,

  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,

  // expansion
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_NOP3: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,

  // template matching params
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};

Opcode.reverseMap = [];

for (var k in Opcode.map) {
  Opcode.reverseMap[Opcode.map[k]] = k;
}

// Easier access to opcodes
_.extend(Opcode, Opcode.map);

/**
 * @returns true if opcode is one of OP_0, OP_1, ..., OP_16
 */
Opcode.isSmallIntOp = function(opcode) {
  if (opcode instanceof Opcode) {
    opcode = opcode.toNumber();
  }
  return ((opcode === Opcode.map.OP_0) ||
    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Script opcode
 */
Opcode.prototype.inspect = function() {
  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';
};

module.exports = Opcode;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 461:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var buffer = __webpack_require__(2);
var compare = Buffer.compare || __webpack_require__(256);

var errors = __webpack_require__(115);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var Hash = __webpack_require__(74);
var Signature = __webpack_require__(103);
var Sighash = __webpack_require__(181);
var SighashWitness = __webpack_require__(354);

var Address = __webpack_require__(140);
var UnspentOutput = __webpack_require__(859);
var Input = __webpack_require__(462);
var PublicKeyHashInput = Input.PublicKeyHash;
var PublicKeyInput = Input.PublicKey;
var MultiSigScriptHashInput = Input.MultiSigScriptHash;
var MultiSigInput = Input.MultiSig;
var Output = __webpack_require__(161);
var Script = __webpack_require__(104);
var PrivateKey = __webpack_require__(266);
var BN = __webpack_require__(73);

/**
 * Represents a transaction, a set of inputs and outputs to change ownership of tokens
 *
 * @param {*} serialized
 * @constructor
 */
function Transaction(serialized, opts) {
  if (!(this instanceof Transaction)) {
    return new Transaction(serialized);
  }
  this.inputs = [];
  this.outputs = [];
  this._inputAmount = undefined;
  this._outputAmount = undefined;

  if (serialized) {
    if (serialized instanceof Transaction) {
      return Transaction.shallowCopy(serialized);
    } else if (JSUtil.isHexa(serialized)) {
      this.fromString(serialized);
    } else if (BufferUtil.isBuffer(serialized)) {
      this.fromBuffer(serialized);
    } else if (_.isObject(serialized)) {
      this.fromObject(serialized, opts);
    } else {
      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');
    }
  } else {
    this._newTransaction();
  }
}
var CURRENT_VERSION = 2;
var DEFAULT_NLOCKTIME = 0;
var MAX_BLOCK_SIZE = 1000000;

// Minimum amount for an output for it not to be considered a dust output
Transaction.DUST_AMOUNT = 546;

// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference
Transaction.FEE_SECURITY_MARGIN = 150;

// max amount of satoshis in circulation
Transaction.MAX_MONEY = 21000000 * 1e8;

// nlocktime limit to be considered block height rather than a timestamp
Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;

// Max value for an unsigned 32 bit value
Transaction.NLOCKTIME_MAX_VALUE = 4294967295;

// Value used for fee estimation (satoshis per kilobyte)
Transaction.FEE_PER_KB = 100000;

// Safe upper bound for change address script size in bytes
Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;
Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;

/* Constructors and Serialization */

/**
 * Create a 'shallow' copy of the transaction, by serializing and deserializing
 * it dropping any additional information that inputs and outputs may have hold
 *
 * @param {Transaction} transaction
 * @return {Transaction}
 */
Transaction.shallowCopy = function(transaction) {
  var copy = new Transaction(transaction.toBuffer());
  return copy;
};

var hashProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');
    return this._hash;
  }
};

var witnessHashProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');
  }
};

Object.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);
Object.defineProperty(Transaction.prototype, 'hash', hashProperty);
Object.defineProperty(Transaction.prototype, 'id', hashProperty);

var ioProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    return this._getInputAmount();
  }
};
Object.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);
ioProperty.get = function() {
  return this._getOutputAmount();
};
Object.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);

/**
 * Retrieve the little endian hash of the transaction (used for serialization)
 * @return {Buffer}
 */
Transaction.prototype._getHash = function() {
  return Hash.sha256sha256(this.toBuffer(true));
};

/**
 * Retrieve the little endian hash of the transaction including witness data
 * @return {Buffer}
 */
Transaction.prototype._getWitnessHash = function() {
  return Hash.sha256sha256(this.toBuffer(false));
};

/**
 * Retrieve a hexa string that can be used with bitcoind's CLI interface
 * (decoderawtransaction, sendrawtransaction)
 *
 * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,
 *   it's expected to contain a set of flags to skip certain tests:
 * * `disableAll`: disable all checks
 * * `disableSmallFees`: disable checking for fees that are too small
 * * `disableLargeFees`: disable checking for fees that are too large
 * * `disableIsFullySigned`: disable checking if all inputs are fully signed
 * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts
 * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts
 * @return {string}
 */
Transaction.prototype.serialize = function(unsafe) {
  if (true === unsafe || unsafe && unsafe.disableAll) {
    return this.uncheckedSerialize();
  } else {
    return this.checkedSerialize(unsafe);
  }
};

Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {
  return this.toBuffer().toString('hex');
};

/**
 * Retrieve a hexa string that can be used with bitcoind's CLI interface
 * (decoderawtransaction, sendrawtransaction)
 *
 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
 * @return {string}
 */
Transaction.prototype.checkedSerialize = function(opts) {
  var serializationError = this.getSerializationError(opts);
  if (serializationError) {
    serializationError.message += ' - For more information please see: ' +
      'https://bitcore.io/api/lib/transaction#serialization-checks';
    throw serializationError;
  }
  return this.uncheckedSerialize();
};

Transaction.prototype.invalidSatoshis = function() {
  var invalid = false;
  for (var i = 0; i < this.outputs.length; i++) {
    if (this.outputs[i].invalidSatoshis()) {
      invalid = true;
    }
  }
  return invalid;
};

/**
 * Retrieve a possible error that could appear when trying to serialize and
 * broadcast this transaction.
 *
 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
 * @return {bitcore.Error}
 */
Transaction.prototype.getSerializationError = function(opts) {
  opts = opts || {};

  if (this.invalidSatoshis()) {
    return new errors.Transaction.InvalidSatoshis();
  }

  var unspent = this._getUnspentValue();
  var unspentError;
  if (unspent < 0) {
    if (!opts.disableMoreOutputThanInput) {
      unspentError = new errors.Transaction.InvalidOutputAmountSum();
    }
  } else {
    unspentError = this._hasFeeError(opts, unspent);
  }

  return unspentError ||
    this._hasDustOutputs(opts) ||
    this._isMissingSignatures(opts);
};

Transaction.prototype._hasFeeError = function(opts, unspent) {

  if (!_.isUndefined(this._fee) && this._fee !== unspent) {
    return new errors.Transaction.FeeError.Different(
      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee
    );
  }

  if (!opts.disableLargeFees) {
    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
    if (unspent > maximumFee) {
      if (this._missingChange()) {
        return new errors.Transaction.ChangeAddressMissing(
          'Fee is too large and no change address was provided'
        );
      }
      return new errors.Transaction.FeeError.TooLarge(
        'expected less than ' + maximumFee + ' but got ' + unspent
      );
    }
  }

  if (!opts.disableSmallFees) {
    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);
    if (unspent < minimumFee) {
      return new errors.Transaction.FeeError.TooSmall(
        'expected more than ' + minimumFee + ' but got ' + unspent
      );
    }
  }
};

Transaction.prototype._missingChange = function() {
  return !this._changeScript;
};

Transaction.prototype._hasDustOutputs = function(opts) {
  if (opts.disableDustOutputs) {
    return;
  }
  var index, output;
  for (index in this.outputs) {
    output = this.outputs[index];
    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {
      return new errors.Transaction.DustOutputs();
    }
  }
};

Transaction.prototype._isMissingSignatures = function(opts) {
  if (opts.disableIsFullySigned) {
    return;
  }
  if (!this.isFullySigned()) {
    return new errors.Transaction.MissingSignatures();
  }
};

Transaction.prototype.inspect = function() {
  return '<Transaction: ' + this.uncheckedSerialize() + '>';
};

Transaction.prototype.toBuffer = function(noWitness) {
  var writer = new BufferWriter();
  return this.toBufferWriter(writer, noWitness).toBuffer();
};

Transaction.prototype.hasWitnesses = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].hasWitnesses()) {
      return true;
    }
  }
  return false;
};

Transaction.prototype.toBufferWriter = function(writer, noWitness) {
  writer.writeInt32LE(this.version);

  var hasWitnesses = this.hasWitnesses();

  if (hasWitnesses && !noWitness) {
    writer.write(Buffer.from('0001', 'hex'));
  }

  writer.writeVarintNum(this.inputs.length);

  _.each(this.inputs, function(input) {
    input.toBufferWriter(writer);
  });

  writer.writeVarintNum(this.outputs.length);
  _.each(this.outputs, function(output) {
    output.toBufferWriter(writer);
  });

  if (hasWitnesses && !noWitness) {
    _.each(this.inputs, function(input) {
      var witnesses = input.getWitnesses();
      writer.writeVarintNum(witnesses.length);
      for (var j = 0; j < witnesses.length; j++) {
        writer.writeVarintNum(witnesses[j].length);
        writer.write(witnesses[j]);
      }
    });
  }

  writer.writeUInt32LE(this.nLockTime);
  return writer;
};

Transaction.prototype.fromBuffer = function(buffer) {
  var reader = new BufferReader(buffer);
  return this.fromBufferReader(reader);
};

Transaction.prototype.fromBufferReader = function(reader) {
  $.checkArgument(!reader.finished(), 'No transaction data received');

  this.version = reader.readInt32LE();
  var sizeTxIns = reader.readVarintNum();

  // check for segwit
  var hasWitnesses = false;
  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {
    reader.pos += 1;
    hasWitnesses = true;
    sizeTxIns = reader.readVarintNum();
  }

  for (var i = 0; i < sizeTxIns; i++) {
    var input = Input.fromBufferReader(reader);
    this.inputs.push(input);
  }

  var sizeTxOuts = reader.readVarintNum();
  for (var j = 0; j < sizeTxOuts; j++) {
    this.outputs.push(Output.fromBufferReader(reader));
  }

  if (hasWitnesses) {
    for (var k = 0; k < sizeTxIns; k++) {
      var itemCount = reader.readVarintNum();
      var witnesses = [];
      for (var l = 0; l < itemCount; l++) {
        var size = reader.readVarintNum();
        var item = reader.read(size);
        witnesses.push(item);
      }
      this.inputs[k].setWitnesses(witnesses);
    }
  }

  this.nLockTime = reader.readUInt32LE();
  return this;
};


Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {
  var inputs = [];
  this.inputs.forEach(function(input) {
    inputs.push(input.toObject());
  });
  var outputs = [];
  this.outputs.forEach(function(output) {
    outputs.push(output.toObject());
  });
  var obj = {
    hash: this.hash,
    version: this.version,
    inputs: inputs,
    outputs: outputs,
    nLockTime: this.nLockTime
  };
  if (this._changeScript) {
    obj.changeScript = this._changeScript.toString();
  }
  if (!_.isUndefined(this._changeIndex)) {
    obj.changeIndex = this._changeIndex;
  }
  if (!_.isUndefined(this._fee)) {
    obj.fee = this._fee;
  }
  return obj;
};

Transaction.prototype.fromObject = function fromObject(arg, opts) {
  /* jshint maxstatements: 20 */
  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);
  var self = this;
  var transaction;
  if (arg instanceof Transaction) {
    transaction = transaction.toObject();
  } else {
    transaction = arg;
  }
  _.each(transaction.inputs, function(input) {
    if (!input.output || !input.output.script) {
      self.uncheckedAddInput(new Input(input));
      return;
    }
    var script = new Script(input.output.script);
    var txin;
    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {
      txin = new Input.MultiSigScriptHash(
        input, input.publicKeys, input.threshold, input.signatures, opts
      );
    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {
      txin = new Input.PublicKeyHash(input);
    } else if (script.isPublicKeyOut()) {
      txin = new Input.PublicKey(input);
    } else {
      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);
    }
    self.addInput(txin);
  });
  _.each(transaction.outputs, function(output) {
    self.addOutput(new Output(output));
  });
  if (transaction.changeIndex) {
    this._changeIndex = transaction.changeIndex;
  }
  if (transaction.changeScript) {
    this._changeScript = new Script(transaction.changeScript);
  }
  if (transaction.fee) {
    this._fee = transaction.fee;
  }
  this.nLockTime = transaction.nLockTime;
  this.version = transaction.version;
  this._checkConsistency(arg);
  return this;
};

Transaction.prototype._checkConsistency = function(arg) {
  if (!_.isUndefined(this._changeIndex)) {
    $.checkState(this._changeScript, 'Change script is expected.');
    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');
    $.checkState(this.outputs[this._changeIndex].script.toString() ===
      this._changeScript.toString(), 'Change output has an unexpected script.');
  }
  if (arg && arg.hash) {
    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');
  }
};

/**
 * Sets nLockTime so that transaction is not valid until the desired date(a
 * timestamp in seconds since UNIX epoch is also accepted)
 *
 * @param {Date | Number} time
 * @return {Transaction} this
 */
Transaction.prototype.lockUntilDate = function(time) {
  $.checkArgument(time);
  if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    throw new errors.Transaction.LockTimeTooEarly();
  }
  if (_.isDate(time)) {
    time = time.getTime() / 1000;
  }

  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){
      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
    }
  }

  this.nLockTime = time;
  return this;
};

/**
 * Sets nLockTime so that transaction is not valid until the desired block
 * height.
 *
 * @param {Number} height
 * @return {Transaction} this
 */
Transaction.prototype.lockUntilBlockHeight = function(height) {
  $.checkArgument(_.isNumber(height));
  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    throw new errors.Transaction.BlockHeightTooHigh();
  }
  if (height < 0) {
    throw new errors.Transaction.NLockTimeOutOfRange();
  }

  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){
      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
    }
  }


  this.nLockTime = height;
  return this;
};

/**
 *  Returns a semantic version of the transaction's nLockTime.
 *  @return {Number|Date}
 *  If nLockTime is 0, it returns null,
 *  if it is < 500000000, it returns a block height (number)
 *  else it returns a Date object.
 */
Transaction.prototype.getLockTime = function() {
  if (!this.nLockTime) {
    return null;
  }
  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    return this.nLockTime;
  }
  return new Date(1000 * this.nLockTime);
};

Transaction.prototype.fromString = function(string) {
  this.fromBuffer(buffer.Buffer.from(string, 'hex'));
};

Transaction.prototype._newTransaction = function() {
  this.version = CURRENT_VERSION;
  this.nLockTime = DEFAULT_NLOCKTIME;
};

/* Transaction creation interface */

/**
 * @typedef {Object} Transaction~fromObject
 * @property {string} prevTxId
 * @property {number} outputIndex
 * @property {(Buffer|string|Script)} script
 * @property {number} satoshis
 */

/**
 * Add an input to this transaction. This is a high level interface
 * to add an input, for more control, use @{link Transaction#addInput}.
 *
 * Can receive, as output information, the output of bitcoind's `listunspent` command,
 * and a slightly fancier format recognized by bitcore:
 *
 * ```
 * {
 *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',
 *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',
 *  outputIndex: 0,
 *  script: Script.empty(),
 *  satoshis: 1020000
 * }
 * ```
 * Where `address` can be either a string or a bitcore Address object. The
 * same is true for `script`, which can be a string or a bitcore Script.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @example
 * ```javascript
 * var transaction = new Transaction();
 *
 * // From a pay to public key hash output from bitcoind's listunspent
 * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});
 *
 * // From a pay to public key hash output
 * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});
 *
 * // From a multisig P2SH output
 * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},
 *                  ['03000...', '02000...'], 2);
 * ```
 *
 * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo
 * @param {Array=} pubkeys
 * @param {number=} threshold
 * @param {Object=} opts - Several options:
 *        - noSorting: defaults to false, if true and is multisig, don't
 *                      sort the given public keys before creating the script
 */
Transaction.prototype.from = function(utxo, pubkeys, threshold, opts) {
  if (_.isArray(utxo)) {
    var self = this;
    _.each(utxo, function(utxo) {
      self.from(utxo, pubkeys, threshold, opts);
    });
    return this;
  }
  var exists = _.some(this.inputs, function(input) {
    // TODO: Maybe prevTxId should be a string? Or defined as read only property?
    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;
  });
  if (exists) {
    return this;
  }
  if (pubkeys && threshold) {
    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);
  } else {
    this._fromNonP2SH(utxo);
  }
  return this;
};

/**
 * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.
 * Populating these inputs allows for them to be signed with .sign(privKeys)
 *
 * @param {Array<Object>} utxos
 * @param {Array<string | PublicKey>} pubkeys
 * @param {number} threshold
 * @param {Object} opts
 * @returns {Array<number>}
 */
Transaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts) {
  let indexes = [];
  for(let utxo of utxos) {
    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);
    indexes.push(index);
    if(index >= 0) {
      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);
    }
  }
  return indexes;
}


Transaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {
  var clazz;
  utxo = new UnspentOutput(utxo);
  if(pubkeys && threshold) {
    if (utxo.script.isMultisigOut()) {
      clazz = MultiSigInput;
    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {
      clazz = MultiSigScriptHashInput;
    }
  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {
    clazz = PublicKeyHashInput;
  } else if (utxo.script.isPublicKeyOut()) {
    clazz = PublicKeyInput;
  } else {
    clazz = Input;
  }
  return clazz;
}


Transaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts) {
  utxo = new UnspentOutput(utxo);
  const InputClass = this._selectInputType(utxo, pubkeys, threshold);
  const input = {
    output: new Output({
      script: utxo.script,
      satoshis: utxo.satoshis
    }),
    prevTxId: utxo.txId,
    outputIndex: utxo.outputIndex,
    sequenceNumber: utxo.sequenceNumber,
    script: Script.empty()
  };
  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []
  return new InputClass(input, ...args);
}

Transaction.prototype._fromNonP2SH = function(utxo) {
  const input = this._getInputFrom(utxo);
  this.addInput(input);
};

Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {
  $.checkArgument(threshold <= pubkeys.length,
    'Number of required signatures must be greater than the number of public keys');
  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);
  this.addInput(input);
};

/**
 * Add an input to this transaction. The input must be an instance of the `Input` class.
 * It should have information about the Output that it's spending, but if it's not already
 * set, two additional parameters, `outputScript` and `satoshis` can be provided.
 *
 * @param {Input} input
 * @param {String|Script} outputScript
 * @param {number} satoshis
 * @return Transaction this, for chaining
 */
Transaction.prototype.addInput = function(input, outputScript, satoshis) {
  $.checkArgumentType(input, Input, 'input');
  if (!input.output && (_.isUndefined(outputScript) || _.isUndefined(satoshis))) {
    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');
  }
  if (!input.output && outputScript && !_.isUndefined(satoshis)) {
    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
    $.checkArgumentType(satoshis, 'number', 'satoshis');
    input.output = new Output({
      script: outputScript,
      satoshis: satoshis
    });
  }
  return this.uncheckedAddInput(input);
};

/**
 * Add an input to this transaction, without checking that the input has information about
 * the output that it's spending.
 *
 * @param {Input} input
 * @return Transaction this, for chaining
 */
Transaction.prototype.uncheckedAddInput = function(input) {
  $.checkArgumentType(input, Input, 'input');
  this.inputs.push(input);
  this._inputAmount = undefined;
  this._updateChangeOutput();
  return this;
};

/**
 * Returns true if the transaction has enough info on all inputs to be correctly validated
 *
 * @return {boolean}
 */
Transaction.prototype.hasAllUtxoInfo = function() {
  return _.every(this.inputs.map(function(input) {
    return !!input.output;
  }));
};

/**
 * Manually set the fee for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 *
 * @param {number} amount satoshis to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.fee = function(amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._fee = amount;
  this._updateChangeOutput();
  return this;
};

/**
 * Manually set the fee per KB for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 *
 * @param {number} amount satoshis per KB to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.feePerKb = function(amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._feePerKb = amount;
  this._updateChangeOutput();
  return this;
};

/**
 * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 * fee per Byte will be ignored if fee per KB is set
 *
 * @param {number} amount satoshis per Byte to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.feePerByte = function (amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._feePerByte = amount;
  this._updateChangeOutput();
  return this;
};

/* Output management */

/**
 * Set the change address for this transaction
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {Address} address An address for change to be sent to.
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.change = function(address) {
  $.checkArgument(address, 'address is required');
  this._changeScript = Script.fromAddress(address);
  this._updateChangeOutput();
  return this;
};


/**
 * @return {Output} change output, if it exists
 */
Transaction.prototype.getChangeOutput = function() {
  if (!_.isUndefined(this._changeIndex)) {
    return this.outputs[this._changeIndex];
  }
  return null;
};

/**
 * @typedef {Object} Transaction~toObject
 * @property {(string|Address)} address
 * @property {number} satoshis
 */

/**
 * Add an output to the transaction.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {(string|Address|Array.<Transaction~toObject>)} address
 * @param {number} amount in satoshis
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.to = function(address, amount) {
  if (_.isArray(address)) {
    var self = this;
    _.each(address, function(to) {
      self.to(to.address, to.satoshis);
    });
    return this;
  }

  $.checkArgument(
    JSUtil.isNaturalNumber(amount),
    'Amount is expected to be a positive integer'
  );
  this.addOutput(new Output({
    script: Script(new Address(address)),
    satoshis: amount
  }));
  return this;
};

/**
 * Add an OP_RETURN output to the transaction.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {Buffer|string} value the data to be stored in the OP_RETURN output.
 *    In case of a string, the UTF-8 representation will be stored
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.addData = function(value) {
  this.addOutput(new Output({
    script: Script.buildDataOut(value),
    satoshis: 0
  }));
  return this;
};


/**
 * Add an output to the transaction.
 *
 * @param {Output} output the output to add.
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.addOutput = function(output) {
  $.checkArgumentType(output, Output, 'output');
  this._addOutput(output);
  this._updateChangeOutput();
  return this;
};


/**
 * Remove all outputs from the transaction.
 *
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.clearOutputs = function() {
  this.outputs = [];
  this._clearSignatures();
  this._outputAmount = undefined;
  this._changeIndex = undefined;
  this._updateChangeOutput();
  return this;
};


Transaction.prototype._addOutput = function(output) {
  this.outputs.push(output);
  this._outputAmount = undefined;
};


/**
 * Calculates or gets the total output amount in satoshis
 *
 * @return {Number} the transaction total output amount
 */
Transaction.prototype._getOutputAmount = function() {
  if (_.isUndefined(this._outputAmount)) {
    var self = this;
    this._outputAmount = 0;
    _.each(this.outputs, function(output) {
      self._outputAmount += output.satoshis;
    });
  }
  return this._outputAmount;
};


/**
 * Calculates or gets the total input amount in satoshis
 *
 * @return {Number} the transaction total input amount
 */
Transaction.prototype._getInputAmount = function() {
  if (_.isUndefined(this._inputAmount)) {
    this._inputAmount = _.sumBy(this.inputs, function(input) {
      if (_.isUndefined(input.output)) {
        throw new errors.Transaction.Input.MissingPreviousOutput();
      }
      return input.output.satoshis;
    });
  }
  return this._inputAmount;
};

Transaction.prototype._updateChangeOutput = function() {
  if (!this._changeScript) {
    return;
  }
  this._clearSignatures();
  if (!_.isUndefined(this._changeIndex)) {
    this._removeOutput(this._changeIndex);
  }
  var available = this._getUnspentValue();
  var fee = this.getFee();
  var changeAmount = available - fee;
  if (changeAmount > 0) {
    this._changeIndex = this.outputs.length;
    this._addOutput(new Output({
      script: this._changeScript,
      satoshis: changeAmount
    }));
  } else {
    this._changeIndex = undefined;
  }
};
/**
 * Calculates the fee of the transaction.
 *
 * If there's a fixed fee set, return that.
 *
 * If there is no change output set, the fee is the
 * total value of the outputs minus inputs. Note that
 * a serialized transaction only specifies the value
 * of its outputs. (The value of inputs are recorded
 * in the previous transaction outputs being spent.)
 * This method therefore raises a "MissingPreviousOutput"
 * error when called on a serialized transaction.
 *
 * If there's no fee set and no change address,
 * estimate the fee based on size.
 *
 * @return {Number} fee of this transaction in satoshis
 */
Transaction.prototype.getFee = function() {
  if (this.isCoinbase()) {
    return 0;
  }
  if (!_.isUndefined(this._fee)) {
    return this._fee;
  }
  // if no change output is set, fees should equal all the unspent amount
  if (!this._changeScript) {
    return this._getUnspentValue();
  }
  return this._estimateFee();
};

/**
 * Estimates fee from serialized transaction size in bytes.
 */
Transaction.prototype._estimateFee = function () {
  var estimatedSize = this._estimateSize();
  var available = this._getUnspentValue();
  var feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;
  function getFee(size) {
    return size * feeRate;
  }
  var fee = Math.ceil(getFee(estimatedSize));
  var feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(Transaction.CHANGE_OUTPUT_MAX_SIZE));
  if (!this._changeScript || available <= feeWithChange) {
    return fee;
  }
  return feeWithChange;
};

Transaction.prototype._getUnspentValue = function() {
  return this._getInputAmount() - this._getOutputAmount();
};

Transaction.prototype._clearSignatures = function() {
  _.each(this.inputs, function(input) {
    input.clearSignatures();
  });
};

Transaction.prototype._estimateSize = function() {
  var result = Transaction.MAXIMUM_EXTRA_SIZE;
  _.each(this.inputs, function(input) {
    result += 32 + 4;  // prevout size:w
    result += input._estimateSize();
  });
  _.each(this.outputs, function(output) {
    result += output.script.toBuffer().length + 9;
  });
  return Math.ceil(result);
};

Transaction.prototype._removeOutput = function(index) {
  var output = this.outputs[index];
  this.outputs = _.without(this.outputs, output);
  this._outputAmount = undefined;
};

Transaction.prototype.removeOutput = function(index) {
  this._removeOutput(index);
  this._updateChangeOutput();
};

/**
 * Sort a transaction's inputs and outputs according to BIP69
 *
 * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}
 * @return {Transaction} this
 */
Transaction.prototype.sort = function() {
  this.sortInputs(function(inputs) {
    var copy = Array.prototype.concat.apply([], inputs);
    let i = 0;
    copy.forEach((x) => { x.i = i++});
    copy.sort(function(first, second) {
     return compare(first.prevTxId, second.prevTxId)
        || first.outputIndex - second.outputIndex
        || first.i - second.i;  // to ensure stable sort
    });
    return copy;
  });
  this.sortOutputs(function(outputs) {
    var copy = Array.prototype.concat.apply([], outputs);
    let i = 0;
    copy.forEach((x) => { x.i = i++});
    copy.sort(function(first, second) {
      return first.satoshis - second.satoshis
        || compare(first.script.toBuffer(), second.script.toBuffer())
        || first.i - second.i;  // to ensure stable sort
    });
    return copy;
  });
  return this;
};

/**
 * Randomize this transaction's outputs ordering. The shuffling algorithm is a
 * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().
 *
 * @return {Transaction} this
 */
Transaction.prototype.shuffleOutputs = function() {
  return this.sortOutputs(_.shuffle);
};

/**
 * Sort this transaction's outputs, according to a given sorting function that
 * takes an array as argument and returns a new array, with the same elements
 * but with a different order. The argument function MUST NOT modify the order
 * of the original array
 *
 * @param {Function} sortingFunction
 * @return {Transaction} this
 */
Transaction.prototype.sortOutputs = function(sortingFunction) {
  var outs = sortingFunction(this.outputs);
  return this._newOutputOrder(outs);
};

/**
 * Sort this transaction's inputs, according to a given sorting function that
 * takes an array as argument and returns a new array, with the same elements
 * but with a different order.
 *
 * @param {Function} sortingFunction
 * @return {Transaction} this
 */
Transaction.prototype.sortInputs = function(sortingFunction) {
  this.inputs = sortingFunction(this.inputs);
  this._clearSignatures();
  return this;
};

Transaction.prototype._newOutputOrder = function(newOutputs) {
  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||
                          _.difference(this.outputs, newOutputs).length !== 0);
  if (isInvalidSorting) {
    throw new errors.Transaction.InvalidSorting();
  }

  if (!_.isUndefined(this._changeIndex)) {
    var changeOutput = this.outputs[this._changeIndex];
    this._changeIndex = _.findIndex(newOutputs, changeOutput);
  }

  this.outputs = newOutputs;
  return this;
};

Transaction.prototype.removeInput = function(txId, outputIndex) {
  var index;
  if (!outputIndex && _.isNumber(txId)) {
    index = txId;
  } else {
    index = _.findIndex(this.inputs, function(input) {
      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;
    });
  }
  if (index < 0 || index >= this.inputs.length) {
    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);
  }
  var input = this.inputs[index];
  this.inputs = _.without(this.inputs, input);
  this._inputAmount = undefined;
  this._updateChangeOutput();
};

/* Signature handling */

/**
 * Sign the transaction using one or more private keys.
 *
 * It tries to sign each input, verifying that the signature will be valid
 * (matches a public key).
 *
 * @param {Array|String|PrivateKey} privateKey
 * @param {number} sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.sign = function(privateKey, sigtype, signingMethod) {
  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');
  var self = this;
  if (_.isArray(privateKey)) {
    _.each(privateKey, function(privateKey) {
      self.sign(privateKey, sigtype, signingMethod);
    });
    return this;
  }
  _.each(this.getSignatures(privateKey, sigtype, signingMethod), function(signature) {
    self.applySignature(signature, signingMethod);
  });
  return this;
};

Transaction.prototype.getSignatures = function(privKey, sigtype, signingMethod) {
  privKey = new PrivateKey(privKey);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  var transaction = this;
  var results = [];
  var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());
  _.each(this.inputs, function forEachInput(input, index) {
    _.each(input.getSignatures(transaction, privKey, index, sigtype, hashData, signingMethod), function(signature) {
      results.push(signature);
    });
  });
  return results;
};

/**
 * Add a signature to the transaction
 *
 * @param {Object} signature
 * @param {number} signature.inputIndex
 * @param {number} signature.sigtype
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {String} signingMethod - 'ecdsa' to sign transaction
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.applySignature = function(signature, signingMethod) {
  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);
  return this;
};

Transaction.prototype.isFullySigned = function() {
  _.each(this.inputs, function(input) {
    if (input.isFullySigned === Input.prototype.isFullySigned) {
      throw new errors.Transaction.UnableToVerifySignature(
        'Unrecognized script kind, or not enough information to execute script.' +
        'This usually happens when creating a transaction from a serialized transaction'
      );
    }
  });
  return _.every(_.map(this.inputs, function(input) {
    return input.isFullySigned();
  }));
};

Transaction.prototype.isValidSignature = function(signature, signingMethod) {
  var self = this;
  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
    throw new errors.Transaction.UnableToVerifySignature(
      'Unrecognized script kind, or not enough information to execute script.' +
      'This usually happens when creating a transaction from a serialized transaction'
    );
  }
  return this.inputs[signature.inputIndex].isValidSignature(self, signature, signingMethod);
};

/**
 * @param {String} signingMethod method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @returns {bool} whether the signature is valid for this transaction input
 */
Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, signingMethod) {

  if (_.isUndefined(sigversion)) {
    sigversion = 0;
  }

  if (sigversion === 1) {
    var subscriptBuffer = subscript.toBuffer();
    var scriptCodeWriter = new BufferWriter();
    scriptCodeWriter.writeVarintNum(subscriptBuffer.length);
    scriptCodeWriter.write(subscriptBuffer);

    var satoshisBuffer;
    if (satoshis) {
      $.checkState(JSUtil.isNaturalNumber(satoshis));
      satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();
    } else {
      satoshisBuffer = this.inputs[nin].getSatoshisBuffer();
    }
    var verified = SighashWitness.verify(
      this,
      sig,
      pubkey,
      nin,
      scriptCodeWriter.toBuffer(),
      satoshisBuffer,
      signingMethod
    );
    return verified;
  }

  return Sighash.verify(this, sig, pubkey, nin, subscript, signingMethod);
};

/**
 * Check that a transaction passes basic sanity tests. If not, return a string
 * describing the error. This function contains the same logic as
 * CheckTransaction in bitcoin core.
 */
Transaction.prototype.verify = function() {
  // Basic checks that don't depend on any context
  if (this.inputs.length === 0) {
    return 'transaction txins empty';
  }

  if (this.outputs.length === 0) {
    return 'transaction txouts empty';
  }

  // Check for negative or overflow output values
  var valueoutbn = new BN(0);
  for (var i = 0; i < this.outputs.length; i++) {
    var txout = this.outputs[i];

    if (txout.invalidSatoshis()) {
      return 'transaction txout ' + i + ' satoshis is invalid';
    }
    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {
      return 'transaction txout ' + i + ' greater than MAX_MONEY';
    }
    valueoutbn = valueoutbn.add(txout._satoshisBN);
    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {
      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';
    }
  }

  // Size limits
  if (this.toBuffer().length > MAX_BLOCK_SIZE) {
    return 'transaction over the maximum block size';
  }

  // Check for duplicate inputs
  var txinmap = {};
  for (i = 0; i < this.inputs.length; i++) {
    var txin = this.inputs[i];

    var inputid = txin.prevTxId + ':' + txin.outputIndex;
    if (!_.isUndefined(txinmap[inputid])) {
      return 'transaction input ' + i + ' duplicate input';
    }
    txinmap[inputid] = true;
  }

  var isCoinbase = this.isCoinbase();
  if (isCoinbase) {
    var buf = this.inputs[0]._scriptBuffer;
    if (buf.length < 2 || buf.length > 100) {
      return 'coinbase transaction script size invalid';
    }
  } else {
    for (i = 0; i < this.inputs.length; i++) {
      if (this.inputs[i].isNull()) {
        return 'transaction input ' + i + ' has null input';
      }
    }
  }
  return true;
};

/**
 * Analogous to bitcoind's IsCoinBase function in transaction.h
 */
Transaction.prototype.isCoinbase = function() {
  return (this.inputs.length === 1 && this.inputs[0].isNull());
};

/**
 * Determines if this transaction can be replaced in the mempool with another
 * transaction that provides a sufficiently higher fee (RBF).
 */
Transaction.prototype.isRBF = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    var input = this.inputs[i];
    if (input.sequenceNumber < Input.MAXINT - 1) {
      return true;
    }
  }
  return false;
};

/**
 * Enable this transaction to be replaced in the mempool (RBF) if a transaction
 * includes a sufficiently higher fee. It will set the sequenceNumber to
 * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not
 * already enable RBF.
 */
Transaction.prototype.enableRBF = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    var input = this.inputs[i];
    if (input.sequenceNumber >= Input.MAXINT - 1) {
      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;
    }
  }
  return this;
};

Transaction.prototype.setVersion = function(version) {
  $.checkArgument(
    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,
    'Wrong version number');
  this.version = version;
  return this;
};



module.exports = Transaction;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 462:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(268);

module.exports.PublicKey = __webpack_require__(1496);
module.exports.PublicKeyHash = __webpack_require__(1497);
module.exports.MultiSig = __webpack_require__(1498);
module.exports.MultiSigScriptHash = __webpack_require__(1499);


/***/ }),

/***/ 463:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

var errors = __webpack_require__(115);
var $ = __webpack_require__(35);

var UNITS = {
  'EDU'      : [1e8, 8],
  'mEDU'     : [1e5, 5],
  'uEDU'     : [1e2, 2],
  'bits'     : [1e2, 2],
  'satoshis' : [1, 0]
};

/**
 * Utility for handling and converting bitcoins units. The supported units are
 * EDU, mEDU, bits (also named uEDU) and satoshis. A unit instance can be created with an
 * amount and a unit code, or alternatively using static methods like {fromBTC}.
 * It also allows to be created from a fiat amount and the exchange rate, or
 * alternatively using the {fromFiat} static method.
 * You can consult for different representation of a unit instance using it's
 * {to} method, the fixed unit methods like {toSatoshis} or alternatively using
 * the unit accessors. It also can be converted to a fiat amount by providing the
 * corresponding EDU/fiat exchange rate.
 *
 * @example
 * ```javascript
 * var sats = Unit.fromBTC(1.3).toSatoshis();
 * var mili = Unit.fromBits(1.3).to(Unit.mEDU);
 * var bits = Unit.fromFiat(1.3, 350).bits;
 * var btc = new Unit(1.3, Unit.bits).EDU;
 * ```
 *
 * @param {Number} amount - The amount to be represented
 * @param {String|Number} code - The unit of the amount or the exchange rate
 * @returns {Unit} A new instance of an Unit
 * @constructor
 */
function Unit(amount, code) {
  if (!(this instanceof Unit)) {
    return new Unit(amount, code);
  }

  // convert fiat to EDU
  if (_.isNumber(code)) {
    if (code <= 0) {
      throw new errors.Unit.InvalidRate(code);
    }
    amount = amount / code;
    code = Unit.EDU;
  }

  this._value = this._from(amount, code);

  var self = this;
  var defineAccesor = function(key) {
    Object.defineProperty(self, key, {
      get: function() { return self.to(key); },
      enumerable: true,
    });
  };

  Object.keys(UNITS).forEach(defineAccesor);
}

Object.keys(UNITS).forEach(function(key) {
  Unit[key] = key;
});

/**
 * Returns a Unit instance created from JSON string or object
 *
 * @param {String|Object} json - JSON with keys: amount and code
 * @returns {Unit} A Unit instance
 */
Unit.fromObject = function fromObject(data){
  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');
  return new Unit(data.amount, data.code);
};

/**
 * Returns a Unit instance created from an amount in EDU
 *
 * @param {Number} amount - The amount in EDU
 * @returns {Unit} A Unit instance
 */
Unit.fromBTC = function(amount) {
  return new Unit(amount, Unit.EDU);
};

/**
 * Returns a Unit instance created from an amount in mEDU
 *
 * @param {Number} amount - The amount in mEDU
 * @returns {Unit} A Unit instance
 */
Unit.fromMillis = Unit.fromMilis = function(amount) {
  return new Unit(amount, Unit.mEDU);
};

/**
 * Returns a Unit instance created from an amount in bits
 *
 * @param {Number} amount - The amount in bits
 * @returns {Unit} A Unit instance
 */
Unit.fromMicros = Unit.fromBits = function(amount) {
  return new Unit(amount, Unit.bits);
};

/**
 * Returns a Unit instance created from an amount in satoshis
 *
 * @param {Number} amount - The amount in satoshis
 * @returns {Unit} A Unit instance
 */
Unit.fromSatoshis = function(amount) {
  return new Unit(amount, Unit.satoshis);
};

/**
 * Returns a Unit instance created from a fiat amount and exchange rate.
 *
 * @param {Number} amount - The amount in fiat
 * @param {Number} rate - The exchange rate EDU/fiat
 * @returns {Unit} A Unit instance
 */
Unit.fromFiat = function(amount, rate) {
  return new Unit(amount, rate);
};

Unit.prototype._from = function(amount, code) {
  if (!UNITS[code]) {
    throw new errors.Unit.UnknownCode(code);
  }
  return parseInt((amount * UNITS[code][0]).toFixed());
};

/**
 * Returns the value represented in the specified unit
 *
 * @param {String|Number} code - The unit code or exchange rate
 * @returns {Number} The converted value
 */
Unit.prototype.to = function(code) {
  if (_.isNumber(code)) {
    if (code <= 0) {
      throw new errors.Unit.InvalidRate(code);
    }
    return parseFloat((this.EDU * code).toFixed(2));
  }

  if (!UNITS[code]) {
    throw new errors.Unit.UnknownCode(code);
  }

  var value = this._value / UNITS[code][0];
  return parseFloat(value.toFixed(UNITS[code][1]));
};

/**
 * Returns the value represented in EDU
 *
 * @returns {Number} The value converted to EDU
 */
Unit.prototype.toEDU = function() {
  return this.to(Unit.EDU);
};

/**
 * Returns the value represented in mEDU
 *
 * @returns {Number} The value converted to mEDU
 */
Unit.prototype.toMillis = Unit.prototype.toMilis = function() {
  return this.to(Unit.mEDU);
};

/**
 * Returns the value represented in bits
 *
 * @returns {Number} The value converted to bits
 */
Unit.prototype.toMicros = Unit.prototype.toBits = function() {
  return this.to(Unit.bits);
};

/**
 * Returns the value represented in satoshis
 *
 * @returns {Number} The value converted to satoshis
 */
Unit.prototype.toSatoshis = function() {
  return this.to(Unit.satoshis);
};

/**
 * Returns the value represented in fiat
 *
 * @param {string} rate - The exchange rate between EDU/currency
 * @returns {Number} The value converted to satoshis
 */
Unit.prototype.atRate = function(rate) {
  return this.to(rate);
};

/**
 * Returns a the string representation of the value in satoshis
 *
 * @returns {string} the value in satoshis
 */
Unit.prototype.toString = function() {
  return this.satoshis + ' satoshis';
};

/**
 * Returns a plain object representation of the Unit
 *
 * @returns {Object} An object with the keys: amount and code
 */
Unit.prototype.toObject = Unit.prototype.toJSON = function toObject() {
  return {
    amount: this.EDU,
    code: Unit.EDU
  };
};

/**
 * Returns a string formatted for the console
 *
 * @returns {string} the value in satoshis
 */
Unit.prototype.inspect = function() {
  return '<Unit: ' + this.toString() + '>';
};

module.exports = Unit;


/***/ }),

/***/ 464:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);

function Opcode(num) {
  if (!(this instanceof Opcode)) {
    return new Opcode(num);
  }

  var value;

  if (_.isNumber(num)) {
    value = num;
  } else if (_.isString(num)) {
    value = Opcode.map[num];
  } else {
    throw new TypeError('Unrecognized num type: "' + typeof(num) + '" for Opcode');
  }

  JSUtil.defineImmutable(this, {
    num: value
  });

  return this;
}

Opcode.fromBuffer = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return new Opcode(Number('0x' + buf.toString('hex')));
};

Opcode.fromNumber = function(num) {
  $.checkArgument(_.isNumber(num));
  return new Opcode(num);
};

Opcode.fromString = function(str) {
  $.checkArgument(_.isString(str));
  var value = Opcode.map[str];
  if (typeof value === 'undefined') {
    throw new TypeError('Invalid opcodestr');
  }
  return new Opcode(value);
};

Opcode.prototype.toHex = function() {
  return this.num.toString(16);
};

Opcode.prototype.toBuffer = function() {
  return Buffer.from(this.toHex(), 'hex');
};

Opcode.prototype.toNumber = function() {
  return this.num;
};

Opcode.prototype.toString = function() {
  var str = Opcode.reverseMap[this.num];
  if (typeof str === 'undefined') {
    throw new Error('Opcode does not have a string representation');
  }
  return str;
};

Opcode.smallInt = function(n) {
  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');
  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');
  if (n === 0) {
    return Opcode('OP_0');
  }
  return new Opcode(Opcode.map.OP_1 + n - 1);
};

Opcode.map = {
  // push value
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,

  // control
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,

  // stack ops
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,

  // splice ops
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,

  // bit logic
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,

  // numeric
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,

  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,

  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,

  OP_WITHIN: 165,

  // crypto
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,

  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,

  // expansion
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_NOP3: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,

  // template matching params
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};

Opcode.reverseMap = [];

for (var k in Opcode.map) {
  Opcode.reverseMap[Opcode.map[k]] = k;
}

// Easier access to opcodes
_.extend(Opcode, Opcode.map);

/**
 * @returns true if opcode is one of OP_0, OP_1, ..., OP_16
 */
Opcode.isSmallIntOp = function(opcode) {
  if (opcode instanceof Opcode) {
    opcode = opcode.toNumber();
  }
  return ((opcode === Opcode.map.OP_0) ||
    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));
};

/**
 * Will return a string formatted for the console
 *
 * @returns {string} Script opcode
 */
Opcode.prototype.inspect = function() {
  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';
};

module.exports = Opcode;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 465:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var buffer = __webpack_require__(2);
var compare = Buffer.compare || __webpack_require__(256);

var errors = __webpack_require__(116);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var Hash = __webpack_require__(76);
var Signature = __webpack_require__(105);
var Sighash = __webpack_require__(182);
var SighashWitness = __webpack_require__(361);

var Address = __webpack_require__(142);
var UnspentOutput = __webpack_require__(864);
var Input = __webpack_require__(466);
var PublicKeyHashInput = Input.PublicKeyHash;
var PublicKeyInput = Input.PublicKey;
var MultiSigScriptHashInput = Input.MultiSigScriptHash;
var MultiSigInput = Input.MultiSig;
var Output = __webpack_require__(163);
var Script = __webpack_require__(106);
var PrivateKey = __webpack_require__(270);
var BN = __webpack_require__(75);

/**
 * Represents a transaction, a set of inputs and outputs to change ownership of tokens
 *
 * @param {*} serialized
 * @constructor
 */
function Transaction(serialized, opts) {
  if (!(this instanceof Transaction)) {
    return new Transaction(serialized);
  }
  this.inputs = [];
  this.outputs = [];
  this._inputAmount = undefined;
  this._outputAmount = undefined;

  if (serialized) {
    if (serialized instanceof Transaction) {
      return Transaction.shallowCopy(serialized);
    } else if (JSUtil.isHexa(serialized)) {
      this.fromString(serialized);
    } else if (BufferUtil.isBuffer(serialized)) {
      this.fromBuffer(serialized);
    } else if (_.isObject(serialized)) {
      this.fromObject(serialized, opts);
    } else {
      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');
    }
  } else {
    this._newTransaction();
  }
}
var CURRENT_VERSION = 2;
var DEFAULT_NLOCKTIME = 0;
var MAX_BLOCK_SIZE = 1000000;

// Minimum amount for an output for it not to be considered a dust output
Transaction.DUST_AMOUNT = 546;

// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference
Transaction.FEE_SECURITY_MARGIN = 150;

// max amount of satoshis in circulation
Transaction.MAX_MONEY = 21000000 * 1e8;

// nlocktime limit to be considered block height rather than a timestamp
Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;

// Max value for an unsigned 32 bit value
Transaction.NLOCKTIME_MAX_VALUE = 4294967295;

// Value used for fee estimation (satoshis per kilobyte)
Transaction.FEE_PER_KB = 100000;

// Safe upper bound for change address script size in bytes
Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;
Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;

/* Constructors and Serialization */

/**
 * Create a 'shallow' copy of the transaction, by serializing and deserializing
 * it dropping any additional information that inputs and outputs may have hold
 *
 * @param {Transaction} transaction
 * @return {Transaction}
 */
Transaction.shallowCopy = function(transaction) {
  var copy = new Transaction(transaction.toBuffer());
  return copy;
};

var hashProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');
    return this._hash;
  }
};

var witnessHashProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');
  }
};

Object.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);
Object.defineProperty(Transaction.prototype, 'hash', hashProperty);
Object.defineProperty(Transaction.prototype, 'id', hashProperty);

var ioProperty = {
  configurable: false,
  enumerable: true,
  get: function() {
    return this._getInputAmount();
  }
};
Object.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);
ioProperty.get = function() {
  return this._getOutputAmount();
};
Object.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);

/**
 * Retrieve the little endian hash of the transaction (used for serialization)
 * @return {Buffer}
 */
Transaction.prototype._getHash = function() {
  return Hash.sha256sha256(this.toBuffer(true));
};

/**
 * Retrieve the little endian hash of the transaction including witness data
 * @return {Buffer}
 */
Transaction.prototype._getWitnessHash = function() {
  return Hash.sha256sha256(this.toBuffer(false));
};

/**
 * Retrieve a hexa string that can be used with bitcoind's CLI interface
 * (decoderawtransaction, sendrawtransaction)
 *
 * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,
 *   it's expected to contain a set of flags to skip certain tests:
 * * `disableAll`: disable all checks
 * * `disableSmallFees`: disable checking for fees that are too small
 * * `disableLargeFees`: disable checking for fees that are too large
 * * `disableIsFullySigned`: disable checking if all inputs are fully signed
 * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts
 * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts
 * @return {string}
 */
Transaction.prototype.serialize = function(unsafe) {
  if (true === unsafe || unsafe && unsafe.disableAll) {
    return this.uncheckedSerialize();
  } else {
    return this.checkedSerialize(unsafe);
  }
};

Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {
  return this.toBuffer().toString('hex');
};

/**
 * Retrieve a hexa string that can be used with bitcoind's CLI interface
 * (decoderawtransaction, sendrawtransaction)
 *
 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
 * @return {string}
 */
Transaction.prototype.checkedSerialize = function(opts) {
  var serializationError = this.getSerializationError(opts);
  if (serializationError) {
    serializationError.message += ' - For more information please see: ' +
      'https://bitcore.io/api/lib/transaction#serialization-checks';
    throw serializationError;
  }
  return this.uncheckedSerialize();
};

Transaction.prototype.invalidSatoshis = function() {
  var invalid = false;
  for (var i = 0; i < this.outputs.length; i++) {
    if (this.outputs[i].invalidSatoshis()) {
      invalid = true;
    }
  }
  return invalid;
};

/**
 * Retrieve a possible error that could appear when trying to serialize and
 * broadcast this transaction.
 *
 * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}
 * @return {bitcore.Error}
 */
Transaction.prototype.getSerializationError = function(opts) {
  opts = opts || {};

  if (this.invalidSatoshis()) {
    return new errors.Transaction.InvalidSatoshis();
  }

  var unspent = this._getUnspentValue();
  var unspentError;
  if (unspent < 0) {
    if (!opts.disableMoreOutputThanInput) {
      unspentError = new errors.Transaction.InvalidOutputAmountSum();
    }
  } else {
    unspentError = this._hasFeeError(opts, unspent);
  }

  return unspentError ||
    this._hasDustOutputs(opts) ||
    this._isMissingSignatures(opts);
};

Transaction.prototype._hasFeeError = function(opts, unspent) {

  if (!_.isUndefined(this._fee) && this._fee !== unspent) {
    return new errors.Transaction.FeeError.Different(
      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee
    );
  }

  if (!opts.disableLargeFees) {
    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
    if (unspent > maximumFee) {
      if (this._missingChange()) {
        return new errors.Transaction.ChangeAddressMissing(
          'Fee is too large and no change address was provided'
        );
      }
      return new errors.Transaction.FeeError.TooLarge(
        'expected less than ' + maximumFee + ' but got ' + unspent
      );
    }
  }

  if (!opts.disableSmallFees) {
    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);
    if (unspent < minimumFee) {
      return new errors.Transaction.FeeError.TooSmall(
        'expected more than ' + minimumFee + ' but got ' + unspent
      );
    }
  }
};

Transaction.prototype._missingChange = function() {
  return !this._changeScript;
};

Transaction.prototype._hasDustOutputs = function(opts) {
  if (opts.disableDustOutputs) {
    return;
  }
  var index, output;
  for (index in this.outputs) {
    output = this.outputs[index];
    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {
      return new errors.Transaction.DustOutputs();
    }
  }
};

Transaction.prototype._isMissingSignatures = function(opts) {
  if (opts.disableIsFullySigned) {
    return;
  }
  if (!this.isFullySigned()) {
    return new errors.Transaction.MissingSignatures();
  }
};

Transaction.prototype.inspect = function() {
  return '<Transaction: ' + this.uncheckedSerialize() + '>';
};

Transaction.prototype.toBuffer = function(noWitness) {
  var writer = new BufferWriter();
  return this.toBufferWriter(writer, noWitness).toBuffer();
};

Transaction.prototype.hasWitnesses = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].hasWitnesses()) {
      return true;
    }
  }
  return false;
};

Transaction.prototype.toBufferWriter = function(writer, noWitness) {
  writer.writeInt32LE(this.version);

  var hasWitnesses = this.hasWitnesses();

  if (hasWitnesses && !noWitness) {
    writer.write(Buffer.from('0001', 'hex'));
  }

  writer.writeVarintNum(this.inputs.length);

  _.each(this.inputs, function(input) {
    input.toBufferWriter(writer);
  });

  writer.writeVarintNum(this.outputs.length);
  _.each(this.outputs, function(output) {
    output.toBufferWriter(writer);
  });

  if (hasWitnesses && !noWitness) {
    _.each(this.inputs, function(input) {
      var witnesses = input.getWitnesses();
      writer.writeVarintNum(witnesses.length);
      for (var j = 0; j < witnesses.length; j++) {
        writer.writeVarintNum(witnesses[j].length);
        writer.write(witnesses[j]);
      }
    });
  }

  writer.writeUInt32LE(this.nLockTime);
  return writer;
};

Transaction.prototype.fromBuffer = function(buffer) {
  var reader = new BufferReader(buffer);
  return this.fromBufferReader(reader);
};

Transaction.prototype.fromBufferReader = function(reader) {
  $.checkArgument(!reader.finished(), 'No transaction data received');

  this.version = reader.readInt32LE();
  var sizeTxIns = reader.readVarintNum();

  // check for segwit
  var hasWitnesses = false;
  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {
    reader.pos += 1;
    hasWitnesses = true;
    sizeTxIns = reader.readVarintNum();
  }

  for (var i = 0; i < sizeTxIns; i++) {
    var input = Input.fromBufferReader(reader);
    this.inputs.push(input);
  }

  var sizeTxOuts = reader.readVarintNum();
  for (var j = 0; j < sizeTxOuts; j++) {
    this.outputs.push(Output.fromBufferReader(reader));
  }

  if (hasWitnesses) {
    for (var k = 0; k < sizeTxIns; k++) {
      var itemCount = reader.readVarintNum();
      var witnesses = [];
      for (var l = 0; l < itemCount; l++) {
        var size = reader.readVarintNum();
        var item = reader.read(size);
        witnesses.push(item);
      }
      this.inputs[k].setWitnesses(witnesses);
    }
  }

  this.nLockTime = reader.readUInt32LE();
  return this;
};


Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {
  var inputs = [];
  this.inputs.forEach(function(input) {
    inputs.push(input.toObject());
  });
  var outputs = [];
  this.outputs.forEach(function(output) {
    outputs.push(output.toObject());
  });
  var obj = {
    hash: this.hash,
    version: this.version,
    inputs: inputs,
    outputs: outputs,
    nLockTime: this.nLockTime
  };
  if (this._changeScript) {
    obj.changeScript = this._changeScript.toString();
  }
  if (!_.isUndefined(this._changeIndex)) {
    obj.changeIndex = this._changeIndex;
  }
  if (!_.isUndefined(this._fee)) {
    obj.fee = this._fee;
  }
  return obj;
};

Transaction.prototype.fromObject = function fromObject(arg, opts) {
  /* jshint maxstatements: 20 */
  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);
  var self = this;
  var transaction;
  if (arg instanceof Transaction) {
    transaction = transaction.toObject();
  } else {
    transaction = arg;
  }
  _.each(transaction.inputs, function(input) {
    if (!input.output || !input.output.script) {
      self.uncheckedAddInput(new Input(input));
      return;
    }
    var script = new Script(input.output.script);
    var txin;
    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {
      txin = new Input.MultiSigScriptHash(
        input, input.publicKeys, input.threshold, input.signatures, opts
      );
    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {
      txin = new Input.PublicKeyHash(input);
    } else if (script.isPublicKeyOut()) {
      txin = new Input.PublicKey(input);
    } else {
      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);
    }
    self.addInput(txin);
  });
  _.each(transaction.outputs, function(output) {
    self.addOutput(new Output(output));
  });
  if (transaction.changeIndex) {
    this._changeIndex = transaction.changeIndex;
  }
  if (transaction.changeScript) {
    this._changeScript = new Script(transaction.changeScript);
  }
  if (transaction.fee) {
    this._fee = transaction.fee;
  }
  this.nLockTime = transaction.nLockTime;
  this.version = transaction.version;
  this._checkConsistency(arg);
  return this;
};

Transaction.prototype._checkConsistency = function(arg) {
  if (!_.isUndefined(this._changeIndex)) {
    $.checkState(this._changeScript, 'Change script is expected.');
    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');
    $.checkState(this.outputs[this._changeIndex].script.toString() ===
      this._changeScript.toString(), 'Change output has an unexpected script.');
  }
  if (arg && arg.hash) {
    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');
  }
};

/**
 * Sets nLockTime so that transaction is not valid until the desired date(a
 * timestamp in seconds since UNIX epoch is also accepted)
 *
 * @param {Date | Number} time
 * @return {Transaction} this
 */
Transaction.prototype.lockUntilDate = function(time) {
  $.checkArgument(time);
  if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    throw new errors.Transaction.LockTimeTooEarly();
  }
  if (_.isDate(time)) {
    time = time.getTime() / 1000;
  }

  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){
      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
    }
  }

  this.nLockTime = time;
  return this;
};

/**
 * Sets nLockTime so that transaction is not valid until the desired block
 * height.
 *
 * @param {Number} height
 * @return {Transaction} this
 */
Transaction.prototype.lockUntilBlockHeight = function(height) {
  $.checkArgument(_.isNumber(height));
  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    throw new errors.Transaction.BlockHeightTooHigh();
  }
  if (height < 0) {
    throw new errors.Transaction.NLockTimeOutOfRange();
  }

  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){
      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
    }
  }


  this.nLockTime = height;
  return this;
};

/**
 *  Returns a semantic version of the transaction's nLockTime.
 *  @return {Number|Date}
 *  If nLockTime is 0, it returns null,
 *  if it is < 500000000, it returns a block height (number)
 *  else it returns a Date object.
 */
Transaction.prototype.getLockTime = function() {
  if (!this.nLockTime) {
    return null;
  }
  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
    return this.nLockTime;
  }
  return new Date(1000 * this.nLockTime);
};

Transaction.prototype.fromString = function(string) {
  this.fromBuffer(buffer.Buffer.from(string, 'hex'));
};

Transaction.prototype._newTransaction = function() {
  this.version = CURRENT_VERSION;
  this.nLockTime = DEFAULT_NLOCKTIME;
};

/* Transaction creation interface */

/**
 * @typedef {Object} Transaction~fromObject
 * @property {string} prevTxId
 * @property {number} outputIndex
 * @property {(Buffer|string|Script)} script
 * @property {number} satoshis
 */

/**
 * Add an input to this transaction. This is a high level interface
 * to add an input, for more control, use @{link Transaction#addInput}.
 *
 * Can receive, as output information, the output of bitcoind's `listunspent` command,
 * and a slightly fancier format recognized by bitcore:
 *
 * ```
 * {
 *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',
 *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',
 *  outputIndex: 0,
 *  script: Script.empty(),
 *  satoshis: 1020000
 * }
 * ```
 * Where `address` can be either a string or a bitcore Address object. The
 * same is true for `script`, which can be a string or a bitcore Script.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @example
 * ```javascript
 * var transaction = new Transaction();
 *
 * // From a pay to public key hash output from bitcoind's listunspent
 * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});
 *
 * // From a pay to public key hash output
 * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});
 *
 * // From a multisig P2SH output
 * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},
 *                  ['03000...', '02000...'], 2);
 * ```
 *
 * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo
 * @param {Array=} pubkeys
 * @param {number=} threshold
 * @param {Object=} opts - Several options:
 *        - noSorting: defaults to false, if true and is multisig, don't
 *                      sort the given public keys before creating the script
 */
Transaction.prototype.from = function(utxo, pubkeys, threshold, opts) {
  if (_.isArray(utxo)) {
    var self = this;
    _.each(utxo, function(utxo) {
      self.from(utxo, pubkeys, threshold, opts);
    });
    return this;
  }
  var exists = _.some(this.inputs, function(input) {
    // TODO: Maybe prevTxId should be a string? Or defined as read only property?
    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;
  });
  if (exists) {
    return this;
  }
  if (pubkeys && threshold) {
    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);
  } else {
    this._fromNonP2SH(utxo);
  }
  return this;
};

/**
 * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.
 * Populating these inputs allows for them to be signed with .sign(privKeys)
 *
 * @param {Array<Object>} utxos
 * @param {Array<string | PublicKey>} pubkeys
 * @param {number} threshold
 * @param {Object} opts
 * @returns {Array<number>}
 */
Transaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts) {
  let indexes = [];
  for(let utxo of utxos) {
    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);
    indexes.push(index);
    if(index >= 0) {
      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);
    }
  }
  return indexes;
}


Transaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {
  var clazz;
  utxo = new UnspentOutput(utxo);
  if(pubkeys && threshold) {
    if (utxo.script.isMultisigOut()) {
      clazz = MultiSigInput;
    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {
      clazz = MultiSigScriptHashInput;
    }
  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {
    clazz = PublicKeyHashInput;
  } else if (utxo.script.isPublicKeyOut()) {
    clazz = PublicKeyInput;
  } else {
    clazz = Input;
  }
  return clazz;
}


Transaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts) {
  utxo = new UnspentOutput(utxo);
  const InputClass = this._selectInputType(utxo, pubkeys, threshold);
  const input = {
    output: new Output({
      script: utxo.script,
      satoshis: utxo.satoshis
    }),
    prevTxId: utxo.txId,
    outputIndex: utxo.outputIndex,
    sequenceNumber: utxo.sequenceNumber,
    script: Script.empty()
  };
  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []
  return new InputClass(input, ...args);
}

Transaction.prototype._fromNonP2SH = function(utxo) {
  const input = this._getInputFrom(utxo);
  this.addInput(input);
};

Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {
  $.checkArgument(threshold <= pubkeys.length,
    'Number of required signatures must be greater than the number of public keys');
  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);
  this.addInput(input);
};

/**
 * Add an input to this transaction. The input must be an instance of the `Input` class.
 * It should have information about the Output that it's spending, but if it's not already
 * set, two additional parameters, `outputScript` and `satoshis` can be provided.
 *
 * @param {Input} input
 * @param {String|Script} outputScript
 * @param {number} satoshis
 * @return Transaction this, for chaining
 */
Transaction.prototype.addInput = function(input, outputScript, satoshis) {
  $.checkArgumentType(input, Input, 'input');
  if (!input.output && (_.isUndefined(outputScript) || _.isUndefined(satoshis))) {
    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');
  }
  if (!input.output && outputScript && !_.isUndefined(satoshis)) {
    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
    $.checkArgumentType(satoshis, 'number', 'satoshis');
    input.output = new Output({
      script: outputScript,
      satoshis: satoshis
    });
  }
  return this.uncheckedAddInput(input);
};

/**
 * Add an input to this transaction, without checking that the input has information about
 * the output that it's spending.
 *
 * @param {Input} input
 * @return Transaction this, for chaining
 */
Transaction.prototype.uncheckedAddInput = function(input) {
  $.checkArgumentType(input, Input, 'input');
  this.inputs.push(input);
  this._inputAmount = undefined;
  this._updateChangeOutput();
  return this;
};

/**
 * Returns true if the transaction has enough info on all inputs to be correctly validated
 *
 * @return {boolean}
 */
Transaction.prototype.hasAllUtxoInfo = function() {
  return _.every(this.inputs.map(function(input) {
    return !!input.output;
  }));
};

/**
 * Manually set the fee for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 *
 * @param {number} amount satoshis to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.fee = function(amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._fee = amount;
  this._updateChangeOutput();
  return this;
};

/**
 * Manually set the fee per KB for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 *
 * @param {number} amount satoshis per KB to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.feePerKb = function(amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._feePerKb = amount;
  this._updateChangeOutput();
  return this;
};

/**
 * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures
 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
 * be reset).
 * fee per Byte will be ignored if fee per KB is set
 *
 * @param {number} amount satoshis per Byte to be sent
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.feePerByte = function (amount) {
  $.checkArgument(_.isNumber(amount), 'amount must be a number');
  this._feePerByte = amount;
  this._updateChangeOutput();
  return this;
};

/* Output management */

/**
 * Set the change address for this transaction
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {Address} address An address for change to be sent to.
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.change = function(address) {
  $.checkArgument(address, 'address is required');
  this._changeScript = Script.fromAddress(address);
  this._updateChangeOutput();
  return this;
};


/**
 * @return {Output} change output, if it exists
 */
Transaction.prototype.getChangeOutput = function() {
  if (!_.isUndefined(this._changeIndex)) {
    return this.outputs[this._changeIndex];
  }
  return null;
};

/**
 * @typedef {Object} Transaction~toObject
 * @property {(string|Address)} address
 * @property {number} satoshis
 */

/**
 * Add an output to the transaction.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {(string|Address|Array.<Transaction~toObject>)} address
 * @param {number} amount in satoshis
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.to = function(address, amount) {
  if (_.isArray(address)) {
    var self = this;
    _.each(address, function(to) {
      self.to(to.address, to.satoshis);
    });
    return this;
  }

  $.checkArgument(
    JSUtil.isNaturalNumber(amount),
    'Amount is expected to be a positive integer'
  );
  this.addOutput(new Output({
    script: Script(new Address(address)),
    satoshis: amount
  }));
  return this;
};

/**
 * Add an OP_RETURN output to the transaction.
 *
 * Beware that this resets all the signatures for inputs (in further versions,
 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
 *
 * @param {Buffer|string} value the data to be stored in the OP_RETURN output.
 *    In case of a string, the UTF-8 representation will be stored
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.addData = function(value) {
  this.addOutput(new Output({
    script: Script.buildDataOut(value),
    satoshis: 0
  }));
  return this;
};


/**
 * Add an output to the transaction.
 *
 * @param {Output} output the output to add.
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.addOutput = function(output) {
  $.checkArgumentType(output, Output, 'output');
  this._addOutput(output);
  this._updateChangeOutput();
  return this;
};


/**
 * Remove all outputs from the transaction.
 *
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.clearOutputs = function() {
  this.outputs = [];
  this._clearSignatures();
  this._outputAmount = undefined;
  this._changeIndex = undefined;
  this._updateChangeOutput();
  return this;
};


Transaction.prototype._addOutput = function(output) {
  this.outputs.push(output);
  this._outputAmount = undefined;
};


/**
 * Calculates or gets the total output amount in satoshis
 *
 * @return {Number} the transaction total output amount
 */
Transaction.prototype._getOutputAmount = function() {
  if (_.isUndefined(this._outputAmount)) {
    var self = this;
    this._outputAmount = 0;
    _.each(this.outputs, function(output) {
      self._outputAmount += output.satoshis;
    });
  }
  return this._outputAmount;
};


/**
 * Calculates or gets the total input amount in satoshis
 *
 * @return {Number} the transaction total input amount
 */
Transaction.prototype._getInputAmount = function() {
  if (_.isUndefined(this._inputAmount)) {
    this._inputAmount = _.sumBy(this.inputs, function(input) {
      if (_.isUndefined(input.output)) {
        throw new errors.Transaction.Input.MissingPreviousOutput();
      }
      return input.output.satoshis;
    });
  }
  return this._inputAmount;
};

Transaction.prototype._updateChangeOutput = function() {
  if (!this._changeScript) {
    return;
  }
  this._clearSignatures();
  if (!_.isUndefined(this._changeIndex)) {
    this._removeOutput(this._changeIndex);
  }
  var available = this._getUnspentValue();
  var fee = this.getFee();
  var changeAmount = available - fee;
  if (changeAmount > 0) {
    this._changeIndex = this.outputs.length;
    this._addOutput(new Output({
      script: this._changeScript,
      satoshis: changeAmount
    }));
  } else {
    this._changeIndex = undefined;
  }
};
/**
 * Calculates the fee of the transaction.
 *
 * If there's a fixed fee set, return that.
 *
 * If there is no change output set, the fee is the
 * total value of the outputs minus inputs. Note that
 * a serialized transaction only specifies the value
 * of its outputs. (The value of inputs are recorded
 * in the previous transaction outputs being spent.)
 * This method therefore raises a "MissingPreviousOutput"
 * error when called on a serialized transaction.
 *
 * If there's no fee set and no change address,
 * estimate the fee based on size.
 *
 * @return {Number} fee of this transaction in satoshis
 */
Transaction.prototype.getFee = function() {
  if (this.isCoinbase()) {
    return 0;
  }
  if (!_.isUndefined(this._fee)) {
    return this._fee;
  }
  // if no change output is set, fees should equal all the unspent amount
  if (!this._changeScript) {
    return this._getUnspentValue();
  }
  return this._estimateFee();
};

/**
 * Estimates fee from serialized transaction size in bytes.
 */
Transaction.prototype._estimateFee = function () {
  var estimatedSize = this._estimateSize();
  var available = this._getUnspentValue();
  var feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;
  function getFee(size) {
    return size * feeRate;
  }
  var fee = Math.ceil(getFee(estimatedSize));
  var feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(Transaction.CHANGE_OUTPUT_MAX_SIZE));
  if (!this._changeScript || available <= feeWithChange) {
    return fee;
  }
  return feeWithChange;
};

Transaction.prototype._getUnspentValue = function() {
  return this._getInputAmount() - this._getOutputAmount();
};

Transaction.prototype._clearSignatures = function() {
  _.each(this.inputs, function(input) {
    input.clearSignatures();
  });
};

Transaction.prototype._estimateSize = function() {
  var result = Transaction.MAXIMUM_EXTRA_SIZE;
  _.each(this.inputs, function(input) {
    result += 32 + 4;  // prevout size:w
    result += input._estimateSize();
  });
  _.each(this.outputs, function(output) {
    result += output.script.toBuffer().length + 9;
  });
  return Math.ceil(result);
};

Transaction.prototype._removeOutput = function(index) {
  var output = this.outputs[index];
  this.outputs = _.without(this.outputs, output);
  this._outputAmount = undefined;
};

Transaction.prototype.removeOutput = function(index) {
  this._removeOutput(index);
  this._updateChangeOutput();
};

/**
 * Sort a transaction's inputs and outputs according to BIP69
 *
 * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}
 * @return {Transaction} this
 */
Transaction.prototype.sort = function() {
  this.sortInputs(function(inputs) {
    var copy = Array.prototype.concat.apply([], inputs);
    let i = 0;
    copy.forEach((x) => { x.i = i++});
    copy.sort(function(first, second) {
     return compare(first.prevTxId, second.prevTxId)
        || first.outputIndex - second.outputIndex
        || first.i - second.i;  // to ensure stable sort
    });
    return copy;
  });
  this.sortOutputs(function(outputs) {
    var copy = Array.prototype.concat.apply([], outputs);
    let i = 0;
    copy.forEach((x) => { x.i = i++});
    copy.sort(function(first, second) {
      return first.satoshis - second.satoshis
        || compare(first.script.toBuffer(), second.script.toBuffer())
        || first.i - second.i;  // to ensure stable sort
    });
    return copy;
  });
  return this;
};

/**
 * Randomize this transaction's outputs ordering. The shuffling algorithm is a
 * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().
 *
 * @return {Transaction} this
 */
Transaction.prototype.shuffleOutputs = function() {
  return this.sortOutputs(_.shuffle);
};

/**
 * Sort this transaction's outputs, according to a given sorting function that
 * takes an array as argument and returns a new array, with the same elements
 * but with a different order. The argument function MUST NOT modify the order
 * of the original array
 *
 * @param {Function} sortingFunction
 * @return {Transaction} this
 */
Transaction.prototype.sortOutputs = function(sortingFunction) {
  var outs = sortingFunction(this.outputs);
  return this._newOutputOrder(outs);
};

/**
 * Sort this transaction's inputs, according to a given sorting function that
 * takes an array as argument and returns a new array, with the same elements
 * but with a different order.
 *
 * @param {Function} sortingFunction
 * @return {Transaction} this
 */
Transaction.prototype.sortInputs = function(sortingFunction) {
  this.inputs = sortingFunction(this.inputs);
  this._clearSignatures();
  return this;
};

Transaction.prototype._newOutputOrder = function(newOutputs) {
  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||
                          _.difference(this.outputs, newOutputs).length !== 0);
  if (isInvalidSorting) {
    throw new errors.Transaction.InvalidSorting();
  }

  if (!_.isUndefined(this._changeIndex)) {
    var changeOutput = this.outputs[this._changeIndex];
    this._changeIndex = _.findIndex(newOutputs, changeOutput);
  }

  this.outputs = newOutputs;
  return this;
};

Transaction.prototype.removeInput = function(txId, outputIndex) {
  var index;
  if (!outputIndex && _.isNumber(txId)) {
    index = txId;
  } else {
    index = _.findIndex(this.inputs, function(input) {
      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;
    });
  }
  if (index < 0 || index >= this.inputs.length) {
    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);
  }
  var input = this.inputs[index];
  this.inputs = _.without(this.inputs, input);
  this._inputAmount = undefined;
  this._updateChangeOutput();
};

/* Signature handling */

/**
 * Sign the transaction using one or more private keys.
 *
 * It tries to sign each input, verifying that the signature will be valid
 * (matches a public key).
 *
 * @param {Array|String|PrivateKey} privateKey
 * @param {number} sigtype
 * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.sign = function(privateKey, sigtype, signingMethod) {
  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');
  var self = this;
  if (_.isArray(privateKey)) {
    _.each(privateKey, function(privateKey) {
      self.sign(privateKey, sigtype, signingMethod);
    });
    return this;
  }
  _.each(this.getSignatures(privateKey, sigtype, signingMethod), function(signature) {
    self.applySignature(signature, signingMethod);
  });
  return this;
};

Transaction.prototype.getSignatures = function(privKey, sigtype, signingMethod) {
  privKey = new PrivateKey(privKey);
  sigtype = sigtype || Signature.SIGHASH_ALL;
  var transaction = this;
  var results = [];
  var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());
  _.each(this.inputs, function forEachInput(input, index) {
    _.each(input.getSignatures(transaction, privKey, index, sigtype, hashData, signingMethod), function(signature) {
      results.push(signature);
    });
  });
  return results;
};

/**
 * Add a signature to the transaction
 *
 * @param {Object} signature
 * @param {number} signature.inputIndex
 * @param {number} signature.sigtype
 * @param {PublicKey} signature.publicKey
 * @param {Signature} signature.signature
 * @param {String} signingMethod - 'ecdsa' to sign transaction
 * @return {Transaction} this, for chaining
 */
Transaction.prototype.applySignature = function(signature, signingMethod) {
  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);
  return this;
};

Transaction.prototype.isFullySigned = function() {
  _.each(this.inputs, function(input) {
    if (input.isFullySigned === Input.prototype.isFullySigned) {
      throw new errors.Transaction.UnableToVerifySignature(
        'Unrecognized script kind, or not enough information to execute script.' +
        'This usually happens when creating a transaction from a serialized transaction'
      );
    }
  });
  return _.every(_.map(this.inputs, function(input) {
    return input.isFullySigned();
  }));
};

Transaction.prototype.isValidSignature = function(signature, signingMethod) {
  var self = this;
  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
    throw new errors.Transaction.UnableToVerifySignature(
      'Unrecognized script kind, or not enough information to execute script.' +
      'This usually happens when creating a transaction from a serialized transaction'
    );
  }
  return this.inputs[signature.inputIndex].isValidSignature(self, signature, signingMethod);
};

/**
 * @param {String} signingMethod method used to sign - 'ecdsa' or 'schnorr' (future signing method)
 * @returns {bool} whether the signature is valid for this transaction input
 */
Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, signingMethod) {

  if (_.isUndefined(sigversion)) {
    sigversion = 0;
  }

  if (sigversion === 1) {
    var subscriptBuffer = subscript.toBuffer();
    var scriptCodeWriter = new BufferWriter();
    scriptCodeWriter.writeVarintNum(subscriptBuffer.length);
    scriptCodeWriter.write(subscriptBuffer);

    var satoshisBuffer;
    if (satoshis) {
      $.checkState(JSUtil.isNaturalNumber(satoshis));
      satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();
    } else {
      satoshisBuffer = this.inputs[nin].getSatoshisBuffer();
    }
    var verified = SighashWitness.verify(
      this,
      sig,
      pubkey,
      nin,
      scriptCodeWriter.toBuffer(),
      satoshisBuffer,
      signingMethod
    );
    return verified;
  }

  return Sighash.verify(this, sig, pubkey, nin, subscript, signingMethod);
};

/**
 * Check that a transaction passes basic sanity tests. If not, return a string
 * describing the error. This function contains the same logic as
 * CheckTransaction in bitcoin core.
 */
Transaction.prototype.verify = function() {
  // Basic checks that don't depend on any context
  if (this.inputs.length === 0) {
    return 'transaction txins empty';
  }

  if (this.outputs.length === 0) {
    return 'transaction txouts empty';
  }

  // Check for negative or overflow output values
  var valueoutbn = new BN(0);
  for (var i = 0; i < this.outputs.length; i++) {
    var txout = this.outputs[i];

    if (txout.invalidSatoshis()) {
      return 'transaction txout ' + i + ' satoshis is invalid';
    }
    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {
      return 'transaction txout ' + i + ' greater than MAX_MONEY';
    }
    valueoutbn = valueoutbn.add(txout._satoshisBN);
    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {
      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';
    }
  }

  // Size limits
  if (this.toBuffer().length > MAX_BLOCK_SIZE) {
    return 'transaction over the maximum block size';
  }

  // Check for duplicate inputs
  var txinmap = {};
  for (i = 0; i < this.inputs.length; i++) {
    var txin = this.inputs[i];

    var inputid = txin.prevTxId + ':' + txin.outputIndex;
    if (!_.isUndefined(txinmap[inputid])) {
      return 'transaction input ' + i + ' duplicate input';
    }
    txinmap[inputid] = true;
  }

  var isCoinbase = this.isCoinbase();
  if (isCoinbase) {
    var buf = this.inputs[0]._scriptBuffer;
    if (buf.length < 2 || buf.length > 100) {
      return 'coinbase transaction script size invalid';
    }
  } else {
    for (i = 0; i < this.inputs.length; i++) {
      if (this.inputs[i].isNull()) {
        return 'transaction input ' + i + ' has null input';
      }
    }
  }
  return true;
};

/**
 * Analogous to bitcoind's IsCoinBase function in transaction.h
 */
Transaction.prototype.isCoinbase = function() {
  return (this.inputs.length === 1 && this.inputs[0].isNull());
};

/**
 * Determines if this transaction can be replaced in the mempool with another
 * transaction that provides a sufficiently higher fee (RBF).
 */
Transaction.prototype.isRBF = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    var input = this.inputs[i];
    if (input.sequenceNumber < Input.MAXINT - 1) {
      return true;
    }
  }
  return false;
};

/**
 * Enable this transaction to be replaced in the mempool (RBF) if a transaction
 * includes a sufficiently higher fee. It will set the sequenceNumber to
 * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not
 * already enable RBF.
 */
Transaction.prototype.enableRBF = function() {
  for (var i = 0; i < this.inputs.length; i++) {
    var input = this.inputs[i];
    if (input.sequenceNumber >= Input.MAXINT - 1) {
      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;
    }
  }
  return this;
};

Transaction.prototype.setVersion = function(version) {
  $.checkArgument(
    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,
    'Wrong version number');
  this.version = version;
  return this;
};



module.exports = Transaction;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 466:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(272);

module.exports.PublicKey = __webpack_require__(1509);
module.exports.PublicKeyHash = __webpack_require__(1510);
module.exports.MultiSig = __webpack_require__(1511);
module.exports.MultiSigScriptHash = __webpack_require__(1512);


/***/ }),

/***/ 467:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

var errors = __webpack_require__(116);
var $ = __webpack_require__(36);

var UNITS = {
  'TIK'      : [1e8, 8],
  'mTIK'     : [1e5, 5],
  'uTIK'     : [1e2, 2],
  'bits'     : [1e2, 2],
  'satoshis' : [1, 0]
};

/**
 * Utility for handling and converting bitcoins units. The supported units are
 * TIK, mTIK, bits (also named uTIK) and satoshis. A unit instance can be created with an
 * amount and a unit code, or alternatively using static methods like {fromBTC}.
 * It also allows to be created from a fiat amount and the exchange rate, or
 * alternatively using the {fromFiat} static method.
 * You can consult for different representation of a unit instance using it's
 * {to} method, the fixed unit methods like {toSatoshis} or alternatively using
 * the unit accessors. It also can be converted to a fiat amount by providing the
 * corresponding TIK/fiat exchange rate.
 *
 * @example
 * ```javascript
 * var sats = Unit.fromBTC(1.3).toSatoshis();
 * var mili = Unit.fromBits(1.3).to(Unit.mTIK);
 * var bits = Unit.fromFiat(1.3, 350).bits;
 * var btc = new Unit(1.3, Unit.bits).TIK;
 * ```
 *
 * @param {Number} amount - The amount to be represented
 * @param {String|Number} code - The unit of the amount or the exchange rate
 * @returns {Unit} A new instance of an Unit
 * @constructor
 */
function Unit(amount, code) {
  if (!(this instanceof Unit)) {
    return new Unit(amount, code);
  }

  // convert fiat to TIK
  if (_.isNumber(code)) {
    if (code <= 0) {
      throw new errors.Unit.InvalidRate(code);
    }
    amount = amount / code;
    code = Unit.TIK;
  }

  this._value = this._from(amount, code);

  var self = this;
  var defineAccesor = function(key) {
    Object.defineProperty(self, key, {
      get: function() { return self.to(key); },
      enumerable: true,
    });
  };

  Object.keys(UNITS).forEach(defineAccesor);
}

Object.keys(UNITS).forEach(function(key) {
  Unit[key] = key;
});

/**
 * Returns a Unit instance created from JSON string or object
 *
 * @param {String|Object} json - JSON with keys: amount and code
 * @returns {Unit} A Unit instance
 */
Unit.fromObject = function fromObject(data){
  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');
  return new Unit(data.amount, data.code);
};

/**
 * Returns a Unit instance created from an amount in TIK
 *
 * @param {Number} amount - The amount in TIK
 * @returns {Unit} A Unit instance
 */
Unit.fromBTC = function(amount) {
  return new Unit(amount, Unit.TIK);
};

/**
 * Returns a Unit instance created from an amount in mTIK
 *
 * @param {Number} amount - The amount in mTIK
 * @returns {Unit} A Unit instance
 */
Unit.fromMillis = Unit.fromMilis = function(amount) {
  return new Unit(amount, Unit.mTIK);
};

/**
 * Returns a Unit instance created from an amount in bits
 *
 * @param {Number} amount - The amount in bits
 * @returns {Unit} A Unit instance
 */
Unit.fromMicros = Unit.fromBits = function(amount) {
  return new Unit(amount, Unit.bits);
};

/**
 * Returns a Unit instance created from an amount in satoshis
 *
 * @param {Number} amount - The amount in satoshis
 * @returns {Unit} A Unit instance
 */
Unit.fromSatoshis = function(amount) {
  return new Unit(amount, Unit.satoshis);
};

/**
 * Returns a Unit instance created from a fiat amount and exchange rate.
 *
 * @param {Number} amount - The amount in fiat
 * @param {Number} rate - The exchange rate TIK/fiat
 * @returns {Unit} A Unit instance
 */
Unit.fromFiat = function(amount, rate) {
  return new Unit(amount, rate);
};

Unit.prototype._from = function(amount, code) {
  if (!UNITS[code]) {
    throw new errors.Unit.UnknownCode(code);
  }
  return parseInt((amount * UNITS[code][0]).toFixed());
};

/**
 * Returns the value represented in the specified unit
 *
 * @param {String|Number} code - The unit code or exchange rate
 * @returns {Number} The converted value
 */
Unit.prototype.to = function(code) {
  if (_.isNumber(code)) {
    if (code <= 0) {
      throw new errors.Unit.InvalidRate(code);
    }
    return parseFloat((this.TIK * code).toFixed(2));
  }

  if (!UNITS[code]) {
    throw new errors.Unit.UnknownCode(code);
  }

  var value = this._value / UNITS[code][0];
  return parseFloat(value.toFixed(UNITS[code][1]));
};

/**
 * Returns the value represented in TIK
 *
 * @returns {Number} The value converted to TIK
 */
Unit.prototype.toTIK = function() {
  return this.to(Unit.TIK);
};

/**
 * Returns the value represented in mTIK
 *
 * @returns {Number} The value converted to mTIK
 */
Unit.prototype.toMillis = Unit.prototype.toMilis = function() {
  return this.to(Unit.mTIK);
};

/**
 * Returns the value represented in bits
 *
 * @returns {Number} The value converted to bits
 */
Unit.prototype.toMicros = Unit.prototype.toBits = function() {
  return this.to(Unit.bits);
};

/**
 * Returns the value represented in satoshis
 *
 * @returns {Number} The value converted to satoshis
 */
Unit.prototype.toSatoshis = function() {
  return this.to(Unit.satoshis);
};

/**
 * Returns the value represented in fiat
 *
 * @param {string} rate - The exchange rate between TIK/currency
 * @returns {Number} The value converted to satoshis
 */
Unit.prototype.atRate = function(rate) {
  return this.to(rate);
};

/**
 * Returns a the string representation of the value in satoshis
 *
 * @returns {string} the value in satoshis
 */
Unit.prototype.toString = function() {
  return this.satoshis + ' satoshis';
};

/**
 * Returns a plain object representation of the Unit
 *
 * @returns {Object} An object with the keys: amount and code
 */
Unit.prototype.toObject = Unit.prototype.toJSON = function toObject() {
  return {
    amount: this.TIK,
    code: Unit.TIK
  };
};

/**
 * Returns a string formatted for the console
 *
 * @returns {string} the value in satoshis
 */
Unit.prototype.inspect = function() {
  return '<Unit: ' + this.toString() + '>';
};

module.exports = Unit;


/***/ }),

/***/ 48:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var buffer = __webpack_require__(2);
var assert = __webpack_require__(12);

var js = __webpack_require__(59);
var $ = __webpack_require__(35);

function equals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  var length = a.length;
  for (var i = 0; i < length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

module.exports = {
  /**
   * Fill a buffer with a value.
   *
   * @param {Buffer} buffer
   * @param {number} value
   * @return {Buffer}
   */
  fill: function fill(buffer, value) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    $.checkArgumentType(value, 'number', 'value');
    var length = buffer.length;
    for (var i = 0; i < length; i++) {
      buffer[i] = value;
    }
    return buffer;
  },

  /**
   * Return a copy of a buffer
   *
   * @param {Buffer} original
   * @return {Buffer}
   */
  copy: function(original) {
    var buffer = Buffer.alloc(original.length);
    original.copy(buffer);
    return buffer;
  },

  /**
   * Returns true if the given argument is an instance of a buffer. Tests for
   * both node's Buffer and Uint8Array
   *
   * @param {*} arg
   * @return {boolean}
   */
  isBuffer: function isBuffer(arg) {
    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
  },

  /**
   * Returns a zero-filled byte array
   *
   * @param {number} bytes
   * @return {Buffer}
   */
  emptyBuffer: function emptyBuffer(bytes) {
    $.checkArgumentType(bytes, 'number', 'bytes');
    var result = Buffer.alloc(bytes);
    for (var i = 0; i < bytes; i++) {
      result.write('\0', i);
    }
    return result;
  },

  /**
   * Concatenates a buffer
   *
   * Shortcut for <tt>buffer.Buffer.concat</tt>
   */
  concat: buffer.Buffer.concat,

  equals: equals,
  equal: equals,

  /**
   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value
   *
   * @param {number} integer
   * @return {Buffer}
   */
  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
    $.checkArgumentType(integer, 'number', 'integer');
    return Buffer.from([integer & 0xff]);
  },

  /**
   * Transform a 4-byte integer into a Buffer of length 4.
   *
   * @param {number} integer
   * @return {Buffer}
   */
  integerAsBuffer: function integerAsBuffer(integer) {
    $.checkArgumentType(integer, 'number', 'integer');
    var bytes = [];
    bytes.push((integer >> 24) & 0xff);
    bytes.push((integer >> 16) & 0xff);
    bytes.push((integer >> 8) & 0xff);
    bytes.push(integer & 0xff);
    return Buffer.from(bytes);
  },

  /**
   * Transform the first 4 values of a Buffer into a number, in little endian encoding
   *
   * @param {Buffer} buffer
   * @return {number}
   */
  integerFromBuffer: function integerFromBuffer(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
  },

  /**
   * Transforms the first byte of an array into a number ranging from -128 to 127
   * @param {Buffer} buffer
   * @return {number}
   */
  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer[0];
  },

  /**
   * Transforms a buffer into a string with a number in hexa representation
   *
   * Shorthand for <tt>buffer.toString('hex')</tt>
   *
   * @param {Buffer} buffer
   * @return {string}
   */
  bufferToHex: function bufferToHex(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer.toString('hex');
  },

  /**
   * Reverse a buffer
   * @param {Buffer} param
   * @return {Buffer}
   */
  reverse: function reverse(param) {
    return (Buffer.from(param)).reverse();
  },
};

module.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);
module.exports.EMPTY_BUFFER = Buffer.alloc(0);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 49:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var buffer = __webpack_require__(2);
var assert = __webpack_require__(12);

var js = __webpack_require__(60);
var $ = __webpack_require__(36);

function equals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  var length = a.length;
  for (var i = 0; i < length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

module.exports = {
  /**
   * Fill a buffer with a value.
   *
   * @param {Buffer} buffer
   * @param {number} value
   * @return {Buffer}
   */
  fill: function fill(buffer, value) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    $.checkArgumentType(value, 'number', 'value');
    var length = buffer.length;
    for (var i = 0; i < length; i++) {
      buffer[i] = value;
    }
    return buffer;
  },

  /**
   * Return a copy of a buffer
   *
   * @param {Buffer} original
   * @return {Buffer}
   */
  copy: function(original) {
    var buffer = Buffer.alloc(original.length);
    original.copy(buffer);
    return buffer;
  },

  /**
   * Returns true if the given argument is an instance of a buffer. Tests for
   * both node's Buffer and Uint8Array
   *
   * @param {*} arg
   * @return {boolean}
   */
  isBuffer: function isBuffer(arg) {
    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
  },

  /**
   * Returns a zero-filled byte array
   *
   * @param {number} bytes
   * @return {Buffer}
   */
  emptyBuffer: function emptyBuffer(bytes) {
    $.checkArgumentType(bytes, 'number', 'bytes');
    var result = Buffer.alloc(bytes);
    for (var i = 0; i < bytes; i++) {
      result.write('\0', i);
    }
    return result;
  },

  /**
   * Concatenates a buffer
   *
   * Shortcut for <tt>buffer.Buffer.concat</tt>
   */
  concat: buffer.Buffer.concat,

  equals: equals,
  equal: equals,

  /**
   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value
   *
   * @param {number} integer
   * @return {Buffer}
   */
  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
    $.checkArgumentType(integer, 'number', 'integer');
    return Buffer.from([integer & 0xff]);
  },

  /**
   * Transform a 4-byte integer into a Buffer of length 4.
   *
   * @param {number} integer
   * @return {Buffer}
   */
  integerAsBuffer: function integerAsBuffer(integer) {
    $.checkArgumentType(integer, 'number', 'integer');
    var bytes = [];
    bytes.push((integer >> 24) & 0xff);
    bytes.push((integer >> 16) & 0xff);
    bytes.push((integer >> 8) & 0xff);
    bytes.push(integer & 0xff);
    return Buffer.from(bytes);
  },

  /**
   * Transform the first 4 values of a Buffer into a number, in little endian encoding
   *
   * @param {Buffer} buffer
   * @return {number}
   */
  integerFromBuffer: function integerFromBuffer(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
  },

  /**
   * Transforms the first byte of an array into a number ranging from -128 to 127
   * @param {Buffer} buffer
   * @return {number}
   */
  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer[0];
  },

  /**
   * Transforms a buffer into a string with a number in hexa representation
   *
   * Shorthand for <tt>buffer.toString('hex')</tt>
   *
   * @param {Buffer} buffer
   * @return {string}
   */
  bufferToHex: function bufferToHex(buffer) {
    $.checkArgumentType(buffer, 'Buffer', 'buffer');
    return buffer.toString('hex');
  },

  /**
   * Reverse a buffer
   * @param {Buffer} param
   * @return {Buffer}
   */
  reverse: function reverse(param) {
    return (Buffer.from(param)).reverse();
  },
};

module.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);
module.exports.EMPTY_BUFFER = Buffer.alloc(0);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 492:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DownloadProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let DownloadProvider = class DownloadProvider {
    constructor(logger) {
        this.logger = logger;
        this.logger.debug('DownloadProvider initialized');
    }
    download(ew, fileName) {
        return new Promise((resolve) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(1000).toPromise();
            let a = document.createElement('a');
            let blob = this.newBlob(ew, 'text/plain;charset=utf-8');
            let url = window.URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
            return resolve();
        }));
    }
    newBlob(data, datatype) {
        let out;
        try {
            this.logger.debug('Trying to blob data');
            out = new Blob([data], {
                type: datatype
            });
        }
        catch (e) {
            if (e.name == 'InvalidStateError') {
                // InvalidStateError (tested on FF13 WinXP)
                this.logger.debug('Invalid state Error: Trying to blob data again');
                out = new Blob([data], {
                    type: datatype
                });
            }
            else {
                // We're screwed, blob constructor unsupported entirely
                this.logger.error('Error: blob constructor unsupported entirely');
            }
        }
        return out;
    }
};
DownloadProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], DownloadProvider);

//# sourceMappingURL=download.js.map

/***/ }),

/***/ 494:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_qr_scanner__ = __webpack_require__(795);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(13);





// Providers



let ScanProvider = class ScanProvider {
    constructor(qrScanner, platform, logger, events, translate, errorsProvider) {
        this.qrScanner = qrScanner;
        this.platform = platform;
        this.logger = logger;
        this.events = events;
        this.translate = translate;
        this.errorsProvider = errorsProvider;
        this.isDesktop = !this.platform.isCordova;
        this.isAvailable = true;
        this.hasPermission = false;
        this.isDenied = false;
        this.isRestricted = false;
        this.canEnableLight = false;
        this.canChangeCamera = false;
        this.canOpenSettings = false;
        this.backCamera = true;
        this.initializeStarted = false;
        this.initializeCompleted = false;
        this.scannerVisible = false;
        this.lightEnabled = false;
        this.frontCameraEnabled = false;
    }
    checkCapabilities(status) {
        this.logger.info('scannerService is reviewing platform capabilities...');
        // Permission can be assumed on the desktop builds
        this.hasPermission = this.isDesktop || status.authorized ? true : false;
        this.isDenied = status.denied ? true : false;
        this.isRestricted = status.restricted ? true : false;
        this.canEnableLight = status.canEnableLight ? true : false;
        this.canChangeCamera = status.canChangeCamera ? true : false;
        this.canOpenSettings = status.canOpenSettings ? true : false;
        this.logCapabilities();
    }
    orIsNot(bool) {
        return bool ? '' : 'not ';
    }
    logCapabilities() {
        this.logger.debug('A camera is ' + this.orIsNot(this.isAvailable) + 'available to this app.');
        var access = 'not authorized';
        if (this.hasPermission)
            access = 'authorized';
        if (this.isDenied)
            access = 'denied';
        if (this.isRestricted)
            access = 'restricted';
        this.logger.debug('Camera access is ' + access + '.');
        this.logger.debug('Support for opening device settings is ' +
            this.orIsNot(this.canOpenSettings) +
            'available on this platform.');
        this.logger.debug('A light is ' +
            this.orIsNot(this.canEnableLight) +
            'available on this platform.');
        this.logger.debug('A second camera is ' +
            this.orIsNot(this.canChangeCamera) +
            'available on this platform.');
    }
    /**
     * Immediately return known capabilities of the current platform.
     */
    getCapabilities() {
        return {
            isAvailable: this.isAvailable,
            hasPermission: this.hasPermission,
            isDenied: this.isDenied,
            isRestricted: this.isRestricted,
            canEnableLight: this.canEnableLight,
            canChangeCamera: this.canChangeCamera,
            canOpenSettings: this.canOpenSettings
        };
    }
    /**
     * If camera access has been granted, pre-initialize the QRScanner. This method
     * can be safely called before the scanner is visible to improve perceived
     * scanner loading times.
     *
     * The `status` of QRScanner is returned to the callback.
     */
    gentleInitialize() {
        return new Promise(resolve => {
            if (this.initializeStarted && !this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                });
                return resolve();
            }
            this.initializeStarted = true;
            this.logger.debug('Trying to pre-initialize QRScanner.');
            if (!this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.checkCapabilities(status);
                    if (status.authorized) {
                        this.logger.debug('Camera permission already granted.');
                        this.initialize().then(() => {
                            return resolve();
                        });
                    }
                    else {
                        this.logger.debug('QRScanner not authorized, waiting to initalize.');
                        this.completeInitialization(status);
                        return resolve();
                    }
                });
            }
            else {
                this.logger.debug('To avoid flashing the privacy light, we do not pre-initialize the camera on desktop.');
                return resolve();
            }
        });
    }
    reinitialize() {
        this.initializeCompleted = false;
        this.qrScanner.destroy();
        this.initialize();
    }
    initialize() {
        return new Promise(resolve => {
            this.logger.info('Initializing scanner...');
            this.qrScanner
                .prepare()
                .then(status => {
                this.completeInitialization(status);
                return resolve();
            })
                .catch(err => {
                this.isAvailable = false;
                this.logger.error(err);
                if (err && err.name === 'CAMERA_ACCESS_DENIED') {
                    const msg = this.translate.instant('Check the app camera permissions under your phone settings');
                    const title = this.translate.instant('Camera access denied');
                    this.errorsProvider.showDefaultError(msg, title);
                }
                // does not return `status` if there is an error
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                    return resolve();
                });
            });
        });
    }
    completeInitialization(status) {
        this.checkCapabilities(status);
        this.initializeCompleted = true;
        this.events.publish('scannerServiceInitialized');
    }
    isInitialized() {
        return this.initializeCompleted;
    }
    isInitializeStarted() {
        return this.initializeStarted;
    }
    /**
     * (Re)activate the QRScanner, and cancel the timeouts if present.
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    activate() {
        return new Promise(resolve => {
            this.logger.info('Activating scanner...');
            this.qrScanner.show().then(status => {
                this.initializeCompleted = true;
                this.checkCapabilities(status);
                return resolve();
            });
        });
    }
    /**
     * Start a new scan.
     */
    scan() {
        return new Promise(resolve => {
            this.logger.info('Scanning...');
            let scanSub = this.qrScanner.scan().subscribe((text) => {
                this.logger.debug('Scan success');
                scanSub.unsubscribe(); // stop scanning
                return resolve(text);
            });
        });
    }
    pausePreview() {
        this.qrScanner.pausePreview();
    }
    resumePreview() {
        this.qrScanner.resumePreview();
    }
    /**
     * Deactivate the QRScanner. To balance user-perceived performance and power
     * consumption, this kicks off a countdown which will "sleep" the scanner
     * after a certain amount of time.
     *
     * The `status` of QRScanner is passed to the callback when deactivation
     * is complete.
     */
    deactivate() {
        this.logger.info('Deactivating scanner...');
        if (this.lightEnabled) {
            this.qrScanner.disableLight();
            this.lightEnabled = false;
        }
        this.hide();
        this.destroy();
    }
    // Natively hide the QRScanner's preview
    // On mobile platforms, this can reduce GPU/power usage
    // On desktop, this fully turns off the camera (and any associated privacy lights)
    hide() {
        this.qrScanner.hide();
    }
    // Reduce QRScanner power/processing consumption by the maximum amount
    destroy() {
        this.qrScanner.destroy();
    }
    /**
     * Toggle the device light (if available).
     *
     * The callback receives a boolean which is `true` if the light is enabled.
     */
    toggleLight() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling light...');
            if (this.lightEnabled) {
                this.qrScanner
                    .disableLight()
                    .then(() => {
                    this.lightEnabled = false;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (disableLight)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .enableLight()
                    .then(() => {
                    this.lightEnabled = true;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (enableLight)', err);
                    return reject(err);
                });
            }
        });
    }
    /**
     * Switch cameras (if a second camera is available).
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    toggleCamera() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling camera...');
            if (this.frontCameraEnabled) {
                this.qrScanner
                    .useBackCamera()
                    .then(() => {
                    this.frontCameraEnabled = false;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useBackCamera)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .useFrontCamera()
                    .then(() => {
                    this.frontCameraEnabled = true;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useFrontCamera)', err);
                    return reject(err);
                });
            }
        });
    }
    openSettings() {
        this.logger.info('Attempting to open device settings...');
        this.qrScanner.openSettings();
    }
};
ScanProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_qr_scanner__["a" /* QRScanner */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__errors_errors__["a" /* ErrorsProvider */]])
], ScanProvider);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 495:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxConfirmNotificationProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__ = __webpack_require__(20);



// providers

let TxConfirmNotificationProvider = class TxConfirmNotificationProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.debug('TxConfirmNotificationProvider initialized');
    }
    checkIfEnabled(txid) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxConfirmNotification(txid)
                .then(res => {
                return resolve(!!res);
            })
                .catch(err => {
                this.logger.error(err);
                return reject(err);
            });
        });
    }
    subscribe(client, opts) {
        client.txConfirmationSubscribe(opts, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider
                .setTxConfirmNotification(opts.txid, true)
                .catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
    unsubscribe(client, txId) {
        client.txConfirmationUnsubscribe(txId, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider.removeTxConfirmNotification(txId).catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
};
TxConfirmNotificationProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__["b" /* PersistenceProvider */]])
], TxConfirmNotificationProvider);

//# sourceMappingURL=tx-confirm-notification.js.map

/***/ }),

/***/ 496:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletConnectProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__walletconnect_client__ = __webpack_require__(1978);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__walletconnect_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__walletconnect_client__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__walletconnect_utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_eth_sig_util__ = __webpack_require__(2002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_eth_sig_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_eth_sig_util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__replace_parameters_replace_parameters__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__web3_providers_web3_providers__ = __webpack_require__(968);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_wallet_connect_web3_providers_web3_providers__ = __webpack_require__(968);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__incoming_data_incoming_data__ = __webpack_require__(126);
























let WalletConnectProvider = class WalletConnectProvider {
    constructor(logger, translate, homeIntegrationsProvider, configProvider, analyticsProvider, replaceParametersProvider, popupProvider, persistenceProvider, profileProvider, errorsProvider, onGoingProcessProvider, walletProvider, events, incomingDataProvider, keyProvider, bwcProvider) {
        this.logger = logger;
        this.translate = translate;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.analyticsProvider = analyticsProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.profileProvider = profileProvider;
        this.errorsProvider = errorsProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.events = events;
        this.incomingDataProvider = incomingDataProvider;
        this.keyProvider = keyProvider;
        this.bwcProvider = bwcProvider;
        this.walletConnector = null;
        this.requests = [];
        this.connected = false;
        this.activeChainId = 1;
        this.logger.debug('WalletConnect Provider initialized');
    }
    signTypedData(data, wallet) {
        const key = this.keyProvider.getKey(wallet.keyId).get();
        const bitcore = this.bwcProvider.getBitcore();
        const xpriv = new bitcore.HDPrivateKey(key.xPrivKey);
        const priv = xpriv.deriveChild("m/44'/60'/0'/0/0").privateKey;
        const result = Object(__WEBPACK_IMPORTED_MODULE_5_eth_sig_util__["signTypedData_v4"])(Buffer.from(priv.toString(), 'hex'), {
            data
        });
        return result;
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'walletConnect',
            title: this.translate.instant('WalletConnect'),
            icon: 'assets/img/wallet-connect.svg',
            showIcon: true,
            logo: null,
            logoWidth: '110',
            background: 'linear-gradient(to bottom,rgba(60, 63, 69, 1) 0,rgba(45, 47, 51, 1) 100%)',
            page: 'WalletConnectPage',
            show: !!this.configProvider.get().showIntegration['walletConnect'],
            type: 'external-services'
        });
    }
    retrieveWalletConnector(walletConnectData) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (walletConnectData) {
                const session = walletConnectData.session;
                const walletId = walletConnectData.walletId;
                this.logger.debug('retrieving session');
                this.walletConnector = new __WEBPACK_IMPORTED_MODULE_3__walletconnect_client___default.a({ session });
                const { connected, accounts, peerMeta } = this.walletConnector;
                this.address = accounts[0]; // TODO handle multiple accounts
                this.activeChainId = this.walletConnector.chainId;
                this.connected = connected;
                this.peerMeta = peerMeta;
                this.walletId = walletId;
                this.subscribeToEvents();
            }
        });
    }
    initWalletConnect(uri) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            try {
                this.onGoingProcessProvider.set('Initializing');
                this.walletConnector = new __WEBPACK_IMPORTED_MODULE_3__walletconnect_client___default.a({
                    uri
                });
                if (!this.walletConnector.connected) {
                    this.logger.debug('walletConnector.createSession');
                    yield this.walletConnector.createSession();
                }
                setTimeout(() => {
                    if (!this.peerMeta) {
                        this.errorsProvider.showDefaultError(this.translate.instant('Dapp not responding. Try scanning a new QR code'), this.translate.instant('Could not connect'));
                    }
                    this.onGoingProcessProvider.clear();
                }, 10000);
                this.subscribeToEvents();
            }
            catch (error) {
                this.onGoingProcessProvider.clear();
                this.errorsProvider.showDefaultError(error, this.translate.instant('Error'));
            }
        });
    }
    getConnectionData() {
        return {
            connected: this.connected,
            peerMeta: this.peerMeta,
            walletId: this.walletId,
            requests: this.requests,
            address: this.address,
            activeChainId: this.activeChainId
        };
    }
    setAccountInfo(wallet) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.activeChainId =
                wallet.network === 'livenet' ? __WEBPACK_IMPORTED_MODULE_21__providers_wallet_connect_web3_providers_web3_providers__["b" /* MAINNET_CHAIN_ID */] : __WEBPACK_IMPORTED_MODULE_21__providers_wallet_connect_web3_providers_web3_providers__["a" /* KOVAN_CHAIN_ID */];
            this.walletId = wallet.credentials.walletId;
            try {
                this.address = yield this.walletProvider.getAddress(wallet, false);
            }
            catch (error) {
                this.errorsProvider.showDefaultError(error, this.translate.instant('Error getting address'));
            }
        });
    }
    subscribeToEvents() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!this.walletConnector)
                return;
            this.walletConnector.on('session_request', (error, payload) => {
                this.logger.debug('walletConnector.on("session_request")');
                if (error) {
                    throw error;
                }
                this.peerMeta = payload.params[0].peerMeta;
                this.openConnectPopUpConfirmation(this.peerMeta);
            });
            this.walletConnector.on('session_update', (error, _payload) => {
                this.logger.debug('walletConnector.on("session_update")');
                if (error) {
                    throw error;
                }
            });
            this.walletConnector.on('call_request', (error, payload) => {
                this.logger.debug('walletConnector.on("call_request")');
                if (error) {
                    throw error;
                }
                // Sample Request
                // {
                // id: 1601004477618457
                // jsonrpc: "2.0"
                // method: "eth_sendTransaction"
                // params: Array(1)
                // 0:
                // data: "0x095ea7b30000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                // from: "0xf4e3dfd2c9a951928f8fd53a782e364945047d11"
                // gas: "0xd78d"
                // to: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
                // }
                this.analyticsProvider.logEvent('wallet_connect_call_request', {});
                const _payload = this.refEthereumRequests(payload);
                const alreadyExist = __WEBPACK_IMPORTED_MODULE_22_lodash__["some"](this.requests, request => {
                    return request.id === _payload;
                });
                if (!alreadyExist) {
                    this.requests.push(_payload);
                    this.requests = __WEBPACK_IMPORTED_MODULE_22_lodash__["uniqBy"](this.requests, 'id');
                    this.events.publish('Update/Requests', this.requests);
                    this.incomingDataProvider.redir('wc:');
                }
            });
            this.walletConnector.on('connect', (error, _payload) => {
                this.logger.debug('walletConnector.on("connect")');
                if (error) {
                    throw error;
                }
                this.analyticsProvider.logEvent('wallet_connect_connection_success', {});
                this.connected = true;
                this.events.publish('Update/ConnectionData');
            });
            this.walletConnector.on('disconnect', (error, _payload) => {
                this.logger.debug('walletConnector.on("disconnect")');
                if (error) {
                    throw error;
                }
                this.connected = false;
                this.events.publish('Update/ConnectionData');
            });
        });
    }
    getChainData(chainId) {
        const chainData = __WEBPACK_IMPORTED_MODULE_20__web3_providers_web3_providers__["c" /* supportedProviders */].filter((chain) => chain.chain_id === chainId)[0];
        if (!chainData) {
            throw new Error('ChainId missing or not supported');
        }
        return chainData;
    }
    openConnectPopUpConfirmation(peerMeta) {
        const wallet = this.profileProvider.getWallet(this.walletId);
        const title = this.translate.instant('Session Request');
        const message = this.replaceParametersProvider.replace(this.translate.instant(`{{peerMetaName}} ({{peerMetaUrl}}) is trying to connect to {{walletName}}`), {
            peerMetaName: peerMeta.name,
            peerMetaUrl: peerMeta.url,
            walletName: wallet.name
        });
        const okText = this.translate.instant('Approve');
        const cancelText = this.translate.instant('Reject');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.approveSession();
            }
            else {
                this.rejectSession();
            }
        });
    }
    approveSession() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.walletConnector) {
                this.logger.debug('walletConnector.approveSession');
                this.walletConnector.approveSession({
                    chainId: this.activeChainId,
                    accounts: [this.address]
                });
                const walletConnectData = {
                    session: this.walletConnector.session,
                    walletId: this.walletId
                };
                yield this.persistenceProvider.setWalletConnect(walletConnectData);
            }
        });
    }
    approveRequest(id, result) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.walletConnector) {
                this.logger.debug('walletConnector.approveRequest');
                this.walletConnector.approveRequest({
                    id,
                    result
                });
                this.closeRequest(id);
                this.analyticsProvider.logEvent('wallet_connect_action_completed', {});
            }
        });
    }
    rejectSession() {
        if (this.walletConnector) {
            this.logger.debug('walletConnector.rejectSession');
            this.walletConnector.rejectSession();
        }
    }
    refEthereumRequests(payload) {
        this.logger.debug(`refEthereumRequests ${payload.method}`);
        switch (payload.method) {
            case 'eth_sendTransaction':
                payload.params[0].gas = payload.params[0].gas
                    ? Object(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__["convertHexToNumber"])(payload.params[0].gas)
                    : null;
                payload.params[0].gasLimit = payload.params[0].gasLimit
                    ? Object(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__["convertHexToNumber"])(payload.params[0].gasLimit)
                    : null;
                payload.params[0].gasPrice = payload.params[0].gasPrice
                    ? Object(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__["convertHexToNumber"])(payload.params[0].gasPrice)
                    : null;
                payload.params[0].nonce = payload.params[0].nonce
                    ? Object(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__["convertHexToNumber"])(payload.params[0].nonce)
                    : null;
                payload.params[0].value = payload.params[0].value
                    ? Object(__WEBPACK_IMPORTED_MODULE_4__walletconnect_utils__["convertHexToNumber"])(payload.params[0].value)
                    : 0;
                break;
            case 'eth_signTypedData':
                // nothing
                break;
            default:
                this.errorsProvider.showDefaultError(this.translate.instant(`Not supported method: ${payload.method}`), this.translate.instant('Error'));
                break;
        }
        return payload;
    }
    killSession() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.walletConnector) {
                this.logger.debug('walletConnector.killSession');
                this.walletConnector.killSession();
                yield this.persistenceProvider.removeWalletConnect();
                this.peerMeta = null;
                this.connected = false;
            }
        });
    }
    closeRequest(id) {
        const filteredRequests = this.requests.filter(request => request.id !== id);
        this.requests = filteredRequests;
        this.events.publish('Update/Requests', this.requests);
    }
    rejectRequest(request) {
        if (this.walletConnector) {
            try {
                this.logger.debug('walletConnector.rejectRequest');
                this.walletConnector.rejectRequest({
                    id: request.id,
                    error: { message: 'Failed or Rejected Request' }
                });
            }
            catch (error) {
                this.errorsProvider.showDefaultError(error, this.translate.instant('Error'));
            }
        }
        this.closeRequest(request.id);
    }
};
WalletConnectProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_18__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_16__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_15__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_17__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_13__errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_14__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_19__wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_6_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_23__incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_12__bwc_bwc__["a" /* BwcProvider */]])
], WalletConnectProvider);

//# sourceMappingURL=wallet-connect.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2).Buffer))

/***/ }),

/***/ 499:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_create_wallet_create_wallet__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);




// pages



// providers



let AddWalletPage = class AddWalletPage {
    constructor(navCtrl, logger, profileProvider, navParams, translate) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.navParams = navParams;
        this.translate = translate;
        this.fromEthCard = this.navParams.data.fromEthCard;
        this.title = this.fromEthCard
            ? this.translate.instant('Select Key to add ETH Wallet to')
            : this.translate.instant('Select Key');
        const opts = {
            canAddNewAccount: true,
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        this.walletsGroups = __WEBPACK_IMPORTED_MODULE_9_lodash__["values"](__WEBPACK_IMPORTED_MODULE_9_lodash__["groupBy"](wallets, 'keyId'));
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddWalletPage');
    }
    goToAddPage(keyId) {
        if (this.navParams.data.isCreate) {
            if (this.fromEthCard) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__add_create_wallet_create_wallet__["a" /* CreateWalletPage */], {
                    isShared: false,
                    coin: 'eth',
                    keyId
                });
            }
            else {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__["a" /* SelectCurrencyPage */], {
                    isShared: this.navParams.data.isShared,
                    isZeroState: keyId ? false : true,
                    keyId
                });
            }
        }
        else if (this.navParams.data.isJoin) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__["a" /* JoinWalletPage */], {
                keyId,
                url: this.navParams.data.url
            });
        }
    }
};
AddWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-add-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add-wallet/add-wallet.html"*/'<wide-header-page title="{{ title }}">\n  <div page-content>\n    <ion-list class="bp-list">\n      <button ion-item *ngFor="let walletsGroup of walletsGroups; let i = index" (click)="goToAddPage(walletsGroup[0].keyId)">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-key.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          <div class="main-label" *ngIf="walletsGroup[0].canSign">{{profileProvider.getWalletGroup(walletsGroup[0].keyId).name}}</div>\n          <div class="main-label" *ngIf="!walletsGroup[0].canSign" translate>Read Only Wallets</div>\n        </ion-label>\n        <ion-note item-end>\n          {{walletsGroup.length}} Wallet<span *ngIf="walletsGroup.length > 1">s</span>\n        </ion-note>\n      </button>\n    </ion-list>\n\n    <label-tip *ngIf="walletsGroups && walletsGroups[0]" type="info" class="no-arrowhead">\n      <span label-tip-title translate>Don\'t see your Key?</span>\n      <div label-tip-body>\n        <span translate>\n          Legacy wallets created before 9/15 can\'t support additional wallets being added.\n        </span>\n      </div>\n    </label-tip>\n\n    <button ion-button class="button-standard button-secondary" (click)="goToAddPage()">\n      <span translate>Create New Key</span>\n    </button>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add-wallet/add-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], AddWalletPage);

//# sourceMappingURL=add-wallet.js.map

/***/ }),

/***/ 500:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CreateWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_push_notifications_push_notifications__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__add_copayers_copayers__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__add_create_eth_multisig_create_eth_multisig__ = __webpack_require__(971);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__settings_key_settings_key_onboarding_key_onboarding__ = __webpack_require__(389);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__wallet_details_wallet_details__ = __webpack_require__(144);






// Providers














// Pages




let CreateWalletPage = class CreateWalletPage {
    constructor(actionSheetProvider, currencyProvider, navCtrl, navParams, fb, profileProvider, configProvider, derivationPathHelperProvider, onGoingProcessProvider, logger, walletProvider, translate, events, pushNotificationsProvider, externalLinkProvider, bwcErrorProvider, bwcProvider, modalCtrl, persistenceProvider, errorsProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.fb = fb;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.modalCtrl = modalCtrl;
        this.persistenceProvider = persistenceProvider;
        this.errorsProvider = errorsProvider;
        /* For compressed keys, m*73 + n*34 <= 496 */
        this.COPAYER_PAIR_LIMITS = {
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 4,
            6: 4,
            7: 3,
            8: 3,
            9: 2,
            10: 2,
            11: 1,
            12: 1
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.isShared = this.navParams.get('isShared');
        this.coin = this.navParams.get('coin');
        this.coinName = this.currencyProvider.getCoinName(this.coin);
        this.keyId = this.navParams.get('keyId');
        this.defaults = this.configProvider.getDefaults();
        this.multisigAddresses = [];
        this.tc = this.isShared ? this.defaults.wallet.totalCopayers : 1;
        this.copayers = __WEBPACK_IMPORTED_MODULE_5_lodash__["range"](2, this.defaults.limits.totalCopayers + 1);
        this.derivationPathByDefault = this.isShared
            ? this.coin === 'bch'
                ? this.derivationPathHelperProvider.defaultMultisigBCH
                : this.derivationPathHelperProvider.defaultMultisigBTC
            : this.bwcProvider.getCore().Deriver.pathFor(this.coin, 'livenet');
        this.derivationPathForTestnet = this.bwcProvider
            .getCore()
            .Deriver.pathFor(this.coin, 'testnet');
        this.showAdvOpts = false;
        const walletName = this.currencyProvider.getCoinName(this.coin) +
            (this.isShared ? ' Multisig' : '');
        this.createForm = this.fb.group({
            walletName: [walletName, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required],
            myName: [null],
            totalCopayers: [1],
            requiredCopayers: [1],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [this.derivationPathByDefault],
            testnetEnabled: [false],
            useNativeSegwit: [false],
            singleAddress: [false],
            coin: [null, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]
        });
        this.createForm.controls['coin'].setValue(this.coin);
        if (this.coin === 'btc' || this.coin === 'edu' || this.coin === 'tik')
            this.createForm.controls['useNativeSegwit'].setValue(true);
        this.showKeyOnboarding = this.navParams.data.showKeyOnboarding;
        this.setTotalCopayers(this.tc);
        this.updateRCSelect(this.tc);
        this.updateSeedSourceSelect();
    }
    ngOnInit() {
        if (this.isShared) {
            if (this.coin.toLowerCase() == 'eth') {
                this.showPairedWalletSelector();
            }
            else {
                this.createForm.get('myName').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
            }
        }
    }
    setTotalCopayers(n) {
        this.createForm.controls['totalCopayers'].setValue(n);
    }
    updateRCSelect(n) {
        const maxReq = this.COPAYER_PAIR_LIMITS[n];
        this.signatures = __WEBPACK_IMPORTED_MODULE_5_lodash__["range"](1, maxReq + 1);
        this.createForm.controls['requiredCopayers'].setValue(Math.min(Math.trunc(n / 2 + 1), maxReq));
    }
    isSingleAddress() {
        return this.currencyProvider.isSingleAddress(this.coin);
    }
    updateSeedSourceSelect() {
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
        this.createForm.controls['selectedSeed'].setValue(this.seedOptions[0].id); // new or set
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.createForm
                .get('recoveryPhrase')
                .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]);
        }
        else {
            this.createForm.get('recoveryPhrase').setValidators(null);
        }
        this.createForm.controls['selectedSeed'].setValue(seed); // new or set
        if (this.createForm.controls['testnet'])
            this.createForm.controls['testnet'].setValue(false);
        if (this.createForm.controls['useNativeSegwit'])
            this.createForm.controls['useNativeSegwit'].setValue(false);
        this.createForm.controls['derivationPath'].setValue(this.derivationPathByDefault);
        this.createForm.controls['recoveryPhrase'].setValue(null);
    }
    setDerivationPath() {
        const path = this.createForm.value.testnet
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.createForm.controls['derivationPath'].setValue(path);
    }
    setOptsAndCreate() {
        const opts = {
            keyId: this.keyId,
            name: this.createForm.value.walletName,
            m: this.createForm.value.requiredCopayers,
            n: this.createForm.value.totalCopayers,
            myName: this.createForm.value.totalCopayers > 1
                ? this.createForm.value.myName
                : null,
            networkName: this.createForm.value.testnetEnabled ? 'testnet' : 'livenet',
            useNativeSegwit: this.createForm.value.useNativeSegwit,
            bwsurl: this.createForm.value.bwsURL,
            singleAddress: this.currencyProvider.isSingleAddress(this.createForm.value.coin)
                ? true
                : this.createForm.value.singleAddress,
            coin: this.createForm.value.coin
        };
        const setSeed = this.createForm.value.selectedSeed == 'set';
        if (setSeed) {
            const words = this.createForm.value.recoveryPhrase || '';
            if (words.indexOf(' ') == -1 &&
                words.indexOf('prv') == 1 &&
                words.length > 108) {
                opts.extendedPrivateKey = words;
            }
            else {
                opts.mnemonic = words;
            }
            const derivationPath = this.createForm.value.derivationPath;
            opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
            opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
            opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
            // set opts.useLegacyPurpose
            if (this.derivationPathHelperProvider.parsePath(this.createForm.value.derivationPath).purpose == "44'" &&
                opts.n > 1) {
                opts.useLegacyPurpose = true;
                this.logger.debug('Using 44 for Multisig');
            }
            // set opts.useLegacyCoinType
            if (this.coin == 'bch' &&
                this.derivationPathHelperProvider.parsePath(this.createForm.value.derivationPath).coinCode == "0'") {
                opts.useLegacyCoinType = true;
                this.logger.debug('Using 0 for BCH creation');
            }
            if (!opts.networkName ||
                !opts.derivationStrategy ||
                !Number.isInteger(opts.account)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path');
                this.errorsProvider.showDefaultError(subtitle, title);
                return;
            }
        }
        if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.errorsProvider.showDefaultError(subtitle, title);
            return;
        }
        if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.createForm.value.derivationPath, this.coin)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path for selected coin');
            this.errorsProvider.showDefaultError(subtitle, title);
            return;
        }
        if (this.showKeyOnboarding) {
            this.showKeyOnboardingSlides(opts);
        }
        else {
            this.create(opts);
        }
    }
    showKeyOnboardingSlides(opts) {
        this.logger.debug('Showing key onboarding');
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_22__settings_key_settings_key_onboarding_key_onboarding__["a" /* KeyOnboardingPage */], null, {
            showBackdrop: false,
            enableBackdropDismiss: false
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.create(opts);
        });
        this.persistenceProvider.setKeyOnboardingFlag();
    }
    create(opts) {
        this.onGoingProcessProvider.set('creatingWallet');
        opts['keyId'] = this.keyId;
        this.profileProvider
            .createWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            if (this.createForm.value.selectedSeed == 'set') {
                this.profileProvider.setBackupGroupFlag(wallet.credentials.keyId);
                this.profileProvider.setWalletBackup(wallet.credentials.walletId);
            }
            this.navCtrl.popToRoot().then(() => {
                this.events.publish('Local/FetchWallets');
                setTimeout(() => {
                    if (wallet.isComplete()) {
                        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_23__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                            walletId: wallet.credentials.walletId
                        });
                    }
                    else {
                        const copayerModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_20__add_copayers_copayers__["a" /* CopayersPage */], {
                            walletId: wallet.credentials.walletId
                        }, {
                            cssClass: 'wallet-details-modal'
                        });
                        copayerModal.present();
                    }
                }, 1000);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                this.logger.error('Create: could not create wallet', err);
                if (err.message === 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    const title = this.translate.instant('Error');
                    err = this.bwcErrorProvider.msg(err);
                    this.errorsProvider.showDefaultError(err, title);
                }
            }
            return;
        });
    }
    openSupportSingleAddress() {
        const url = '';
        // TODO FIX 'https://support.tkcoin.org/hc/en-us/articles/360015920572-Setting-up-the-Single-Address-Feature-for-your-TKCoin-Wallet';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    set(type, number) {
        switch (type) {
            case 'requiredCopayers':
                if (this.signatures.includes(number)) {
                    this.createForm.controls['requiredCopayers'].setValue(number);
                }
                break;
            case 'totalCopayers':
                if (this.copayers.includes(number)) {
                    this.createForm.controls['totalCopayers'].setValue(number);
                }
                break;
        }
    }
    showPairedWalletSelector() {
        this.isOpenSelector = true;
        const eligibleWallets = this.keyId
            ? this.profileProvider.getWalletsFromGroup({
                keyId: this.keyId,
                hasFunds: true,
                coin: 'eth',
                m: 1,
                n: 1
            })
            : [];
        const walletSelector = this.actionSheetProvider.createInfoSheet('linkEthWallet', {
            wallets: eligibleWallets,
            isEthMultisig: true
        });
        walletSelector.present();
        walletSelector.onDidDismiss(pairedWallet => {
            this.isOpenSelector = false;
            if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](pairedWallet)) {
                this.pairedWallet = pairedWallet;
                this.createForm.controls['testnetEnabled'].setValue(this.pairedWallet.network == 'testnet' ? true : false);
            }
        });
    }
    goToCreateEthMultisig() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__add_create_eth_multisig_create_eth_multisig__["a" /* CreateEthMultisigPage */], {
            pairedWallet: this.pairedWallet,
            m: this.createForm.value.requiredCopayers,
            n: this.createForm.value.totalCopayers,
            testnetEnabled: this.createForm.value.testnetEnabled,
            walletName: this.createForm.value.walletName
        });
    }
};
CreateWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-create-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/create-wallet/create-wallet.html"*/'<wide-header-page title="{{ \'Create {coinLabel} Wallet\' | translate: {coinLabel: coin.toUpperCase()} }}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button *ngIf="!isShared || (isShared && coin !== \'eth\')" (click)="setOptsAndCreate()" [disabled]="!createForm.valid" ion-button>\n      <span translate>Create</span>\n    </button>\n    <button clear wide-header-bar-button *ngIf="isShared && coin === \'eth\' && pairedWallet" (click)="goToCreateEthMultisig()" [disabled]="!createForm.valid" ion-button>\n      <span translate>Next</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <button class="linked-wallet" *ngIf="isShared && coin === \'eth\'" ion-item (click)="showPairedWalletSelector()" detail-none>\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Linked to</span>\n        </div>\n      </ion-label>\n\n      <ion-note item-end>\n        <ion-row align-items-center class="wallet" *ngIf="pairedWallet">\n          <ion-col>\n            <coin-icon [coin]="pairedWallet.coin" [network]="pairedWallet.network"></coin-icon>\n          </ion-col>\n\n          <ion-col>\n            <span class="note-container ellipsis">{{pairedWallet.name}}</span>\n          </ion-col>\n        </ion-row>\n\n        <ion-row align-items-center class="wallet" *ngIf="!pairedWallet">\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </ion-row>\n      </ion-note>\n    </button>\n\n    <form [formGroup]="createForm">\n      <ion-item>\n        <ion-label floating>{{\'Wallet name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="walletName"></ion-input>\n      </ion-item>\n\n      <div *ngIf="isShared">\n        <ion-item *ngIf="coin != \'eth\'">\n          <ion-label floating>{{\'Your name\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="myName"></ion-input>\n        </ion-item>\n\n        <div class="custom-item">\n          <div class="label">{{\'Required number of signatures\' | translate}}</div>\n          <div class="buttons-container">\n            <button clear class="remove-button" (click)="set(\'requiredCopayers\', this.createForm.value.requiredCopayers - 1)" ion-button>\n              <ion-icon name="remove"></ion-icon>\n            </button>\n            <button clear class="add-button" (click)="set(\'requiredCopayers\', this.createForm.value.requiredCopayers + 1)" ion-button>\n              {{createForm.value.requiredCopayers}}\n            </button>\n          </div>\n        </div>\n\n        <div class="custom-item">\n          <div class="label">{{\'Total number of copayers\' | translate}}</div>\n          <div class="buttons-container">\n            <button clear class="remove-button" (click)="set(\'totalCopayers\', this.createForm.value.totalCopayers - 1)" ion-button>\n              <ion-icon name="remove"></ion-icon>\n            </button>\n            <button clear class="add-button" (click)="set(\'totalCopayers\',this.createForm.value.totalCopayers + 1)" ion-button>\n              {{createForm.value.totalCopayers}}\n            </button>\n          </div>\n        </div>\n\n        <label-tip type="info" header="no-header" class="no-arrowhead">\n          <div label-tip-body>\n            <span translate>Multi-user wallet require multiple devices to set up. It takes longer to complete but it\'s recommended security configuration for long term storage.</span>\n          </div>\n        </label-tip>\n      </div>\n\n      <button ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n        <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n        <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n      </button>\n\n      <ion-item no-lines *ngIf="showAdvOpts && ( coin === \'btc\' || coin === \'edu\' || coin === \'tik\' ) && createForm.value.selectedSeed == \'new\'">\n        <ion-label>Segwit</ion-label>\n        <ion-toggle formControlName="useNativeSegwit"></ion-toggle>\n      </ion-item>\n\n      <div *ngIf="showAdvOpts" padding-bottom>\n        <ion-item *ngIf="!(isShared && coin == \'eth\')">\n          <ion-label stacked>Wallet Service URL</ion-label>\n          <ion-input type="text" formControlName="bwsURL"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="!keyId">\n          <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n          <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(createForm.value.selectedSeed)">\n            <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n          </ion-select>\n        </ion-item>\n\n        <ion-item *ngIf="createForm.value.selectedSeed == \'set\' && !keyId">\n          <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n        </ion-item>\n\n        <ion-item [ngClass]="{\'with-label\': createForm.value.testnetEnabled}" *ngIf="createForm.value.selectedSeed == \'new\'">\n          <ion-label><span *ngIf="coin === \'eth\'">Kovan </span>Testnet</ion-label>\n          <ion-toggle formControlName="testnetEnabled" (ionChange)="setDerivationPath()" [disabled]="isShared && coin == \'eth\'"></ion-toggle>\n        </ion-item>\n\n        <label-tip *ngIf="createForm.value.testnetEnabled && createForm.value.selectedSeed == \'new\'" type="warn">\n          <span label-tip-title translate>Testnet Wallet</span>\n          <div label-tip-body>\n            {{ \'The testnet is an alternative {coinName} block chain, to be used for testing. Testnet coins are separate and distinct from actual {coinName}, and do not have any value. This allows application developers or {coinName} testers to experiment, without having to use real {coinName}\' | translate : {coinName: coinName } }} .\n          </div>\n        </label-tip>\n\n        <ion-item *ngIf="createForm.value.selectedSeed == \'set\' && !keyId">\n          <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="derivationPath"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="!isSingleAddress()" [ngClass]="{\'with-label\': createForm.value.singleAddress}">\n          <ion-label>{{\'Single address\' | translate}}</ion-label>\n          <ion-toggle formControlName="singleAddress"></ion-toggle>\n        </ion-item>\n        <label-tip *ngIf="createForm.value.singleAddress" type="info" header="no-header">\n          <div label-tip-body>\n            <span translate>The single address feature will force the wallet to only use one address rather than generating new addresses.</span>\n            <br>\n            <a class="label-tip-link" (click)="openSupportSingleAddress()" translate>Learn More</a>\n          </div>\n        </label-tip>\n      </div>\n    </form>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/create-wallet/create-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_18__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_16__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__["a" /* ErrorsProvider */]])
], CreateWalletPage);

//# sourceMappingURL=create-wallet.js.map

/***/ }),

/***/ 501:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_location_location__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tab_tab__ = __webpack_require__(953);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__cards_cards__ = __webpack_require__(975);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__home_home__ = __webpack_require__(976);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__settings_settings__ = __webpack_require__(506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__wallets_wallets__ = __webpack_require__(1022);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_lodash__);




















let TabsPage = class TabsPage {
    constructor(plt, appProvider, profileProvider, logger, walletProvider, events, persistenceProvider, translate, bwcErrorProvider, tabProvider, rateProvider, platformProvider, locationProvider) {
        this.plt = plt;
        this.appProvider = appProvider;
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.events = events;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.bwcErrorProvider = bwcErrorProvider;
        this.tabProvider = tabProvider;
        this.rateProvider = rateProvider;
        this.platformProvider = platformProvider;
        this.locationProvider = locationProvider;
        this.NETWORK = 'livenet';
        this.bwsEventHandler = (walletId, type) => {
            __WEBPACK_IMPORTED_MODULE_19_lodash__["each"]([
                'TxProposalRejectedBy',
                'TxProposalAcceptedBy',
                'transactionProposalRemoved',
                'TxProposalRemoved',
                'NewOutgoingTx',
                'UpdateTx',
                'NewIncomingTx'
            ], (eventName) => {
                if (walletId &&
                    type == eventName &&
                    (type === 'NewIncomingTx' || type === 'NewOutgoingTx')) {
                    this.fetchAllWalletsStatus();
                }
            });
        };
        this.connectionError = __WEBPACK_IMPORTED_MODULE_19_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.events.publish('Local/ConnectionError');
        }), 5000, {
            leading: false
        });
        this.fetchAllWalletsStatus = __WEBPACK_IMPORTED_MODULE_19_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this._fetchAllWallets();
        }), 5000, {
            leading: true
        });
        this.homeRoot = __WEBPACK_IMPORTED_MODULE_15__home_home__["a" /* HomePage */];
        this.walletsRoot = __WEBPACK_IMPORTED_MODULE_18__wallets_wallets__["a" /* WalletsPage */];
        this.scanRoot = __WEBPACK_IMPORTED_MODULE_16__scan_scan__["a" /* ScanPage */];
        this.cardsRoot = __WEBPACK_IMPORTED_MODULE_14__cards_cards__["a" /* CardsPage */];
        this.settingsRoot = __WEBPACK_IMPORTED_MODULE_17__settings_settings__["a" /* SettingsPage */];
        this.persistenceProvider.getNetwork().then((network) => {
            if (network) {
                this.NETWORK = network;
            }
            this.logger.log(`tabs initialized with ${this.NETWORK}`);
        });
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.logger.info('Loaded: TabsPage');
        this.appName = this.appProvider.info.nameCase;
        this.isCordova = this.platformProvider.isCordova;
        this.scanIconType =
            this.appName == 'TKCoin' ? 'tab-scan' : 'tab-copay-scan';
        if (this.platformProvider.isElectron) {
            this.updateDesktopOnFocus();
        }
        this.persistenceProvider.getCardExperimentFlag().then(status => {
            if (status === 'enabled') {
                this.persistenceProvider
                    .getCardNotificationBadge()
                    .then(badgeStatus => {
                    this.cardNotificationBadgeText =
                        badgeStatus === 'disabled' ? null : 'New';
                });
            }
        });
    }
    subscribeEvents() {
        this.events.subscribe('experimentUpdateStart', () => {
            this.tabs.select(2);
        });
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
        this.events.subscribe('Local/UpdateTxps', data => {
            this.setTxps(data);
        });
        this.events.subscribe('Local/FetchWallets', () => {
            this.fetchAllWalletsStatus();
        });
    }
    unsubscribeEvents() {
        this.events.unsubscribe('bwsEvent');
        this.events.unsubscribe('Local/UpdateTxps');
        this.events.unsubscribe('Local/FetchWallets');
        this.events.unsubscribe('experimentUpdateStart');
    }
    ngOnInit() {
        this.subscribeEvents();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.subscribeEvents();
            setTimeout(() => {
                this.updateTxps();
                this.fetchAllWalletsStatus();
            }, 1000);
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.events.unsubscribe('bwsEvent');
            this.events.unsubscribe('Local/UpdateTxps');
            this.events.unsubscribe('Local/FetchWallets');
            this.events.unsubscribe('experimentUpdateStart');
        });
        this.checkCardEnabled();
        this.tabProvider.prefetchGiftCards();
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
        this.unsubscribeEvents();
    }
    checkCardEnabled() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            let cardExperimentEnabled = (yield this.persistenceProvider.getCardExperimentFlag()) === 'enabled';
            const cards = yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["a" /* Network */][this.NETWORK]);
            if (!cardExperimentEnabled) {
                try {
                    this.logger.debug('TKCoin: setting country');
                    const country = yield this.locationProvider.getCountry();
                    if (country === 'US') {
                        this.logger.debug('If US: Set Card Experiment Flag Enabled');
                        yield this.persistenceProvider.setCardExperimentFlag('enabled');
                        cardExperimentEnabled = true;
                    }
                }
                catch (err) {
                    this.logger.error('Error setting country: ', err);
                }
            }
            // set banner advertisement in home.ts
            this.events.publish('CardAdvertisementUpdate', {
                status: cards ? 'connected' : null,
                cardExperimentEnabled,
                cards
            });
        });
    }
    disableCardNotificationBadge() {
        this.persistenceProvider.getCardExperimentFlag().then(status => {
            if (status === 'enabled') {
                this.cardNotificationBadgeText = null;
                this.persistenceProvider.setCardNotificationBadge('disabled');
            }
        });
        // TODO FIX: OVERRIDE 
        this.cardNotificationBadgeText = null;
        this.persistenceProvider.setCardNotificationBadge('disabled');
    }
    updateTxps() {
        this.profileProvider.getTxps({ limit: 3 }).then(data => {
            this.setTxps(data);
        });
    }
    setTxps(data) {
        this.zone.run(() => {
            this.txpsN = data.n;
        });
    }
    updateDesktopOnFocus() {
        const { remote } = window.require('electron');
        const win = remote.getCurrentWindow();
        win.on('focus', () => {
            this.events.publish('Desktop/onFocus');
            setTimeout(() => {
                this.updateTxps();
                this.fetchAllWalletsStatus();
            }, 1000);
        });
    }
    updateTotalBalance(wallets) {
        this.rateProvider.getLastDayRates().then(lastDayRatesArray => {
            this.walletProvider
                .getTotalAmount(wallets, lastDayRatesArray)
                .then(data => {
                this.logger.debug('Total Balance and Price Updated');
                this.events.publish('Local/HomeBalance', data);
                this.events.publish('Local/PriceUpdate');
            });
        });
    }
    processWalletError(wallet, err) {
        wallet.error = wallet.errorObj = null;
        if (!err || err == 'INPROGRESS')
            return;
        wallet.cachedStatus = null;
        wallet.errorObj = err;
        if (err.message === '403') {
            this.events.publish('Local/AccessDenied');
            wallet.error = this.translate.instant('Access denied');
        }
        else if (err === 'WALLET_NOT_REGISTERED') {
            wallet.error = this.translate.instant('Wallet not registered');
        }
        else {
            wallet.error = this.bwcErrorProvider.msg(err);
        }
        this.logger.warn(this.bwcErrorProvider.msg(wallet.error, 'Error updating status for ' + wallet.id));
    }
    _fetchAllWallets() {
        let hasConnectionError = false;
        this.profileProvider.setLastKnownBalance();
        let wallets = this.profileProvider.wallet;
        if (__WEBPACK_IMPORTED_MODULE_19_lodash__["isEmpty"](wallets)) {
            this.events.publish('Local/HomeBalance');
            return;
        }
        this.logger.debug('Fetching All Wallets and Updating Total Balance');
        wallets = __WEBPACK_IMPORTED_MODULE_19_lodash__["filter"](this.profileProvider.wallet, w => {
            return !w.hidden;
        });
        const pr = wallet => {
            return this.walletProvider
                .fetchStatus(wallet, {})
                .then(st => {
                wallet.cachedStatus = st;
                wallet.error = wallet.errorObj = null;
                const balance = wallet.coin === 'xrp'
                    ? wallet.cachedStatus.availableBalanceStr
                    : wallet.cachedStatus.totalBalanceStr;
                this.persistenceProvider.setLastKnownBalance(wallet.id, balance);
                this.events.publish('Local/WalletUpdate', {
                    walletId: wallet.id,
                    finished: true
                });
                if (!__WEBPACK_IMPORTED_MODULE_19_lodash__["isEmpty"](st.serverMessages)) {
                    this.events.publish('Local/ServerMessages', {
                        serverMessages: st.serverMessages
                    });
                }
                return Promise.resolve();
            })
                .catch(err => {
                this.processWalletError(wallet, err);
                if (err && err.message == 'Wallet service connection error.') {
                    hasConnectionError = true;
                    this.connectionError();
                }
                return Promise.resolve();
            });
        };
        const promises = [];
        __WEBPACK_IMPORTED_MODULE_19_lodash__["each"](wallets, wallet => {
            promises.push(pr(wallet));
        });
        Promise.all(promises).then(() => {
            if (!hasConnectionError) {
                this.updateTotalBalance(wallets);
            }
            this.updateTxps();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('tabs'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], TabsPage.prototype, "tabs", void 0);
TabsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/tabs/tabs.html"*/'<ion-tabs #tabs>\n  <ion-tab [root]="homeRoot" tabIcon="tab-home"></ion-tab>\n  <ion-tab [root]="walletsRoot" [tabBadge]="txpsN" tabIcon="tab-wallets"></ion-tab>\n  <ion-tab [root]="scanRoot" [tabIcon]="scanIconType" [show]="isCordova"></ion-tab>\n  <!-- TODO FIX HIDE!\n  <ion-tab (ionSelect)="disableCardNotificationBadge()" [root]="cardsRoot" [tabBadgeStyle]="\'danger\'" [tabBadge]="cardNotificationBadgeText" [show]="appName === \'TKCoin\'" tabIcon="tab-cards"></ion-tab>\n  -->\n  <ion-tab [root]="settingsRoot" tabIcon="tab-settings"></ion-tab>\n</ion-tabs>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/tabs/tabs.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tab_tab__["a" /* TabProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_location_location__["a" /* LocationProvider */]])
], TabsPage);

//# sourceMappingURL=tabs.js.map

/***/ }),

/***/ 502:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NewFeaturePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_theme_theme__ = __webpack_require__(56);





let NewFeaturePage = class NewFeaturePage {
    constructor(viewCtrl, navParams, themeProvider) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.themeProvider = themeProvider;
        this.endSlide = false;
        this.firstSlide = true;
        this.featureList = [];
        this.featureList.push(...this.navParams.data.featureList.features);
        this.endSlide = this.featureList.length == 1;
        this.isDarkMode = this.themeProvider.isDarkModeEnabled();
    }
    getImage(imagePath) {
        if (this.isDarkMode) {
            var pointIndex = imagePath.lastIndexOf('.');
            var output = [
                imagePath.slice(0, pointIndex),
                '-dark',
                imagePath.slice(pointIndex)
            ].join('');
            return output;
        }
        else {
            return imagePath;
        }
    }
    setBGImgHeader(imagePath) {
        return {
            'background-image': 'url(' + imagePath + ')',
            'background-repeat': 'no-repeat',
            'background-position': 'bottom',
            height: '100%'
        };
    }
    slideChanged() {
        this.endSlide = this.slider.isEnd();
        this.firstSlide = this.slider.isBeginning();
        this.slider.lockSwipeToNext(this.endSlide);
        this.slider.lockSwipeToPrev(this.firstSlide);
        this.tryit = null;
        if (this.slider._activeIndex &&
            this.featureList[this.slider._activeIndex]) {
            this.tryit = this.featureList[this.slider._activeIndex].tryit;
        }
    }
    nextSlide() {
        this.slider.slideNext();
    }
    close(data) {
        typeof data === 'function'
            ? data(this.viewCtrl)
            : this.viewCtrl.dismiss({ data, done: this.endSlide });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewChild"])('newFeatureSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Slides */])
], NewFeaturePage.prototype, "slider", void 0);
NewFeaturePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'page-new-feature',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/new-feature/new-feature.html"*/'<ion-slides #newFeatureSlides pager="{{featureList && featureList.length>1}}" class="new-feature-slides" *ngIf="featureList && featureList.length>0" (ionSlideDidChange)="slideChanged()">\n  <ion-slide *ngFor="let newfeature of featureList">\n    <div class="supperior-container" *ngIf="newfeature.image && !!newfeature.image.fitClass">\n      <div *ngIf="newfeature.image" class="img-fit" [ngStyle]="setBGImgHeader(getImage(newfeature.image.path))"></div>\n    </div>\n    <div class="supperior-container" *ngIf="!newfeature.image.fitClass">\n      <div class="page-title" *ngIf="newfeature.slideTitle != \'\'">{{ newfeature.slideTitle || \'Recently added\' }}</div>\n      <div *ngIf="newfeature.image" class="img-container">\n        <img [ngClass]="(!!newfeature.image.fitClass)?\'imgFit\':\'img\'" src="{{getImage(newfeature.image.path)}}" />\n      </div>\n    </div>\n    <div class="slide-info">\n      <div class="title">{{newfeature.title}}</div>\n      <div class="text">{{newfeature.details}}</div>\n    </div>\n  </ion-slide>\n</ion-slides>\n<div padding>\n  <button @fade ion-button clear class="try-it-button" (click)="close(tryit)" *ngIf="tryit">\n    {{ \'Try it\' | translate }}\n  </button>\n  <button ion-button clear class="next-slide-button" (click)="nextSlide()" *ngIf="!endSlide">\n    {{ \'Next\' | translate }}\n  </button>\n  <button ion-button clear class="next-slide-button" (click)="close(true)" *ngIf="endSlide">\n    {{ \'Got it\' | translate }}\n  </button>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/new-feature/new-feature.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["l" /* trigger */])('fade', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["k" /* transition */])(':enter', [
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({
                        transform: 'translateX(3px)',
                        opacity: 0
                    }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('200ms')
                ]),
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["k" /* transition */])(':leave', [
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('200ms', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* style */])({
                        transform: 'translateX(3px)',
                        opacity: 0
                    }))
                ])
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_theme_theme__["a" /* ThemeProvider */]])
], NewFeaturePage);

//# sourceMappingURL=new-feature.js.map

/***/ }),

/***/ 503:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CryptoOrderSummaryPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_buy_crypto_buy_crypto__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_tkcoin_tkcoin__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pages_add_select_currency_select_currency__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__pages_buy_crypto_country_selector_country_selector__ = __webpack_require__(977);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pages_buy_crypto_crypto_coin_selector_crypto_coin_selector__ = __webpack_require__(978);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__pages_buy_crypto_crypto_offers_crypto_offers__ = __webpack_require__(979);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__pages_buy_crypto_crypto_payment_method_crypto_payment_method__ = __webpack_require__(980);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pages_send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__wallet_details_wallet_details__ = __webpack_require__(144);






// Providers










// Pages







let CryptoOrderSummaryPage = class CryptoOrderSummaryPage {
    constructor(logger, navParams, modalCtrl, navCtrl, persistenceProvider, platformProvider, profileProvider, walletProvider, bitPayProvider, buyCryptoProvider, errorsProvider, actionSheetProvider, translate, onGoingProcessProvider) {
        this.logger = logger;
        this.navParams = navParams;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.bitPayProvider = bitPayProvider;
        this.buyCryptoProvider = buyCryptoProvider;
        this.errorsProvider = errorsProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.translate = translate;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.countryList = [];
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.coin = this.navParams.data.coin;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CryptoOrderSummaryPage');
        this.onGoingProcessProvider.set(this.translate.instant('Setting parameters...'));
        this.persistenceProvider
            .getLastCountryUsed()
            .then((lastUsedCountry) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (lastUsedCountry && __WEBPACK_IMPORTED_MODULE_4_lodash__["isObject"](lastUsedCountry)) {
                this.selectedCountry = lastUsedCountry;
            }
            else {
                this.selectedCountry = {
                    name: 'United States',
                    phonePrefix: '+1',
                    shortCode: 'US',
                    threeLetterCode: 'USA'
                };
            }
            this.isSimplexPromotionActive = yield this.buyCryptoProvider.isPromotionActive('simplexPromotion202002');
            this.logger.debug('Is promotion active from the server: ' +
                this.isSimplexPromotionActive);
            this.onGoingProcessProvider.clear();
            if (this.navParams.data.walletId) {
                this.setWallet(this.navParams.data.walletId);
            }
            else {
                this.selectFirstAvailableWallet();
            }
            if (this.navParams.data.paymentMethod) {
                this.paymentMethod = this.navParams.data.paymentMethod;
            }
            else {
                this.logger.debug('No payment method selected. Setting to default.');
                this.setDefaultPaymentMethod();
            }
        }));
    }
    ionViewWillEnter() {
        this.persistenceProvider.getCountries().then(data => {
            if (data) {
                this.countryList = data;
            }
            else {
                this.bitPayProvider.get('/countries', ({ data }) => {
                    this.persistenceProvider.setCountries(data);
                    this.countryList = data;
                }, () => { });
            }
        });
    }
    isPromotionActiveForCountry(country) {
        if (this.isSimplexPromotionActive &&
            country &&
            (country.EUCountry || country.threeLetterCode == 'CAN'))
            return true;
        return false;
    }
    selectFirstAvailableWallet() {
        const supportedCoins = this.isPromotionActiveForCountry(this.navParams.data.country)
            ? this.buyCryptoProvider.getExchangeCoinsSupported('simplex')
            : this.buyCryptoProvider.getExchangeCoinsSupported();
        // Select first available wallet
        this.wallets = this.profileProvider.getWallets({
            network: __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].name == 'development' ? null : 'livenet',
            onlyComplete: true,
            coin: this.coin && supportedCoins.includes(this.coin)
                ? this.coin
                : supportedCoins,
            backedUp: true
        });
        if (this.wallets[0]) {
            this.logger.debug('Setting wallet to deposit funds: ' +
                this.wallets[0].credentials.walletId);
            this.setWallet(this.wallets[0].credentials.walletId);
        }
        else {
            this.logger.debug('No wallets available to deposit funds.');
            const walletsGroups = this.profileProvider.orderedWalletsByGroup;
            this.errorsProvider.showNoWalletError(this.coin ? this.coin.toUpperCase() : null, option => {
                // Single seed case:
                let data;
                if (walletsGroups.length == 1 && walletsGroups[0][0]) {
                    data = {
                        keyId: walletsGroups[0][0].credentials.keyId
                    };
                }
                if (option) {
                    this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__pages_add_select_currency_select_currency__["a" /* SelectCurrencyPage */], data);
                }
            });
        }
    }
    setWallet(walletId) {
        this.walletId = walletId;
        this.wallet = this.profileProvider.getWallet(this.walletId);
        this.coin = this.wallet.coin;
        if (this.isCoinSupportedByCountry()) {
            this.walletProvider.getAddress(this.wallet, false).then(addr => {
                this.address = addr;
            });
        }
        else {
            this.showCoinAndCountryError();
        }
    }
    openAmountModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_21__pages_send_amount_amount__["a" /* AmountPage */], {
            fromBuyCrypto: true,
            walletId: this.walletId,
            coin: this.coin,
            useAsModal: true,
            currency: this.currency
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data) {
                this.amount = data.fiatAmount;
                this.currency = data.currency;
                this.checkPaymentMethod();
            }
        });
    }
    openCryptoCoinSelectorModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_18__pages_buy_crypto_crypto_coin_selector_crypto_coin_selector__["a" /* CryptoCoinSelectorPage */], {
            useAsModal: true,
            country: this.selectedCountry,
            isPromotionActiveForCountry: this.isPromotionActiveForCountry(this.selectedCountry)
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data) {
                this.coin = data.coin;
                this.setWallet(data.walletId);
                this.checkPaymentMethod();
            }
        });
    }
    openCountrySelectorModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_17__pages_buy_crypto_country_selector_country_selector__["a" /* CountrySelectorPage */], {
            countryList: this.countryList,
            useAsModal: true
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data) {
                this.selectedCountry = data.selectedCountry;
                if (this.isCoinSupportedByCountry()) {
                    this.checkPaymentMethod();
                }
                else {
                    this.showCoinAndCountryError();
                }
            }
        });
    }
    setDefaultPaymentMethod() {
        if (this.isPromotionActiveForCountry(this.selectedCountry) &&
            this.buyCryptoProvider.isPaymentMethodSupported('simplex', this.buyCryptoProvider.paymentMethodsAvailable.creditCard, this.coin, this.currency)) {
            this.paymentMethod = this.buyCryptoProvider.paymentMethodsAvailable.creditCard;
        }
        else {
            if (this.platformProvider.isIOS) {
                this.paymentMethod =
                    this.buyCryptoProvider.isPaymentMethodSupported('simplex', this.buyCryptoProvider.paymentMethodsAvailable.applePay, this.coin, this.currency) ||
                        this.buyCryptoProvider.isPaymentMethodSupported('wyre', this.buyCryptoProvider.paymentMethodsAvailable.applePay, this.coin, this.currency)
                        ? this.buyCryptoProvider.paymentMethodsAvailable.applePay
                        : this.buyCryptoProvider.paymentMethodsAvailable.debitCard;
            }
            else {
                this.paymentMethod = this.buyCryptoProvider.paymentMethodsAvailable.debitCard;
            }
        }
    }
    checkPaymentMethod() {
        if (!this.coin || !this.currency || !this.paymentMethod)
            return;
        if (this.paymentMethod.method == 'sepaBankTransfer' &&
            !this.selectedCountry.EUCountry) {
            this.setDefaultPaymentMethod();
            this.showPaymentMethodWarning('country');
            return;
        }
        if (this.buyCryptoProvider.isPaymentMethodSupported('simplex', this.paymentMethod, this.coin, this.currency) ||
            this.buyCryptoProvider.isPaymentMethodSupported('wyre', this.paymentMethod, this.coin, this.currency)) {
            this.logger.debug(`Payment methods available for ${this.coin} and ${this.currency}`);
            return;
        }
        else {
            this.logger.debug(`No payment methods available for ${this.coin} and ${this.currency}. Show warning.`);
            this.setDefaultPaymentMethod();
            this.showPaymentMethodWarning('coin');
        }
    }
    isCoinSupportedByCountry() {
        if (this.isPromotionActiveForCountry(this.selectedCountry) &&
            !__WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.buyCryptoProvider.getExchangeCoinsSupported('simplex'), this.coin)) {
            this.logger.debug(`Selected coin: ${this.coin} is not currently available for selected country: ${this.selectedCountry.name}. Show warning.`);
            return false;
        }
        else {
            return true;
        }
    }
    showCoinAndCountryError() {
        if (!this.coin)
            return;
        const title = this.translate.instant('Error');
        const subtitle = this.translate.instant(`The selected coin (${this.coin.toUpperCase()}) is not currently available to buy in your country.`);
        this.errorsProvider.showDefaultError(subtitle, title);
        this.wallet = null;
        this.address = null;
        this.coin = null;
    }
    showPaymentMethodWarning(reason) {
        const infoSheet = this.actionSheetProvider.createInfoSheet('payment-method-changed', {
            coin: this.coin,
            currency: this.currency,
            reason
        });
        infoSheet.present();
    }
    openCryptoPaymentMethodModal() {
        if (!this.coin) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant(`You must first select a wallet to deposit.`);
            this.errorsProvider.showDefaultError(subtitle, title);
            return;
        }
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_20__pages_buy_crypto_crypto_payment_method_crypto_payment_method__["a" /* CryptoPaymentMethodPage */], {
            paymentMethod: this.paymentMethod.method,
            useAsModal: true,
            coin: this.coin,
            selectedCountry: this.selectedCountry,
            currency: this.currency,
            isPromotionActiveForCountry: this.isPromotionActiveForCountry(this.selectedCountry)
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data) {
                this.paymentMethod = data.paymentMethod;
            }
        });
    }
    goToCryptoOffersPage() {
        const params = {
            amount: this.amount,
            currency: this.currency,
            paymentMethod: this.paymentMethod,
            coin: this.coin,
            walletId: this.walletId,
            selectedCountry: this.selectedCountry,
            isPromotionActiveForCountry: this.isPromotionActiveForCountry(this.selectedCountry)
        };
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__pages_buy_crypto_crypto_offers_crypto_offers__["a" /* CryptoOffersPage */], params);
    }
    getDigitsInfo(currency) {
        if (!this.coin || this.coin.toUpperCase() === currency)
            return '';
        else
            return '1.2-2';
    }
    goToCoinSelector() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__pages_buy_crypto_crypto_coin_selector_crypto_coin_selector__["a" /* CryptoCoinSelectorPage */], {
            country: this.selectedCountry,
            isPromotionActiveForCountry: this.isPromotionActiveForCountry(this.selectedCountry)
        });
    }
    cancelOrder() {
        this.navCtrl.popToRoot().then(_ => {
            if (this.wallet &&
                this.wallet.credentials.walletId == this.navParams.data.walletId) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_22__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                    walletId: this.navParams.data.walletId
                });
            }
        });
    }
};
CryptoOrderSummaryPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-crypto-order-summary',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-order-summary/crypto-order-summary.html"*/'<wide-header-page title="{{\'Order Summary\' | translate}}" hideBackButton="true">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="cancelOrder()" ion-button>\n      <span translate>Cancel</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <div class="item-label" translate>Amount</div>\n      <ion-card class="item-card" (click)="openAmountModal()">\n        <ion-item>\n          <div class="main-label"> <span *ngIf="currency == \'USD\'">$</span>{{amount | number : getDigitsInfo(currency)}}<span *ngIf="currency != \'USD\'"> {{currency}}</span></div>\n          <ion-note item-end>\n            <ion-row align-items-center>\n              <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n            </ion-row>\n          </ion-note>\n        </ion-item>\n      </ion-card>\n\n      <div class="item-label" translate>Deposit to</div>\n      <ion-card class="item-card" (click)="openCryptoCoinSelectorModal()">\n        <ion-item>\n          <coin-icon item-start [coin]="wallet?.coin" [network]="wallet?.network"></coin-icon>\n          <div *ngIf="wallet" class="main-label">\n            {{wallet?.name}}\n          </div>\n          <div *ngIf="!wallet" class="main-label warn-msg" translate>\n            No wallet selected\n          </div>\n          <ion-note item-end>\n            <ion-row align-items-center>\n              <div class="secondary-note address-label">\n                <span>{{address | shortenedAddress}}</span>\n              </div>\n              <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n            </ion-row>\n          </ion-note>\n        </ion-item>\n      </ion-card>\n\n      <div class="item-label" translate>Country</div>\n      <ion-card class="item-card" (click)="openCountrySelectorModal()">\n        <ion-item>\n          <div class="main-label">{{selectedCountry?.name}}</div>\n          <ion-note item-end>\n            <ion-row align-items-center>\n              <div class="secondary-note address-label">\n                <span>{{selectedCountry?.threeLetterCode}}</span>\n              </div>\n              <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n            </ion-row>\n          </ion-note>\n        </ion-item>\n      </ion-card>\n\n      <div class="item-label" translate>Payment Method</div>\n      <ion-card class="item-card" (click)="openCryptoPaymentMethodModal()">\n        <ion-item>\n          <div class="main-label">{{paymentMethod?.label}}</div>\n          <ion-note item-end>\n            <ion-row align-items-center>\n              <ion-icon class="item-img" item-start>\n                <img src="{{paymentMethod?.imgSrc}}">\n              </ion-icon>\n              <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n            </ion-row>\n          </ion-note>\n        </ion-item>\n      </ion-card>\n    </ion-list>\n\n    <button ion-button class="button-standard button-primary" (click)="goToCryptoOffersPage()" [disabled]="!wallet">\n      <span>{{\'View Offers\' | translate}}</span>\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-order-summary/crypto-order-summary.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_11__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_tkcoin_tkcoin__["a" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_buy_crypto_buy_crypto__["a" /* BuyCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_10__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], CryptoOrderSummaryPage);

//# sourceMappingURL=crypto-order-summary.js.map

/***/ }),

/***/ 504:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormatCurrencyPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);



let FormatCurrencyPipe = class FormatCurrencyPipe {
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
    }
    transform(amount, currencyCode, customPrecision) {
        const precision = customPrecision === 'minimal'
            ? getMinimalPrecision(amount, currencyCode)
            : typeof customPrecision === 'number'
                ? customPrecision
                : getPrecision(currencyCode);
        const numericValue = this.decimalPipe.transform(amount, getPrecisionString(precision));
        const symbolMap = {
            BRL: 'R$',
            CAD: 'C$',
            EUR: '',
            GBP: '',
            INR: '',
            JPY: '',
            PHP: '',
            USD: '$'
        };
        const symbol = symbolMap[currencyCode.toUpperCase()];
        const finalValue = symbol
            ? `${symbol}${numericValue}`
            : `${numericValue} ${currencyCode}`;
        return finalValue;
    }
};
FormatCurrencyPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Pipe"])({
        name: 'formatCurrency'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */]])
], FormatCurrencyPipe);

function getPrecision(currencyCode) {
    return currencyCode.toUpperCase() === 'JPY' ? 0 : 2;
}
function getMinimalPrecision(amount, currencyCode) {
    return Number.isInteger(amount) ? 0 : getPrecision(currencyCode);
}
function getPrecisionString(precision) {
    return `1.${precision}-${precision}`;
}
//# sourceMappingURL=format-currency.js.map

/***/ }),

/***/ 505:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_time_time__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_tkcoin_card_tkcoin_card__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tkcoin_tkcoin__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_moment__);





// Pages

// providers









const TIMEOUT_FOR_REFRESHER = 1000;
let TKCoinCardPage = class TKCoinCardPage {
    constructor(translate, bitPayProvider, bitPayCardProvider, logger, popupProvider, timeProvider, externalLinkProvider, navParams, navCtrl, platformProvider, themeProvider) {
        this.translate = translate;
        this.bitPayProvider = bitPayProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.timeProvider = timeProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.platformProvider = platformProvider;
        this.themeProvider = themeProvider;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.dateRange = {
            value: 'last30Days'
        };
        this.network = this.bitPayProvider.getEnvironment().network;
        this.cardId = this.navParams.data.id;
        if (!this.cardId)
            this.navCtrl.pop();
        this.bitPayCardProvider
            .get({
            cardId: this.cardId
        })
            .then(cards => {
            if (cards && cards[0]) {
                this.lastFourDigits = cards[0].lastFourDigits;
                this.balance = cards[0].balance;
                this.updatedOn = cards[0].updatedOn;
                this.currency = cards[0].currency;
                this.setDateTime(cards[0].history);
                this.setHistory(cards[0].history);
            }
            this.update();
        });
    }
    ionViewWillEnter() {
        this.backgroundColor = this.themeProvider.isDarkModeEnabled()
            ? this.themeProvider.getThemeInfo().walletDetailsBackgroundStart
            : '#0c204e';
        if (this.platformProvider.isCordova) {
            this.themeProvider.useCustomStatusBar('#0c204e');
        }
    }
    ionViewDidEnter() {
        this.bitPayCardProvider.logEvent('legacycard_view', {});
    }
    ionViewWillLeave() {
        if (this.platformProvider.isCordova) {
            this.themeProvider.useDefaultStatusBar();
        }
    }
    logLegacyCardTopupStartEvent() {
        this.bitPayCardProvider.logEvent('legacycard_topup_start', {});
    }
    logLegacyCardViewAmountItem() {
        this.bitPayCardProvider.logEvent('view_item', {
            items: [
                {
                    name: 'legacyCard',
                    category: 'debitCard'
                }
            ]
        });
    }
    setDateRange(preset) {
        let startDate;
        let endDate;
        preset = preset || 'last30Days';
        switch (preset) {
            case 'last30Days':
                startDate = __WEBPACK_IMPORTED_MODULE_14_moment__().subtract(30, 'days').toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_14_moment__().toISOString();
                break;
            case 'lastMonth':
                startDate = __WEBPACK_IMPORTED_MODULE_14_moment__()
                    .startOf('month')
                    .subtract(1, 'month')
                    .toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_14_moment__().startOf('month').toISOString();
                break;
            case 'all':
                startDate = null;
                endDate = null;
                break;
            default:
                return undefined;
        }
        return {
            startDate,
            endDate
        };
    }
    setGetStarted(history, cb) {
        // Is the card new?
        if (!__WEBPACK_IMPORTED_MODULE_13_lodash__["isEmpty"](history.transactionList))
            return cb();
        let dateRange = this.setDateRange('all');
        this.bitPayCardProvider.updateHistory(this.cardId, dateRange, (err, history) => {
            if (!err && __WEBPACK_IMPORTED_MODULE_13_lodash__["isEmpty"](history.transactionList))
                this.getStarted = true;
            return cb();
        });
    }
    update() {
        let dateRange = this.setDateRange(this.dateRange.value);
        this.loadingHistory = true;
        this.bitPayCardProvider.updateHistory(this.cardId, dateRange, (err, history) => {
            this.loadingHistory = false;
            if (err) {
                this.logger.error(err);
                this.tkcoinCardTransactionHistoryCompleted = null;
                this.tkcoinCardTransactionHistoryConfirming = null;
                this.tkcoinCardTransactionHistoryPreAuth = null;
                this.balance = null;
                this.popupProvider
                    .ionicAlert(err, this.translate.instant('Could not get transactions'))
                    .then(() => {
                    this.navCtrl.pop();
                });
                return;
            }
            this.setGetStarted(history, () => {
                let txs = __WEBPACK_IMPORTED_MODULE_13_lodash__["clone"](history.txs);
                this.setDateTime(txs);
                this.setHistory(txs);
                this.balance = history.currentCardBalance;
                this.updatedOn = null;
                if (this.dateRange.value == 'last30Days') {
                    // TODO?
                    // $log.debug('BitPay Card: storing cache history');
                    // let cacheHistory = {
                    //   balance: history.currentCardBalance,
                    //   transactions: history.txs
                    // };
                    // this.bitPayCardProvider.setHistory($scope.cardId, cacheHistory, {}, (err) => {
                    //   if (err) $log.error(err);
                    //   $scope.historyCached = true;
                    // });
                }
            });
        });
    }
    setHistory(txs) {
        if (!txs)
            return;
        this.tkcoinCardTransactionHistoryConfirming = this.bitPayCardProvider.filterTransactions('confirming', txs);
        this.tkcoinCardTransactionHistoryCompleted = this.bitPayCardProvider.filterTransactions('completed', txs);
        this.tkcoinCardTransactionHistoryPreAuth = this.bitPayCardProvider.filterTransactions('preAuth', txs);
    }
    setDateTime(txs) {
        if (!txs)
            return;
        let txDate, txDateUtc;
        let newDate;
        for (let i = 0; i < txs.length; i++) {
            txDate = new Date(txs[i].date);
            if (txDate == 'Invalid Date')
                return; // iOS
            txDateUtc = new Date(txs[i].date.replace('Z', ''));
            let amTime = this.createdWithinPastDay(txs[i]);
            newDate = amTime
                ? __WEBPACK_IMPORTED_MODULE_14_moment__(txDateUtc).fromNow()
                : __WEBPACK_IMPORTED_MODULE_14_moment__(txDate).utc().format('MMM D, YYYY');
            txs[i].date = newDate;
        }
    }
    createdWithinPastDay(tx) {
        let result = false;
        if (tx.date) {
            result = this.timeProvider.withinPastDay(tx.date);
        }
        return result;
    }
    openExternalLink(url) {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    topUp() {
        this.logLegacyCardTopupStartEvent();
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__send_amount_amount__["a" /* AmountPage */], {
            id: this.cardId,
            nextPage: 'TKCoinCardTopUpPage',
            currency: this.currency
        });
    }
    doRefresh(refresher) {
        this.update();
        setTimeout(() => {
            refresher.complete();
        }, TIMEOUT_FOR_REFRESHER);
    }
};
TKCoinCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tkcoin-card',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card.html"*/'<ion-header no-border>\n  <ion-navbar>\n    <ion-title>\n      <div class="tkcoin-card-header ellipsis">\n        TKCoin Visa <sup>&reg;</sup> Card ({{lastFourDigits}})\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea [fixed-scroll-bg-color]="\'backgroundColor\'">\n  <ion-refresher (ionRefresh)="doRefresh($event)" [ngStyle]="{\'background\': backgroundColor}">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper wrapper--feather">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea">\n      <expandable-header-primary class="balance-header">\n        <div class="balance-str" *ngIf="balance">\n          {{balance | number:\'1.2-2\' }} {{currency}}\n        </div>\n        <button class="add-funds-button" ion-button color="light" clear (click)="topUp()" *ngIf="balance" no-low-fee>\n          <span translate>Add funds</span>\n          <ion-icon name="arrow-forward"></ion-icon>\n        </button>\n        <div class="card-info">\n          <ion-spinner *ngIf="!balance || loadingHistory"></ion-spinner>\n        </div>\n      </expandable-header-primary>\n    </expandable-header>\n\n    <div *ngIf="getStarted" class="initial-message">\n      <h1 translate>Get started</h1>\n      <div translate>\n        Your BitPay Card is ready. Add funds to your card to start using it at stores.\n      </div>\n    </div>\n\n    <ion-list class="bp-list" *ngIf="!getStarted">\n      <ion-item>\n        <ion-label>\n          <span translate>Activity</span>\n        </ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" padding-horizontal [(ngModel)]="dateRange.value" (ionChange)="update()">\n          <ion-option value="last30Days" selected translate>Recent</ion-option>\n          <ion-option value="lastMonth" translate>Last Month</ion-option>\n          <ion-option value="all" translate>All</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item-divider *ngIf="tkcoinCardTransactionHistoryConfirming && tkcoinCardTransactionHistoryConfirming[0]">\n        <ion-icon item-end (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/115003014526-Why-do-you-require-one-blockchain-confirmation-for-TKCoin-Card-loads-\')">\n          <img src="assets/img/icon-help-support.svg" />\n        </ion-icon>\n        <span translate>Confirming</span>\n      </ion-item-divider>\n      <ion-list class="bp-list">\n        <div *ngFor="let card of tkcoinCardTransactionHistoryConfirming">\n          <page-card-item [card]="card" [currency]="currency"></page-card-item>\n        </div>\n      </ion-list>\n\n      <ion-item-divider *ngIf="tkcoinCardTransactionHistoryPreAuth && tkcoinCardTransactionHistoryPreAuth[0]">\n        <ion-icon item-end (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/115003003563-Why-was-I-overcharged-on-my-TKCoin-Card-account-Why-is-there-a-hold-on-my-account-\')">\n          <img src="assets/img/icon-help-support.svg" />\n        </ion-icon>\n        <span translate>Pre-Auth Holds</span>\n      </ion-item-divider>\n      <ion-list class="bp-list">\n        <div *ngFor="let card of tkcoinCardTransactionHistoryPreAuth">\n          <page-card-item [card]="card" [currency]="currency"></page-card-item>\n        </div>\n      </ion-list>\n\n      <ion-item-divider *ngIf="(tkcoinCardTransactionHistoryPreAuth && tkcoinCardTransactionHistoryPreAuth[0]) || (tkcoinCardTransactionHistoryConfirming && tkcoinCardTransactionHistoryConfirming[0])">\n        <span translate>Completed</span>\n      </ion-item-divider>\n      <ion-list class="bp-list">\n        <div *ngFor="let card of tkcoinCardTransactionHistoryCompleted">\n          <page-card-item [card]="card" [currency]="currency"></page-card-item>\n        </div>\n      </ion-list>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tkcoin_tkcoin__["a" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_tkcoin_card_tkcoin_card__["a" /* TKCoinCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__["a" /* ThemeProvider */]])
], TKCoinCardPage);

//# sourceMappingURL=tkcoin-card.js.map

/***/ }),

/***/ 506:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_language_language__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_new_feature_data_new_feature_data__ = __webpack_require__(969);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_tkcoin_card_tkcoin_card__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__angular_animations__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__add_add__ = __webpack_require__(396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__buy_crypto_crypto_settings_crypto_settings__ = __webpack_require__(987);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__exchange_crypto_exchange_crypto_settings_exchange_crypto_settings__ = __webpack_require__(990);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__integrations_coinbase_coinbase_settings_coinbase_settings__ = __webpack_require__(992);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__integrations_gift_cards_gift_cards_settings_gift_cards_settings__ = __webpack_require__(993);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__integrations_tkcoin_card_tkcoin_settings_tkcoin_settings__ = __webpack_require__(995);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__integrations_wallet_connect_wallet_connect__ = __webpack_require__(508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__new_feature_new_feature__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pin_pin_modal_pin_modal__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__about_about__ = __webpack_require__(510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__addressbook_addressbook__ = __webpack_require__(997);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__advanced_advanced__ = __webpack_require__(999);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__alt_currency_alt_currency__ = __webpack_require__(1002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__fee_policy_fee_policy__ = __webpack_require__(1003);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__key_settings_key_settings__ = __webpack_require__(1004);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__language_language__ = __webpack_require__(1017);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__local_theme_local_theme__ = __webpack_require__(1018);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__lock_lock__ = __webpack_require__(1019);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__notifications_notifications__ = __webpack_require__(1020);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__share_share__ = __webpack_require__(512);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__tkcoin_id_tkcoin_id__ = __webpack_require__(1021);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__wallet_settings_wallet_settings__ = __webpack_require__(513);




















// pages























let SettingsPage = class SettingsPage {
    constructor(navCtrl, app, language, externalLinkProvider, profileProvider, configProvider, logger, homeIntegrationsProvider, bitPayCardProvider, platformProvider, translate, modalCtrl, touchid, analyticsProvider, persistenceProvider, bitPayIdProvider, changeRef, iabCardProvider, themeProvider, events, newFeatureData) {
        this.navCtrl = navCtrl;
        this.app = app;
        this.language = language;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.touchid = touchid;
        this.analyticsProvider = analyticsProvider;
        this.persistenceProvider = persistenceProvider;
        this.bitPayIdProvider = bitPayIdProvider;
        this.changeRef = changeRef;
        this.iabCardProvider = iabCardProvider;
        this.themeProvider = themeProvider;
        this.events = events;
        this.newFeatureData = newFeatureData;
        this.integrationServices = [];
        this.cardServices = [];
        this.externalServices = [];
        this.tkcoinCardItems = [];
        this.showTKCoinCard = false;
        this.network = __WEBPACK_IMPORTED_MODULE_14__providers_persistence_persistence__["a" /* Network */][this.bitPayIdProvider.getEnvironment().network];
        this.showReorder = false;
        this.tapped = 0;
        this.certOnlyTapped = 0;
        this.appName = this.app.info.nameCase;
        this.appVersion = this.app.info.version;
        this.isCordova = this.platformProvider.isCordova;
        this.isCopay = this.app.info.name === 'copay';
        this.user$ = this.iabCardProvider.user$;
        this.events.subscribe('updateCards', cards => {
            if (cards && cards.length > 0) {
                this.tkcoinCardItems = cards;
            }
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SettingsPage');
    }
    ionViewWillEnter() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.persistenceProvider
                .getBitpayIdPairingFlag()
                .then(res => (this.tkcoinIdPairingEnabled = res === 'enabled'));
            if (this.iabCardProvider.ref) {
                // check for user info
                this.persistenceProvider
                    .getTKCoinIdUserInfo(this.network)
                    .then((user) => {
                    this.bitPayIdUserInfo = user;
                });
                this.user$.subscribe((user) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                    if (user) {
                        this.bitPayIdUserInfo = user;
                        this.changeRef.detectChanges();
                    }
                }));
            }
            this.currentLanguageName = this.language.getName(this.language.getCurrent());
            const opts = {
                showHidden: true
            };
            const wallets = this.profileProvider.getWallets(opts);
            this.walletsGroups = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](__WEBPACK_IMPORTED_MODULE_4_lodash__["groupBy"](__WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](wallets, wallet => {
                return wallet.keyId != 'read-only';
            }), 'keyId'));
            this.readOnlyWalletsGroup = this.profileProvider.getWalletsFromGroup({
                keyId: 'read-only'
            });
            this.config = this.configProvider.get();
            this.selectedAlternative = {
                name: this.config.wallet.settings.alternativeName,
                isoCode: this.config.wallet.settings.alternativeIsoCode
            };
            this.lockMethod =
                this.config && this.config.lock && this.config.lock.method
                    ? this.config.lock.method.toLowerCase()
                    : null;
            this.useLegacyQrCode = this.config.legacyQrCode.show;
            this.showTotalBalance = this.config.totalBalance.show;
            this.featureList = yield this.newFeatureData.get();
        });
    }
    ionViewDidEnter() {
        // Show integrations
        const integrations = this.homeIntegrationsProvider.get();
        // Get Theme
        this.appTheme = this.themeProvider.getCurrentAppTheme();
        // Hide TKCoin if linked
        setTimeout(() => {
            this.integrationServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](integrations), x => {
                if (x.type == 'card' ||
                    x.type == 'external-services' ||
                    (this.platformProvider.isMacApp() && !x.linked))
                    return false;
                else
                    return x;
            });
            this.cardServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](integrations), x => {
                if (x.name === 'debitcard' ||
                    x.type === 'exchange' ||
                    x.type === 'external-services' ||
                    (x.name === 'giftcards' && this.platformProvider.isMacApp()))
                    return false;
                else
                    return x;
            });
            this.externalServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](integrations), x => {
                if (x.type !== 'external-services')
                    return false;
                else
                    return x;
            });
        }, 200);
        // Only TKCoin Wallet
        this.bitPayCardProvider.get({ noHistory: true }).then(cards => {
            this.showTKCoinCard = !!this.app.info._enabledExtensions.debitcard;
            this.tkcoinCardItems = cards;
        });
    }
    trackBy(index) {
        return index;
    }
    openTKCoinIdPage() {
        if (this.bitPayIdUserInfo) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_41__tkcoin_id_tkcoin_id__["a" /* TKCoinIdPage */], this.bitPayIdUserInfo);
        }
        else {
            this.iabCardProvider.loadingWrapper(() => {
                this.logger.log('settings - pairing');
                this.iabCardProvider.show();
                setTimeout(() => {
                    this.iabCardProvider.sendMessage({
                        message: 'pairingOnly'
                    }, () => { });
                }, 100);
            });
        }
    }
    mdesFlag() {
        // adding this for testing purposes
        this.tapped++;
        if (this.tapped >= 10) {
            this.persistenceProvider.getTempMdesFlag().then(flag => {
                if (flag === 'bypassed') {
                    this.persistenceProvider.setTempMdesFlag('disabled');
                    alert('MDES bypass -> disabled');
                }
                else {
                    this.persistenceProvider.setTempMdesFlag('bypassed');
                    alert('MDES bypass -> bypassed');
                }
                this.tapped = 0;
            });
        }
    }
    mdesCertOnlyFlag() {
        // adding this for testing purposes
        this.certOnlyTapped++;
        if (this.certOnlyTapped >= 10) {
            this.persistenceProvider.getTempMdesCertOnlyFlag().then(flag => {
                if (flag === 'bypassed') {
                    this.persistenceProvider.setTempMdesCertOnlyFlag('disabled');
                    alert('MDES cert only bypass -> disabled');
                }
                else {
                    this.persistenceProvider.setTempMdesCertOnlyFlag('bypassed');
                    alert('MDES cert only bypass -> bypassed');
                }
                this.certOnlyTapped = 0;
            });
        }
    }
    openAltCurrencyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_33__alt_currency_alt_currency__["a" /* AltCurrencyPage */]);
    }
    openLanguagePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_36__language_language__["a" /* LanguagePage */]);
    }
    openWhatsNew() {
        if (this.featureList && this.featureList.features.length > 0) {
            const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_28__new_feature_new_feature__["a" /* NewFeaturePage */], {
                featureList: this.featureList
            });
            modal.present();
            modal.onDidDismiss(data => {
                if (data && data.data && typeof data.data !== 'boolean') {
                    this.events.publish('IncomingDataRedir', data.data);
                }
            });
        }
    }
    openAdvancedPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_32__advanced_advanced__["a" /* AdvancedPage */]);
    }
    openAboutPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_30__about_about__["a" /* AboutPage */]);
    }
    openThemePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_37__local_theme_local_theme__["a" /* LocalThemePage */]);
    }
    openLockPage() {
        const config = this.configProvider.get();
        const lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod || lockMethod == 'disabled')
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_38__lock_lock__["a" /* LockPage */]);
        if (lockMethod == 'pin')
            this.openPinModal('lockSetUp');
        if (lockMethod == 'fingerprint')
            this.checkFingerprint();
    }
    openAddressBookPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_31__addressbook_addressbook__["a" /* AddressbookPage */]);
    }
    openNotificationsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_39__notifications_notifications__["a" /* NotificationsPage */]);
    }
    openFeePolicyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_34__fee_policy_fee_policy__["a" /* FeePolicyPage */]);
    }
    openWalletSettingsPage(walletId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_42__wallet_settings_wallet_settings__["a" /* WalletSettingsPage */], { walletId });
    }
    openSharePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_40__share_share__["a" /* SharePage */]);
    }
    openSettingIntegration(name) {
        switch (name) {
            case 'coinbase':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_24__integrations_coinbase_coinbase_settings_coinbase_settings__["a" /* CoinbaseSettingsPage */]);
                break;
            case 'debitcard':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_26__integrations_tkcoin_card_tkcoin_settings_tkcoin_settings__["a" /* TKCoinSettingsPage */]);
                break;
            case 'buycrypto':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_22__buy_crypto_crypto_settings_crypto_settings__["a" /* CryptoSettingsPage */]);
                break;
            case 'exchangecrypto':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_23__exchange_crypto_exchange_crypto_settings_exchange_crypto_settings__["a" /* ExchangeCryptoSettingsPage */]);
                break;
            case 'giftcards':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_25__integrations_gift_cards_gift_cards_settings_gift_cards_settings__["a" /* GiftCardsSettingsPage */]);
                break;
            case 'walletConnect':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_27__integrations_wallet_connect_wallet_connect__["a" /* WalletConnectPage */]);
                break;
        }
    }
    openCardSettings(id) {
        this.iabCardProvider.loadingWrapper(() => {
            const message = `openSettings?${id}`;
            this.iabCardProvider.show();
            setTimeout(() => {
                this.iabCardProvider.sendMessage({
                    message
                }, () => { });
            });
        });
    }
    openGiftCardsSettings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_25__integrations_gift_cards_gift_cards_settings_gift_cards_settings__["a" /* GiftCardsSettingsPage */]);
    }
    openHelpExternalLink() {
        this.analyticsProvider.logEvent('help', {});
        const url = this.appName == 'Copay'
            ? 'https://github.com/tkcoin/copay/issues'
            : 'https://help.tkcoin.org/tkcoin-app';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_29__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(cancelClicked => {
            if (!cancelClicked)
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_38__lock_lock__["a" /* LockPage */]);
        });
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_38__lock_lock__["a" /* LockPage */]);
        });
    }
    openSupportEncryptPassword() {
        const url = 'https://support.tkcoin.org/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openWalletGroupSettings(keyId) {
        if (this.showReorder)
            return;
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_35__key_settings_key_settings__["a" /* KeySettingsPage */], { keyId });
    }
    goToAddView() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__add_add__["a" /* AddPage */], {
            isZeroState: true
        });
    }
    toggleShowBalanceFlag() {
        let opts = {
            totalBalance: { show: this.showTotalBalance }
        };
        this.configProvider.set(opts);
        if (this.showTotalBalance)
            this.events.publish('Local/FetchWallets');
    }
    reorder() {
        this.showReorder = !this.showReorder;
    }
    reorderAccounts(indexes) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const element = this.walletsGroups[indexes.from];
            this.walletsGroups.splice(indexes.from, 1);
            this.walletsGroups.splice(indexes.to, 0, element);
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](this.walletsGroups, (walletGroup, index) => {
                this.profileProvider.setWalletGroupOrder(walletGroup[0].keyId, index);
            });
            yield new Promise(resolve => setTimeout(resolve, 1000));
            this.profileProvider.setOrderedWalletsByGroup();
        });
    }
    toggleQrCodeLegacyFlag() {
        let opts = {
            legacyQrCode: { show: this.useLegacyQrCode }
        };
        this.configProvider.set(opts);
    }
    openPrivacyPolicy() {
        const url = 'https://tkcoin.org/about/privacy';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Privacy Notice');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openTermsOfUse() {
        const url = 'https://tkcoin.org/legal/terms-of-use/#wallet-terms-of-use';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Wallet Terms of Use');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
SettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/settings.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Settings\' | translate }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          {{ \'Settings\' | translate }}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list">\n      <ion-item-divider> {{ \'General\' | translate }} </ion-item-divider>\n\n      <button ion-item (click)="openWhatsNew()" *ngIf="featureList && featureList.features.length > 0">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-info.svg" />\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>What\'s new</span>\n        </ion-label>\n        <ion-note item-end>\n          {{appVersion}}\n        </ion-note>\n      </button>\n      \n      <button ion-item (click)="openThemePage()">\n        <ion-icon class="item-img icon-settings ionic-icon" name="ios-color-palette" item-start></ion-icon>\n        <ion-label>\n          <div class="main-label">{{ \'Theme\' | translate }}</div>\n        </ion-label>\n        <ion-note *ngIf="appTheme" item-end>\n          {{ appTheme }}\n        </ion-note>\n      </button>\n\n      <button ion-item (click)="openAltCurrencyPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-currency.svg" />\n        </ion-icon>\n        <ion-label>\n          <div class="main-label">{{ \'Display Currency\' | translate }}</div>\n        </ion-label>\n        <ion-note *ngIf="selectedAlternative" item-end>\n          {{ selectedAlternative.name }}\n        </ion-note>\n      </button>\n\n      <button ion-item (click)="openLanguagePage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-language.svg" />\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Language</span>\n        </ion-label>\n        <ion-note *ngIf="currentLanguageName" item-end>\n          {{ currentLanguageName }}\n        </ion-note>\n      </button>\n\n      <button ion-item *ngIf="isCordova" (click)="openLockPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-lock.svg" />\n        </ion-icon>\n        <ion-label>\n          <div class="main-label">{{ \'Lock App\' | translate }}</div>\n        </ion-label>\n        <ion-note *ngIf="lockMethod === \'disabled\'" item-end>\n          {{ \'Disabled\' | translate }}\n        </ion-note>\n        <ion-note *ngIf="lockMethod === \'pin\'" item-end>\n          {{ \'PIN\' | translate }}\n        </ion-note>\n        <ion-note *ngIf="lockMethod === \'fingerprint\'" item-end>\n          {{ \'Biometric\' | translate }}\n        </ion-note>\n      </button>\n\n      <button ion-item (click)="openNotificationsPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-notifications.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Notifications</span>\n      </button>\n\n      <ion-item class="align-with-button">\n        <ion-icon class="item-img icon-settings ionic-icon" name="md-eye" item-start></ion-icon>\n        <ion-label>\n          <div class="main-label">\n            {{\'Show Portfolio Value\' | translate}}\n          </div>\n        </ion-label>\n        <ion-toggle [(ngModel)]="showTotalBalance" (ionChange)="toggleShowBalanceFlag()"></ion-toggle>\n      </ion-item>\n\n      <ion-item-divider *ngIf="walletsGroups && walletsGroups[0]">\n        {{ \'Crypto Wallets & Keys\' | translate }}\n        <button class="reorder-option" ion-button item-end clear *ngIf="!showReorder && walletsGroups?.length > 1" (click)="reorder()">\n          <img src="assets/img/sort.svg">\n        </button>\n        <button class="reorder-option" ion-button item-end clear *ngIf="showReorder" (click)="reorder()">\n          {{\'Done\' | translate}}\n        </button>\n      </ion-item-divider>\n\n      <button ion-item (click)="openAddressBookPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-address-book.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Address Book</span>\n      </button>\n\n      <button ion-item (click)="openFeePolicyPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-network.svg" />\n        </ion-icon>\n        <ion-label>\n          <div class="main-label">\n            {{ \'Bitcoin Network Fee Policy\' | translate }}\n          </div>\n        </ion-label>\n      </button>\n\n      <ion-item class="align-with-button">\n        <ion-icon class="item-img icon-settings icon-qrcode" style="opacity: 0.3;" item-start>\n          <img src="assets/img/settings-icons/icon-qrcode.svg">\n        </ion-icon>\n        <ion-label>\n          <div class="main-label">\n            {{\'Use Basic QR Code\' | translate}}\n          </div>\n        </ion-label>\n        <ion-toggle [(ngModel)]="useLegacyQrCode" (ionChange)="toggleQrCodeLegacyFlag()"></ion-toggle>\n      </ion-item>\n\n      <ion-list reorder="{{showReorder}}" (ionItemReorder)="reorderAccounts($event)">\n        <button ion-item [attr.detail-none]="showReorder ? true : null" *ngFor="let walletsGroup of walletsGroups; let i = index" (click)="openWalletGroupSettings(walletsGroup[0].keyId)">\n          <ion-icon class="item-img icon-settings" item-start>\n            <img src="assets/img/settings-icons/icon-key.svg" />\n          </ion-icon>\n          <ion-label>\n            <div class="main-label">\n              <span>{{profileProvider.getWalletGroup(walletsGroup[0].keyId).name}}</span>\n            </div>\n          </ion-label>\n          <ion-note *ngIf="walletsGroup.length == 1" item-end>\n            {{\'{walletsGroupLength} Wallet\' | translate:{walletsGroupLength: walletsGroup.length} }}\n          </ion-note>\n          <ion-note *ngIf="walletsGroup.length > 1" item-end>\n            {{\'{walletsGroupLength} Wallets\' | translate:{walletsGroupLength: walletsGroup.length} }}\n          </ion-note>\n        </button>\n      </ion-list>\n\n      <button ion-item (click)="openWalletGroupSettings(readOnlyWalletsGroup[0].keyId)" *ngIf="readOnlyWalletsGroup && readOnlyWalletsGroup.length > 0">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-read-only.svg" width="26" />\n        </ion-icon>\n        <ion-label>\n          <div class="main-label" translate>\n            Read Only\n          </div>\n        </ion-label>\n        <ion-note *ngIf="readOnlyWalletsGroup.length == 1" item-end>\n          {{\'{walletsGroupLength} Wallet\' | translate:{walletsGroupLength: readOnlyWalletsGroup.length} }}\n        </ion-note>\n        <ion-note *ngIf="readOnlyWalletsGroup.length > 1" item-end>\n          {{\'{walletsGroupLength} Wallets\' | translate:{walletsGroupLength: readOnlyWalletsGroup.length} }}\n        </ion-note>\n      </button>\n\n      <button ion-item detail-none class="create-button" *ngIf="walletsGroups && walletsGroups[0]" (click)="goToAddView()">\n        {{ \'Create or Import a Key\' | translate }}\n      </button>\n\n      <!-- TODO FIX HIDE UNRELATED SETTINGS\n      <ion-item-divider *ngIf="cardServices && cardServices[0]">\n        {{ \'Cards\' | translate }}\n      </ion-item-divider>\n\n      <div *ngIf="isCordova && !isCopay && showTKCoinCard && tkcoinCardItems?.length">\n        <ion-list>\n          <ng-container *ngFor="let card of tkcoinCardItems; let i = index; trackBy: trackBy">\n            <button ion-item (click)="openCardSettings(card.id)" @fade *ngIf="!card.hide">\n              <ion-icon class="item-img" item-start>\n                <img src="assets/img/tkcoin-card/tkcoin-card-icon-list.svg" />\n              </ion-icon>\n              <div class="main-label">TKCoin {{card.brand === \'Mastercard\'? \'Mastercard&reg;\' : \'Visa&reg; Card\'}} ({{card.lastFourDigits}})</div>\n              <ion-note item-end *ngIf="card.cardType === \'virtual\'">\n                <span translate>Virtual</span>\n              </ion-note>\n            </button>\n          </ng-container>\n        </ion-list>\n      </div>\n\n      <button ion-item *ngFor="let card of (cardServices | orderBy: [\'title\'])" (click)="openSettingIntegration(card.name)">\n        <ion-icon class="item-img" item-start>\n          <img src="{{card.icon}}" />\n        </ion-icon>\n        <span class="main-label">{{ card.title }}</span>\n        <ion-note item-end *ngIf="card.linked">\n          <span *ngIf="card.linked" translate>Linked</span>\n          <span *ngIf="!card.linked">\n            {{ card.show ? (\'On\' | translate) : (\'Off\' | translate) }}\n          </span>\n        </ion-note>\n      </button>\n\n      <ng-container *ngIf="isCordova && !isCopay">\n        <ion-item-divider tappable (click)="mdesFlag()">\n          {{\'TKCoin Account\' | translate}}\n        </ion-item-divider>\n\n        <button ion-item (click)="openTKCoinIdPage()">\n          <ion-icon class="item-img" item-start>\n            <img src="assets/img/tkcoin-card/icon-tkcoin.svg" width="25">\n          </ion-icon>\n          <span class="main-label">{{ bitPayIdUserInfo ? bitPayIdUserInfo.email : \'Connect your TKCoin ID\' | translate}}</span>\n          <ion-note item-end *ngIf="bitPayIdUserInfo">\n            <span translate>Linked</span>\n          </ion-note>\n        </button>\n      </ng-container>\n\n\n      <ion-item-divider *ngIf="integrationServices && integrationServices[0]">\n        {{ \'Exchanges\' | translate }}\n      </ion-item-divider>\n\n      <button ion-item *ngFor="let integration of (integrationServices | orderBy: [\'title\'])" (click)="openSettingIntegration(integration.name)">\n        <ion-icon class="item-img" item-start>\n          <img src="{{integration.icon}}" />\n        </ion-icon>\n        <span class="main-label">{{ integration.title }}</span>\n        <div *ngIf="integration.linked && integration.email" class="secondary-label">{{ integration.email }}</div>\n        <ion-note item-end *ngIf="integration.linked">\n          <span *ngIf="integration.linked" translate>Linked</span>\n          <span *ngIf="!integration.linked">\n            {{ integration.show ? (\'On\' | translate) : (\'Off\' | translate) }}\n          </span>\n        </ion-note>\n      </button>\n      -->\n\n      <!-- TODO FIX\n      <ion-item-divider *ngIf="externalServices && externalServices[0]">\n        {{ \'External Services\' | translate }}\n      </ion-item-divider>\n\n      <button ion-item *ngFor="let externalService of (externalServices | orderBy: [\'title\'])" (click)="openSettingIntegration(externalService.name)">\n        <ion-icon class="item-img" item-start>\n          <img src="{{externalService.icon}}" />\n        </ion-icon>\n        <span class="main-label">{{ externalService.title }}</span>\n      </button>\n      -->\n    \n      <ion-item-divider tappable (click)="mdesCertOnlyFlag()">{{ \'More\' | translate }}</ion-item-divider>\n\n      <button ion-item (click)="openAdvancedPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-advanced.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Advanced</span>\n      </button>\n\n      <!-- TODO FIX\n      <button ion-item (click)="openHelpExternalLink()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-help-support.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Help &amp; Support</span>\n      </button>\n\n      <button ion-item *ngIf="isCordova" (click)="openSharePage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-heart.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Share</span> {{ appName }}\n      </button>\n\n      <button ion-item (click)="openPrivacyPolicy()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-lock.svg" />\n        </ion-icon>\n        <span class="main-label" translate>Privacy Notice</span>\n      </button>\n\n      <button ion-item (click)="openTermsOfUse()">\n        <ion-icon class="item-img icon-settings ionic-icon" name="md-list-box" item-start></ion-icon>\n        <span class="main-label" translate>Terms of Use</span>\n      </button>\n      -->\n      <button ion-item (click)="openAboutPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-info.svg" />\n        </ion-icon>\n        <span class="main-label" translate>About {{ appName }}</span>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/settings.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_20__angular_animations__["l" /* trigger */])('fade', [
                Object(__WEBPACK_IMPORTED_MODULE_20__angular_animations__["k" /* transition */])(':enter', [
                    Object(__WEBPACK_IMPORTED_MODULE_20__angular_animations__["j" /* style */])({
                        transform: 'translateY(5px)',
                        opacity: 0
                    }),
                    Object(__WEBPACK_IMPORTED_MODULE_20__angular_animations__["e" /* animate */])('200ms')
                ])
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_tkcoin_card_tkcoin_card__["a" /* TKCoinCardProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["_19" /* TKCoinIdProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ChangeDetectorRef"],
        __WEBPACK_IMPORTED_MODULE_5__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_theme_theme__["a" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_13__providers_new_feature_data_new_feature_data__["a" /* NewFeatureData */]])
], SettingsPage);

//# sourceMappingURL=settings.js.map

/***/ }),

/***/ 507:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WyrePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__wyre_details_wyre_details__ = __webpack_require__(989);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wyre_wyre__ = __webpack_require__(289);




// Pages

// Proviers





let WyrePage = class WyrePage {
    constructor(analyticsProvider, logger, externalLinkProvider, modalCtrl, navParams, wyreProvider, themeProvider) {
        this.analyticsProvider = analyticsProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.wyreProvider = wyreProvider;
        this.themeProvider = themeProvider;
    }
    ionViewDidLoad() {
        this.wyrePaymentRequests = [];
        this.logger.info('Loaded: WyrePage');
    }
    ionViewWillEnter() {
        this.init();
    }
    init() {
        this.loading = true;
        this.wyreProvider
            .getWyre()
            .then(wyreData => {
            if (!wyreData || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wyreData))
                wyreData = {};
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.navParams.data) && this.navParams.data.orderId) {
                wyreData[this.navParams.data.orderId] = this.navParams.data;
                this.logger.debug('Wyre trying to get order details');
                this.wyreProvider
                    .getWalletOrderDetails(this.navParams.data.orderId)
                    .then((orderData) => {
                    this.logger.debug('Wyre get order details: SUCCESS');
                    if (orderData && !__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](orderData)) {
                        switch (orderData.status) {
                            case 'RUNNING_CHECKS':
                                wyreData[this.navParams.data.orderId].status =
                                    'paymentRequestSent';
                                break;
                            case 'PROCESSING':
                                wyreData[this.navParams.data.orderId].status =
                                    'paymentRequestSent';
                                break;
                            case 'FAILED':
                                wyreData[this.navParams.data.orderId].status = 'failed';
                                break;
                            case 'COMPLETE':
                                wyreData[this.navParams.data.orderId].status = 'success';
                                break;
                            default:
                                wyreData[this.navParams.data.orderId].status =
                                    'paymentRequestSent';
                                break;
                        }
                        wyreData[this.navParams.data.orderId].sourceAmount = orderData.sourceAmount
                            ? orderData.sourceAmount
                            : '';
                        wyreData[this.navParams.data.orderId].destAmount = this
                            .navParams.data.destAmount
                            ? this.navParams.data.destAmount
                            : '';
                        wyreData[this.navParams.data.orderId].purchaseAmount = orderData.purchaseAmount
                            ? orderData.purchaseAmount
                            : '';
                        wyreData[this.navParams.data.orderId].fee =
                            orderData.sourceAmount &&
                                orderData.purchaseAmount &&
                                orderData.sourceAmount - orderData.purchaseAmount >= 0
                                ? orderData.sourceAmount - orderData.purchaseAmount
                                : ''; // Total fee (crypto fee + Wyre fee)
                        wyreData[this.navParams.data.orderId].destCurrency = orderData.destCurrency
                            ? orderData.destCurrency
                            : '';
                        wyreData[this.navParams.data.orderId].sourceCurrency = orderData.sourceCurrency
                            ? orderData.sourceCurrency
                            : '';
                        if (orderData.transferId) {
                            wyreData[this.navParams.data.orderId].transferId =
                                orderData.transferId;
                            this.logger.debug('Wyre trying get transfer');
                            this.wyreProvider
                                .getTransfer(orderData.transferId)
                                .then((transferData) => {
                                this.logger.debug('Wyre get transfer: SUCCESS');
                                if (transferData && !__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](transferData)) {
                                    wyreData[this.navParams.data.orderId].blockchainNetworkTx = transferData.blockchainNetworkTx
                                        ? transferData.blockchainNetworkTx
                                        : '';
                                    wyreData[this.navParams.data.orderId].destAmount = transferData.destAmount
                                        ? transferData.destAmount
                                        : '';
                                    this.setWyrePaymentRequests(wyreData);
                                    this.saveWyre(wyreData[this.navParams.data.orderId], true);
                                }
                            })
                                .catch(_err => {
                                this.logger.warn('Could not get transfer for transferId: ' +
                                    orderData.transferId);
                                this.setWyrePaymentRequests(wyreData);
                                this.saveWyre(wyreData[this.navParams.data.orderId], true);
                            });
                        }
                        else {
                            this.setWyrePaymentRequests(wyreData);
                            this.saveWyre(wyreData[this.navParams.data.orderId], true);
                        }
                    }
                })
                    .catch(_err => {
                    this.logger.warn('Could not get order details for orderId: ' +
                        this.navParams.data.orderId);
                    this.setWyrePaymentRequests(wyreData);
                    this.saveWyre(wyreData[this.navParams.data.orderId], false);
                });
            }
            else {
                this.setWyrePaymentRequests(wyreData);
            }
        })
            .catch(err => {
            this.loading = false;
            if (err)
                this.logger.error(err);
        });
    }
    setWyrePaymentRequests(wyreData) {
        const wyrePaymentRequests = {};
        Object.assign(wyrePaymentRequests, wyreData);
        this.wyrePaymentRequests = Object.values(wyrePaymentRequests);
        this.loading = false;
    }
    saveWyre(wyreOrderData, addToAnalytics) {
        this.wyreProvider
            .saveWyre(wyreOrderData, null)
            .then(() => {
            this.logger.debug('Saved Wyre with orderId: ' + wyreOrderData.orderId);
            if (addToAnalytics && wyreOrderData.walletId) {
                this.analyticsProvider.logEvent('buy_crypto_payment_success', {
                    exchange: 'wyre',
                    userId: wyreOrderData.walletId
                });
            }
        })
            .catch(() => {
            this.logger.warn('Could not update payment request status');
        });
    }
    openWyreModal(paymentRequestData) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__wyre_details_wyre_details__["a" /* WyreDetailsPage */], {
            paymentRequestData
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data &&
                this.navParams.data &&
                data.removedPaymentRequest == this.navParams.data.orderId) {
                delete this.navParams.data;
            }
            this.init();
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
WyrePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wyre',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wyre/wyre.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img width="110" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/wyre/logo-wyre.svg\' : \'assets/img/wyre/logo-wyre-dm.svg\'" alt="Wyre" class="wyre-logo">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <div>\n          <expandable-header-primary>\n            <img margin-left width="130" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/wyre/logo-wyre.svg\' : \'assets/img/wyre/logo-wyre-dm.svg\'" alt="Wyre">\n          </expandable-header-primary>\n        </div>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list" *ngIf="wyrePaymentRequests && wyrePaymentRequests.length > 0">\n      <ion-item-divider>{{\'Payment Requests\' | translate}}\n        <ion-spinner item-end name="crescent" *ngIf="loading"></ion-spinner>\n      </ion-item-divider>\n      <button ion-item *ngFor="let paymentRequest of wyrePaymentRequests | orderBy : [\'-created_on\']" (click)="openWyreModal(paymentRequest)">\n        <ion-label>\n          <div class="ellipsis">{{paymentRequest.sourceAmount }} {{ paymentRequest.sourceCurrency }}</div>\n          <div class="status">\n            <span class="assertive" *ngIf="paymentRequest.status == \'failed\'" translate>Payment request rejected</span>\n            <span class="balanced" *ngIf="paymentRequest.status == \'success\'" translate>Payment request approved</span>\n            <span class="royal" *ngIf="paymentRequest.status == \'paymentRequestSent\'" translate>Attempted payment request</span>\n          </div>\n        </ion-label>\n        <div item-content text-end>\n          <div class="text-bold">{{ paymentRequest.destAmount | number:\'1.0-6\'}} {{ paymentRequest.destCurrency }}</div>\n          <div class="date calm">{{paymentRequest.created_on | amTimeAgo}}</div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <div class="wyre-problems">\n      <span translate>Having problems with Wyre?</span>\n      <a (click)="openExternalLink(\'https://wyre-support.zendesk.com/hc/en-us/requests/new\')" translate>\n        Visit Help Center\n      </a>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wyre/wyre.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wyre_wyre__["a" /* WyreProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_theme_theme__["a" /* ThemeProvider */]])
], WyrePage);

//# sourceMappingURL=wyre.js.map

/***/ }),

/***/ 508:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletConnectPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__scan_scan__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash__);




// Pages


// Providers


let WalletConnectPage = class WalletConnectPage {
    constructor(actionSheetProvider, logger, navParams, persistenceProvider, profileProvider, translate, walletConnectProvider, errorsProvider, popupProvider, analyticsProvider, navCtrl, events, platformProvider, externalLinkProvider, replaceParametersProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.persistenceProvider = persistenceProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.walletConnectProvider = walletConnectProvider;
        this.errorsProvider = errorsProvider;
        this.popupProvider = popupProvider;
        this.analyticsProvider = analyticsProvider;
        this.navCtrl = navCtrl;
        this.events = events;
        this.platformProvider = platformProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.uri = '';
        this.requests = [];
        this.connected = false;
        this.activeChainId = 1;
        this.updateAddressHandler = data => {
            this.analyticsProvider.logEvent('wallet_connect_camera_scan_attempt', {});
            this.uri = data.value;
        };
        this.setConnectionData = _ => {
            const { connected, activeChainId, walletId, address, peerMeta, requests } = this.walletConnectProvider.getConnectionData();
            this.connected = connected;
            this.activeChainId = activeChainId;
            this.wallet = this.profileProvider.getWallet(walletId);
            this.address = address;
            this.peerMeta = peerMeta;
            this.requests = requests;
        };
        this.setRequests = requests => {
            this.requests = requests;
        };
        this.isCordova = this.platformProvider.isCordova;
        this.uri = this.navParams.data.uri;
        this.events.subscribe('Local/UriScan', this.updateAddressHandler);
        this.events.subscribe('Update/ConnectionData', this.setConnectionData);
        this.events.subscribe('Update/Requests', this.setRequests);
    }
    ngOnInit() {
        this.initWallet();
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/UriScan', this.updateAddressHandler);
        this.events.unsubscribe('Update/ConnectionData', this.setConnectionData);
        this.events.unsubscribe('Update/Requests', this.setRequests);
    }
    initWallet() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const walletConnectData = yield this.persistenceProvider.getWalletConnect();
            if (walletConnectData) {
                this.setConnectionData();
                if (this.uri && this.uri.indexOf('bridge') !== -1) {
                    this.showNewConnectionAlert();
                }
                else {
                    this.uri = null;
                }
            }
            else {
                this.wallets = this.profileProvider.getWallets({
                    coin: 'eth',
                    onlyComplete: true,
                    backedUp: true
                });
                if (__WEBPACK_IMPORTED_MODULE_7_lodash__["isEmpty"](this.wallets)) {
                    return;
                }
                else {
                    this.onWalletSelect(this.wallets[0]);
                }
            }
        });
    }
    onWalletSelect(wallet) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.wallet = wallet;
            this.walletConnectProvider.setAccountInfo(wallet);
        });
    }
    initWalletConnect() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('Initialize wallet connect with uri: ' + this.uri);
            this.walletConnectProvider.initWalletConnect(this.uri);
            this.uri = null;
        });
    }
    showNewConnectionAlert() {
        const wallet = this.wallet;
        const peerMeta = this.peerMeta;
        const title = this.translate.instant('New Session Request');
        const message = this.replaceParametersProvider.replace(this.translate.instant(`{{walletName}} will be disconected from your actual connection to {{peerMetaName}} ({{peerMetaUrl}})`), {
            walletName: wallet.name,
            peerMetaName: peerMeta.name,
            peerMetaUrl: peerMeta.url
        });
        const okText = this.translate.instant('Continue');
        const cancelText = this.translate.instant('Go Back');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.killSession();
            }
        });
    }
    killSession() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.walletConnectProvider.killSession();
            this.initWallet();
        });
    }
    showWallets() {
        const params = {
            wallets: this.wallets,
            selectedWalletId: null,
            title: this.translate.instant('Select a wallet')
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            this.onSelectWalletEvent(wallet);
        });
    }
    onSelectWalletEvent(wallet) {
        if (!__WEBPACK_IMPORTED_MODULE_7_lodash__["isEmpty"](wallet))
            this.onWalletSelect(wallet);
    }
    rejectRequest(request) {
        this.walletConnectProvider.rejectRequest(request);
    }
    approveRequest(request) {
        try {
            let addressRequested = request.params[0].from || request.params[0];
            const address = this.address;
            const wallet = this.wallet;
            const peerMeta = this.peerMeta;
            switch (request.method) {
                case 'eth_sendTransaction':
                    if (address.toLowerCase() === addressRequested.toLowerCase()) {
                        // redirect to confirm page with navParams
                        let data = {
                            amount: request.params[0].value,
                            toAddress: request.params[0].to,
                            coin: wallet.credentials.coin,
                            walletId: wallet.credentials.walletId,
                            network: wallet.network,
                            data: request.params[0].data,
                            gasLimit: request.params[0].gas,
                            walletConnectRequestId: request.id
                        };
                        this.logger.debug('redirect to confirm page with data: ', JSON.stringify(data));
                        this.openConfirmPageConfirmation(peerMeta, data);
                    }
                    else {
                        this.errorsProvider.showDefaultError(this.translate.instant('Address requested does not match active account'), this.translate.instant('Error'));
                    }
                    break;
                case 'eth_signTypedData':
                    if (address.toLowerCase() === addressRequested.toLowerCase()) {
                        const result = this.walletConnectProvider.signTypedData(JSON.parse(request.params[1]), this.wallet);
                        this.walletConnectProvider.approveRequest(request.id, result);
                    }
                    else {
                        this.errorsProvider.showDefaultError(this.translate.instant('Address requested does not match active account'), this.translate.instant('Error'));
                    }
                    break;
                default:
                    this.errorsProvider.showDefaultError(this.translate.instant(`Not supported method: ${request.method}`), this.translate.instant('Error'));
                    break;
            }
        }
        catch (error) {
            this.logger.error('Wallet Connect - ApproveRequest error: ', error);
            this.errorsProvider.showDefaultError(error, this.translate.instant('Error'));
        }
    }
    getChainData(chainId) {
        return this.walletConnectProvider.getChainData(chainId);
    }
    openConfirmPageConfirmation(peerMeta, data) {
        const title = this.translate.instant('Confirm Request');
        const message = this.replaceParametersProvider.replace(this.translate.instant(`Please make sure {{peerMetaName}} request is still waiting for confirmation, and that the amount is correct before proceeding to the confirmation step`), { peerMetaName: peerMeta.name });
        const okText = this.translate.instant('Continue');
        const cancelText = this.translate.instant('Go Back');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__send_confirm_confirm__["a" /* ConfirmPage */], data);
            }
        });
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__scan_scan__["a" /* ScanPage */], { fromWalletConnect: true }, { animate: false });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
WalletConnectPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-connect',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wallet-connect/wallet-connect.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">Wallet Connect</ion-title>\n    <ion-buttons *ngIf="connected" right>\n      <button (click)="killSession()" ion-button>\n        {{\'Disconnect\' | translate }}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content no-bounce>\n  <div *ngIf="!connected">\n    <label-tip type="info" header="no-header" class="no-arrowhead">\n      <div label-tip-body>\n        <span translate>WalletConnect is an open source protocol for connecting decentralized applications to mobile wallets with QR code scanning or deep linking.</span>\n        <br>\n        <br>\n        <a class="pointer" (click)="openExternalLink(\'https://walletconnect.org/\')" translate>Read more</a>\n      </div>\n    </label-tip>\n\n    <div class="uri-header-wrapper">\n      <ion-item class="search-wrapper">\n        <ion-input placeholder="{{\'Enter the wallet connect uri\' | translate}}" [(ngModel)]="uri"></ion-input>\n        <ion-icon *ngIf="isCordova" item-end class="scan-icon" (click)="openScanner()">\n          <img src="assets/img/scan-ico.svg">\n        </ion-icon>\n      </ion-item>\n    </div>\n\n    <ion-list *ngIf="wallet" class="bp-list">\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label">{{ \'Select a wallet\' | translate }}</div>\n        </ion-label>\n      </ion-item>\n      <wallet-item-content [wallet]="wallet" (click)="showWallets()"></wallet-item-content>\n    </ion-list>\n\n    <button ion-button class="button-standard" [disabled]="!uri" (click)="initWalletConnect()">\n      {{\'Connect\' | translate}}\n    </button>\n  </div>\n\n  <div *ngIf="connected && wallet">\n    <ion-list class="bp-list">\n      <ion-item *ngIf="peerMeta && peerMeta.name">\n        <ion-label>\n          <div class="main-label">\n            <div class="main-label">\n              {{ \'Connected with\' | translate}}\n              <span class="peer-meta-name">{{ peerMeta.name | uppercase }}</span>\n            </div>\n            <div class="secondary-label">{{ peerMeta.url }}</div>\n          </div>\n        </ion-label>\n      </ion-item>\n\n      <div class="description" *ngIf="peerMeta && peerMeta.description">\n        {{ peerMeta.description }}\n      </div>\n      \n      <div class="item-label" translate>{{ \'Linked wallet\' | translate }}</div>\n      <ion-item *ngIf="peerMeta && peerMeta.name">\n        <coin-icon item-start [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n        <ion-label>\n          <div class="main-label">\n              <span>{{wallet.name}}</span>\n            <div class="secondary-label">{{address | shortenedAddress}}</div>\n          </div>\n        </ion-label>\n      </ion-item>\n      \n      <div class="item-label" translate>{{ \'Pending Call Requests\' | translate }}</div>\n      <action-card *ngIf="requests.length === 0" class=\'zero-state\'>\n        <div action-card-title class="main-label">\n          {{\'No pending call requests\' | translate}}\n        </div>\n      </action-card>\n\n      <div *ngFor="let request of requests">\n        <action-card>\n          <div action-card-title class="main-label">\n            <div>\n              {{ \'Id\' }}\n              <ion-note item-end>\n                {{ request.id }}\n              </ion-note>\n            </div>\n            <div (click)="rejectRequest(request)">\n              <ion-icon ios="md-close" md="md-close"></ion-icon>\n            </div>\n          </div>\n          <div action-card-body>\n            <div class="item" *ngIf="request.method">{{ \'Method\' | translate }}</div>\n            <ion-note *ngIf="request.method" item-end>\n              {{ request.method }}\n            </ion-note>\n            <div *ngFor="let param of request.params; let i = index;">\n              <div *ngIf="request.method === \'eth_sendTransaction\'">\n                <div class="item" *ngIf="param.to">\n                  <div>{{ \'To\' | translate }}</div>\n                  <ion-note class="ellipsis" item-end>\n                    {{ param.to }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="param.gas">\n                  <div>{{ \'Gas Limit\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param.gas }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="param.gasLimit">\n                  <div>{{ \'Gas Limit\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param.gasLimit }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="param.gasPrice">\n                  <div>{{ \'Gas Price\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param.gasPrice | satToUnit: wallet.coin }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="param.nonce">\n                  <div>{{ \'Nonce\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param.nonce }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="param.value">\n                  <div>{{ \'Amount\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param.value | satToUnit: wallet.coin }}\n                  </ion-note>\n                </div>\n              </div>\n              <div *ngIf="request.method === \'eth_signTypedData\'">\n                <div class="item" *ngIf="i === 0 && param">\n                  <div>{{ \'Address\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param }}\n                  </ion-note>\n                </div>\n                <div class="item" *ngIf="i === 1 && param">\n                  <div>{{ \'Message\' | translate }}</div>\n                  <ion-note item-end>\n                    {{ param }}\n                  </ion-note>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div *ngIf="request.method === \'eth_sendTransaction\'" action-card-button (click)="approveRequest(request)">\n            {{\'Continue\' | translate }}\n          </div>\n          <div *ngIf="request.method === \'eth_signTypedData\'" action-card-button (click)="approveRequest(request)">\n            {{\'Approve\' | translate }}\n          </div>\n        </action-card>\n      </div>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wallet-connect/wallet-connect.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_5" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_30" /* WalletConnectProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["C" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_4" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["d" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_3" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["E" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_10" /* ReplaceParametersProvider */]])
], WalletConnectPage);

//# sourceMappingURL=wallet-connect.js.map

/***/ }),

/***/ 509:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Animate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let Animate = class Animate {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    animate(animationName) {
        this.renderer.addClass(this.el.nativeElement, animationName);
        setTimeout(() => {
            this.renderer.removeClass(this.el.nativeElement, animationName);
        }, 600);
    }
};
Animate = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[animate]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer2"]])
], Animate);

//# sourceMappingURL=animate.js.map

/***/ }),

/***/ 510:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AboutPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__feedback_send_feedback_send_feedback__ = __webpack_require__(511);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__session_log_session_log__ = __webpack_require__(996);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);




// pages


// providers

let AboutPage = class AboutPage {
    constructor(navCtrl, appProvider, logger, externalLinkProvider, replaceParametersProvider, translate, tkcoinProvider, persistenceProvider, events) {
        this.navCtrl = navCtrl;
        this.appProvider = appProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.tkcoinProvider = tkcoinProvider;
        this.persistenceProvider = persistenceProvider;
        this.events = events;
        this.tapped = 0;
        this.releaseInfoTaps = 0;
        this.pressed = 0;
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('Loaded: AboutPage');
            this.commitHash = this.appProvider.info.commitHash;
            this.version = this.appProvider.info.version;
            this.releaseInfoTaps = 0;
            this.title = this.replaceParametersProvider.replace(this.translate.instant('About {{appName}}'), { appName: this.appProvider.info.nameCase });
            this.easterEggStatus = yield this.persistenceProvider.getTestingAdvertisments();
        });
    }
    openExternalLink() {
        const url = 'https://github.com/tkcoin/' +
            this.appProvider.info.gitHubRepoName +
            '/tree/' +
            this.appProvider.info.commitHash +
            '';
        const optIn = true;
        const title = this.translate.instant('Open GitHub Project');
        const message = this.translate.instant('You can see the latest developments and contribute to this open source app by visiting our project on GitHub.');
        const okText = this.translate.instant('Open GitHub');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openBitPayWalletHome() {
        const url = 'https://bitpay.com/';
        const optIn = true;
        const title = this.translate.instant('Open');
        const message = this.translate.instant('Open BitPay Wallet official site');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    countReleaseHeaderTaps() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.releaseInfoTaps++;
            if (this.releaseInfoTaps !== 12)
                return;
            this.releaseInfoTaps = 0;
            if (this.easterEggStatus === 'enabled') {
                this.easterEggStatus = undefined;
                this.persistenceProvider.removeTestingAdvertisments();
                this.events.publish('Local/TestAdsToggle', false);
            }
            else {
                this.easterEggStatus = 'enabled';
                this.persistenceProvider.setTestingAdvertisements('enabled');
                this.events.publish('Local/TestAdsToggle', true);
            }
        });
    }
    openSessionLog() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__session_log_session_log__["a" /* SessionLogPage */]);
    }
    openSendFeedbackPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */]);
    }
    // adding this for testing purposes
    wipeTKCoinAccounts() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.tapped++;
            if (this.tapped >= 10) {
                yield this.persistenceProvider.removeAllTKCoinAccounts(this.tkcoinProvider.getEnvironment().network);
                alert('removed accounts');
                this.tapped = 0;
            }
        });
    }
};
AboutPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-about',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/about/about.html"*/'<wide-header-page title="{{title}}">\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item-divider (tap)="countReleaseHeaderTaps($event)">{{\'Release information\'| translate}}</ion-item-divider>\n      <button ion-item (click)="wipeTKCoinAccounts()">\n        <ion-icon class="item-img icon-settings" name="ios-download-outline" item-start></ion-icon>\n        <span class="main-label" translate>Version</span>\n        <ion-note item-end>\n          v{{version}}\n        </ion-note>\n      </button>\n\n      <div class="section-header">\n        <h3 class="title" translate>TKCoin Wallet is a fork from the original Bitpay Wallet</h3>\n      </div>\n      <div class="description-container">\n        <div>\n          <div class="text" translate>\n            TKCoin Wallet was developed by forking the original BitPay Wallet source code and it has several limitations. The BitPay and Bitcore developers made an amazing job with the entire Bitcore suite and they released it under the MIT license. Thanks to all of them! Hopefully in the future they will include EDUCoin and TKCoin cryptocurrencies in the official Bitpay Wallet so you can access all the spectacular features they offer on the full application. Thanks a lot to all BitPay and Bitcore teams!\n          </div>\n          <ion-row justify-content-center class="background-button-content">\n            <div class="background-content">\n              <button ion-button clear (click)="openBitPayWalletHome()">\n                {{\'Go to site\' | translate}}\n              </button>\n            </div>\n          </ion-row>\n        </div>\n      </div>\n      <!-- TODO FIX\n      <button ion-item>\n        <ion-icon class="item-img icon-settings" name="logo-github" item-start></ion-icon>\n        <span class="main-label">Commit Hash</span>\n        <ion-note item-end>\n          #{{commitHash}}\n        </ion-note>\n      </button>\n\n      <ion-item-divider class="item-without-title"></ion-item-divider>\n\n      <button ion-item (click)="openSendFeedbackPage()">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/settings-icons/icon-send-feedback.svg">\n        </ion-icon>\n        <span class="main-label" translate>Send Feedback</span>\n      </button>\n\n      <ion-item-divider class="item-without-title"></ion-item-divider>\n\n      <button ion-item (click)="openSessionLog()">\n        <ion-icon class="item-img icon-settings" name="ios-copy-outline" item-start></ion-icon>\n        <span class="main-label" translate>Session Log</span>\n      </button>\n      -->\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/about/about.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["f" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["E" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_10" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_20" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], AboutPage);

//# sourceMappingURL=about.js.map

/***/ }),

/***/ 511:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendFeedbackPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_device__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_launch_review__ = __webpack_require__(794);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_feedback_feedback__ = __webpack_require__(948);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__settings_share_share__ = __webpack_require__(512);







// native


// providers








// pages


let SendFeedbackPage = class SendFeedbackPage {
    constructor(actionSheetProvider, configProvider, externalLinkProvider, launchReview, modalCtrl, navCtrl, navParams, platformProvider, appProvider, onGoingProcessProvider, feedbackProvider, formBuilder, popupProvider, translate, device) {
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.launchReview = launchReview;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.feedbackProvider = feedbackProvider;
        this.formBuilder = formBuilder;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.device = device;
        this.feedbackForm = this.formBuilder.group({
            comment: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required])
            ]
        });
        this.fromCard = this.navParams.data.fromCard;
        this.score = this.navParams.data.score;
        this.appName = this.appProvider.info.nameCase;
        this.leavingFeedback = false;
        this.isCordova = this.platformProvider.isCordova;
        this.isAndroid = this.platformProvider.isAndroid;
    }
    ionViewWillEnter() {
        switch (this.score) {
            case 1:
                this.reaction = this.translate.instant('Ouch!');
                this.comment = this.translate.instant("There's obviously something we're doing wrong. How could we improve your experience?");
                break;
            case 2:
                this.reaction = this.translate.instant('How can we improve?');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Is there anything we could do to improve your experience?");
                break;
            case 3:
                this.reaction = this.translate.instant('Thanks!');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Feel free to leave us 5 star review in the app store or share with your friends!");
                break;
            default:
                this.reaction = this.translate.instant('Feedback!');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Feel free to leave us a review in the app store or request a new feature. Also, let us know if you experience any technical issues.");
                break;
        }
    }
    showAppreciationSheet() {
        const storeName = this.isAndroid ? 'Play Store' : 'App Store';
        const infoSheet = this.actionSheetProvider.createInfoSheet('appreciate-review', { storeName });
        infoSheet.present();
        infoSheet.onDidDismiss((option) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!option)
                return;
            if (this.launchReview.isRatingSupported()) {
                this.launchReview.rating();
            }
            else {
                yield this.launchReview.launch();
            }
        }));
    }
    leaveFeedback() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.leavingFeedback = this.leavingFeedback ? false : true;
            if (this.leavingFeedback) {
                yield __WEBPACK_IMPORTED_MODULE_6_rxjs__["Observable"].timer(50).toPromise();
                this.feedbackTextarea.setFocus();
            }
        });
    }
    openExternalLink(url) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.externalLinkProvider.open(url);
        });
    }
    goHome() {
        this.navCtrl.popToRoot({ animate: false });
    }
    openSharePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__settings_share_share__["a" /* SharePage */]);
    }
    sendFeedback(feedback, goHome) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const config = this.configProvider.get();
            let version;
            let platform;
            if (this.platformProvider.isElectron) {
                version = this.platformProvider
                    .getDeviceInfo()
                    .match(/(Electron[\/]\d+(\.\d)*)/i)[0]; // getDeviceInfo example: 5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Copay/5.1.0 Chrome/66.0.3359.181 Electron/3.0.8 Safari/537.36
                platform =
                    this.platformProvider.getOS() && this.platformProvider.getOS().OSName;
            }
            else {
                version = this.device.version || 'Unknown version';
                platform = this.device.platform || 'Unknown platform';
            }
            const dataSrc = {
                email: __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](config.emailFor)[0] || ' ',
                feedback: goHome ? ' ' : feedback,
                score: this.score || ' ',
                appVersion: this.appProvider.info.version,
                platform,
                deviceVersion: version
            };
            if (!goHome)
                this.onGoingProcessProvider.set('sendingFeedback');
            this.feedbackProvider
                .send(dataSrc)
                .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                if (goHome)
                    return;
                this.onGoingProcessProvider.clear();
                const params = {
                    finishText: 'Thanks',
                    finishComment: 'A member of the team will review your feedback as soon as possible.'
                };
                const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_17__finish_finish__["a" /* FinishModalPage */], params, {
                    showBackdrop: true,
                    enableBackdropDismiss: false
                });
                yield modal.present();
                this.navCtrl.popToRoot({ animate: false });
            }))
                .catch(() => {
                if (goHome)
                    return;
                this.onGoingProcessProvider.clear();
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Feedback could not be submitted. Please try again later.');
                this.popupProvider.ionicAlert(title, subtitle);
            });
            if (goHome) {
                this.navCtrl.popToRoot({ animate: false });
            }
        });
    }
    showInfoSheet(key, externalLink) {
        const infoSheet = this.actionSheetProvider.createInfoSheet(key);
        infoSheet.present();
        infoSheet.onDidDismiss((option) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!option) {
                this.openExternalLink(externalLink);
            }
            else {
                // Click on Get Help
                // TODO FIX
                this.openExternalLink('https://support.tkcoin.org/hc/en-us');
            }
        }));
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('focusMe'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], SendFeedbackPage.prototype, "feedbackTextarea", void 0);
SendFeedbackPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-send-feedback',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/feedback/send-feedback/send-feedback.html"*/'<wide-header-page title="{{\'Send Feedback\' | translate}}" [hideBackButton]="fromCard">\n  <ion-buttons left>\n    <button *ngIf="fromCard" (click)="goHome()" clear wide-header-bar-button ion-button>\n      <ion-icon class="close-btn" name="close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div class="msg-to-user">\n      <div class="rating-title">\n        <div class="feedback-title">\n          <span>{{reaction}}</span>\n        </div>\n        <div>\n          <img *ngIf="1 == score" src="assets/img/disappointed-face.svg" />\n          <img *ngIf="2 == score" src="assets/img/satisfied-face.svg" />\n          <img *ngIf="3 == score || !score" src="assets/img/happy-face.svg" />\n        </div>\n      </div>\n      <div class="feedback-msg">{{comment}}</div>\n    </div>\n\n    <!--\n      TODO: reactivate feedback / create server to receive feedback\n      <div *ngIf="score == 1" class="user-feedback-card" (click)="leaveFeedback()">\n      <ion-row>\n        <div class="feedback-icon">\n          <img src="assets/img/ico-chat.svg" />\n        </div>\n        <ion-col>\n          <div class="user-feedback-title">\n            <span translate>Leave Feedback</span>\n          </div>\n        </ion-col>\n        <div *ngIf="!leavingFeedback" class="feedback-action-icon arrow arrow-dropdown"></div>\n        <div *ngIf="leavingFeedback" class="feedback-action-icon arrow arrow-dropup"></div>\n      </ion-row>\n    </div>\n    <div class="feedback-form-card" *ngIf="leavingFeedback">\n      <form class="feedback-form" [formGroup]="feedbackForm">\n        <ion-item>\n          <ion-textarea #focusMe rows="3" type="text" formControlName="comment" [value]="feedbackForm.value.comment" required padding></ion-textarea>\n        </ion-item>\n      </form>\n      <button ion-button class="button-standard" (click)="sendFeedback(feedbackForm.value.comment)" [disabled]="!feedbackForm.valid">\n        {{\'Send\' | translate}}\n      </button>\n    </div> -->\n    <div *ngIf="(score == 3 || !score) && isCordova" class="user-feedback-card" (click)="showAppreciationSheet()">\n      <ion-row>\n        <div class="feedback-icon">\n          <img src="assets/img/icon-star-review.svg" />\n        </div>\n        <ion-col>\n          <div class="user-feedback-title">\n            <span translate>Write a Review</span>\n          </div>\n        </ion-col>\n        <div class="feedback-action-icon arrow arrow-right"></div>\n      </ion-row>\n    </div>\n    <div *ngIf="(score == 3 || !score) && isCordova" class="user-feedback-card" (click)="openSharePage()">\n      <ion-row>\n        <div class="feedback-icon">\n          <img src="assets/img/add-favorite.svg" />\n        </div>\n        <ion-col>\n          <div class="user-feedback-title">\n            <span translate>Share with friends</span>\n          </div>\n        </ion-col>\n        <div class="feedback-action-icon arrow arrow-right"></div>\n      </ion-row>\n    </div>\n    <div *ngIf="score != 3" class="user-feedback-card" (click)="showInfoSheet(\'request-feature\', \'https://tkcoin.canny.io/feature-request\')">\n      <ion-row>\n        <div class="feedback-icon">\n          <img src="assets/img/ico-chat.svg" />\n        </div>\n        <ion-col>\n          <div class="user-feedback-title">\n            <span translate>Request a Feature</span>\n          </div>\n        </ion-col>\n        <div class="feedback-action-icon">\n          <img src="assets/img/ico-link.svg" />\n        </div>\n      </ion-row>\n    </div>\n    <div *ngIf="score != 3" class="user-feedback-card" (click)="showInfoSheet(\'report-issue\', \'https://tkcoin.org/request-help/wizard?category=wallet\')">\n      <ion-row>\n        <div class="feedback-icon">\n          <img src="assets/img/ico-bug.svg" />\n        </div>\n        <ion-col>\n          <div class="user-feedback-title">\n            <span translate>Report an Issue</span>\n          </div>\n        </ion-col>\n        <div class="feedback-action-icon">\n          <img src="assets/img/ico-link.svg" />\n        </div>\n      </ion-row>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/feedback/send-feedback/send-feedback.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__ionic_native_launch_review__["a" /* LaunchReview */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__ionic_native_device__["a" /* Device */]])
], SendFeedbackPage);

//# sourceMappingURL=send-feedback.js.map

/***/ }),

/***/ 512:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);




// native

// providers





let SharePage = class SharePage {
    constructor(logger, socialSharing, appProvider, configProvider, replaceParametersProvider, translate, popupProvider, analyticsProvider) {
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.analyticsProvider = analyticsProvider;
        this.title = this.replaceParametersProvider.replace(this.translate.instant('Share {{appName}}'), { appName: this.appProvider.info.nameCase });
        let defaults = this.configProvider.getDefaults();
        this.downloadUrl =
            this.appProvider.info.name == 'copay'
                ? defaults.download.copay.url
                : defaults.download.tkcoin.url;
        this.downloadText = this.replaceParametersProvider.replace(this.translate.instant('Spend and control your cryptocurrency by downloading the {{appName}} app.'), { appName: this.appProvider.info.nameCase });
    }
    ionViewWillEnter() {
        this.socialSharing
            .canShareVia('com.apple.social.facebook', 'msg', null, null, null)
            .then(() => {
            this.shareFacebookVia = 'com.apple.social.facebook';
            this.facebook = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.facebook.katana', 'msg', null, null, null)
                .then(() => {
                this.shareFacebookVia = 'com.facebook.katana';
                this.facebook = true;
            })
                .catch(e => {
                this.logger.error('facebook error: ' + e);
                this.facebook = false;
            });
        });
        this.socialSharing
            .canShareVia('com.apple.social.twitter', 'msg', null, null, null)
            .then(() => {
            this.shareTwitterVia = 'com.apple.social.twitter';
            this.twitter = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.twitter.android', 'msg', null, null, null)
                .then(() => {
                this.shareTwitterVia = 'com.twitter.android';
                this.twitter = true;
            })
                .catch(e => {
                this.logger.error('twitter error: ' + e);
                this.twitter = false;
            });
        });
        this.socialSharing
            .canShareVia('whatsapp', 'msg', null, null, null)
            .then(() => {
            this.whatsapp = true;
        })
            .catch(e => {
            this.logger.error('whatsapp error: ' + e);
            this.whatsapp = false;
        });
    }
    shareFacebook() {
        this.analyticsProvider.logEvent('share', { method: 'Facebook' });
        if (!this.facebook) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareFacebookVia, this.downloadText, null, null, this.downloadUrl);
    }
    shareTwitter() {
        this.analyticsProvider.logEvent('share', { method: 'Twitter' });
        if (!this.twitter) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareTwitterVia, this.downloadText, null, null, this.downloadUrl);
    }
    shareWhatsapp() {
        this.analyticsProvider.logEvent('share', { method: 'Whatsapp' });
        if (!this.whatsapp) {
            this.showError();
            return;
        }
        this.socialSharing.shareViaWhatsApp(this.downloadText, null, this.downloadUrl);
    }
    showError() {
        let msg = this.translate.instant('This app is not available for your device.');
        this.popupProvider.ionicAlert(this.translate.instant('Error'), msg);
    }
};
SharePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-share',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/share/share.html"*/'<wide-header-page title="{{title}}">\n  <div page-content>\n    <div class="share-image-container">\n      <div>\n        <div class="share-the-love">\n          <img src="assets/img/ico-positive-feedback.svg" class="share-the-love-illustration" />\n        </div>\n        <div class="subtitle" translate>Share the love by inviting your friends.</div>\n      </div>\n    </div>\n    <div class="share-buttons">\n      <div class="share-buttons__action" (click)="shareFacebook()">\n        <ion-icon>\n          <img src="assets/img/social-icons/ico-social-facebook.svg" />\n        </ion-icon>\n        <div class="name">Facebook</div>\n      </div>\n      <div class="share-buttons__action" (click)="shareTwitter()">\n        <ion-icon>\n          <img src="assets/img/social-icons/ico-social-twitter.svg" />\n        </ion-icon>\n        <div class="name">Twitter</div>\n      </div>\n      <div class="share-buttons__action" (click)="shareWhatsapp()">\n        <ion-icon>\n          <img src="assets/img/social-icons/ico-social-whatsapp.svg" />\n        </ion-icon>\n        <div class="name">Whatsapp</div>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/share/share.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__["a" /* AnalyticsProvider */]])
], SharePage);

//# sourceMappingURL=share.js.map

/***/ }),

/***/ 513:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_touchid_touchid__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__wallet_delete_wallet_delete__ = __webpack_require__(1006);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__wallet_name_wallet_name__ = __webpack_require__(1007);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wallet_settings_advanced_wallet_duplicate_wallet_duplicate__ = __webpack_require__(1009);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(515);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_settings_advanced_wallet_information_wallet_information__ = __webpack_require__(1010);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__wallet_settings_advanced_wallet_service_url_wallet_service_url__ = __webpack_require__(1011);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__ = __webpack_require__(1012);





// providers







// pages








let WalletSettingsPage = class WalletSettingsPage {
    constructor(profileProvider, logger, walletProvider, externalLinkProvider, configProvider, navCtrl, navParams, touchIdProvider, translate, keyProvider, pushNotificationsProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.touchIdProvider = touchIdProvider;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.deleted = false;
        this.logger.info('Loaded:  WalletSettingsPage');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
    }
    ionViewWillEnter() {
        this.canSign = this.wallet.canSign;
        this.needsBackup = this.wallet.needsBackup;
        this.hiddenBalance = this.wallet.balanceHidden;
        this.encryptEnabled = this.wallet.isPrivKeyEncrypted;
        this.checkBiometricIdAvailable();
        this.config = this.configProvider.get();
        this.touchIdEnabled = this.config.touchIdFor
            ? this.config.touchIdFor[this.wallet.credentials.walletId]
            : null;
        this.touchIdPrevValue = this.touchIdEnabled;
        if (this.wallet.credentials &&
            !this.wallet.credentials.mnemonicEncrypted &&
            !this.wallet.credentials.mnemonic) {
            this.deleted = true;
        }
        this.showDuplicateWallet = this.getShowDuplicateWalletOption();
    }
    getShowDuplicateWalletOption() {
        if (this.wallet.network != 'livenet' || this.wallet.coin != 'btc')
            return false;
        const key = this.keyProvider.getKey(this.wallet.credentials.keyId);
        if (!key)
            return false;
        // only available for OLD multisig wallets. or single sig
        if (this.wallet.n > 1 && !key.use44forMultisig)
            return false;
        // only first account
        if (this.wallet.credentials.account != 0)
            return false;
        return true;
    }
    checkBiometricIdAvailable() {
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            this.touchIdAvailable = isAvailable;
        });
    }
    hiddenBalanceChange() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    openSupportEncryptPassword() {
        const url = 'https://support.tkcoin.org/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    touchIdChange() {
        if (this.touchIdPrevValue == this.touchIdEnabled)
            return;
        const newStatus = this.touchIdEnabled;
        this.walletProvider
            .setTouchId([].concat(this.wallet), newStatus)
            .then(() => {
            this.touchIdPrevValue = this.touchIdEnabled;
            this.logger.debug('Touch Id status changed: ' + newStatus);
        })
            .catch(err => {
            this.logger.error('Error with fingerprint:', err);
            this.checkBiometricIdAvailable();
            this.touchIdEnabled = this.touchIdPrevValue;
        });
    }
    openWalletName() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__wallet_name_wallet_name__["a" /* WalletNamePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletInformation() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__wallet_settings_advanced_wallet_information_wallet_information__["a" /* WalletInformationPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openExportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletServiceUrl() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__wallet_settings_advanced_wallet_service_url_wallet_service_url__["a" /* WalletServiceUrlPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openTransactionHistory() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__["a" /* WalletTransactionHistoryPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openDuplicateWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__wallet_settings_advanced_wallet_duplicate_wallet_duplicate__["a" /* WalletDuplicatePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    hiddenWalletChange(walletId) {
        if (!walletId)
            return;
        this.profileProvider.toggleHideWalletFlag(walletId);
        if (!!this.wallet.hidden)
            this.pushNotificationsProvider.unsubscribe(this.wallet);
        else
            this.pushNotificationsProvider.updateSubscription(this.wallet);
    }
    openWalletGroupDelete() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__wallet_delete_wallet_delete__["a" /* WalletDeletePage */], {
            keyId: this.wallet.keyId,
            walletId: this.wallet.id
        });
    }
};
WalletSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings.html"*/'<wide-header-page title="{{\'Wallet Settings\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button ion-item (click)="openWalletName()">\n        <div translate float-left>Name</div>\n        <ion-note item-end>\n          {{wallet && wallet.name}}\n        </ion-note>\n      </button>\n      <ion-item class="with-label no-border">\n        <ion-label>{{\'Hide Wallet\' | translate }}</ion-label>\n        <ion-toggle checked="{{wallet?.hidden}}" (ionChange)="hiddenWalletChange(wallet.id)"></ion-toggle>\n      </ion-item>\n      <label-tip class="info" type="info" header="no-header" *ngIf="!wallet?.hidden">\n        <div label-tip-body translate>\n          The wallet won\'t be removed from this device. You can hide it whenever you need it.\n        </div>\n      </label-tip>\n      <ion-item>\n        <ion-label>{{\'Hide Balance\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="hiddenBalance" (ionChange)="hiddenBalanceChange()"></ion-toggle>\n      </ion-item>\n      <ion-item-divider *ngIf="canSign && touchIdAvailable">{{\'Security\' | translate}}</ion-item-divider>\n      <div *ngIf="canSign && touchIdAvailable">\n        <ion-item>\n          <ion-label [ngClass]="{\'disabled\': needsBackup}">{{\'Request Biometric Authentication\'| translate}}</ion-label>\n          <ion-toggle [(ngModel)]="touchIdEnabled" (ionChange)="touchIdChange()"></ion-toggle>\n        </ion-item>\n      </div>\n      <ion-item-divider>{{\'Advanced\' | translate}}</ion-item-divider>\n      <button ion-item (click)="openWalletInformation()">\n        <span translate>Information</span>\n      </button>\n      <button ion-item (click)="openWalletAddresses()">\n        <span translate>Addresses</span>\n      </button>\n      <button ion-item (click)="openExportWallet()">\n        <span translate>Export Wallet</span>\n      </button>\n      <button ion-item (click)="openWalletServiceUrl()">\n        <span>Wallet Service URL</span>\n      </button>\n      <button ion-item (click)="openTransactionHistory()">\n        <span translate>Transaction History</span>\n      </button>\n      <button ion-item (click)="openDuplicateWallet()" *ngIf="showDuplicateWallet">\n        <span translate>Duplicate to BCH</span>\n      </button>\n      <button *ngIf="!canSign" ion-item (click)="openWalletGroupDelete()">\n        <span translate>Delete</span>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], WalletSettingsPage);

//# sourceMappingURL=wallet-settings.js.map

/***/ }),

/***/ 514:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__wallet_details_wallet_details__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__all_addresses_all_addresses__ = __webpack_require__(1008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash__);





// providers





// pages



let WalletAddressesPage = class WalletAddressesPage {
    constructor(profileProvider, walletProvider, navCtrl, navParams, logger, bwcErrorProvider, popupProvider, modalCtrl, txFormatProvider, translate) {
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.bwcErrorProvider = bwcErrorProvider;
        this.popupProvider = popupProvider;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.UNUSED_ADDRESS_LIMIT = 5;
        this.BALANCE_ADDRESS_LIMIT = 5;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.withBalance = null;
        this.noBalance = null;
    }
    ionViewWillEnter() {
        this.loading = true;
        this.walletProvider
            .getMainAddresses(this.wallet, {
            doNotVerify: true
        })
            .then(allAddresses => {
            const { token, multisigEthInfo } = this.wallet.credentials;
            this.walletProvider
                .getBalance(this.wallet, {
                tokenAddress: token ? token.address : '',
                multisigContractAddress: multisigEthInfo
                    ? multisigEthInfo.multisigContractAddress
                    : ''
            })
                .then(resp => {
                this.withBalance = resp.byAddress;
                const idx = __WEBPACK_IMPORTED_MODULE_12_lodash__["keyBy"](this.withBalance, 'address');
                this.noBalance = __WEBPACK_IMPORTED_MODULE_12_lodash__["reject"](allAddresses, x => {
                    return idx[x.address];
                });
                this.processList(this.noBalance);
                this.processList(this.withBalance);
                this.latestUnused = __WEBPACK_IMPORTED_MODULE_12_lodash__["slice"](this.noBalance, 0, this.UNUSED_ADDRESS_LIMIT);
                this.latestWithBalance = __WEBPACK_IMPORTED_MODULE_12_lodash__["slice"](this.withBalance, 0, this.BALANCE_ADDRESS_LIMIT);
                this.viewAll =
                    this.noBalance.length > this.UNUSED_ADDRESS_LIMIT ||
                        this.withBalance.length > this.BALANCE_ADDRESS_LIMIT;
                this.loading = false;
            })
                .catch(err => {
                this.logger.error(err);
                this.loading = false;
                this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
            });
        })
            .catch(err => {
            this.logger.error(err);
            this.loading = false;
            this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
        });
        this.walletProvider
            .getLowUtxos(this.wallet)
            .then(resp => {
            if (resp && resp.allUtxos && resp.allUtxos.length) {
                const allSum = __WEBPACK_IMPORTED_MODULE_12_lodash__["sumBy"](resp.allUtxos || 0, 'satoshis');
                const per = (resp.minFee / allSum) * 100;
                this.lowUtxosNb = resp.lowUtxos.length;
                this.allUtxosNb = resp.allUtxos.length;
                this.lowUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, __WEBPACK_IMPORTED_MODULE_12_lodash__["sumBy"](resp.lowUtxos || 0, 'satoshis'));
                this.allUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, allSum);
                this.minFee = this.txFormatProvider.formatAmountStr(this.wallet.coin, resp.minFee || 0);
                this.minFeePer = per.toFixed(2) + '%';
            }
        })
            .catch(err => {
            this.logger.warn('GetLowUtxos', err);
        });
    }
    processList(list) {
        __WEBPACK_IMPORTED_MODULE_12_lodash__["each"](list, n => {
            n.path = n.path ? n.path.replace(/^m/g, 'xpub') : null;
            n.address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, n.address);
        });
    }
    viewAllAddresses() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_11__all_addresses_all_addresses__["a" /* AllAddressesPage */], {
            noBalance: this.noBalance,
            withBalance: this.withBalance,
            coin: this.wallet.coin,
            walletName: this.wallet.name
        });
        modal.present();
    }
    scan() {
        this.walletProvider.startScan(this.wallet);
        this.navCtrl.popToRoot().then(() => {
            setTimeout(() => {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                    walletId: this.wallet.credentials.walletId
                });
            }, 1000);
        });
    }
};
WalletAddressesPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-addresses',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/'<wide-header-page title="{{\'Wallet Addresses\' | translate}}">\n  <div page-content>\n    <div class="explanation">\n      <span translate>\n        Each bitcoin wallet can generate billions of addresses from your 12-word recovery phrase. A new address is automatically generated and shown each time you receive a payment.\n      </span>\n      <a (click)="showInfo = !showInfo" *ngIf="!showInfo" translate>Why?</a>\n\n      <div *ngIf="showInfo">\n        <br>\n        <span translate>\n          It\'s a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.</span>\n        <a (click)="showInfo = !showInfo" translate>Hide</a>\n      </div>\n    </div>\n\n    <button ion-button class="button-standard" (click)="scan()">\n      <span translate>Scan addresses for funds</span>\n    </button>\n\n    <button ion-item *ngIf="viewAll" (click)="viewAllAddresses()">\n      <span translate>View all addresses</span>\n    </button>\n\n    <div class="loading" *ngIf="loading">\n      <ion-spinner icon="crescent"></ion-spinner>\n      <span translate>Loading addresses...</span>\n    </div>\n\n    <ion-list *ngIf="!loading" class="settings-list bp-list">\n      <div *ngIf="allUtxosNb">\n        <ion-item-divider>{{\'Wallet Inputs\' | translate}}</ion-item-divider>\n\n        <ion-item>\n          <span translate>Total wallet inputs</span>\n          <p class="info">{{allUtxosNb}} [{{allUtxosSum}}]</p>\n        </ion-item>\n\n        <ion-item>\n          <span translate> Low amount inputs </span>\n          <p class="info">{{lowUtxosNb}} [{{ lowUtxosSum }}]</p>\n        </ion-item>\n\n        <ion-item>\n          <span translate>Approximate Bitcoin network fee to transfer wallet\'s balance (with normal priority)</span>\n          <p class="info">{{minFeePer}} [{{minFee}}]</p>\n        </ion-item>\n      </div>\n\n      <div *ngIf="latestWithBalance && latestWithBalance[0]">\n        <ion-item-divider>{{\'Addresses with balance\' | translate}}</ion-item-divider>\n        <ion-item *ngFor="let w of latestWithBalance" copy-to-clipboard="{{w.address}}">\n          <h3>{{w.address}}</h3>\n          <p class="info">{{w.amount | satToUnit: wallet.coin}}</p>\n        </ion-item>\n      </div>\n\n      <div *ngIf="latestUnused && latestUnused[0]">\n        <ion-item-divider>{{\'Unused addresses\' | translate}}</ion-item-divider>\n        <ion-item *ngFor="let u of latestUnused" copy-to-clipboard="{{u.address}}">\n          <h3>{{u.address}}</h3>\n          <p>{{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}</p>\n        </ion-item>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], WalletAddressesPage);

//# sourceMappingURL=wallet-addresses.js.map

/***/ }),

/***/ 515:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletExportPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_clipboard__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_backup_backup__ = __webpack_require__(945);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__ = __webpack_require__(31);






// native


// providers









let WalletExportPage = class WalletExportPage {
    constructor(profileProvider, navCtrl, walletProvider, navParams, formBuilder, logger, persistenceProvider, backupProvider, platformProvider, socialSharing, appProvider, clipboard, toastCtrl, translate, configProvider, bwcErrorProvider, errorsProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.walletProvider = walletProvider;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.backupProvider = backupProvider;
        this.platformProvider = platformProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.toastCtrl = toastCtrl;
        this.translate = translate;
        this.configProvider = configProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.errorsProvider = errorsProvider;
        this.password = '';
        this.showAdv = false;
        this.showAdvanced = false;
        this.exportWalletForm = this.formBuilder.group({
            password: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required],
            confirmPassword: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required],
            noSignEnabled: [false]
        }, { validator: this.matchingPasswords('password', 'confirmPassword') });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletExportPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.isEncrypted = this.wallet.isPrivKeyEncrypted;
        this.canSign = this.wallet.canSign;
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
    }
    matchingPasswords(passwordKey, confirmPasswordKey) {
        return (group) => {
            const password = group.controls[passwordKey];
            const confirmPassword = group.controls[confirmPasswordKey];
            if (password.value !== confirmPassword.value) {
                return {
                    mismatchedPasswords: true
                };
            }
            return undefined;
        };
    }
    getPassword() {
        return new Promise((resolve, reject) => {
            if (this.password)
                return resolve(this.password);
            this.walletProvider
                .prepare(this.wallet)
                .then(password => {
                this.password = password;
                return resolve(password);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    downloadWalletBackup() {
        this.getPassword()
            .then((password) => {
            this.getAddressBook()
                .then(localAddressBook => {
                const opts = {
                    noSign: this.exportWalletForm.value.noSignEnabled,
                    addressBook: localAddressBook,
                    password
                };
                this.backupProvider
                    .walletDownload(this.navParams.data.walletId, opts, this.exportWalletForm.value.password)
                    .then(() => {
                    this.navCtrl.pop();
                })
                    .catch(() => {
                    this.showErrorInfoSheet();
                });
            })
                .catch(() => {
                this.showErrorInfoSheet();
            });
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err));
                }
            }
        });
    }
    getAddressBook() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(this.wallet.credentials.network)
                .then(localAddressBook => {
                if (!localAddressBook)
                    return resolve();
                try {
                    localAddressBook = JSON.parse(localAddressBook);
                }
                catch (ex) {
                    this.logger.warn('Wallet Export: JSON Parse localAddressBook is not necessary', ex);
                }
                return resolve(localAddressBook);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getBackup() {
        return new Promise(resolve => {
            this.getPassword()
                .then((password) => {
                this.getAddressBook()
                    .then(localAddressBook => {
                    const opts = {
                        noSign: this.exportWalletForm.value.noSignEnabled,
                        addressBook: localAddressBook,
                        password
                    };
                    const ew = this.backupProvider.walletExport(this.navParams.data.walletId, opts, this.exportWalletForm.value.password);
                    if (!ew) {
                        this.showErrorInfoSheet();
                    }
                    return resolve(ew);
                })
                    .catch(() => {
                    this.showErrorInfoSheet();
                    return resolve();
                });
            })
                .catch(err => {
                if (err &&
                    err.message != 'FINGERPRINT_CANCELLED' &&
                    err.message != 'PASSWORD_CANCELLED') {
                    if (err.message == 'WRONG_PASSWORD') {
                        this.errorsProvider.showWrongEncryptPasswordError();
                    }
                    else {
                        this.showErrorInfoSheet(this.bwcErrorProvider.msg(err));
                    }
                }
                return resolve();
            });
        });
    }
    viewWalletBackup() {
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            this.backupWalletPlainText = ew;
        });
    }
    copyWalletBackup() {
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            this.clipboard.copy(ew);
            const copyMessage = this.translate.instant('Copied to clipboard');
            const showSuccess = this.toastCtrl.create({
                message: copyMessage,
                duration: 1000
            });
            showSuccess.present();
        });
    }
    sendWalletBackup() {
        const preparingMessage = this.translate.instant('Preparing backup...');
        const showSuccess = this.toastCtrl.create({
            message: preparingMessage,
            duration: 1000
        });
        showSuccess.present();
        let name = this.wallet.credentials.walletName || this.wallet.credentials.walletId;
        const config = this.configProvider.get();
        const alias = config.aliasFor && config.aliasFor[this.wallet.credentials.walletId];
        if (alias) {
            name = alias + ' [' + name + ']';
        }
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            if (this.exportWalletForm.value.noSignEnabled)
                name = name + '(No Private Key)';
            const subject = this.appProvider.info.nameCase + ' Wallet Backup: ' + name;
            const body = 'Here is the encrypted backup of the wallet ' +
                name +
                ': \n\n' +
                ew +
                '\n\n To import this backup, copy all text between {...}, including the symbols {}';
            // Check if sharing via email is supported
            this.socialSharing
                .canShareViaEmail()
                .then(() => {
                this.logger.info('sharing via email is possible');
                this.socialSharing
                    .shareViaEmail(body, subject, null, // TO: must be null or an array
                null, // CC: must be null or an array
                null, // BCC: must be null or an array
                null // FILES: can be null, a string, or an array
                )
                    .then(data => {
                    this.logger.info('Email created successfully: ', data);
                })
                    .catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            })
                .catch(() => {
                this.logger.warn('sharing via email is not possible');
                this.socialSharing.share(body, subject).catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            });
        });
    }
    showErrorInfoSheet(err) {
        const title = this.translate.instant('Error');
        const msg = err ? err : this.translate.instant('Failed to export');
        this.logger.error(err);
        this.errorsProvider.showDefaultError(msg, title);
    }
};
WalletExportPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-export',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/'<wide-header-page title="{{\'Export Wallet\' | translate}}">\n  <div page-content>\n    <ion-list class="bp-list">\n      <div *ngIf="!backupWalletPlainText">\n        <form [formGroup]="exportWalletForm">\n          <ion-item>\n            <ion-label stacked>{{\'Set up a password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="password" required></ion-input>\n          </ion-item>\n          <ion-item>\n            <ion-label stacked>{{\'Repeat the password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="confirmPassword" required></ion-input>\n          </ion-item>\n          <ion-item *ngIf="exportWalletForm.controls.confirmPassword.touched && exportWalletForm.hasError(\'mismatchedPasswords\') && exportWalletForm.controls.password.valid">\n            <span ion-text color="warning" translate>Passwords do not match</span>\n          </ion-item>\n          <label-tip class="no-arrowhead warning-message" *ngIf="!canSign" type="warn">\n            <span label-tip-title translate>No Private Key</span>\n            <div label-tip-body translate>\n              The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.\n            </div>\n          </label-tip>\n          <div *ngIf="canSign">\n            <button ion-button class="button-standard button-secondary" (click)="showAdv = !showAdv">\n              <span *ngIf="!showAdv">{{\'Show advanced options\' | translate}}</span>\n              <span *ngIf="showAdv">{{\'Hide advanced options\' | translate}}</span>\n            </button>\n          </div>\n          <ion-item [ngClass]="{\'with-label\': exportWalletForm.value.noSignEnabled }" *ngIf="showAdv">\n            <ion-label stacked>{{\'Do not include private key\' | translate}}</ion-label>\n            <ion-checkbox formControlName="noSignEnabled"></ion-checkbox>\n          </ion-item>\n\n          <label-tip *ngIf="exportWalletForm.value.noSignEnabled" class="warning-message" type="warn">\n            <span label-tip-title translate>Funds Will Not Be Accessible</span>\n            <div label-tip-body translate>\n              Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.\n            </div>\n          </label-tip>\n\n          <button *ngIf="!isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="downloadWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n            <span translate>Download</span>\n          </button>\n          <button *ngIf="isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="viewWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n            <span translate>View</span>\n          </button>\n          <div *ngIf="isCordova">\n            <button class="button-standard" ion-button type="submit" (click)="copyWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n              <span translate>Copy to clipboard</span>\n            </button>\n            <button class="button-standard" ion-button type="submit" (click)="sendWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n              <span translate>Send by email</span>\n            </button>\n          </div>\n        </form>\n      </div>\n      <div *ngIf="backupWalletPlainText">\n        <span translate>Backup wallet</span>\n        <p translate>Copy this text as it is to a safe place (notepad or email)</p>\n        <ion-textarea rows="12">{{backupWalletPlainText}}</ion-textarea>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_backup_backup__["a" /* BackupProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_8__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["s" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_errors_errors__["a" /* ErrorsProvider */]])
], WalletExportPage);

//# sourceMappingURL=wallet-export.js.map

/***/ }),

/***/ 516:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProposalsNotificationsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__finish_finish__ = __webpack_require__(145);





// providers









// pages

let ProposalsNotificationsPage = class ProposalsNotificationsPage {
    constructor(plt, addressBookProvider, bwcErrorProvider, logger, onGoingProcessProvider, profileProvider, platformProvider, translate, events, replaceParametersProvider, walletProvider, modalCtrl, navCtrl, navParams, errorsProvider) {
        this.plt = plt;
        this.addressBookProvider = addressBookProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.events = events;
        this.replaceParametersProvider = replaceParametersProvider;
        this.walletProvider = walletProvider;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.errorsProvider = errorsProvider;
        this.updatePendingProposals = (opts = { finished: true }) => {
            if (!opts.finished)
                return;
            this.profileProvider
                .getTxps({ limit: 50 })
                .then(txpsData => {
                this.zone.run(() => {
                    this.allTxps = [];
                    // Check if txp were checked before
                    txpsData.txps.forEach(txp => {
                        txp.checked = __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.txpsToSign, txp) >= 0 ? true : false;
                    });
                    if (this.walletId) {
                        txpsData.txps = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](txpsData.txps, txps => {
                            return txps.walletId == this.walletId;
                        });
                    }
                    else if (this.multisigContractAddress) {
                        txpsData.txps = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](txpsData.txps, txps => {
                            return (txps.multisigContractAddress == this.multisigContractAddress);
                        });
                    }
                    this.checkStatus(txpsData.txps);
                    this.allTxps.push({
                        title: this.translate.instant('Payment Proposal'),
                        type: 'pending',
                        data: this.groupByWallets(this.txpsPending)
                    });
                    this.allTxps.push({
                        title: this.translate.instant('Accepted'),
                        type: 'accepted',
                        data: this.groupByWallets(this.txpsAccepted)
                    });
                    this.allTxps.push({
                        title: this.translate.instant('Rejected'),
                        type: 'rejected',
                        data: this.groupByWallets(this.txpsRejected)
                    });
                    if (this.navCtrl.canGoBack() &&
                        !this.txpsPending[0] &&
                        !this.txpsAccepted[0] &&
                        !this.txpsRejected[0]) {
                        this.navCtrl.pop();
                    }
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.isElectron = this.platformProvider.isElectron;
        this.walletId = this.navParams.data.walletId;
        this.multisigContractAddress = this.navParams.data.multisigContractAddress;
        this.isCordova = this.platformProvider.isCordova;
        this.buttonText = this.translate.instant('Sign selected proposals');
        this.allTxps = [];
        this.txpsToSign = [];
        this.txpsPending = [];
        this.txpsAccepted = [];
        this.txpsRejected = [];
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
        this.updateAddressBook();
        this.updatePendingProposals();
        this.subscribeEvents();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.subscribeEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.unsubscribeEvents();
        });
        // Update Wallet on Focus
        if (this.isElectron) {
            this.updateDesktopOnFocus();
        }
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.updatePendingProposals);
    }
    unsubscribeEvents() {
        this.events.unsubscribe('Local/WalletUpdate', this.updatePendingProposals);
    }
    ionViewWillLeave() {
        this.unsubscribeEvents();
        this.navCtrl.swipeBackEnabled = true;
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    updateDesktopOnFocus() {
        const { remote } = window.require('electron');
        const win = remote.getCurrentWindow();
        win.on('focus', () => {
            if (this.navCtrl.getActive() &&
                this.navCtrl.getActive().name === 'ProposalsNotificationsPage')
                this.updatePendingProposals();
        });
    }
    updateAddressBook() {
        this.addressBookProvider
            .list()
            .then(ab => {
            this.addressbook = ab || {};
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    checkStatus(txps) {
        this.txpsPending = [];
        this.txpsAccepted = [];
        this.txpsRejected = [];
        txps.forEach(txp => {
            const action = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](txp.actions, {
                copayerId: txp.wallet.copayerId
            });
            if ((!action || action.type === 'failed') && txp.status == 'pending') {
                txp.pendingForUs = true;
            }
            if (action && action.type == 'accept') {
                txp.statusForUs = 'accepted';
                this.txpsAccepted.push(txp);
            }
            else if (action && action.type == 'reject') {
                txp.statusForUs = 'rejected';
                this.txpsRejected.push(txp);
            }
            else {
                txp.statusForUs = 'pending';
                this.txpsPending.push(txp);
            }
        });
    }
    groupByWallets(txps) {
        const walletIdGetter = txp => txp.walletId;
        const map = new Map();
        const txpsByWallet = [];
        txps.forEach(txp => {
            const walletId = walletIdGetter(txp);
            const collection = map.get(walletId);
            if (!collection) {
                map.set(walletId, [txp]);
            }
            else {
                collection.push(txp);
            }
        });
        Array.from(map).forEach(txpsPerWallet => {
            const txpToBeSigned = this.getTxpToBeSigned(txpsPerWallet[1]);
            txpsByWallet.push({
                walletId: txpsPerWallet[0],
                canSign: txpsPerWallet[1][0].wallet.canSign || false,
                txps: txpsPerWallet[1],
                multipleSignAvailable: txpToBeSigned > 1 && !txpsPerWallet[1][0].multisigContractAddress
            });
        });
        return txpsByWallet;
    }
    getTxpToBeSigned(txpsPerWallet) {
        let i = 0;
        txpsPerWallet.forEach(txp => {
            if (txp.statusForUs === 'pending')
                i = i + 1;
        });
        return i;
    }
    signMultipleProposals(txp) {
        this.txpsToSign = [];
        this.walletIdSelectedToSign =
            this.walletIdSelectedToSign == txp.walletId
                ? this.resetMultiSignValues()
                : txp.walletId;
    }
    sign() {
        const wallet = this.txpsToSign[0].wallet
            ? this.txpsToSign[0].wallet
            : this.profileProvider.getWallet(this.txpsToSign[0].walletId);
        this.walletProvider
            .signMultipleTxps(wallet, this.txpsToSign)
            .then(data => {
            this.resetMultiSignValues();
            this.onGoingProcessProvider.clear();
            const count = this.countSuccessAndFailed(data);
            if (count.failed > 0) {
                const signErr = this.replaceParametersProvider.replace(this.translate.instant('There was problem while trying to sign {{txpsFailed}} of your transactions proposals. Please, try again'), { txpsFailed: count.failed });
                const title = this.translate.instant('Error');
                this.showErrorInfoSheet(title, signErr);
            }
            if (count.success > 0) {
                const finishText = this.replaceParametersProvider.replace(count.success > 1
                    ? this.translate.instant('{{txpsSuccess}} proposals signed')
                    : this.translate.instant('{{txpsSuccess}} proposal signed'), { txpsSuccess: count.success });
                this.openModal(finishText, wallet.coin, 'success');
            }
            // own TxActions  are not triggered?
            this.events.publish('Local/TxAction', wallet.walletId);
        })
            .catch(err => {
            this.logger.error('Sign multiple transaction proposals failed: ', err);
            this.onGoingProcessProvider.clear();
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                if (err.message == 'WRONG_PASSWORD') {
                    this.errorsProvider.showWrongEncryptPasswordError();
                }
                else {
                    const title = this.translate.instant('Error');
                    const msg = this.bwcErrorProvider.msg(err);
                    this.showErrorInfoSheet(title, msg);
                }
            }
        });
    }
    showErrorInfoSheet(title, msg) {
        this.errorsProvider.showDefaultError(msg, title);
    }
    countSuccessAndFailed(arrayData) {
        const count = { success: 0, failed: 0 };
        arrayData.forEach(data => {
            if (data.id) {
                count.success = count.success + 1;
            }
            else {
                count.failed = count.failed + 1;
            }
        });
        return count;
    }
    txpSelectionChange(txp) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.txpsToSign, txp) >= 0) {
            __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](this.txpsToSign, txpToSign => {
                return txpToSign.id == txp.id;
            });
            txp.checked = false;
        }
        else {
            txp.checked = true;
            this.txpsToSign.push(txp);
        }
    }
    resetMultiSignValues() {
        this.allTxps.forEach(txpsByStatus => {
            txpsByStatus.data.forEach(txpsByWallet => {
                if (txpsByWallet.walletId == this.walletIdSelectedToSign) {
                    txpsByWallet.txps.forEach(txp => {
                        txp.checked = false;
                    });
                }
            });
        });
        this.txpsToSign = [];
        this.walletIdSelectedToSign = null;
    }
    openModal(finishText, coin, cssClass) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_14__finish_finish__["a" /* FinishModalPage */], {
            finishText,
            cssClass,
            coin
        }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
    }
    selectAll(txpsByWallet) {
        this.zone.run(() => {
            this.txpsToSign = [];
            txpsByWallet.txps.forEach(txp => {
                this.txpsToSign.push(txp);
                txp.checked = true;
            });
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], ProposalsNotificationsPage.prototype, "slideButton", void 0);
ProposalsNotificationsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-proposals-notifications',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallets/proposals-notifications/proposals-notifications.html"*/'<wide-header-page title="{{\'Notifications\' | translate}}" [hasSlideButton]="txpsToSign[0]">\n  <div page-content>\n    <ion-list class="content-list" *ngIf="allTxps && allTxps[0]">\n      <div *ngFor="let txpsByStatus of allTxps">\n        <ion-item-divider *ngIf="txpsByStatus.data && txpsByStatus.data[0]" class="item-divider-header">\n          <span class="ellipsis">{{txpsByStatus.title}}</span>\n        </ion-item-divider>\n        <div *ngFor="let txpsByWallet of txpsByStatus.data; let i = index">\n          <ion-item-divider *ngIf="i > 0" class="item-divider-header sm"></ion-item-divider>\n          <ion-item *ngIf="txpsByWallet.walletId && txpsByWallet.txps && txpsByWallet.txps[0] && txpsByWallet.txps[0].wallet" class="recipient">\n            <ion-icon class="item-img wallet" item-start>\n              <img [ngClass]="{ testnet: txpsByWallet.txps[0].wallet.network === \'testnet\' }" src="assets/img/currencies/{{txpsByWallet.txps[0].wallet.coin}}.svg" class="icon-wallet" />\n            </ion-icon>\n            <ion-label>\n              <span class="ellipsis">{{txpsByWallet.txps[0].wallet.name}}</span>\n            </ion-label>\n            <ion-note *ngIf="txpsByStatus.type == \'pending\' && txpsByWallet.canSign" item-end text-end>\n              <div class="select-all" *ngIf="txpsByWallet.multipleSignAvailable && !walletIdSelectedToSign">\n                <div class="multi-sign close" (click)="signMultipleProposals(txpsByWallet)">\n                  <ion-icon name="ios-list-outline"></ion-icon>\n                </div>\n              </div>\n              <div class="select-all" *ngIf="walletIdSelectedToSign && txpsByWallet.walletId == walletIdSelectedToSign">\n                <div class="multi-sign" (click)="selectAll(txpsByWallet)">\n                  <ion-icon name="ios-done-all"></ion-icon>\n                </div>\n                <div class="multi-sign close" (click)="signMultipleProposals(txpsByWallet)">\n                  <ion-icon name="ios-close"></ion-icon>\n                </div>\n              </div>\n            </ion-note>\n            <ion-note *ngIf="txpsByStatus.type != \'pending\'" item-end text-end>\n              <div class="circle-status" [ngClass]="{\'balanced\': txpsByStatus.type == \'accepted\', \'assertive\': txpsByStatus.type == \'rejected\'}"></div>\n            </ion-note>\n          </ion-item>\n          <div class="txp-container" *ngFor="let txp of txpsByWallet.txps">\n            <ion-checkbox mode="ios" (click)="txpSelectionChange(txp)" *ngIf="walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'" [checked]="txp.checked" [disabled]="txp.statusForUs == \'accepted\' || txp.statusForUs == \'rejected\'"></ion-checkbox>\n            <page-txp [ngClass]="{\'with-checkbox\': walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'}" [tx]="txp" [addressbook]="addressbook" [noOpenModal]="walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'"></page-txp>\n          </div>\n        </div>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova && txpsToSign[0]" [buttonText]="buttonText" (slideDone)="sign()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova && txpsToSign[0]">\n    <button ion-button full class="button-footer" (click)="sign()">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/wallets/proposals-notifications/proposals-notifications.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_errors_errors__["a" /* ErrorsProvider */]])
], ProposalsNotificationsPage);

//# sourceMappingURL=proposals-notifications.js.map

/***/ }),

/***/ 517:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExchangeCryptoPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_exchange_crypto_exchange_checkout_exchange_checkout__ = __webpack_require__(1023);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pages_integrations_changelly_changelly__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_changelly_changelly__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_exchange_crypto_exchange_crypto__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__ = __webpack_require__(31);





// Pages



// Providers











let ExchangeCryptoPage = class ExchangeCryptoPage {
    constructor(actionSheetProvider, logger, modalCtrl, changellyProvider, navCtrl, navParams, onGoingProcessProvider, profileProvider, translate, currencyProvider, txFormatProvider, exchangeCryptoProvider, feeProvider, walletProvider, themeProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.changellyProvider = changellyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.currencyProvider = currencyProvider;
        this.txFormatProvider = txFormatProvider;
        this.exchangeCryptoProvider = exchangeCryptoProvider;
        this.feeProvider = feeProvider;
        this.walletProvider = walletProvider;
        this.themeProvider = themeProvider;
        this.allWallets = [];
        this.toWallets = [];
        this.fromWallets = [];
        this.loading = false;
        this.fromWalletSelectorTitle = this.translate.instant('Select Source Wallet');
        this.toWalletSelectorTitle = this.translate.instant('Select Destination Wallet');
        this.onGoingProcessProvider.set('connectingChangelly');
        this.exchangeCryptoProvider.getSwapTxs().then(res => {
            this.changellySwapTxs = res.changellySwapTxs;
        });
        this.changellyProvider
            .getCurrencies()
            .then(data => {
            if (data.error) {
                this.logger.error('Changelly getCurrencies Error: ' + data.error.message);
                this.showErrorAndBack(null, this.translate.instant('Changelly is not available at this moment. Please, try again later.'));
                return;
            }
            if (data &&
                data.result &&
                __WEBPACK_IMPORTED_MODULE_4_lodash__["isArray"](data.result) &&
                data.result.length > 0) {
                this.supportedCoins = __WEBPACK_IMPORTED_MODULE_4_lodash__["intersection"](this.currencyProvider.getAvailableCoins(), data.result);
                const coinsToRemove = ['xrp', 'busd'];
                coinsToRemove.forEach((coin) => {
                    const index = this.supportedCoins.indexOf(coin);
                    if (index > -1) {
                        this.logger.debug(`Removing ${coin.toUpperCase()} from supported coins`);
                        this.supportedCoins.splice(index, 1);
                    }
                });
            }
            this.logger.debug('Changelly supportedCoins: ' + this.supportedCoins);
            this.allWallets = this.profileProvider.getWallets({
                network: 'livenet',
                onlyComplete: true,
                coin: this.supportedCoins,
                backedUp: true
            });
            this.onGoingProcessProvider.clear();
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.allWallets)) {
                this.showErrorAndBack(null, this.translate.instant('No wallets available to use this exchange'));
                return;
            }
            this.fromWallets = this.allWallets.filter(w => {
                return w.cachedStatus && w.cachedStatus.availableBalanceSat > 0;
            });
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.fromWallets)) {
                this.showErrorAndBack(null, this.translate.instant('No wallets with funds'));
                return;
            }
            if (this.navParams.data.walletId) {
                const wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
                if (wallet.network != 'livenet') {
                    this.showErrorAndBack(null, this.translate.instant('Unsupported network'));
                    return;
                }
                if (!wallet.coin || !this.supportedCoins.includes(wallet.coin)) {
                    this.showErrorAndBack(null, this.translate.instant('Currently our partner does not support exchanges with the selected coin'));
                    return;
                }
                else {
                    if (wallet.cachedStatus &&
                        wallet.cachedStatus.spendableAmount &&
                        wallet.cachedStatus.spendableAmount > 0) {
                        this.onWalletSelect(wallet, 'from');
                    }
                    else {
                        this.onWalletSelect(wallet, 'to');
                    }
                }
            }
        })
            .catch(err => {
            this.logger.error('Changelly getCurrencies Error: ', err);
            this.showErrorAndBack(null, this.translate.instant('Changelly is not available at this moment. Please, try again later.'));
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ExchangeCryptoPage');
    }
    showWallets(selector) {
        let walletsForActionSheet = [];
        let selectedWalletId;
        let title = selector == 'from'
            ? this.fromWalletSelectorTitle
            : this.toWalletSelectorTitle;
        if (selector == 'from') {
            this.isOpenSelectorFrom = true;
            walletsForActionSheet = this.fromWallets;
            selectedWalletId = this.fromWalletSelected
                ? this.fromWalletSelected.id
                : null;
        }
        else if (selector == 'to') {
            this.isOpenSelectorTo = true;
            walletsForActionSheet = this.toWallets;
            selectedWalletId = this.toWalletSelected
                ? this.toWalletSelected.id
                : null;
        }
        const params = {
            wallets: walletsForActionSheet,
            selectedWalletId,
            title
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            this.isOpenSelectorFrom = false;
            this.isOpenSelectorTo = false;
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet, selector);
        });
    }
    showToWallets() {
        this.toWallets = this.allWallets.filter(w => !w.needsBackup &&
            w.id != this.fromWalletSelected.id &&
            w.coin != this.fromWalletSelected.coin);
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.toWallets)) {
            let msg = this.translate.instant('Destination wallet needs to be backed up');
            this.showErrorAndBack(null, msg);
            return;
        }
    }
    onWalletSelect(wallet, selector) {
        if (selector == 'from') {
            this.onFromWalletSelect(wallet);
        }
        else if (selector == 'to') {
            this.onToWalletSelect(wallet);
        }
    }
    onFromWalletSelect(wallet) {
        this.fromWalletSelected = wallet;
        this.toWalletSelected = null; // Clear variable to select wallet again
        this.amountFrom = null; // Clear amount and rate to avoid mistakes
        this.rate = null;
        this.fixedRateId = null;
        this.showToWallets();
    }
    onToWalletSelect(wallet) {
        this.toWalletSelected = wallet;
        this.updateMaxAndMin();
    }
    updateMaxAndMin() {
        this.amountTo = null;
        this.rate = null;
        if (!this.fromWalletSelected || !this.toWalletSelected || !this.amountFrom)
            return;
        this.loading = true;
        let pair = this.fromWalletSelected.coin + '_' + this.toWalletSelected.coin;
        this.logger.debug('Updating max and min with pair: ' + pair);
        const data = {
            coinFrom: this.fromWalletSelected.coin,
            coinTo: this.toWalletSelected.coin
        };
        this.changellyProvider
            .getPairsParams(this.fromWalletSelected, data)
            .then((data) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (data.error) {
                const msg = 'Changelly getPairsParams Error: ' + data.error.message;
                this.showErrorAndBack(null, msg, true);
                return;
            }
            this.minAmount = Number(data.result[0].minAmountFixed);
            this.maxAmount = Number(data.result[0].maxAmountFixed);
            this.logger.debug(`Min amount: ${this.minAmount} - Max amount: ${this.maxAmount}`);
            if (this.useSendMax && this.shouldUseSendMax()) {
                this.onGoingProcessProvider.set('calculatingSendMax');
                this.sendMaxInfo = yield this.getSendMaxInfo();
                if (this.sendMaxInfo) {
                    this.logger.debug('Send max info', this.sendMaxInfo);
                    this.amountFrom = this.txFormatProvider.satToUnit(this.sendMaxInfo.amount, this.fromWalletSelected.coin);
                    this.estimatedFee = this.txFormatProvider.satToUnit(this.sendMaxInfo.fee, this.fromWalletSelected.coin);
                }
            }
            this.onGoingProcessProvider.clear();
            if (this.amountFrom > this.maxAmount) {
                const errorActionSheet = this.actionSheetProvider.createInfoSheet('max-amount-allowed', {
                    maxAmount: this.maxAmount,
                    coin: this.fromWalletSelected.coin.toUpperCase()
                });
                errorActionSheet.present();
                errorActionSheet.onDidDismiss(option => {
                    if (option) {
                        this.amountFrom = this.maxAmount;
                        this.useSendMax = null;
                        this.updateReceivingAmount();
                    }
                });
                return;
            }
            if (this.amountFrom < this.minAmount) {
                if (this.useSendMax && this.shouldUseSendMax()) {
                    let msg;
                    if (this.sendMaxInfo) {
                        const warningMsg = this.exchangeCryptoProvider.verifyExcludedUtxos(this.fromWalletSelected.coin, this.sendMaxInfo);
                        msg = !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](warningMsg) ? warningMsg : '';
                    }
                    const errorActionSheet = this.actionSheetProvider.createInfoSheet('send-max-min-amount', {
                        amount: this.amountFrom,
                        fee: this.estimatedFee,
                        minAmount: this.minAmount,
                        coin: this.fromWalletSelected.coin.toUpperCase(),
                        msg
                    });
                    errorActionSheet.present();
                    errorActionSheet.onDidDismiss(() => {
                        this.useSendMax = null;
                        this.amountFrom = null;
                        this.estimatedFee = null;
                        this.sendMaxInfo = null;
                        this.rate = null;
                        this.fixedRateId = null;
                    });
                    return;
                }
                else {
                    const errorActionSheet = this.actionSheetProvider.createInfoSheet('min-amount-allowed', {
                        minAmount: this.minAmount,
                        coin: this.fromWalletSelected.coin.toUpperCase()
                    });
                    errorActionSheet.present();
                    errorActionSheet.onDidDismiss(option => {
                        if (option) {
                            this.amountFrom = this.minAmount;
                            this.useSendMax = null;
                            this.sendMaxInfo = null;
                            this.updateReceivingAmount();
                        }
                    });
                    return;
                }
            }
            this.updateReceivingAmount();
        }))
            .catch(err => {
            this.logger.error('Changelly getPairsParams Error: ', err);
            this.showErrorAndBack(null, this.translate.instant('Changelly is not available at this moment. Please, try again later.'));
        });
    }
    shouldUseSendMax() {
        const chain = this.currencyProvider.getAvailableChains();
        return chain.includes(this.fromWalletSelected.coin);
    }
    showErrorAndBack(title, msg, noExit) {
        this.onGoingProcessProvider.clear();
        this.loading = false;
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.error && msg.error.message ? msg.error.message : msg;
        const errorActionSheet = this.actionSheetProvider.createInfoSheet('default-error', {
            msg,
            title
        });
        errorActionSheet.present();
        errorActionSheet.onDidDismiss(_option => {
            if (!noExit)
                this.navCtrl.pop();
        });
    }
    openAmountModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_7__pages_send_amount_amount__["a" /* AmountPage */], {
            fixedUnit: false,
            fromExchangeCrypto: true,
            walletId: this.fromWalletSelected.id,
            coin: this.fromWalletSelected.coin,
            useAsModal: true
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
        modal.onDidDismiss(data => {
            if (data) {
                this.amountFrom = this.txFormatProvider.satToUnit(data.amount, data.coin);
                this.useSendMax = data.useSendMax;
                this.updateMaxAndMin();
            }
        });
    }
    updateReceivingAmount() {
        if (!this.fromWalletSelected ||
            !this.toWalletSelected ||
            !this.amountFrom) {
            this.loading = false;
            return;
        }
        if (this.fromWalletSelected.cachedStatus &&
            this.fromWalletSelected.cachedStatus.spendableAmount) {
            const spendableAmount = this.txFormatProvider.satToUnit(this.fromWalletSelected.cachedStatus.spendableAmount, this.fromWalletSelected.coin);
            if (spendableAmount < this.amountFrom) {
                this.loading = false;
                this.showErrorAndBack(null, this.translate.instant('You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals or enter a valid amount.'), true);
                return;
            }
        }
        const pair = this.fromWalletSelected.coin + '_' + this.toWalletSelected.coin;
        this.logger.debug('Updating receiving amount with pair: ' + pair);
        const data = {
            amountFrom: this.amountFrom,
            coinFrom: this.fromWalletSelected.coin,
            coinTo: this.toWalletSelected.coin
        };
        this.changellyProvider
            .getFixRateForAmount(this.fromWalletSelected, data)
            .then(data => {
            if (data.error) {
                const msg = 'Changelly getFixRateForAmount Error: ' + data.error.message;
                this.showErrorAndBack(null, msg, true);
                return;
            }
            this.fixedRateId = data.result[0].id;
            this.amountTo = Number(data.result[0].amountTo);
            this.rate = Number(data.result[0].result); // result == rate
            this.loading = false;
        })
            .catch(err => {
            this.logger.error('Changelly getFixRateForAmount Error: ', err);
            this.showErrorAndBack(null, this.translate.instant('Changelly is not available at this moment. Please, try again later.'));
        });
    }
    getChain(coin) {
        return this.currencyProvider.getChain(coin).toLowerCase();
    }
    getSendMaxInfo() {
        return new Promise((resolve, reject) => {
            const feeLevel = this.fromWalletSelected.coin == 'btc' ||
                this.getChain(this.fromWalletSelected.coin) == 'eth'
                ? 'priority'
                : this.feeProvider.getCoinCurrentFeeLevel(this.fromWalletSelected.coin);
            this.feeProvider
                .getFeeRate(this.fromWalletSelected.coin, this.fromWalletSelected.network, feeLevel)
                .then(feeRate => {
                this.walletProvider
                    .getSendMaxInfo(this.fromWalletSelected, {
                    feePerKb: feeRate,
                    excludeUnconfirmedUtxos: true,
                    returnInputs: true
                })
                    .then(res => {
                    this.onGoingProcessProvider.clear();
                    return resolve(res);
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    return reject(err);
                });
            });
        });
    }
    canContinue() {
        return (this.toWalletSelected &&
            this.fromWalletSelected &&
            this.amountTo &&
            this.minAmount &&
            this.maxAmount &&
            this.amountFrom >= this.minAmount &&
            this.amountFrom <= this.maxAmount);
    }
    goToExchangeCheckoutPage() {
        const data = {
            fromWalletSelectedId: this.fromWalletSelected.id,
            toWalletSelectedId: this.toWalletSelected.id,
            fixedRateId: this.fixedRateId,
            amountFrom: this.amountFrom,
            coinFrom: this.fromWalletSelected.coin,
            coinTo: this.toWalletSelected.coin,
            rate: this.rate,
            useSendMax: this.useSendMax,
            sendMaxInfo: this.sendMaxInfo
        };
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__pages_exchange_crypto_exchange_checkout_exchange_checkout__["a" /* ExchangeCheckoutPage */], data);
    }
    goToExchangeHistory() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__pages_integrations_changelly_changelly__["a" /* ChangellyPage */]);
    }
};
ExchangeCryptoPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-exchange-crypto',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-crypto.html"*/'<wide-header-page title="{{\'Exchange Crypto\' | translate}}">\n  <ion-buttons right *ngIf="changellySwapTxs?.length">\n    <button class="history-btn" clear wide-header-bar-button (click)="goToExchangeHistory()" ion-button>\n      <ion-icon>\n        <img src="assets/img/icon-history.svg" />\n      </ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <div class="item-label" translate>Source</div>\n      <ion-row padding align-items-center *ngIf="!fromWalletSelected" (click)="showWallets(\'from\')">\n        <div translate>Select Source Wallet</div>\n        <div class="last-item" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelectorFrom" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelectorFrom" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </ion-row>\n\n      <ion-row padding align-items-center *ngIf="fromWalletSelected">\n        <ion-col class="wallet" (click)="showWallets(\'from\')">\n          <coin-icon [coin]="fromWalletSelected.coin" [network]="fromWalletSelected.network"></coin-icon>\n          <div class="name-balance">\n            <span class="note-container ellipsis">{{fromWalletSelected.name}}</span>            \n            <span class="note-container ellipsis balance">{{fromWalletSelected.lastKnownBalance}}</span>\n          </div>\n        </ion-col>\n\n        <ion-col col-5 class="amount">\n          <div class="amount-container" *ngIf="!amountFrom && !useSendMax" (click)="openAmountModal()">{{\'Enter Amount\' | translate}}</div>\n          <div class="amount-container" *ngIf="amountFrom && !useSendMax" (click)="openAmountModal()">{{amountFrom | number:\'1.0-8\'}} {{fromWalletSelected.coin.toUpperCase()}}</div>\n          <div class="amount-container" *ngIf="useSendMax" (click)="openAmountModal()" translate>Maximum Amount</div>\n        </ion-col>\n      </ion-row>\n\n      <div class="divider">\n        <div class="arrow">\n          <img src="assets/img/exchange-crypto/down-arrow.svg" width="40">\n        </div>\n      </div>\n\n      <div class="item-label" translate>Destination</div>\n      <ion-row padding align-items-center *ngIf="!toWalletSelected" (click)="showWallets(\'to\')">\n        <div translate>Select Destination Wallet</div>\n        <div class="last-item" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelectorTo" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelectorTo" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </ion-row>\n\n      <ion-row padding align-items-center *ngIf="toWalletSelected">\n        <ion-col class="wallet" (click)="showWallets(\'to\')">\n          <coin-icon [coin]="toWalletSelected.coin" [network]="toWalletSelected.network"></coin-icon>\n          <div class="name-balance">\n            <span class="note-container ellipsis">{{toWalletSelected.name}}</span>            \n            <span class="note-container ellipsis balance">{{toWalletSelected.lastKnownBalance}}</span>\n          </div>\n        </ion-col>\n\n        <ion-col col-5 class="amount">\n          <ion-spinner name="crescent" *ngIf="loading && toWalletSelected && fromWalletSelected && amountFrom && !amountTo"></ion-spinner>\n          <div class="amount-container" *ngIf="amountTo">{{amountTo | number:\'1.0-6\'}} {{toWalletSelected.coin.toUpperCase()}}</div>\n        </ion-col>\n      </ion-row>\n      <ion-row class="rate-container">\n        <div *ngIf="rate" class="rate">\n          <span>1 {{fromWalletSelected.coin.toUpperCase()}} ~ {{rate | number:\'1.0-6\'}} {{toWalletSelected.coin.toUpperCase()}}</span>\n        </div>\n        <div *ngIf="!rate && fromWalletSelected && toWalletSelected && amountTo && amountFrom > 0" class="rate">\n          <span>1 {{fromWalletSelected.coin.toUpperCase()}} ~ {{(amountTo / amountFrom) | number:\'1.0-6\'}} {{toWalletSelected.coin.toUpperCase()}}</span>\n        </div>\n      </ion-row>\n    </ion-list>\n\n    <div class="bottom-absolute">\n      <button ion-button class="button-standard button-primary" (click)="goToExchangeCheckoutPage()" [disabled]="!canContinue()">\n        <span>{{\'Continue\' | translate}}</span>\n      </button>\n\n      <div class="partner">\n        <span>{{\'Powered by\' | translate}}</span>\n        <img src="assets/img/exchange-crypto/changelly-vector-logo{{themeProvider.isDarkModeEnabled() ? \'-dark\' : \'\'}}.svg" width="120">\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-crypto.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_changelly_changelly__["a" /* ChangellyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_10__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_exchange_crypto_exchange_crypto__["a" /* ExchangeCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_theme_theme__["a" /* ThemeProvider */]])
], ExchangeCryptoPage);

//# sourceMappingURL=exchange-crypto.js.map

/***/ }),

/***/ 518:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectInvoicePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(27);




// Provider

let SelectInvoicePage = class SelectInvoicePage {
    constructor(currencyProvider, incomingDataProvider, logger, navParams) {
        this.currencyProvider = currencyProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.paymentOptions = this.navParams.data.payProOptions.paymentOptions
            .reverse()
            .sort(a => (a.disabled ? 1 : -1));
        this.payProUrl = this.navParams.data.payProOptions.payProUrl;
        this.hasWallets = this.navParams.data.hasWallets;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SelectInvoicePage');
    }
    getCoinName(currency) {
        const coin = currency.toLowerCase();
        return this.currencyProvider.getCoinName(coin);
    }
    goToPayPro(currency) {
        const coin = currency.toLowerCase();
        if (this.navParams.data.walletCardRedir) {
            this.payProUrl += '?redir=wc';
        }
        this.incomingDataProvider.goToPayPro(this.payProUrl, coin, this.navParams.data.payProOptions);
    }
};
SelectInvoicePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'select-invoice-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/invoice/select-invoice/select-invoice.html"*/'<wide-header-page title="{{\'Select Currency\' | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <div *ngFor="let option of paymentOptions">\n        <button class="list-button" ion-item (click)="goToPayPro(option.currency)" [disabled]="option.disabled">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{option.currency.toLowerCase()}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{getCoinName(option.currency.toLowerCase())}}</div>\n          <span class="alternative">{{option.estimatedAmount | satToUnit: option.currency.toLowerCase()}}</span>\n          <ion-note item-end>\n            <span *ngIf="!option.disabled">{{hasWallets[option.currency.toLowerCase()]}} {{hasWallets[option.currency.toLowerCase()] > 1 ? \'Wallets\' : \'Wallet\'}}</span>\n          </ion-note>\n        </button>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/invoice/select-invoice/select-invoice.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["t" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["P" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */]])
], SelectInvoicePage);

//# sourceMappingURL=select-invoice.js.map

/***/ }),

/***/ 519:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaperWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__ = __webpack_require__(31);





// pages

// providers











let PaperWalletPage = class PaperWalletPage {
    constructor(actionSheetProvider, navCtrl, navParams, bwcProvider, onGoingProcessProvider, popupProvider, logger, walletProvider, feeProvider, profileProvider, modalCtrl, translate, platformProvider, bwcErrorProvider, currencyProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.bwcProvider = bwcProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.feeProvider = feeProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.currencyProvider = currencyProvider;
        this.wallet = {};
        this.balances = [];
        this.bitcore = this.bwcProvider.getBitcore();
        this.isCordova = this.platformProvider.isCordova;
        this.isOpenSelector = false;
        this.scannedKey = this.navParams.data.privateKey;
        this.isPkEncrypted = this.scannedKey
            ? this.scannedKey.substring(0, 2) == '6P'
            : null;
        this.error = false;
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: 'livenet'
        });
        this.wallets = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.wallets), wallet => {
            return (!wallet.needsBackup && this.currencyProvider.isUtxoCoin(wallet.coin));
        });
        this.coins = __WEBPACK_IMPORTED_MODULE_4_lodash__["uniq"](__WEBPACK_IMPORTED_MODULE_4_lodash__["map"](this.wallets, (wallet) => wallet.coin));
        for (const coin of this.coins) {
            this.wallet[coin] = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.wallets, w => {
                return w.coin == coin;
            })[0];
        }
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
    }
    ionViewDidEnter() {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets)) {
            this.popupProvider
                .ionicAlert('Error', this.translate.instant('No wallets available to receive funds'))
                .then(() => {
                this.navCtrl.pop();
            });
            return;
        }
        if (!this.isPkEncrypted) {
            this.onGoingProcessProvider.set('scanning');
            setTimeout(() => {
                this.scanFunds();
            }, 200);
        }
        else {
            let message = this.translate.instant('Private key encrypted. Enter password');
            let opts = {
                type: 'password',
                enableBackdropDismiss: false
            };
            this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                if (res === null) {
                    this.navCtrl.popToRoot();
                    return;
                }
                this.passphrase = res;
                this.onGoingProcessProvider.set('scanning');
                setTimeout(() => {
                    this.scanFunds();
                }, 200);
            });
        }
    }
    getPrivateKey(scannedKey, privateKeyIsEncrypted, passphrase, coin, cb) {
        if (!privateKeyIsEncrypted) {
            return cb(null, scannedKey);
        }
        this.wallet[coin].decryptBIP38PrivateKey(scannedKey, passphrase, null, cb);
    }
    getBalance(privateKey, coin, cb) {
        this.wallet[coin].getBalanceFromPrivateKey(privateKey, coin, cb);
    }
    checkPrivateKey(privateKey) {
        try {
            new this.bitcore.PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    _scanFunds(coin) {
        return new Promise((resolve, reject) => {
            this.getPrivateKey(this.scannedKey, this.isPkEncrypted, this.passphrase, coin, (err, privateKey) => {
                if (err)
                    return reject(err);
                if (!this.checkPrivateKey(privateKey))
                    return reject(new Error('Invalid private key'));
                this.getBalance(privateKey, coin, (err, balance) => {
                    if (err)
                        return reject(err);
                    return resolve({ privateKey, coin, balance });
                });
            });
        });
    }
    scanFunds() {
        let scans = __WEBPACK_IMPORTED_MODULE_4_lodash__["map"](this.coins, (coin) => this._scanFunds(coin));
        Promise.all(scans)
            .then(data => {
            this.onGoingProcessProvider.clear();
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](data, d => {
                this.balances.push(d);
            });
            let available = {};
            this.balances = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.balances), b => {
                let nonzero = b.balance > 0;
                available[b.coin] = nonzero;
                return nonzero;
            });
            this.wallets = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.wallets), w => available[w.coin]);
            this.selectedWallet = this.wallets[0];
            if (this.balances.length == 0) {
                this.popupProvider
                    .ionicAlert('Error', this.translate.instant('No funds found'))
                    .then(() => {
                    this.navCtrl.pop();
                });
            }
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider
                .ionicAlert(this.translate.instant('Error scanning funds:'), this.bwcErrorProvider.msg(err))
                .then(() => {
                this.navCtrl.pop();
            });
        });
    }
    _sweepWallet() {
        return new Promise((resolve, reject) => {
            let balanceToSweep = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.balances, b => {
                return b.coin === this.selectedWallet.coin;
            })[0];
            this.walletProvider
                .getAddress(this.selectedWallet, true)
                .then((destinationAddress) => {
                let opts = {};
                opts.coin = balanceToSweep.coin;
                this.selectedWallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, testTx) => {
                    if (err)
                        return reject(err);
                    let rawTxLength = testTx.serialize().length;
                    this.feeProvider
                        .getFeeRate(balanceToSweep.coin, 'livenet', this.feeProvider.getCoinCurrentFeeLevel(balanceToSweep.coin))
                        .then((feePerKb) => {
                        opts.fee = Math.round((feePerKb * rawTxLength) / 2000);
                        this.selectedWallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, tx) => {
                            if (err)
                                return reject(err);
                            this.selectedWallet.broadcastRawTx({
                                rawTx: tx.serialize(),
                                network: 'livenet',
                                coin: balanceToSweep.coin
                            }, (err, txid) => {
                                if (err)
                                    return reject(err);
                                return resolve({ destinationAddress, txid });
                            });
                        });
                    });
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    sweepWallet() {
        this.onGoingProcessProvider.set('sweepingWallet');
        this._sweepWallet()
            .then(data => {
            this.onGoingProcessProvider.clear();
            this.logger.debug('Success sweep. Destination address:' +
                data.destinationAddress +
                ' - transaction id: ' +
                data.txid);
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider.ionicAlert(this.translate.instant('Error sweeping wallet:'), this.bwcErrorProvider.msg(err));
        });
    }
    onWalletSelect(wallet) {
        this.selectedWallet = wallet;
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.selectedWallet
            ? this.selectedWallet.credentials.walletId
            : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: 'Transfer to'
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishComment = this.translate.instant('Check the transaction on your wallet details');
        let finishText = this.translate.instant('Sweep Completed');
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, coin: this.selectedWallet.coin }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.navCtrl.popToRoot();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], PaperWalletPage.prototype, "slideButton", void 0);
PaperWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-paper-wallet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/paper-wallet/paper-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{\'Sweep paper wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content [ngClass]="{\'add-padding-bottom\': isCordova}" no-bounce>\n  <h4 class="title" *ngIf="balances && balances.length > 0">\n    <span translate>Funds found</span>:\n    <div *ngFor="let b of balances">\n      {{b.balance | satToUnit: b.coin}}\n    </div>\n  </h4>\n  <div *ngIf="selectedWallet">\n    <ion-item-divider>{{\'Funds will be transferred to\' | translate}}</ion-item-divider>\n    <ion-list class="bp-list">\n      <button ion-item detail-none (click)="showWallets()">\n        <ion-icon item-start>\n          <img class="icon-wallet" [ngClass]="{ testnet: selectedWallet.network === \'testnet\' }" src="assets/img/currencies/{{selectedWallet.coin}}.svg" />\n        </ion-icon>\n        <h2>{{selectedWallet.name}}\n          <span *ngIf="selectedWallet.credentials.m > 1">{{selectedWallet.credentials.m}}-{{selectedWallet.credentials.n}}</span>\n        </h2>\n        <span *ngIf="!selectedWallet.balanceHidden"> {{selectedWallet.cachedStatus.totalBalanceStr}} </span>\n        <span *ngIf="selectedWallet.balanceHidden" translate>[Balance Hidden]</span>\n        <span class="assertive" *ngIf="error">{{error}}</span>\n        <div item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="balances.length == 0" buttonText="{{\'Sweep\' | translate}}" [isDogecoin]="selectedWallet && selectedWallet.coin == \'doge\'" (slideDone)="sweepWallet()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button block class="button-footer" (click)="sweepWallet()" [disabled]="balances.length == 0">\n      {{\'Sweep\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/paper-wallet/paper-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */]])
], PaperWalletPage);

//# sourceMappingURL=paper-wallet.js.map

/***/ }),

/***/ 520:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransferToModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let TransferToModalPage = class TransferToModalPage {
    constructor(navParams) {
        this.navParams = navParams;
        this.search = '';
        this.wallet = this.navParams.data.wallet;
        this.fromSelectInputs = this.navParams.data.fromSelectInputs;
        this.fromMultiSend = this.navParams.data.fromMultiSend;
    }
};
TransferToModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-transfer-to-modal',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/transfer-to-modal/transfer-to-modal.html"*/'<wide-header-page title="{{\'Select recipient\' | translate}}">\n  <div page-content>\n    <search-bar [scrollArea]="wideHeaderPage?.scrollArea" placeholder="{{\'Search Wallets or Contacts\' | translate}}" [(ngModel)]="search"></search-bar>\n    <page-transfer-to [wallet]="wallet" [searchInput]="search" [useAsModal]="true" [fromMultiSend]="fromMultiSend"  [fromSelectInputs]="fromSelectInputs"></page-transfer-to>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/transfer-to-modal/transfer-to-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */]])
], TransferToModalPage);

//# sourceMappingURL=transfer-to-modal.js.map

/***/ }),

/***/ 530:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 530;

/***/ }),

/***/ 537:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 537;

/***/ }),

/***/ 56:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ThemeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(319);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__platform_platform__ = __webpack_require__(13);




// providers



let ThemeProvider = class ThemeProvider {
    constructor(logger, statusBar, platformProvider, translate, configProvider) {
        this.logger = logger;
        this.statusBar = statusBar;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.configProvider = configProvider;
        this.useSystemTheme = false;
        this.logger.debug('ThemeProvider initialized');
        this.availableThemes = {
            light: {
                name: this.translate.instant('Light Mode'),
                bodyColor: 'initial',
                backgroundColor: '#ffffff',
                fixedScrollBgColor: '#f8f8f9',
                walletDetailsBackgroundStart: '#ffffff',
                walletDetailsBackgroundEnd: '#ffffff'
            },
            dark: {
                name: this.translate.instant('Dark Mode'),
                bodyColor: '#121212',
                backgroundColor: '#121212',
                fixedScrollBgColor: '#121212',
                walletDetailsBackgroundStart: '#121212',
                walletDetailsBackgroundEnd: '#101010'
            }
        };
    }
    isEnabled() {
        const config = this.configProvider.get();
        return !!config.theme.enabled;
    }
    load() {
        return new Promise(resolve => {
            if (!this.isEnabled())
                return resolve();
            const config = this.configProvider.get();
            if (!config.theme.system) {
                this.useSystemTheme = false;
                this.currentAppTheme = config.theme.name;
                this.logger.debug('Set Stored App Theme: ' + this.currentAppTheme);
                return resolve();
            }
            else {
                // Auto-detect theme
                this.useSystemTheme = true;
                this.getDetectedSystemTheme().then(theme => {
                    this.currentAppTheme = theme;
                    this.logger.debug('Set System App Theme to: ' + this.currentAppTheme);
                    return resolve();
                });
            }
        });
    }
    getDetectedSystemTheme() {
        return new Promise(resolve => {
            if (this.platformProvider.isCordova) {
                cordova.plugins.ThemeDetection.isAvailable(res => {
                    if (res && res.value) {
                        cordova.plugins.ThemeDetection.isDarkModeEnabled(success => {
                            return resolve(success && success.value ? 'dark' : 'light');
                        }, _ => {
                            return resolve('light');
                        });
                    }
                    else {
                        return resolve('light');
                    }
                }, _ => {
                    return resolve('light');
                });
            }
            else {
                return resolve(window.matchMedia &&
                    window.matchMedia('(prefers-color-scheme: dark)').matches
                    ? 'dark'
                    : 'light');
            }
        });
    }
    apply() {
        if (!this.isEnabled())
            return;
        const isDarkMode = this.isDarkModeEnabled();
        if (this.platformProvider.isCordova) {
            setTimeout(() => {
                if (isDarkMode) {
                    this.useDarkStatusBar();
                }
                else {
                    this.useLightStatusBar();
                }
            }, 100);
        }
        // Force body background
        document.body.style.backgroundColor = this.availableThemes[this.currentAppTheme].bodyColor;
        document
            .getElementsByTagName('ion-app')[0]
            .classList.remove('dark', 'light');
        document
            .getElementsByTagName('ion-app')[0]
            .classList.add(isDarkMode ? 'dark' : 'light');
        this.logger.debug('Apply Theme: ' + this.currentAppTheme);
    }
    setActiveTheme(theme, detectedSystemTheme) {
        switch (theme) {
            case 'system':
                this.useSystemTheme = true;
                this.currentAppTheme = detectedSystemTheme;
                break;
            default:
                this.useSystemTheme = false;
                this.currentAppTheme = theme || detectedSystemTheme;
        }
        this.setConfigTheme();
        this.apply();
    }
    setConfigTheme() {
        let opts = {
            theme: {
                enabled: true,
                name: this.currentAppTheme,
                system: this.useSystemTheme
            }
        };
        this.configProvider.set(opts);
    }
    getThemeInfo(theme) {
        // If no theme provided returns current theme info
        if (theme && this.availableThemes[theme])
            return this.availableThemes[theme];
        else if (this.availableThemes[this.currentAppTheme])
            return this.availableThemes[this.currentAppTheme];
        else
            return this.availableThemes['light'];
    }
    isDarkModeEnabled() {
        return Boolean(this.currentAppTheme === 'dark');
    }
    getCurrentAppTheme() {
        if (!this.isEnabled())
            return;
        return this.useSystemTheme
            ? 'System Default'
            : this.availableThemes[this.currentAppTheme].name;
    }
    getSelectedTheme() {
        return this.useSystemTheme ? 'system' : this.currentAppTheme;
    }
    useDarkStatusBar() {
        this.statusBar.backgroundColorByHexString(this.availableThemes['dark'].backgroundColor);
        this.statusBar.styleBlackOpaque();
    }
    useLightStatusBar() {
        this.statusBar.backgroundColorByHexString(this.availableThemes['light'].backgroundColor);
        this.statusBar.styleDefault();
    }
    useCustomStatusBar(color) {
        this.statusBar.backgroundColorByHexString(color);
        this.statusBar.styleBlackOpaque();
    }
    useDefaultStatusBar() {
        if (this.isDarkModeEnabled()) {
            this.useDarkStatusBar();
        }
        else {
            this.useLightStatusBar();
        }
    }
};
ThemeProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_6__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */]])
], ThemeProvider);

//# sourceMappingURL=theme.js.map

/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

/**
 * Determines whether a string contains only hexadecimal values
 *
 * @name JSUtil.isHexa
 * @param {string} value
 * @return {boolean} true if the string is the hexa representation of a number
 */
var isHexa = function isHexa(value) {
  if (!_.isString(value)) {
    return false;
  }
  return /^[0-9a-fA-F]+$/.test(value);
};

/**
 * @namespace JSUtil
 */
module.exports = {
  /**
   * Test if an argument is a valid JSON object. If it is, returns a truthy
   * value (the json object decoded), so no double JSON.parse call is necessary
   *
   * @param {string} arg
   * @return {Object|boolean} false if the argument is not a JSON string.
   */
  isValidJSON: function isValidJSON(arg) {
    var parsed;
    if (!_.isString(arg)) {
      return false;
    }
    try {
      parsed = JSON.parse(arg);
    } catch (e) {
      return false;
    }
    if (typeof(parsed) === 'object') {
      return true;
    }
    return false;
  },
  isHexa: isHexa,
  isHexaString: isHexa,

  /**
   * Clone an array
   */
  cloneArray: function(array) {
    return [].concat(array);
  },

  /**
   * Define immutable properties on a target object
   *
   * @param {Object} target - An object to be extended
   * @param {Object} values - An object of properties
   * @return {Object} The target object
   */
  defineImmutable: function defineImmutable(target, values) {
    Object.keys(values).forEach(function(key){
      Object.defineProperty(target, key, {
        configurable: false,
        enumerable: true,
        value: values[key]
      });
    });
    return target;
  },
  /**
   * Checks that a value is a natural number, a positive integer or zero.
   *
   * @param {*} value
   * @return {Boolean}
   */
  isNaturalNumber: function isNaturalNumber(value) {
    return typeof value === 'number' &&
      isFinite(value) &&
      Math.floor(value) === value &&
      value >= 0;
  }
};


/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);

/**
 * Determines whether a string contains only hexadecimal values
 *
 * @name JSUtil.isHexa
 * @param {string} value
 * @return {boolean} true if the string is the hexa representation of a number
 */
var isHexa = function isHexa(value) {
  if (!_.isString(value)) {
    return false;
  }
  return /^[0-9a-fA-F]+$/.test(value);
};

/**
 * @namespace JSUtil
 */
module.exports = {
  /**
   * Test if an argument is a valid JSON object. If it is, returns a truthy
   * value (the json object decoded), so no double JSON.parse call is necessary
   *
   * @param {string} arg
   * @return {Object|boolean} false if the argument is not a JSON string.
   */
  isValidJSON: function isValidJSON(arg) {
    var parsed;
    if (!_.isString(arg)) {
      return false;
    }
    try {
      parsed = JSON.parse(arg);
    } catch (e) {
      return false;
    }
    if (typeof(parsed) === 'object') {
      return true;
    }
    return false;
  },
  isHexa: isHexa,
  isHexaString: isHexa,

  /**
   * Clone an array
   */
  cloneArray: function(array) {
    return [].concat(array);
  },

  /**
   * Define immutable properties on a target object
   *
   * @param {Object} target - An object to be extended
   * @param {Object} values - An object of properties
   * @return {Object} The target object
   */
  defineImmutable: function defineImmutable(target, values) {
    Object.keys(values).forEach(function(key){
      Object.defineProperty(target, key, {
        configurable: false,
        enumerable: true,
        value: values[key]
      });
    });
    return target;
  },
  /**
   * Checks that a value is a natural number, a positive integer or zero.
   *
   * @param {*} value
   * @return {Boolean}
   */
  isNaturalNumber: function isNaturalNumber(value) {
    return typeof value === 'number' &&
      isFinite(value) &&
      Math.floor(value) === value &&
      value >= 0;
  }
};


/***/ }),

/***/ 68:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnalyticsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fcm_ng__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fcm_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_fcm_ng__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__platform_platform__ = __webpack_require__(13);




let AnalyticsProvider = class AnalyticsProvider {
    constructor(FCMPlugin, platformProvider) {
        this.FCMPlugin = FCMPlugin;
        this.platformProvider = platformProvider;
    }
    logEvent(eventName, eventParams) {
        if (this.platformProvider.isCordova)
            this.FCMPlugin.logEvent(eventName, eventParams);
    }
    setUserProperty(name, value) {
        if (this.platformProvider.isCordova)
            this.FCMPlugin.setUserProperty(name, value);
    }
};
AnalyticsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_fcm_ng__["FCMNG"],
        __WEBPACK_IMPORTED_MODULE_3__platform_platform__["a" /* PlatformProvider */]])
], AnalyticsProvider);

//# sourceMappingURL=analytics.js.map

/***/ }),

/***/ 7:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Logger; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);

/* tslint:disable:no-console */


let Logger = class Logger {
    constructor() {
        this.logs = [];
        this.levels = [
            { level: 'error', weight: 1, label: 'Error', def: false },
            { level: 'warn', weight: 2, label: 'Warning', def: false },
            { level: 'info', weight: 3, label: 'Info', def: true },
            { level: 'debug', weight: 4, label: 'Debug', def: false }
        ];
        // Create an array of level weights for performant filtering.
        this.weight = {};
        for (let i = 0; i < this.levels.length; i++) {
            this.weight[this.levels[i].level] = this.levels[i].weight;
        }
    }
    getMessage(message) {
        const isUndefined = __WEBPACK_IMPORTED_MODULE_2_lodash__["isUndefined"](message);
        const isNull = __WEBPACK_IMPORTED_MODULE_2_lodash__["isNull"](message);
        const isError = __WEBPACK_IMPORTED_MODULE_2_lodash__["isError"](message);
        const isObject = __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](message);
        if (isUndefined)
            return 'undefined';
        else if (isNull)
            return 'null';
        else if (isError)
            return message.message;
        else if (isObject)
            return JSON.stringify(message);
        else
            return message;
    }
    error(_message, ..._optionalParams) {
        const type = 'error';
        const args = this.processingArgs(arguments);
        this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    debug(_message, ..._optionalParams) {
        const type = 'debug';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    info(_message, ..._optionalParams) {
        const type = 'info';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    warn(_message, ..._optionalParams) {
        const type = 'warn';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    getLevels() {
        return this.levels;
    }
    getWeight(weight) {
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.levels, l => {
            return l.weight == weight;
        });
    }
    getDefaultWeight() {
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.levels, l => {
            return l.def;
        });
    }
    add(level, msg) {
        msg = msg.replace('/xpriv.*/', '[...]');
        msg = msg.replace('/walletPrivKey.*/', 'walletPrivKey:[...]');
        const newLog = {
            timestamp: new Date().toISOString(),
            level,
            msg
        };
        this.logs.push(newLog);
    }
    /**
     * Returns logs of <= to filteredWeight
     * @param {number} filteredWeight Weight (1-4) to use when filtering logs. optional
     */
    get(filterWeight) {
        let filteredLogs = this.logs;
        if (filterWeight != undefined) {
            filteredLogs = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.logs, l => {
                return this.weight[l.level] <= filterWeight;
            });
        }
        return filteredLogs;
    }
    processingArgs(argsValues) {
        let args = Array.prototype.slice.call(argsValues);
        args = args.map(v => {
            try {
                v = this.getMessage(v);
            }
            catch (e) {
                console.log('Error at log decorator:', e);
                v = 'Unknown message';
            }
            return v;
        });
        return args.join(' ');
    }
    log(msg, ...optionalParams) {
        console.log(msg, ...optionalParams);
    }
};
Logger = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], Logger);

//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 73:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(15);
var $ = __webpack_require__(35);
var _ = __webpack_require__(1);

var reversebuf = function(buf) {
  var buf2 = Buffer.alloc(buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf2[i] = buf[buf.length - 1 - i];
  }
  return buf2;
};

BN.Zero = new BN(0);
BN.One = new BN(1);
BN.Minus1 = new BN(-1);

BN.fromNumber = function(n) {
  $.checkArgument(_.isNumber(n));
  return new BN(n);
};

BN.fromString = function(str, base) {
  $.checkArgument(_.isString(str));
  return new BN(str, base);
};

BN.fromBuffer = function(buf, opts) {
  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }
  var hex = buf.toString('hex');
  var bn = new BN(hex, 16);
  return bn;
};

/**
 * Instantiate a BigNumber from a "signed magnitude buffer"
 * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))
 */
BN.fromSM = function(buf, opts) {
  var ret;
  if (buf.length === 0) {
    return BN.fromBuffer(Buffer.from([0]));
  }

  var endian = 'big';
  if (opts) {
    endian = opts.endian;
  }
  if (endian === 'little') {
    buf = reversebuf(buf);
  }

  if (buf[0] & 0x80) {
    buf[0] = buf[0] & 0x7f;
    ret = BN.fromBuffer(buf);
    ret.neg().copy(ret);
  } else {
    ret = BN.fromBuffer(buf);
  }
  return ret;
};


BN.prototype.toNumber = function() {
  return parseInt(this.toString(10), 10);
};

BN.prototype.toBuffer = function(opts) {
  var buf, hex;
  if (opts && opts.size) {
    hex = this.toString(16, 2);
    var natlen = hex.length / 2;
    buf = Buffer.from(hex, 'hex');

    if (natlen === opts.size) {
      buf = buf;
    } else if (natlen > opts.size) {
      buf = BN.trim(buf, natlen);
    } else if (natlen < opts.size) {
      buf = BN.pad(buf, natlen, opts.size);
    }
  } else {
    hex = this.toString(16, 2);
    buf = Buffer.from(hex, 'hex');
  }

  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }

  return buf;
};

BN.prototype.toSMBigEndian = function() {
  var buf;
  if (this.cmp(BN.Zero) === -1) {
    buf = this.neg().toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x80]), buf]);
    } else {
      buf[0] = buf[0] | 0x80;
    }
  } else {
    buf = this.toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x00]), buf]);
    }
  }

  if (buf.length === 1 & buf[0] === 0) {
    buf = Buffer.from([]);
  }
  return buf;
};

BN.prototype.toSM = function(opts) {
  var endian = opts ? opts.endian : 'big';
  var buf = this.toSMBigEndian();

  if (endian === 'little') {
    buf = reversebuf(buf);
  }
  return buf;
};

/**
 * Create a BN from a "ScriptNum":
 * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in
 * bitcoind's script interpreter use CScriptNum, which is not really a proper
 * bignum. Instead, an error is thrown if trying to input a number bigger than
 * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to
 * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.
 */
BN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {
  var nMaxNumSize = size || 4;
  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));
  if (fRequireMinimal && buf.length > 0) {
    // Check that the number is encoded with the minimum possible
    // number of bytes.
    //
    // If the most-significant-byte - excluding the sign bit - is zero
    // then we're not minimal. Note how this test also rejects the
    // negative-zero encoding, 0x80.
    if ((buf[buf.length - 1] & 0x7f) === 0) {
      // One exception: if there's more than one byte and the most
      // significant bit of the second-most-significant-byte is set
      // it would conflict with the sign bit. An example of this case
      // is +-255, which encode to 0xff00 and 0xff80 respectively.
      // (big-endian).
      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
        throw new Error('non-minimally encoded script number');
      }
    }
  }
  return BN.fromSM(buf, {
    endian: 'little'
  });
};

/**
 * The corollary to the above, with the notable exception that we do not throw
 * an error if the output is larger than four bytes. (Which can happen if
 * performing a numerical operation that results in an overflow to more than 4
 * bytes).
 */
BN.prototype.toScriptNumBuffer = function() {
  return this.toSM({
    endian: 'little'
  });
};

BN.trim = function(buf, natlen) {
  return buf.slice(natlen - buf.length, buf.length);
};

BN.pad = function(buf, natlen, size) {
  var rbuf = Buffer.alloc(size);
  for (var i = 0; i < buf.length; i++) {
    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
  }
  for (i = 0; i < size - natlen; i++) {
    rbuf[i] = 0;
  }
  return rbuf;
};

module.exports = BN;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 74:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var crypto = __webpack_require__(52);
var BufferUtil = __webpack_require__(48);
var $ = __webpack_require__(35);

var Hash = module.exports;

Hash.sha1 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha1').update(buf).digest();
};

Hash.sha1.blocksize = 512;

Hash.sha256 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha256').update(buf).digest();
};

Hash.sha256.blocksize = 512;

Hash.sha256sha256 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return Hash.sha256(Hash.sha256(buf));
};

Hash.ripemd160 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('ripemd160').update(buf).digest();
};

Hash.sha256ripemd160 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return Hash.ripemd160(Hash.sha256(buf));
};

Hash.sha512 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha512').update(buf).digest();
};

Hash.sha512.blocksize = 1024;

Hash.hmac = function(hashf, data, key) {
  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
  //http://tools.ietf.org/html/rfc4868#section-2
  $.checkArgument(BufferUtil.isBuffer(data));
  $.checkArgument(BufferUtil.isBuffer(key));
  $.checkArgument(hashf.blocksize);

  var blocksize = hashf.blocksize / 8;

  if (key.length > blocksize) {
    key = hashf(key);
  } else if (key < blocksize) {
    var fill = Buffer.alloc(blocksize);
    fill.fill(0);
    key.copy(fill);
    key = fill;
  }

  var o_key = Buffer.alloc(blocksize);
  o_key.fill(0x5c);

  var i_key = Buffer.alloc(blocksize);
  i_key.fill(0x36);

  var o_key_pad = Buffer.alloc(blocksize);
  var i_key_pad = Buffer.alloc(blocksize);
  for (var i = 0; i < blocksize; i++) {
    o_key_pad[i] = o_key[i] ^ key[i];
    i_key_pad[i] = i_key[i] ^ key[i];
  }

  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));
};

Hash.sha256hmac = function(data, key) {
  return Hash.hmac(Hash.sha256, data, key);
};

Hash.sha512hmac = function(data, key) {
  return Hash.hmac(Hash.sha512, data, key);
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 75:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var BN = __webpack_require__(15);
var $ = __webpack_require__(36);
var _ = __webpack_require__(1);

var reversebuf = function(buf) {
  var buf2 = Buffer.alloc(buf.length);
  for (var i = 0; i < buf.length; i++) {
    buf2[i] = buf[buf.length - 1 - i];
  }
  return buf2;
};

BN.Zero = new BN(0);
BN.One = new BN(1);
BN.Minus1 = new BN(-1);

BN.fromNumber = function(n) {
  $.checkArgument(_.isNumber(n));
  return new BN(n);
};

BN.fromString = function(str, base) {
  $.checkArgument(_.isString(str));
  return new BN(str, base);
};

BN.fromBuffer = function(buf, opts) {
  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }
  var hex = buf.toString('hex');
  var bn = new BN(hex, 16);
  return bn;
};

/**
 * Instantiate a BigNumber from a "signed magnitude buffer"
 * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))
 */
BN.fromSM = function(buf, opts) {
  var ret;
  if (buf.length === 0) {
    return BN.fromBuffer(Buffer.from([0]));
  }

  var endian = 'big';
  if (opts) {
    endian = opts.endian;
  }
  if (endian === 'little') {
    buf = reversebuf(buf);
  }

  if (buf[0] & 0x80) {
    buf[0] = buf[0] & 0x7f;
    ret = BN.fromBuffer(buf);
    ret.neg().copy(ret);
  } else {
    ret = BN.fromBuffer(buf);
  }
  return ret;
};


BN.prototype.toNumber = function() {
  return parseInt(this.toString(10), 10);
};

BN.prototype.toBuffer = function(opts) {
  var buf, hex;
  if (opts && opts.size) {
    hex = this.toString(16, 2);
    var natlen = hex.length / 2;
    buf = Buffer.from(hex, 'hex');

    if (natlen === opts.size) {
      buf = buf;
    } else if (natlen > opts.size) {
      buf = BN.trim(buf, natlen);
    } else if (natlen < opts.size) {
      buf = BN.pad(buf, natlen, opts.size);
    }
  } else {
    hex = this.toString(16, 2);
    buf = Buffer.from(hex, 'hex');
  }

  if (typeof opts !== 'undefined' && opts.endian === 'little') {
    buf = reversebuf(buf);
  }

  return buf;
};

BN.prototype.toSMBigEndian = function() {
  var buf;
  if (this.cmp(BN.Zero) === -1) {
    buf = this.neg().toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x80]), buf]);
    } else {
      buf[0] = buf[0] | 0x80;
    }
  } else {
    buf = this.toBuffer();
    if (buf[0] & 0x80) {
      buf = Buffer.concat([Buffer.from([0x00]), buf]);
    }
  }

  if (buf.length === 1 & buf[0] === 0) {
    buf = Buffer.from([]);
  }
  return buf;
};

BN.prototype.toSM = function(opts) {
  var endian = opts ? opts.endian : 'big';
  var buf = this.toSMBigEndian();

  if (endian === 'little') {
    buf = reversebuf(buf);
  }
  return buf;
};

/**
 * Create a BN from a "ScriptNum":
 * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in
 * bitcoind's script interpreter use CScriptNum, which is not really a proper
 * bignum. Instead, an error is thrown if trying to input a number bigger than
 * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to
 * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.
 */
BN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {
  var nMaxNumSize = size || 4;
  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));
  if (fRequireMinimal && buf.length > 0) {
    // Check that the number is encoded with the minimum possible
    // number of bytes.
    //
    // If the most-significant-byte - excluding the sign bit - is zero
    // then we're not minimal. Note how this test also rejects the
    // negative-zero encoding, 0x80.
    if ((buf[buf.length - 1] & 0x7f) === 0) {
      // One exception: if there's more than one byte and the most
      // significant bit of the second-most-significant-byte is set
      // it would conflict with the sign bit. An example of this case
      // is +-255, which encode to 0xff00 and 0xff80 respectively.
      // (big-endian).
      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
        throw new Error('non-minimally encoded script number');
      }
    }
  }
  return BN.fromSM(buf, {
    endian: 'little'
  });
};

/**
 * The corollary to the above, with the notable exception that we do not throw
 * an error if the output is larger than four bytes. (Which can happen if
 * performing a numerical operation that results in an overflow to more than 4
 * bytes).
 */
BN.prototype.toScriptNumBuffer = function() {
  return this.toSM({
    endian: 'little'
  });
};

BN.trim = function(buf, natlen) {
  return buf.slice(natlen - buf.length, buf.length);
};

BN.pad = function(buf, natlen, size) {
  var rbuf = Buffer.alloc(size);
  for (var i = 0; i < buf.length; i++) {
    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
  }
  for (i = 0; i < size - natlen; i++) {
    rbuf[i] = 0;
  }
  return rbuf;
};

module.exports = BN;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 76:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var crypto = __webpack_require__(52);
var BufferUtil = __webpack_require__(49);
var $ = __webpack_require__(36);

var Hash = module.exports;

Hash.sha1 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha1').update(buf).digest();
};

Hash.sha1.blocksize = 512;

Hash.sha256 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha256').update(buf).digest();
};

Hash.sha256.blocksize = 512;

Hash.sha256sha256 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return Hash.sha256(Hash.sha256(buf));
};

Hash.ripemd160 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('ripemd160').update(buf).digest();
};

Hash.sha256ripemd160 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return Hash.ripemd160(Hash.sha256(buf));
};

Hash.sha512 = function(buf) {
  $.checkArgument(BufferUtil.isBuffer(buf));
  return crypto.createHash('sha512').update(buf).digest();
};

Hash.sha512.blocksize = 1024;

Hash.hmac = function(hashf, data, key) {
  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
  //http://tools.ietf.org/html/rfc4868#section-2
  $.checkArgument(BufferUtil.isBuffer(data));
  $.checkArgument(BufferUtil.isBuffer(key));
  $.checkArgument(hashf.blocksize);

  var blocksize = hashf.blocksize / 8;

  if (key.length > blocksize) {
    key = hashf(key);
  } else if (key < blocksize) {
    var fill = Buffer.alloc(blocksize);
    fill.fill(0);
    key.copy(fill);
    key = fill;
  }

  var o_key = Buffer.alloc(blocksize);
  o_key.fill(0x5c);

  var i_key = Buffer.alloc(blocksize);
  i_key.fill(0x36);

  var o_key_pad = Buffer.alloc(blocksize);
  var i_key_pad = Buffer.alloc(blocksize);
  for (var i = 0; i < blocksize; i++) {
    o_key_pad[i] = o_key[i] ^ key[i];
    i_key_pad[i] = i_key[i] ^ key[i];
  }

  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));
};

Hash.sha256hmac = function(data, key) {
  return Hash.hmac(Hash.sha256, data, key);
};

Hash.sha512hmac = function(data, key) {
  return Hash.hmac(Hash.sha512, data, key);
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 78:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DateRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return RateProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);









const EXPIRATION_TIME_MS = 5 * 60 * 1000; // 5min
var DateRanges;
(function (DateRanges) {
    DateRanges[DateRanges["Day"] = 1] = "Day";
    DateRanges[DateRanges["Week"] = 7] = "Week";
    DateRanges[DateRanges["Month"] = 30] = "Month";
})(DateRanges || (DateRanges = {}));
let RateProvider = class RateProvider {
    constructor(currencyProvider, http, logger, configProvider) {
        this.currencyProvider = currencyProvider;
        this.http = http;
        this.logger = logger;
        this.configProvider = configProvider;
        this.rates = {};
        this.ratesAvailable = {};
        this.rateServiceUrl = {};
        this.logger.debug('RateProvider initialized');
        this.alternatives = {};
        for (const coin of this.currencyProvider.getAvailableCoins()) {
            this.rateServiceUrl[coin] = __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].ratesAPI[coin];
            this.rates[coin] = { ARS: 1 };
            if (coin == 'tik') {
                this.rates[coin] = { ARS: 0 };
            }
            this.ratesAvailable[coin] = false;
        }
        const defaults = this.configProvider.getDefaults();
        this.bwsURL = defaults.bws.url;
        this.ratesCache = {
            1: [],
            7: [],
            30: []
        };
        this.updateRates();
    }
    updateRates(chain) {
        return new Promise((resolve, reject) => {
            if (chain) {
                this.getCoin(chain)
                    .then(dataCoin => {
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](dataCoin, currency => {
                        if (currency && currency.code && currency.rate) {
                            this.rates[chain][currency.code] = currency.rate;
                        }
                    });
                    resolve();
                })
                    .catch(errorCoin => {
                    this.logger.error(errorCoin);
                    reject(errorCoin);
                });
            }
            else {
                this.getRates()
                    .then(res => {
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](res, (rates, coin) => {
                        const coinRates = {};
                        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](rates, r => {
                            if (r.code && r.rate) {
                                const rate = { [r.code]: r.rate };
                                Object.assign(coinRates, rate);
                            }
                            // set alternative currency list
                            if (r.code && r.name) {
                                this.alternatives[r.code] = { name: r.name };
                            }
                        });
                        // TODO FIX: Set DEFAULT COUNTRYCODE : 1
                        this.rates[coin] = !__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](coinRates) ? coinRates : { ARS: 1 };
                        if (coin == 'tik') {
                            this.rates[coin] = { ARS: 0 };
                        }
                        this.ratesAvailable[coin] = true;
                    });
                    resolve();
                })
                    .catch(err => {
                    this.logger.error(err);
                    reject(err);
                });
            }
        });
    }
    getRates() {
        return new Promise(resolve => {
            this.http.get(`${this.bwsURL}/v3/fiatrates/`).subscribe(res => {
                resolve(res);
            });
        });
    }
    getCoin(chain) {
        return new Promise(resolve => {
            this.http.get(this.rateServiceUrl[chain]).subscribe(data => {
                resolve(data);
            });
        });
    }
    getRate(code, chain, opts) {
        const customRate = opts && opts.rates && opts.rates[chain] && opts.rates[chain][code];
        if (customRate)
            return customRate;
        if (this.rates[chain][code])
            return this.rates[chain][code];
        if (!this.rates[chain][code] &&
            this.rates[chain]['USD'] &&
            this.rates['btc'][code] &&
            this.rates['btc']['USD'] &&
            this.rates['btc']['USD'] > 0) {
            const newRate = +((this.rates[chain]['USD'] * this.rates['btc'][code]) /
                this.rates['btc']['USD']).toFixed(2);
            return newRate;
        }
        this.logger.warn('There are no rates for chain: ' + chain + ' - code: ' + code);
        return undefined;
    }
    getAlternatives() {
        const alternatives = [];
        for (let key in this.alternatives) {
            alternatives.push({ isoCode: key, name: this.alternatives[key].name });
        }
        return alternatives;
    }
    isCoinAvailable(chain) {
        return this.ratesAvailable[chain];
    }
    isAltCurrencyAvailable(currency) {
        return this.alternatives[currency];
    }
    toFiat(satoshis, code, chain, opts) {
        if (!this.isCoinAvailable(chain)) {
            return null;
        }
        const customRate = opts && opts.customRate;
        const rate = customRate || this.getRate(code, chain, opts);
        return (satoshis *
            (1 / this.currencyProvider.getPrecision(chain).unitToSatoshi) *
            rate);
    }
    fromFiat(amount, code, chain, opts) {
        if (!this.isCoinAvailable(chain)) {
            return null;
        }
        return ((amount / this.getRate(code, chain, opts)) *
            this.currencyProvider.getPrecision(chain).unitToSatoshi);
    }
    listAlternatives(sort) {
        const alternatives = this.getAlternatives();
        if (sort) {
            alternatives.sort((a, b) => {
                return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
            });
        }
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["uniqBy"](alternatives, 'isoCode');
    }
    whenRatesAvailable(chain) {
        return new Promise(resolve => {
            if (this.ratesAvailable[chain])
                resolve();
            else {
                if (chain) {
                    this.updateRates(chain).then(() => {
                        resolve();
                    });
                }
            }
        });
    }
    getHistoricFiatRate(currency, coin, ts) {
        return new Promise(resolve => {
            const url = `${this.bwsURL}/v1/fiatrates/${currency}?coin=${coin}&ts=${ts}`;
            this.http.get(url).subscribe(data => {
                resolve(data);
            });
        });
    }
    getLastDayRates() {
        const fiatIsoCode = this.configProvider.get().wallet.settings.alternativeIsoCode || 'USD';
        return this.fetchHistoricalRates(fiatIsoCode, DateRanges.Day).then(x => {
            let ret = {};
            __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](x, (v, k) => {
                ret[k] = __WEBPACK_IMPORTED_MODULE_3_lodash__["last"](v).rate;
            });
            return ret;
        });
    }
    fetchHistoricalRates(fiatIsoCode, dateRange = DateRanges.Day) {
        const firstDateTs = __WEBPACK_IMPORTED_MODULE_4_moment__().subtract(dateRange, 'days').startOf('hour').unix() * 1000;
        const now = Date.now();
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.ratesCache[dateRange].data) ||
            this.ratesCache[dateRange].expiration < now) {
            this.logger.debug(`Refreshing Exchange rates for ${fiatIsoCode} period ${dateRange}`);
            // This pulls ALL coins in one query
            // TODO FIX: REVISAR FIAT RATES para ARS
            const req = this.http.get(`${this.bwsURL}/v2/fiatrates/${fiatIsoCode}?ts=${firstDateTs}`);
            this.ratesCache[dateRange].data = req.first().toPromise();
            this.ratesCache[dateRange].expiration = now + EXPIRATION_TIME_MS;
        }
        return this.ratesCache[dateRange].data;
    }
};
RateProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */]])
], RateProvider);

//# sourceMappingURL=rate.js.map

/***/ }),

/***/ 79:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomeIntegrationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);





const exchangeList = [
    { name: 'coinbase' },
    { name: 'walletConnect' }
];
let HomeIntegrationsProvider = class HomeIntegrationsProvider {
    constructor(http, logger) {
        this.http = http;
        this.logger = logger;
        this.logger.debug('HomeIntegrationsProviders initialized');
        this.services = [];
    }
    register(serviceInfo) {
        // Check if already exists
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.services, { name: serviceInfo.name }))
            return;
        this.logger.info('Adding home Integrations entry:' + serviceInfo.name);
        this.services.push(serviceInfo);
    }
    unregister(serviceName) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            return x.name != serviceName;
        });
    }
    updateLink(serviceName, token) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.linked = !!token;
            return x;
        });
    }
    updateConfig(serviceName, show) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.show = !!show;
            return x;
        });
    }
    shouldShowInHome(serviceName) {
        const service = this.services.find(i => i.name === serviceName);
        if (service && service.name === 'debitcard') {
            return service && service.show && !service.linked;
        }
        else
            return service && service.show;
    }
    get() {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["orderBy"](this.services, ['name'], ['asc']);
    }
    getAvailableExchange() {
        let exchangeServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["intersectionBy"](this.services, exchangeList, 'name');
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](exchangeServices, { linked: true, show: true });
    }
};
HomeIntegrationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], HomeIntegrationsProvider);

//# sourceMappingURL=home-integrations.js.map

/***/ }),

/***/ 797:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChooseFeeLevelComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__action_sheet_action_sheet_parent__ = __webpack_require__(107);











let ChooseFeeLevelComponent = class ChooseFeeLevelComponent extends __WEBPACK_IMPORTED_MODULE_10__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(currencyProvider, logger, popupProvider, feeProvider, translate, externalLinkProvider) {
        super();
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.feeProvider = feeProvider;
        this.translate = translate;
        this.externalLinkProvider = externalLinkProvider;
        this.FEE_MULTIPLIER = 10;
        this.FEE_MIN = 0;
        this.feeOpts = [];
    }
    ngOnInit() {
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        // From parent controller
        this.network = this.params.network;
        this.coin = this.params.coin;
        this.feeLevel = this.params.feeLevel;
        this.setFeeUnits();
        // IF usingCustomFee
        this.customFeePerKB = this.params.customFeePerKB
            ? this.params.customFeePerKB
            : null;
        this.feePerSatByte = this.params.feePerSatByte
            ? this.params.feePerSatByte
            : null;
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.feeLevel))
            this.showErrorAndClose(null, this.translate.instant('Fee level is not defined'));
        this.loadingFee = true;
        this.feeProvider
            .getFeeLevels(this.coin, this.network)
            .then(response => {
            this.loadingFee = false;
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](response)) {
                this.showErrorAndClose(null, this.translate.instant('Could not get fee levels'));
                return;
            }
            this.feeLevels = response.levels;
            this.setFeeRates();
            if (this.customFeePerKB)
                this._setCustomFee();
        })
            .catch(err => {
            this.loadingFee = false;
            this.showErrorAndClose(null, err);
            return;
        });
    }
    setFeeUnits() {
        const { feeUnit, feeUnitAmount, blockTime } = this.currencyProvider.getFeeUnits(this.coin);
        this.feeUnit = feeUnit;
        this.feeUnitAmount = feeUnitAmount;
        this.blockTime = blockTime;
    }
    setFeeRates() {
        this.feeLevels.forEach((feeLevel, i) => {
            this.feeOpts[i] = feeLevel;
            this.feeOpts[i].feePerSatByte = (feeLevel.feePerKb / this.feeUnitAmount).toFixed();
            let avgConfirmationTime = feeLevel.nbBlocks * this.blockTime;
            this.feeOpts[i].avgConfirmationTime = avgConfirmationTime;
            if (feeLevel.level == this.feeLevel)
                this.feePerSatByte = (this.feeOpts[i].feePerKb / this.feeUnitAmount).toFixed();
        });
        setTimeout(() => {
            const index = this.feeOpts
                .map(feeOpt => feeOpt.level)
                .indexOf(this.feeLevel);
            index == -1
                ? this.feeSlides.slideTo(this.feeSlides.length(), 200)
                : this.feeSlides.slideTo(index, 200);
        }, 300);
        // Warnings
        this.setFeesRecommended();
        this.checkFees(this.feePerSatByte);
    }
    _setCustomFee() {
        this.avgConfirmationTime = null;
        this.customSatPerByte = Number(this.customFeePerKB) / this.feeUnitAmount;
    }
    setCustomFee() {
        this.changeSelectedFee('custom');
    }
    showErrorAndClose(title, msg) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.dismiss();
        });
    }
    setFeesRecommended() {
        this.maxFeeRecommended = this.getMaxRecommended();
        this.minFeeRecommended = this.getMinRecommended();
        this.minFeeAllowed = this.FEE_MIN;
        this.maxFeeAllowed = this.maxFeeRecommended * this.FEE_MULTIPLIER;
        this.maxFee =
            this.maxFeeRecommended > this.maxFeeAllowed
                ? this.maxFeeRecommended
                : this.maxFeeAllowed;
        this.minFee =
            this.minFeeRecommended < this.minFeeAllowed
                ? this.minFeeRecommended
                : this.minFeeAllowed;
    }
    getMinRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.feeLevels, feeLevel => {
            return feeLevel.level == 'superEconomy';
        });
        return parseInt((value.feePerKb / this.feeUnitAmount).toFixed(), 10);
    }
    getMaxRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.feeLevels, feeLevel => {
            return feeLevel.level == 'urgent';
        });
        return parseInt((value.feePerKb / this.feeUnitAmount).toFixed(), 10);
    }
    checkFees(feePerSatByte) {
        let fee = Number(feePerSatByte);
        this.showError = fee <= this.minFeeAllowed ? true : false;
        this.showMinWarning =
            fee > this.minFeeAllowed && fee < this.minFeeRecommended ? true : false;
        this.showMaxWarning =
            fee < this.maxFeeAllowed && fee > this.maxFeeRecommended ? true : false;
    }
    changeSelectedFee(feeLevel) {
        this.logger.debug('New fee level: ' + feeLevel);
        this.feeLevel = feeLevel;
        this.customFeePerKB = this.customSatPerByte
            ? (this.customSatPerByte * this.feeUnitAmount).toFixed()
            : null;
        this.dismiss({
            newFeeLevel: this.feeLevel,
            customFeePerKB: this.customFeePerKB,
            showMinWarning: this.showMinWarning
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('feeSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Slides */])
], ChooseFeeLevelComponent.prototype, "feeSlides", void 0);
ChooseFeeLevelComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-choose-fee-level',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/choose-fee-level/choose-fee-level.html"*/'<action-sheet>\n  <ion-row class="addr-header" align-items-center>\n    <ion-col col-10 text-left>\n      <span class="addr-title" translate>\n        Transaction speed\n      </span>\n    </ion-col>\n    <ion-col col-2 text-right>\n      <button ion-button clear icon-only color="primary" (click)="openExternalLink(\'https://support.tkcoin.org/hc/en-us/articles/115003393863-What-are-bitcoin-miner-fees-Why-are-miner-fees-so-high-\')">\n        <ion-icon name="md-help-circle"></ion-icon>\n      </button>\n    </ion-col>\n  </ion-row>\n  <div class="testnet-warning" *ngIf="network!=\'livenet\'">\n    Testnet\n  </div>\n  <div class="fee-container">\n    <ion-slides #feeSlides slidesPerView="2" slidesPerView="2" spaceBetween="20" centeredSlides="true" pager="false" radio-group [(ngModel)]="feeLevel">\n      <ion-slide *ngFor="let fee of feeOpts" class="fee-card" (click)="changeSelectedFee(fee.level)">\n        <ion-grid no-padding>\n          <ion-row class="fee-row">\n            <ion-col col-10>\n              <div class="fee-speed-name">{{ feeProvider.getFeeOpts()[fee.level] | translate }}</div>\n              <div class="fee-speed-satByte">{{fee.feePerSatByte}} {{ feeUnit }}</div>\n            </ion-col>\n            <ion-col text-right col-2>\n              <ion-icon *ngIf="fee.level === feeLevel" name="ios-checkmark-circle" class="fee-check success" item-right></ion-icon>\n            </ion-col>\n          </ion-row>\n          <ion-row padding-top margin-top>\n            <ion-col col-12 item-start>\n              <div class="fee-avg-label" translate>Average confirmation time:</div>\n              <div class="fee-avg-time">\n                <span *ngIf="loadingFee">...</span>\n                <span *ngIf="fee.avgConfirmationTime">\n                  {{ fee.avgConfirmationTime | amDuration: \'minute\' }}\n                </span>\n              </div>\n            </ion-col>\n          </ion-row>\n        </ion-grid>\n      </ion-slide>\n      <ion-slide class="fee-card">\n        <ion-grid no-padding>\n          <ion-row>\n            <ion-col>\n              <div class="fee-speed-name">{{ \'Custom fee\' | translate }}</div>\n            </ion-col>\n            <ion-col text-right col-2>\n              <ion-icon *ngIf="\'custom\' === feeLevel" name="ios-checkmark-circle" class="fee-check success" item-right></ion-icon>\n            </ion-col>\n          </ion-row>\n          <ion-item no-margin no-padding>\n            <ion-label padding-bottom stacked>{{\'Enter custom fee in {feeUnit}\' | translate: { feeUnit: feeUnit } }}:</ion-label>\n            <ion-input type="number" min="minFee" max="maxFee" (ionChange)="checkFees(customSatPerByte)" [(ngModel)]="customSatPerByte" required></ion-input>\n          </ion-item>\n          <div class="fee-error" *ngIf="showError">\n            <span translate>Transactions without fee are not supported.</span>\n          </div>\n          <div class="fee-error" *ngIf="showMinWarning || showMaxWarning" text-wrap>\n            <span *ngIf="showMinWarning" translate>Your fee is lower than recommended.</span>\n            <span *ngIf="showMaxWarning" translate>You should not set a fee higher than {{maxFeeRecommended}} {{feeUnit}}.</span>\n          </div>\n          <button class="apply-button" ion-button clear color="primary" (click)="setCustomFee()" [disabled]="!customSatPerByte || customSatPerByte >= maxFeeAllowed || showError">\n            {{\'Apply changes\' | translate}}\n          </button>\n        </ion-grid>\n      </ion-slide>\n    </ion-slides>\n  </div>\n  <div class="line-divider"></div>\n  <div class="close-btn" text-center>\n    <button ion-button clear icon-only color="dark" (click)="dismiss()">\n      {{\'CLOSE\' | translate }}\n    </button>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/choose-fee-level/choose-fee-level.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], ChooseFeeLevelComponent);

//# sourceMappingURL=choose-fee-level.js.map

/***/ }),

/***/ 85:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxFormatProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter_filter__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);









let TxFormatProvider = class TxFormatProvider {
    constructor(bwcProvider, rate, configProvider, currencyProvider, filter, logger) {
        this.bwcProvider = bwcProvider;
        this.rate = rate;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.filter = filter;
        this.logger = logger;
        this.logger.debug('TxFormatProvider initialized');
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
    }
    toCashAddress(address, withPrefix) {
        return this.bitcoreCash.Address(address).toString(!withPrefix);
    }
    toLegacyAddress(address) {
        let legacyAddr = this.bitcoreCash
            .Address(address)
            .toLegacyAddress();
        return legacyAddr;
    }
    // TODO: Check return of formatAmount(...), sometimes returns a number and sometimes a string
    formatAmount(coin, satoshis, fullPrecision) {
        if (coin == 'sat')
            return satoshis;
        // TODO : now only works for english, specify opts to change thousand separator and decimal separator
        var opts = {
            fullPrecision: !!fullPrecision
        };
        return this.bwcProvider.getUtils().formatAmount(satoshis, coin, opts);
    }
    formatAmountStr(coin, satoshis, fullPrecision) {
        if (isNaN(satoshis))
            return undefined;
        return (this.formatAmount(coin, satoshis, fullPrecision) +
            ' ' +
            coin.toUpperCase());
    }
    toFiat(coin, satoshis, code, opts) {
        // TODO not a promise
        return new Promise(resolve => {
            if (isNaN(satoshis))
                return resolve();
            var v1;
            v1 = this.rate.toFiat(satoshis, code, coin, opts);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatToUSD(coin, satoshis) {
        // TODO not a promise
        return new Promise(resolve => {
            let v1;
            if (isNaN(satoshis))
                return resolve();
            v1 = this.rate.toFiat(satoshis, 'USD', coin);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatAlternativeStr(coin, satoshis) {
        if (isNaN(satoshis))
            return undefined;
        let settings = this.configProvider.get().wallet.settings;
        let val = (() => {
            var v1 = parseFloat(this.rate.toFiat(satoshis, settings.alternativeIsoCode, coin).toFixed(2));
            v1 = this.filter.formatFiatAmount(v1);
            if (!v1)
                return null;
            return v1 + ' ' + settings.alternativeIsoCode;
        }).bind(this);
        if (!this.rate.isCoinAvailable(coin))
            return null;
        return val();
    }
    processTx(coin, tx) {
        if (!tx || tx.action == 'invalid')
            return tx;
        // New transaction output format. Fill tx.amount and tx.toAmount for
        // backward compatibility.
        if (tx.outputs && tx.outputs.length) {
            var outputsNr = tx.outputs.length;
            if (tx.action != 'received') {
                if (outputsNr > 1) {
                    tx.recipientCount = outputsNr;
                    tx.hasMultiplesOutputs = true;
                }
                tx.amount = __WEBPACK_IMPORTED_MODULE_8_lodash__["reduce"](tx.outputs, (total, o) => {
                    o.amountStr = this.formatAmountStr(coin, o.amount);
                    o.alternativeAmountStr = this.formatAlternativeStr(coin, o.amount);
                    return total + o.amount;
                }, 0);
            }
            tx.toAddress = tx.outputs[0].toAddress;
            // toDo: translate all tx.outputs[x].toAddress ?
            if (tx.toAddress && coin == 'bch') {
                tx.toAddress = this.toCashAddress(tx.toAddress);
            }
        }
        // Old tx format. Fill .output, for forward compatibility
        if (!tx.outputs) {
            tx.outputs = [
                {
                    address: tx.toAddress,
                    amount: tx.amount
                }
            ];
        }
        tx.amountStr = this.formatAmountStr(coin, tx.amount);
        tx.alternativeAmountStr = this.formatAlternativeStr(coin, tx.amount);
        const chain = this.currencyProvider.getChain(coin).toLowerCase();
        tx.feeStr = tx.fee
            ? this.formatAmountStr(chain, tx.fee)
            : tx.fees
                ? this.formatAmountStr(chain, tx.fees)
                : 'N/A';
        if (tx.amountStr) {
            tx.amountValueStr = tx.amountStr.split(' ')[0];
            tx.amountUnitStr = tx.amountStr.split(' ')[1];
        }
        if (tx.size && (tx.fee || tx.fees) && tx.amountUnitStr)
            tx.feeRate = `${((tx.fee || tx.fees) / tx.size).toFixed(0)} sat/byte`;
        if (tx.addressTo && coin == 'bch') {
            tx.addressTo = this.toCashAddress(tx.addressTo);
        }
        return tx;
    }
    parseAmount(coin, amount, currency, opts) {
        const { alternativeIsoCode } = this.configProvider.get().wallet.settings;
        const { unitToSatoshi, unitDecimals } = this.currencyProvider.getPrecision(coin);
        const satToUnit = 1 / unitToSatoshi;
        let amountUnitStr;
        let amountSat;
        // If fiat currency
        if (!__WEBPACK_IMPORTED_MODULE_5__currency_currency__["a" /* Coin */][currency] && currency != 'sat') {
            let formattedAmount = opts && opts.onlyIntegers
                ? this.filter.formatFiatAmount(amount.toFixed(0))
                : this.filter.formatFiatAmount(amount);
            amountUnitStr = formattedAmount + ' ' + currency;
            amountSat = Number(this.rate.fromFiat(amount, currency, coin, opts).toFixed(0));
        }
        else if (currency == 'sat') {
            amountSat = Number(amount);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert sat to Coin
            amount = (amountSat * satToUnit).toFixed(unitDecimals);
            currency = coin.toUpperCase();
        }
        else {
            amountSat = parseInt((amount * unitToSatoshi).toFixed(0), 10);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert unit to Coin
            amount = (amountSat * satToUnit).toFixed(unitDecimals);
            currency = coin.toUpperCase();
        }
        return {
            amount,
            currency,
            alternativeIsoCode,
            amountSat,
            amountUnitStr
        };
    }
    satToUnit(amount, coin) {
        let { unitToSatoshi, unitDecimals } = this.currencyProvider.getPrecision(coin);
        let satToUnit = 1 / unitToSatoshi;
        return parseFloat((amount * satToUnit).toFixed(unitDecimals));
    }
};
TxFormatProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], TxFormatProvider);

//# sourceMappingURL=tx-format.js.map

/***/ }),

/***/ 858:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var Address = __webpack_require__(140);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var Hash = __webpack_require__(74);
var Opcode = __webpack_require__(460);
var PublicKey = __webpack_require__(139);
var Signature = __webpack_require__(103);
var Networks = __webpack_require__(199);
var $ = __webpack_require__(35);
var _ = __webpack_require__(1);
var errors = __webpack_require__(115);
var buffer = __webpack_require__(2);
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);

/**
 * A bitcoin transaction script. Each transaction's inputs and outputs
 * has a script that is evaluated to validate it's spending.
 *
 * See https://en.bitcoin.it/wiki/Script
 *
 * @constructor
 * @param {Object|string|Buffer=} from optional data to populate script
 */
var Script = function Script(from) {
  if (!(this instanceof Script)) {
    return new Script(from);
  }
  this.chunks = [];

  if (BufferUtil.isBuffer(from)) {
    return Script.fromBuffer(from);
  } else if (from instanceof Address) {
    return Script.fromAddress(from);
  } else if (from instanceof Script) {
    return Script.fromBuffer(from.toBuffer());
  } else if (_.isString(from)) {
    return Script.fromString(from);
  } else if (_.isObject(from) && _.isArray(from.chunks)) {
    this.set(from);
  }
};

Script.prototype.set = function(obj) {
  $.checkArgument(_.isObject(obj));
  $.checkArgument(_.isArray(obj.chunks));
  this.chunks = obj.chunks;
  return this;
};

Script.fromBuffer = function(buffer) {
  var script = new Script();
  script.chunks = [];

  var br = new BufferReader(buffer);
  while (!br.finished()) {
    try {
      var opcodenum = br.readUInt8();

      var len, buf;
      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
        len = opcodenum;
        script.chunks.push({
          buf: br.read(len),
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
        len = br.readUInt8();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
        len = br.readUInt16LE();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
        len = br.readUInt32LE();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else {
        script.chunks.push({
          opcodenum: opcodenum
        });
      }
    } catch (e) {
      if (e instanceof RangeError) {
        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));
      }
      throw e;
    }
  }

  return script;
};

Script.prototype.toBuffer = function() {
  var bw = new BufferWriter();

  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    var opcodenum = chunk.opcodenum;
    bw.writeUInt8(chunk.opcodenum);
    if (chunk.buf) {
      if (opcodenum < Opcode.OP_PUSHDATA1) {
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
        bw.writeUInt8(chunk.len);
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
        bw.writeUInt16LE(chunk.len);
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
        bw.writeUInt32LE(chunk.len);
        bw.write(chunk.buf);
      }
    }
  }

  return bw.concat();
};

Script.fromASM = function(str) {
  var script = new Script();
  script.chunks = [];

  var tokens = str.split(' ');
  var i = 0;
  while (i < tokens.length) {
    var token = tokens[i];
    var opcode = Opcode(token);
    var opcodenum = opcode.toNumber();

    if (_.isUndefined(opcodenum)) {
      var buf = Buffer.from(tokens[i], 'hex');
      script.chunks.push({
        buf: buf,
        len: buf.length,
        opcodenum: buf.length
      });
      i = i + 1;
    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      script.chunks.push({
        buf: Buffer.from(tokens[i + 2], 'hex'),
        len: parseInt(tokens[i + 1]),
        opcodenum: opcodenum
      });
      i = i + 3;
    } else {
      script.chunks.push({
        opcodenum: opcodenum
      });
      i = i + 1;
    }
  }
  return script;
};

Script.fromHex = function(str) {
  return new Script(Buffer.from(str, 'hex'));
};

Script.fromString = function(str) {
  if (JSUtil.isHexa(str) || str.length === 0) {
    return new Script(Buffer.from(str, 'hex'));
  }
  var script = new Script();
  script.chunks = [];

  var tokens = str.split(' ');
  var i = 0;
  while (i < tokens.length) {
    var token = tokens[i];
    var opcode = Opcode(token);
    var opcodenum = opcode.toNumber();

    if (_.isUndefined(opcodenum)) {
      opcodenum = parseInt(token);
      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
        script.chunks.push({
          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),
          len: opcodenum,
          opcodenum: opcodenum
        });
        i = i + 2;
      } else {
        throw new Error('Invalid script: ' + JSON.stringify(str));
      }
    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      if (tokens[i + 2].slice(0, 2) !== '0x') {
        throw new Error('Pushdata data must start with 0x');
      }
      script.chunks.push({
        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),
        len: parseInt(tokens[i + 1]),
        opcodenum: opcodenum
      });
      i = i + 3;
    } else {
      script.chunks.push({
        opcodenum: opcodenum
      });
      i = i + 1;
    }
  }
  return script;
};

Script.prototype._chunkToString = function(chunk, type) {
  var opcodenum = chunk.opcodenum;
  var asm = (type === 'asm');
  var str = '';
  if (!chunk.buf) {
    // no data chunk
    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {
      if (asm) {
        // A few cases where the opcode name differs from reverseMap
        // aside from 1 to 16 data pushes.
        if (opcodenum === 0) {
          // OP_0 -> 0
          str = str + ' 0';
        } else if(opcodenum === 79) {
          // OP_1NEGATE -> 1
          str = str + ' -1';
        } else {
          str = str + ' ' + Opcode(opcodenum).toString();
        }
      } else {
        str = str + ' ' + Opcode(opcodenum).toString();
      }
    } else {
      var numstr = opcodenum.toString(16);
      if (numstr.length % 2 !== 0) {
        numstr = '0' + numstr;
      }
      if (asm) {
        str = str + ' ' + numstr;
      } else {
        str = str + ' ' + '0x' + numstr;
      }
    }
  } else {
    // data chunk
    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      str = str + ' ' + Opcode(opcodenum).toString();
    }
    if (chunk.len > 0) {
      if (asm) {
        str = str + ' ' + chunk.buf.toString('hex');
      } else {
        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');
      }
    }
  }
  return str;
};

Script.prototype.toASM = function() {
  var str = '';
  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    str += this._chunkToString(chunk, 'asm');
  }

  return str.substr(1);
};

Script.prototype.toString = function() {
  var str = '';
  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    str += this._chunkToString(chunk);
  }

  return str.substr(1);
};

Script.prototype.toHex = function() {
  return this.toBuffer().toString('hex');
};

Script.prototype.inspect = function() {
  return '<Script: ' + this.toString() + '>';
};

// script classification methods

/**
 * @returns {boolean} if this is a pay to pubkey hash output script
 */
Script.prototype.isPublicKeyHashOut = function() {
  return !!(this.chunks.length === 5 &&
    this.chunks[0].opcodenum === Opcode.OP_DUP &&
    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&
    this.chunks[2].buf &&
    this.chunks[2].buf.length === 20 &&
    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&
    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);
};

/**
 * @returns {boolean} if this is a pay to public key hash input script
 */
Script.prototype.isPublicKeyHashIn = function() {
  if (this.chunks.length === 2) {
    var signatureBuf = this.chunks[0].buf;
    var pubkeyBuf = this.chunks[1].buf;
    if (signatureBuf &&
        signatureBuf.length &&
        signatureBuf[0] === 0x30 &&
        pubkeyBuf &&
        pubkeyBuf.length
       ) {
      var version = pubkeyBuf[0];
      if ((version === 0x04 ||
           version === 0x06 ||
           version === 0x07) && pubkeyBuf.length === 65) {
        return true;
      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
        return true;
      }
    }
  }
  return false;
};

Script.prototype.getPublicKey = function() {
  $.checkState(this.isPublicKeyOut(), 'Can\'t retrieve PublicKey from a non-PK output');
  return this.chunks[0].buf;
};

Script.prototype.getPublicKeyHash = function() {
  if (this.isPublicKeyHashOut()) {
    return this.chunks[2].buf;
  } else if (this.isWitnessPublicKeyHashOut()) {
    return this.chunks[1].buf;
  } else {
    throw new Error('Can\'t retrieve PublicKeyHash from a non-PKH output');
  }
};

/**
 * @returns {boolean} if this is a public key output script
 */
Script.prototype.isPublicKeyOut = function() {
  if (this.chunks.length === 2 &&
      this.chunks[0].buf &&
      this.chunks[0].buf.length &&
      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {
    var pubkeyBuf = this.chunks[0].buf;
    var version = pubkeyBuf[0];
    var isVersion = false;
    if ((version === 0x04 ||
         version === 0x06 ||
         version === 0x07) && pubkeyBuf.length === 65) {
      isVersion = true;
    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
      isVersion = true;
    }
    if (isVersion) {
      return PublicKey.isValid(pubkeyBuf);
    }
  }
  return false;
};

/**
 * @returns {boolean} if this is a pay to public key input script
 */
Script.prototype.isPublicKeyIn = function() {
  if (this.chunks.length === 1) {
    var signatureBuf = this.chunks[0].buf;
    if (signatureBuf &&
        signatureBuf.length &&
        signatureBuf[0] === 0x30) {
      return true;
    }
  }
  return false;
};

/**
 * @returns {boolean} if this is a p2sh output script
 */
Script.prototype.isScriptHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 23 &&
    buf[0] === Opcode.OP_HASH160 &&
    buf[1] === 0x14 &&
    buf[buf.length - 1] === Opcode.OP_EQUAL);
};

/**
 * @returns {boolean} if this is a p2wsh output script
 */
Script.prototype.isWitnessScriptHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 34 && buf[0] === 0 && buf[1] === 32);
};

/**
 * @returns {boolean} if this is a p2wpkh output script
 */
Script.prototype.isWitnessPublicKeyHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 22 && buf[0] === 0 && buf[1] === 20);
};

/**
 * @param {Object=} values - The return values
 * @param {Number} values.version - Set with the witness version
 * @param {Buffer} values.program - Set with the witness program
 * @returns {boolean} if this is a p2wpkh output script
 */
Script.prototype.isWitnessProgram = function(values) {
  if (!values) {
    values = {};
  }
  var buf = this.toBuffer();
  if (buf.length < 4 || buf.length > 42) {
    return false;
  }
  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {
    return false;
  }

  if (buf.length === buf[1] + 2) {
    values.version = buf[0];
    values.program = buf.slice(2, buf.length);
    return true;
  }

  return false;
};

/**
 * @returns {boolean} if this is a p2sh input script
 * Note that these are frequently indistinguishable from pubkeyhashin
 */
Script.prototype.isScriptHashIn = function() {
  if (this.chunks.length <= 1) {
    return false;
  }
  var redeemChunk = this.chunks[this.chunks.length - 1];
  var redeemBuf = redeemChunk.buf;
  if (!redeemBuf) {
    return false;
  }

  var redeemScript;
  try {
    redeemScript = Script.fromBuffer(redeemBuf);
  } catch (e) {
    if (e instanceof errors.Script.InvalidBuffer) {
      return false;
    }
    throw e;
  }
  var type = redeemScript.classify();
  return type !== Script.types.UNKNOWN;
};

/**
 * @returns {boolean} if this is a mutlsig output script
 */
Script.prototype.isMultisigOut = function() {
  return (this.chunks.length > 3 &&
    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&
    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
      return obj.buf && BufferUtil.isBuffer(obj.buf);
    }) &&
    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&
    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);
};


/**
 * @returns {boolean} if this is a multisig input script
 */
Script.prototype.isMultisigIn = function() {
  return this.chunks.length >= 2 &&
    this.chunks[0].opcodenum === 0 &&
    this.chunks.slice(1, this.chunks.length).every(function(obj) {
      return obj.buf &&
        BufferUtil.isBuffer(obj.buf) &&
        Signature.isTxDER(obj.buf);
    });
};

/**
 * @returns {boolean} true if this is a valid standard OP_RETURN output
 */
Script.prototype.isDataOut = function() {
  return this.chunks.length >= 1 &&
    this.chunks[0].opcodenum === Opcode.OP_RETURN &&
    (this.chunks.length === 1 ||
      (this.chunks.length === 2 &&
        this.chunks[1].buf &&
        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&
        this.chunks[1].length === this.chunks.len));
};

/**
 * Retrieve the associated data for this script.
 * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.
 * In the case of a standard OP_RETURN, return the data
 * @returns {Buffer}
 */
Script.prototype.getData = function() {
  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut()) {
    if (_.isUndefined(this.chunks[1])) {
      return Buffer.alloc(0);
    } else {
      return Buffer.from(this.chunks[1].buf);
    }
  }
  if (this.isPublicKeyHashOut()) {
    return Buffer.from(this.chunks[2].buf);
  }
  throw new Error('Unrecognized script type to get data from');
};

/**
 * @returns {boolean} if the script is only composed of data pushing
 * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)
 */
Script.prototype.isPushOnly = function() {
  return _.every(this.chunks, function(chunk) {
    return chunk.opcodenum <= Opcode.OP_16;
  });
};


Script.types = {};
Script.types.UNKNOWN = 'Unknown';
Script.types.PUBKEY_OUT = 'Pay to public key';
Script.types.PUBKEY_IN = 'Spend from public key';
Script.types.PUBKEYHASH_OUT = 'Pay to public key hash';
Script.types.PUBKEYHASH_IN = 'Spend from public key hash';
Script.types.SCRIPTHASH_OUT = 'Pay to script hash';
Script.types.SCRIPTHASH_IN = 'Spend from script hash';
Script.types.MULTISIG_OUT = 'Pay to multisig';
Script.types.MULTISIG_IN = 'Spend from multisig';
Script.types.DATA_OUT = 'Data push';

Script.OP_RETURN_STANDARD_SIZE = 80;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classify = function() {
  if (this._isInput) {
    return this.classifyInput();
  } else if (this._isOutput) {
    return this.classifyOutput();
  } else {
    var outputType = this.classifyOutput();
    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();
  }
};

Script.outputIdentifiers = {};
Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classifyOutput = function() {
  for (var type in Script.outputIdentifiers) {
    if (Script.outputIdentifiers[type].bind(this)()) {
      return Script.types[type];
    }
  }
  return Script.types.UNKNOWN;
};

Script.inputIdentifiers = {};
Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classifyInput = function() {
  for (var type in Script.inputIdentifiers) {
    if (Script.inputIdentifiers[type].bind(this)()) {
      return Script.types[type];
    }
  }
  return Script.types.UNKNOWN;
};


/**
 * @returns {boolean} if script is one of the known types
 */
Script.prototype.isStandard = function() {
  // TODO: Add BIP62 compliance
  return this.classify() !== Script.types.UNKNOWN;
};


// Script construction methods

/**
 * Adds a script element at the start of the script.
 * @param {*} obj a string, number, Opcode, Buffer, or object to add
 * @returns {Script} this script instance
 */
Script.prototype.prepend = function(obj) {
  this._addByType(obj, true);
  return this;
};

/**
 * Compares a script with another script
 */
Script.prototype.equals = function(script) {
  $.checkState(script instanceof Script, 'Must provide another script');
  if (this.chunks.length !== script.chunks.length) {
    return false;
  }
  var i;
  for (i = 0; i < this.chunks.length; i++) {
    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {
      return false;
    }
    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {
      return false;
    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {
      return false;
    }
  }
  return true;
};

/**
 * Adds a script element to the end of the script.
 *
 * @param {*} obj a string, number, Opcode, Buffer, or object to add
 * @returns {Script} this script instance
 *
 */
Script.prototype.add = function(obj) {
  this._addByType(obj, false);
  return this;
};

Script.prototype._addByType = function(obj, prepend) {
  if (typeof obj === 'string') {
    this._addOpcode(obj, prepend);
  } else if (typeof obj === 'number') {
    this._addOpcode(obj, prepend);
  } else if (obj instanceof Opcode) {
    this._addOpcode(obj, prepend);
  } else if (BufferUtil.isBuffer(obj)) {
    this._addBuffer(obj, prepend);
  } else if (obj instanceof Script) {
    this.chunks = this.chunks.concat(obj.chunks);
  } else if (typeof obj === 'object') {
    this._insertAtPosition(obj, prepend);
  } else {
    throw new Error('Invalid script chunk');
  }
};

Script.prototype._insertAtPosition = function(op, prepend) {
  if (prepend) {
    this.chunks.unshift(op);
  } else {
    this.chunks.push(op);
  }
};

Script.prototype._addOpcode = function(opcode, prepend) {
  var op;
  if (typeof opcode === 'number') {
    op = opcode;
  } else if (opcode instanceof Opcode) {
    op = opcode.toNumber();
  } else {
    op = Opcode(opcode).toNumber();
  }
  this._insertAtPosition({
    opcodenum: op
  }, prepend);
  return this;
};

Script.prototype._addBuffer = function(buf, prepend) {
  var opcodenum;
  var len = buf.length;
  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
    opcodenum = len;
  } else if (len < Math.pow(2, 8)) {
    opcodenum = Opcode.OP_PUSHDATA1;
  } else if (len < Math.pow(2, 16)) {
    opcodenum = Opcode.OP_PUSHDATA2;
  } else if (len < Math.pow(2, 32)) {
    opcodenum = Opcode.OP_PUSHDATA4;
  } else {
    throw new Error('You can\'t push that much data');
  }
  this._insertAtPosition({
    buf: buf,
    len: len,
    opcodenum: opcodenum
  }, prepend);
  return this;
};

Script.prototype.hasCodeseparators = function() {
  for (var i = 0; i < this.chunks.length; i++) {
    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {
      return true;
    }
  }
  return false;
};

Script.prototype.removeCodeseparators = function() {
  var chunks = [];
  for (var i = 0; i < this.chunks.length; i++) {
    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
      chunks.push(this.chunks[i]);
    }
  }
  this.chunks = chunks;
  return this;
};

// high level script builder methods

/**
 * @returns {Script} a new Multisig output script for given public keys,
 * requiring m of those public keys to spend
 * @param {PublicKey[]} publicKeys - list of all public keys controlling the output
 * @param {number} threshold - amount of required signatures to spend the output
 * @param {Object=} opts - Several options:
 *        - noSorting: defaults to false, if true, don't sort the given
 *                      public keys before creating the script
 */
Script.buildMultisigOut = function(publicKeys, threshold, opts) {
  $.checkArgument(threshold <= publicKeys.length,
    'Number of required signatures must be less than or equal to the number of public keys');
  opts = opts || {};
  var script = new Script();
  script.add(Opcode.smallInt(threshold));
  publicKeys = _.map(publicKeys, PublicKey);
  var sorted = publicKeys;
  if (!opts.noSorting) {
    sorted = _.sortBy(publicKeys, function(publicKey) {
      return publicKey.toString('hex');
    });
  }
  for (var i = 0; i < sorted.length; i++) {
    var publicKey = sorted[i];
    script.add(publicKey.toBuffer());
  }
  script.add(Opcode.smallInt(publicKeys.length));
  script.add(Opcode.OP_CHECKMULTISIG);
  return script;
};

Script.buildWitnessMultisigOutFromScript = function(script) {
  if (script instanceof Script) {
    var s = new Script();
    s.add(Opcode.OP_0);
    s.add(Hash.sha256(script.toBuffer()));
    return s;
  } else {
    throw new TypeError('First argument is expected to be a p2sh script');
  }
};

/**
 * A new Multisig input script for the given public keys, requiring m of those public keys to spend
 *
 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
 * @param {number} threshold amount of required signatures to spend the output
 * @param {Array} signatures and array of signature buffers to append to the script
 * @param {Object=} opts
 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
 *
 * @returns {Script}
 */
Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {
  $.checkArgument(_.isArray(pubkeys));
  $.checkArgument(_.isNumber(threshold));
  $.checkArgument(_.isArray(signatures));
  opts = opts || {};
  var s = new Script();
  s.add(Opcode.OP_0);
  _.each(signatures, function(signature) {
    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');
    // TODO: allow signatures to be an array of Signature objects
    s.add(signature);
  });
  return s;
};

/**
 * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend
 *
 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
 * @param {number} threshold amount of required signatures to spend the output
 * @param {Array} signatures and array of signature buffers to append to the script
 * @param {Object=} opts
 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
 *
 * @returns {Script}
 */
Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
  $.checkArgument(_.isArray(pubkeys));
  $.checkArgument(_.isNumber(threshold));
  $.checkArgument(_.isArray(signatures));
  opts = opts || {};
  var s = new Script();
  s.add(Opcode.OP_0);
  _.each(signatures, function(signature) {
    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');
    // TODO: allow signatures to be an array of Signature objects
    s.add(signature);
  });
  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
  return s;
};

/**
 * @returns {Script} a new pay to public key hash output for the given
 * address or public key
 * @param {(Address|PublicKey)} to - destination address or public key
 */
Script.buildPublicKeyHashOut = function(to) {
  $.checkArgument(!_.isUndefined(to));
  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
  if (to instanceof PublicKey) {
    to = to.toAddress();
  } else if (_.isString(to)) {
    to = new Address(to);
  }
  var s = new Script();
  s.add(Opcode.OP_DUP)
    .add(Opcode.OP_HASH160)
    .add(to.hashBuffer)
    .add(Opcode.OP_EQUALVERIFY)
    .add(Opcode.OP_CHECKSIG);
  s._network = to.network;
  return s;
};

/**
 * @returns {Script} a new pay to witness v0 output for the given
 * address
 * @param {(Address|PublicKey)} to - destination address
 */
Script.buildWitnessV0Out = function(to) {
  $.checkArgument(!_.isUndefined(to));
  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
  if (to instanceof PublicKey) {
    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);
  } else if (_.isString(to)) {
    to = new Address(to);
  }
  var s = new Script();
  s.add(Opcode.OP_0)
    .add(to.hashBuffer);
  s._network = to.network;
  return s;
};

/**
 * @returns {Script} a new pay to public key output for the given
 *  public key
 */
Script.buildPublicKeyOut = function(pubkey) {
  $.checkArgument(pubkey instanceof PublicKey);
  var s = new Script();
  s.add(pubkey.toBuffer())
    .add(Opcode.OP_CHECKSIG);
  return s;
};

/**
 * @returns {Script} a new OP_RETURN script with data
 * @param {(string|Buffer)} data - the data to embed in the output
 * @param {(string)} encoding - the type of encoding of the string
 */
Script.buildDataOut = function(data, encoding) {
  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));
  if (_.isString(data)) {
    data = Buffer.from(data, encoding);
  }
  var s = new Script();
  s.add(Opcode.OP_RETURN);
  if (!_.isUndefined(data)) {
    s.add(data);
  }
  return s;
};

/**
 * @param {Script|Address} script - the redeemScript for the new p2sh output.
 *    It can also be a p2sh address
 * @returns {Script} new pay to script hash script for given script
 */
Script.buildScriptHashOut = function(script) {
  $.checkArgument(script instanceof Script ||
    (script instanceof Address && script.isPayToScriptHash()));
  var s = new Script();
  s.add(Opcode.OP_HASH160)
    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))
    .add(Opcode.OP_EQUAL);

  s._network = script._network || script.network;
  return s;
};

/**
 * Builds a scriptSig (a script for an input) that signs a public key output script.
 *
 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
 */
Script.buildPublicKeyIn = function(signature, sigtype) {
  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
  if (signature instanceof Signature) {
    signature = signature.toBuffer();
  }
  var script = new Script();
  script.add(BufferUtil.concat([
    signature,
    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
  ]));
  return script;
};

/**
 * Builds a scriptSig (a script for an input) that signs a public key hash
 * output script.
 *
 * @param {Buffer|string|PublicKey} publicKey
 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
 */
Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {
  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
  if (signature instanceof Signature) {
    signature = signature.toBuffer();
  }
  var script = new Script()
    .add(BufferUtil.concat([
      signature,
      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
    ]))
    .add(new PublicKey(publicKey).toBuffer());
  return script;
};

/**
 * @returns {Script} an empty script
 */
Script.empty = function() {
  return new Script();
};

/**
 * @returns {Script} a new pay to script hash script that pays to this script
 */
Script.prototype.toScriptHashOut = function() {
  return Script.buildScriptHashOut(this);
};

/**
 * @return {Script} an output script built from the address
 */
Script.fromAddress = function(address) {
  address = Address(address);
  if (address.isPayToScriptHash()) {
    return Script.buildScriptHashOut(address);
  } else if (address.isPayToPublicKeyHash()) {
    return Script.buildPublicKeyHashOut(address);
  } else if (address.isPayToWitnessPublicKeyHash()) {
    return Script.buildWitnessV0Out(address);
  } else if (address.isPayToWitnessScriptHash()) {
    return Script.buildWitnessV0Out(address);
  }
  throw new errors.Script.UnrecognizedAddress(address);
};

/**
 * Will return the associated address information object
 * @return {Address|boolean}
 */
Script.prototype.getAddressInfo = function(opts) {
  if (this._isInput) {
    return this._getInputAddressInfo();
  } else if (this._isOutput) {
    return this._getOutputAddressInfo();
  } else {
    var info = this._getOutputAddressInfo();
    if (!info) {
      return this._getInputAddressInfo();
    }
    return info;
  }
};

/**
 * Will return the associated output scriptPubKey address information object
 * @return {Address|boolean}
 * @private
 */
Script.prototype._getOutputAddressInfo = function() {
  var info = {};
  if (this.isScriptHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToScriptHash;
  } else if (this.isPublicKeyHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToPublicKeyHash;
  } else if (this.isWitnessScriptHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToWitnessScriptHash;
  } else if (this.isWitnessPublicKeyHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToWitnessPublicKeyHash;
  } else {
    return false;
  }
  return info;
};

/**
 * Will return the associated input scriptSig address information object
 * @return {Address|boolean}
 * @private
 */
Script.prototype._getInputAddressInfo = function() {
  var info = {};
  if (this.isPublicKeyHashIn()) {
    // hash the publickey found in the scriptSig
    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);
    info.type = Address.PayToPublicKeyHash;
  } else if (this.isScriptHashIn()) {
    // hash the redeemscript found at the end of the scriptSig
    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
    info.type = Address.PayToScriptHash;
  } else {
    return false;
  }
  return info;
};

/**
 * @param {Network=} network
 * @return {Address|boolean} the associated address for this script if possible, or false
 */
Script.prototype.toAddress = function(network) {
  var info = this.getAddressInfo();
  if (!info) {
    return false;
  }
  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
  return new Address(info);
};

/**
 * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,
 * typically used with push data chunks.  Note that this will find and delete
 * not just the same data, but the same data with the same push data op as
 * produced by default. i.e., if a pushdata in a tx does not use the minimal
 * pushdata op, then when you try to remove the data it is pushing, it will not
 * be removed, because they do not use the same pushdata op.
 */
Script.prototype.findAndDelete = function(script) {
  var buf = script.toBuffer();
  var hex = buf.toString('hex');
  for (var i = 0; i < this.chunks.length; i++) {
    var script2 = Script({
      chunks: [this.chunks[i]]
    });
    var buf2 = script2.toBuffer();
    var hex2 = buf2.toString('hex');
    if (hex === hex2) {
      this.chunks.splice(i, 1);
    }
  }
  return this;
};

/**
 * Comes from bitcoind's script interpreter CheckMinimalPush function
 * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.
 */
Script.prototype.checkMinimalPush = function(i) {
  var chunk = this.chunks[i];
  var buf = chunk.buf;
  var opcodenum = chunk.opcodenum;
  if (!buf) {
    return true;
  }
  if (buf.length === 0) {
    // Could have used OP_0.
    return opcodenum === Opcode.OP_0;
  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
    // Could have used OP_1 .. OP_16.
    return opcodenum === Opcode.OP_1 + (buf[0] - 1);
  } else if (buf.length === 1 && buf[0] === 0x81) {
    // Could have used OP_1NEGATE
    return opcodenum === Opcode.OP_1NEGATE;
  } else if (buf.length <= 75) {
    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).
    return opcodenum === buf.length;
  } else if (buf.length <= 255) {
    // Could have used OP_PUSHDATA.
    return opcodenum === Opcode.OP_PUSHDATA1;
  } else if (buf.length <= 65535) {
    // Could have used OP_PUSHDATA2.
    return opcodenum === Opcode.OP_PUSHDATA2;
  }
  return true;
};

/**
 * Comes from bitcoind's script DecodeOP_N function
 * @param {number} opcode
 * @returns {number} numeric value in range of 0 to 16
 */
Script.prototype._decodeOP_N = function(opcode) {
  if (opcode === Opcode.OP_0) {
    return 0;
  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {
    return opcode - (Opcode.OP_1 - 1);
  } else {
    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));
  }
};

/**
 * Comes from bitcoind's script GetSigOpCount(boolean) function
 * @param {boolean} use current (true) or pre-version-0.6 (false) logic
 * @returns {number} number of signature operations required by this script
 */
Script.prototype.getSignatureOperationsCount = function(accurate) {
  accurate = (_.isUndefined(accurate) ? true : accurate);
  var self = this;
  var n = 0;
  var lastOpcode = Opcode.OP_INVALIDOPCODE;
  _.each(self.chunks, function getChunk(chunk) {
    var opcode = chunk.opcodenum;
    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {
      n++;
    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {
      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {
        n += self._decodeOP_N(lastOpcode);
      } else {
        n += 20;
      }
    }
    lastOpcode = opcode;
  });
  return n;
};

module.exports = Script;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 859:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var $ = __webpack_require__(35);
var JSUtil = __webpack_require__(59);

var Script = __webpack_require__(104);
var Address = __webpack_require__(140);
var Unit = __webpack_require__(463);

/**
 * Represents an unspent output information: its script, associated amount and address,
 * transaction id and output index.
 *
 * @constructor
 * @param {object} data
 * @param {string} data.txid the previous transaction id
 * @param {string=} data.txId alias for `txid`
 * @param {number} data.vout the index in the transaction
 * @param {number=} data.outputIndex alias for `vout`
 * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds
 * @param {string|Script=} data.script alias for `scriptPubKey`
 * @param {number} data.amount amount of bitcoins associated
 * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)
 * @param {string|Address=} data.address the associated address to the script, if provided
 */
function UnspentOutput(data) {
  /* jshint maxcomplexity: 20 */
  /* jshint maxstatements: 20 */
  if (!(this instanceof UnspentOutput)) {
    return new UnspentOutput(data);
  }
  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');
  var address = data.address ? new Address(data.address) : undefined;
  var txId = data.txid ? data.txid : data.txId;
  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
    // TODO: Use the errors library
    throw new Error('Invalid TXID in object', data);
  }
  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
  if (!_.isNumber(outputIndex)) {
    throw new Error('Invalid outputIndex, received ' + outputIndex);
  }
  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),
                  'Must provide the scriptPubKey for that output!');
  var script = new Script(data.scriptPubKey || data.script);
  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),
                      'Must provide an amount for the output');
  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;
  $.checkArgument(_.isNumber(amount), 'Amount must be a number');
  JSUtil.defineImmutable(this, {
    address: address,
    txId: txId,
    outputIndex: outputIndex,
    script: script,
    satoshis: amount
  });
}

/**
 * Provide an informative output when displaying this object in the console
 * @returns string
 */
UnspentOutput.prototype.inspect = function() {
  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +
         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';
};

/**
 * String representation: just "txid:index"
 * @returns string
 */
UnspentOutput.prototype.toString = function() {
  return this.txId + ':' + this.outputIndex;
};

/**
 * Deserialize an UnspentOutput from an object
 * @param {object|string} data
 * @return UnspentOutput
 */
UnspentOutput.fromObject = function(data) {
  return new UnspentOutput(data);
};

/**
 * Returns a plain object (no prototype or methods) with the associated info for this output
 * @return {object}
 */
UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {
  return {
    address: this.address ? this.address.toString() : undefined,
    txid: this.txId,
    vout: this.outputIndex,
    scriptPubKey: this.script.toBuffer().toString('hex'),
    amount: Unit.fromSatoshis(this.satoshis).toBTC()
  };
};

module.exports = UnspentOutput;


/***/ }),

/***/ 86:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_electron_electron__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_filter_filter__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_gift_card_gift_card__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_rate_rate__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_simplex_simplex__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__buy_crypto_crypto_order_summary_crypto_order_summary__ = __webpack_require__(503);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__integrations_gift_cards_confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__receive_custom_amount_custom_amount__ = __webpack_require__(984);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__confirm_confirm__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__integrations_coinbase_coinbase_withdraw_coinbase_withdraw__ = __webpack_require__(985);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__integrations_tkcoin_card_tkcoin_card_topup_tkcoin_card_topup__ = __webpack_require__(986);





// Providers












// Pages







let AmountPage = class AmountPage {
    constructor(actionSheetProvider, configProvider, filterProvider, currencyProvider, logger, navParams, electronProvider, platformProvider, rateProvider, txFormatProvider, changeDetectorRef, events, viewCtrl, profileProvider, navCtrl, iabCardProvider, simplexProvider, formBuilder, translate) {
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.filterProvider = filterProvider;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.electronProvider = electronProvider;
        this.platformProvider = platformProvider;
        this.rateProvider = rateProvider;
        this.txFormatProvider = txFormatProvider;
        this.changeDetectorRef = changeDetectorRef;
        this.events = events;
        this.viewCtrl = viewCtrl;
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.iabCardProvider = iabCardProvider;
        this.simplexProvider = simplexProvider;
        this.formBuilder = formBuilder;
        this.translate = translate;
        this.walletDisableHardwareKeyboardHandler = () => {
            this._disableHardwareKeyboard();
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.config = this.configProvider.get();
        this.useAsModal = this.navParams.data.useAsModal;
        this.recipientType = this.navParams.data.recipientType;
        this.toAddress = this.navParams.data.toAddress;
        this.network = this.navParams.data.network;
        this.name = this.navParams.data.name;
        this.email = this.navParams.data.email;
        this.destinationTag = this.navParams.data.destinationTag;
        this.color = this.navParams.data.color;
        this.fixedUnit = this.navParams.data.fixedUnit;
        this.description = this.navParams.data.description;
        this.onlyIntegers = this.navParams.data.onlyIntegers
            ? this.navParams.data.onlyIntegers
            : false;
        this.fromCoinbase = this.navParams.data.fromCoinbase;
        this.alternativeCurrency = this.navParams.data.alternativeCurrency;
        this.fromBuyCrypto = this.navParams.data.fromBuyCrypto;
        this.fromExchangeCrypto = this.navParams.data.fromExchangeCrypto;
        this.showSendMax = false;
        this.useSendMax = false;
        this.allowSend = false;
        this.useSmallFontSize = false;
        this.availableUnits = [];
        this.expression = '';
        this.LENGTH_EXPRESSION_LIMIT = 19;
        this.amount = 0;
        this.altUnitIndex = 0;
        this.unitIndex = 0;
        this.reNr = /^[1234567890\.]$/;
        this.reOp = /^[\*\+\-\/]$/;
        this.requestingAmount =
            this.navParams.get('nextPage') === 'CustomAmountPage';
        this.nextView = this.getNextView();
        // BitPay Card ID or Wallet ID or Coinbase Account ID
        this._id = this.navParams.data.id;
        // Use only with Coinbase Withdraw
        this.toWalletId = this.navParams.data.toWalletId;
        this.cardName = this.navParams.get('cardName');
        this.cardConfig = this.navParams.get('cardConfig');
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.navBar.backButtonClick = () => {
                if (this.navParams.get('card') === 'v2') {
                    this.iabCardProvider.show(true);
                }
                this.navCtrl.pop();
            };
            this.setAvailableUnits();
            if (this.fromBuyCrypto)
                this.setBuyCryptoParams();
            this.updateUnitUI();
        });
    }
    ionViewWillEnter() {
        this.disableHardwareKeyboard = false;
        this.expression = '';
        this.useSendMax = false;
        this.processAmount();
        this.events.subscribe('Wallet/disableHardwareKeyboard', this.walletDisableHardwareKeyboardHandler);
    }
    ionViewWillLeave() {
        this._disableHardwareKeyboard();
    }
    _disableHardwareKeyboard() {
        this.disableHardwareKeyboard = true;
    }
    handleKeyboardEvent(event) {
        if (this.disableHardwareKeyboard)
            return;
        if (!event.key)
            return;
        if (event.which === 8) {
            event.preventDefault();
            this.removeDigit();
        }
        if (event.key.match(this.reNr)) {
            this.pushDigit(event.key);
        }
        else if (event.key.match(this.reOp)) {
            this.pushOperator(event.key);
        }
        else if (event.keyCode === 86) {
            if (event.ctrlKey || event.metaKey)
                this.processClipboard();
        }
        else if (event.keyCode === 13)
            this.finish();
    }
    isCoin(coin) {
        return !!__WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__["a" /* Coin */][coin];
    }
    setAvailableUnits() {
        this.availableUnits = [];
        const parentWalletCoin = this.navParams.data.wallet
            ? this.navParams.data.wallet.coin
            : this.wallet && this.wallet.coin;
        for (const coin of this.currencyProvider.getAvailableCoins()) {
            if (parentWalletCoin === coin || !parentWalletCoin) {
                const { unitName, unitCode } = this.currencyProvider.getPrecision(coin);
                this.availableUnits.push({
                    name: this.currencyProvider.getCoinName(coin),
                    id: unitCode,
                    shortName: unitName
                });
            }
        }
        this.unitIndex = 0;
        if (this.navParams.data.coin) {
            let coins = this.navParams.data.coin.split(',');
            let newAvailableUnits = [];
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](coins, (c) => {
                let coin = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.availableUnits, {
                    id: c
                });
                if (!coin) {
                    this.logger.warn('Could not find desired coin:' + this.navParams.data.coin);
                }
                else {
                    newAvailableUnits.push(coin);
                }
            });
            if (newAvailableUnits.length > 0) {
                this.availableUnits = newAvailableUnits;
            }
        }
        //  currency have preference
        let fiatName;
        if (this.navParams.data.currency) {
            this.fiatCode = this.navParams.data.currency;
            this.altUnitIndex = this.unitIndex;
            this.unitIndex = this.availableUnits.length;
        }
        else {
            this.fiatCode =
                this.alternativeCurrency ||
                    this.config.wallet.settings.alternativeIsoCode ||
                    'USD';
            fiatName = this.config.wallet.settings.alternativeName || this.fiatCode;
            this.altUnitIndex = this.availableUnits.length;
        }
        this.availableUnits.push({
            name: fiatName || this.fiatCode,
            // TODO
            id: this.fiatCode,
            shortName: this.fiatCode,
            isFiat: true
        });
        if (this.navParams.data.fixedUnit) {
            this.fixedUnit = true;
        }
    }
    paste(value) {
        this.zone.run(() => {
            this.expression = value;
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    getNextView() {
        let nextPage;
        switch (this.navParams.data.nextPage) {
            case 'TKCoinCardTopUpPage':
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_23__integrations_tkcoin_card_tkcoin_card_topup_tkcoin_card_topup__["a" /* TKCoinCardTopUpPage */];
                break;
            case 'ConfirmCardPurchasePage':
                nextPage = __WEBPACK_IMPORTED_MODULE_18__integrations_gift_cards_confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */];
                break;
            case 'CustomAmountPage':
                nextPage = __WEBPACK_IMPORTED_MODULE_19__receive_custom_amount_custom_amount__["a" /* CustomAmountPage */];
                break;
            case 'CryptoOrderSummaryPage':
                nextPage = __WEBPACK_IMPORTED_MODULE_17__buy_crypto_crypto_order_summary_crypto_order_summary__["a" /* CryptoOrderSummaryPage */];
                break;
            case 'CoinbaseWithdrawPage':
                this.showSendMax = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_22__integrations_coinbase_coinbase_withdraw_coinbase_withdraw__["a" /* CoinbaseWithdrawPage */];
                break;
            default:
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_20__confirm_confirm__["a" /* ConfirmPage */];
        }
        return nextPage;
    }
    processClipboard() {
        if (!this.platformProvider.isElectron)
            return;
        let value = this.electronProvider.readFromClipboard();
        if (value && this.evaluate(value) > 0)
            this.paste(this.evaluate(value));
    }
    sendMax() {
        this.useSendMax = true;
        this.allowSend = true;
        if (!this.wallet) {
            return this.finish();
        }
        const maxAmount = this.txFormatProvider.satToUnit(this.wallet.cachedStatus.availableBalanceSat, this.wallet.coin);
        this.zone.run(() => {
            this.expression = this.availableUnits[this.unitIndex].isFiat
                ? this.toFiat(maxAmount, this.wallet.coin).toFixed(2)
                : maxAmount;
            this.processAmount();
            this.changeDetectorRef.detectChanges();
            this.finish();
        });
    }
    isSendMaxButtonShown() {
        return ((this.showSendMax && !this.requestingAmount && !this.useAsModal) ||
            this.fromExchangeCrypto);
    }
    resizeFont() {
        this.useSmallFontSize = this.expression && this.expression.length >= 10;
    }
    pushDigit(digit) {
        this.useSendMax = false;
        if (digit === 'delete') {
            return this.removeDigit();
        }
        if (this.expression &&
            this.expression.length >= this.LENGTH_EXPRESSION_LIMIT)
            return;
        this.zone.run(() => {
            this.expression = (this.expression + digit).replace('..', '.');
            this.processAmount();
            this.changeDetectorRef.detectChanges();
            this.resizeFont();
        });
    }
    removeDigit() {
        this.zone.run(() => {
            this.expression = this.expression.slice(0, -1);
            this.processAmount();
            this.changeDetectorRef.detectChanges();
            this.resizeFont();
        });
    }
    pushOperator(operator) {
        if (!this.expression || this.expression.length == 0)
            return;
        this.zone.run(() => {
            this.expression = this._pushOperator(this.expression, operator);
            this.changeDetectorRef.detectChanges();
        });
    }
    _pushOperator(val, operator) {
        if (!this.isOperator(__WEBPACK_IMPORTED_MODULE_4_lodash__["last"](val))) {
            return val + operator;
        }
        else {
            return val.slice(0, -1) + operator;
        }
    }
    isOperator(val) {
        const regex = /[\/\-\+\x\*]/;
        return regex.test(val);
    }
    isExpression(val) {
        const regex = /^\.?\d+(\.?\d+)?([\/\-\+\*x]\d?\.?\d+)+$/;
        return regex.test(val);
    }
    isNumber(expression) {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](expression) ? true : false;
    }
    processAmount() {
        let formatedValue = this.format(this.expression);
        let result = this.evaluate(formatedValue);
        this.allowSend = this.onlyIntegers
            ? __WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result) && +result > 0 && Number.isInteger(+result)
            : __WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result) && +result > 0;
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result)) {
            this.globalResult = this.isExpression(this.expression)
                ? '= ' + this.processResult(result)
                : '';
            if (this.fromBuyCrypto)
                return;
            if (this.availableUnits[this.unitIndex].isFiat) {
                let a = this.fromFiat(result);
                if (a) {
                    this.alternativeAmount = this.txFormatProvider.formatAmount(this.availableUnits[this.altUnitIndex].id, a * this.unitToSatoshi, true);
                    this.checkAmountForBitpaycard(result);
                }
                else {
                    this.alternativeAmount = result ? 'N/A' : null;
                    this.allowSend = false;
                }
            }
            else {
                this.alternativeAmount = this.filterProvider.formatFiatAmount(this.toFiat(result));
                this.checkAmountForBitpaycard(this.toFiat(result));
            }
        }
    }
    checkAmountForBitpaycard(amount) {
        // Check if the top up amount is at least 1 usd
        const isTopUp = this.navParams.data.nextPage === 'TKCoinCardTopUpPage' ? true : false;
        if (isTopUp && amount < 1) {
            this.allowSend = false;
        }
    }
    processResult(val) {
        if (this.availableUnits[this.unitIndex].isFiat)
            return this.filterProvider.formatFiatAmount(val);
        else
            return this.txFormatProvider.formatAmount(this.unit.toLowerCase(), val.toFixed(this.unitDecimals) * this.unitToSatoshi, true);
    }
    fromFiat(val, coin) {
        coin = coin || this.availableUnits[this.altUnitIndex].id;
        return parseFloat((this.rateProvider.fromFiat(val, this.fiatCode, coin) * this.satToUnit).toFixed(this.unitDecimals));
    }
    toFiat(val, coin) {
        if (!this.rateProvider.getRate(this.fiatCode, coin || this.availableUnits[this.unitIndex].id))
            return undefined;
        return parseFloat(this.rateProvider
            .toFiat(val * this.unitToSatoshi, this.fiatCode, coin || this.availableUnits[this.unitIndex].id)
            .toFixed(2));
    }
    format(val) {
        if (!val)
            return undefined;
        let result = val.toString();
        if (this.isOperator(__WEBPACK_IMPORTED_MODULE_4_lodash__["last"](val)))
            result = result.slice(0, -1);
        return result.replace('x', '*');
    }
    evaluate(val) {
        let result;
        try {
            result = eval(val);
        }
        catch (e) {
            return 0;
        }
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isFinite"](result))
            return 0;
        return result;
    }
    validateGiftCardAmount(amount) {
        return (amount <= this.cardConfig.maxAmount && amount >= this.cardConfig.minAmount);
    }
    showCardAmountInfoSheet(amount) {
        const sheetType = amount < this.cardConfig.minAmount
            ? 'below-minimum-gift-card-amount'
            : 'above-maximum-gift-card-amount';
        this.actionSheetProvider
            .createInfoSheet(sheetType, this.cardConfig)
            .present();
    }
    finish(skipActivationFeeAlert = false) {
        if (!this.allowSend)
            return;
        let unit = this.availableUnits[this.unitIndex];
        let _amount = this.evaluate(this.format(this.expression));
        let coin = unit.id;
        let data;
        if (unit.isFiat) {
            coin = this.availableUnits[this.altUnitIndex].id;
        }
        if (this.navParams.data.nextPage) {
            const amount = this.useSendMax ? null : _amount;
            if (this.cardConfig && !this.validateGiftCardAmount(amount)) {
                this.showCardAmountInfoSheet(amount);
                return;
            }
            data = {
                id: this._id,
                amount,
                currency: this.fromBuyCrypto ? this.unit : unit.id.toUpperCase(),
                coin: this.fromBuyCrypto && !this.navParams.data.coin ? null : coin,
                useSendMax: this.useSendMax,
                toWalletId: this.toWalletId,
                cardConfig: this.cardConfig,
                cardName: this.cardName,
                description: this.description
            };
        }
        else {
            let amount = _amount;
            amount = unit.isFiat
                ? (this.fromFiat(amount) * this.unitToSatoshi).toFixed(0)
                : (amount * this.unitToSatoshi).toFixed(0);
            data = {
                recipientType: this.recipientType,
                amount,
                toAddress: this.toAddress,
                name: this.name,
                email: this.email,
                color: this.color,
                coin,
                useSendMax: this.useSendMax,
                description: this.description,
                fromCoinbase: this.fromCoinbase,
                currency: this.unit
            };
            if (unit.isFiat) {
                data.fiatAmount = _amount;
                data.fiatCode = this.fiatCode;
            }
        }
        this.useSendMax = null;
        if (this.wallet) {
            data.walletId = this.wallet.credentials.walletId;
            data.network = this.wallet.network;
            if (this.wallet.credentials.token) {
                data.tokenAddress = this.wallet.credentials.token.address;
            }
            if (this.wallet.credentials.multisigEthInfo) {
                data.multisigContractAddress = this.wallet.credentials.multisigEthInfo.multisigContractAddress;
            }
        }
        if (this.destinationTag) {
            data.destinationTag = this.destinationTag;
        }
        if (this.navParams.data.fromWalletDetails) {
            data.fromWalletDetails = true;
        }
        if (this.cardName && !skipActivationFeeAlert) {
            const activationFee = Object(__WEBPACK_IMPORTED_MODULE_10__providers_gift_card_gift_card__["b" /* getActivationFee */])(data.amount, this.cardConfig);
            if (activationFee) {
                return this.alertActivationFeeIncluded(activationFee);
            }
        }
        if (this.navParams.get('card') === 'v2') {
            data = Object.assign({}, data, { v2: true });
        }
        this.useAsModal
            ? this.closeModal(data)
            : this.navCtrl.push(this.nextView, data);
    }
    alertActivationFeeIncluded(fee) {
        if (!fee)
            return;
        const sheet = this.actionSheetProvider.createInfoSheet('activation-fee-included', {
            currency: this.cardConfig.currency,
            displayName: this.cardConfig.displayName,
            fee
        });
        sheet.present();
        sheet.onDidDismiss(ok => ok && this.finish(true));
    }
    updateUnitUI() {
        this.unit = this.fromBuyCrypto
            ? this.altCurrencyInitial
            : this.availableUnits[this.unitIndex].shortName;
        this.alternativeUnit = this.availableUnits[this.altUnitIndex].shortName;
        const { unitToSatoshi, unitDecimals } = this.availableUnits[this.unitIndex]
            .isFiat
            ? this.currencyProvider.getPrecision(this.availableUnits[this.altUnitIndex].id)
            : this.currencyProvider.getPrecision(this.unit.toLowerCase());
        this.unitToSatoshi = unitToSatoshi;
        this.satToUnit = 1 / this.unitToSatoshi;
        this.unitDecimals = unitDecimals;
        this.processAmount();
        this.logger.debug('Update unit coin @amount unit:' +
            this.unit +
            ' alternativeUnit:' +
            this.alternativeUnit);
    }
    resetValues() {
        this.expression = '';
        this.globalResult = '';
        this.alternativeAmount = null;
    }
    changeUnit() {
        if (this.fixedUnit)
            return;
        this.unitIndex++;
        if (this.unitIndex >= this.availableUnits.length)
            this.unitIndex = 0;
        if (this.availableUnits[this.unitIndex].isFiat) {
            // Always return to BTC... TODO?
            this.altUnitIndex = 0;
        }
        else {
            this.altUnitIndex = __WEBPACK_IMPORTED_MODULE_4_lodash__["findIndex"](this.availableUnits, {
                isFiat: true
            });
        }
        this.resetValues();
        this.zone.run(() => {
            this.updateUnitUI();
            this.changeDetectorRef.detectChanges();
        });
    }
    closeModal(item) {
        if (this.navParams.data.fromMultiSend) {
            if (item)
                this.events.publish('addRecipient', item);
            this.navCtrl.remove(this.viewCtrl.index - 1).then(() => {
                this.viewCtrl.dismiss();
            });
        }
        else {
            this.viewCtrl.dismiss(item);
        }
    }
    setBuyCryptoParams() {
        const isoCode = this.config.wallet.settings.alternativeIsoCode;
        this.altCurrencyInitial =
            this.fiatCode && this.isSupportedFiat(this.fiatCode)
                ? this.fiatCode
                : this.isSupportedFiat(isoCode)
                    ? isoCode
                    : 'USD';
        this.quoteForm = this.formBuilder.group({
            amount: [
                200,
                [__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].min(50), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].max(20000)]
            ],
            altCurrency: [this.altCurrencyInitial, [__WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]]
        });
        this.altCurrenciesToShow = ['USD', 'ARS', 'EUR'];
        this.altCurrenciesToShow2 = [];
        if (this.altCurrenciesToShow.indexOf(this.altCurrencyInitial) < 0)
            this.altCurrenciesToShow.push(this.altCurrencyInitial);
        this.selectOptions = {
            title: this.translate.instant('Select Currency'),
            cssClass: 'buy-crypto-currency-' + this.altCurrenciesToShow.length
        };
        this.supportedFiatAltCurrencies = this.simplexProvider.getSupportedFiatAltCurrencies();
        this.supportedFiatAltCurrencies.forEach((currency) => {
            if (this.altCurrenciesToShow.indexOf(currency) < 0)
                this.altCurrenciesToShow2.push(currency);
        });
        this.okText = this.translate.instant('Select');
        this.cancelText = this.translate.instant('Cancel');
        this.showLoading = false;
    }
    isSupportedFiat(isoCode) {
        return (this.simplexProvider.getSupportedFiatAltCurrencies().indexOf(isoCode) > -1);
    }
    altCurrencyChange() {
        this.logger.debug('altCurrency changed to: ' + this.quoteForm.value.altCurrency);
        this.unit = this.quoteForm.value.altCurrency;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* Navbar */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* Navbar */])
], AmountPage.prototype, "navBar", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["HostListener"])('document:keydown', ['$event']),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Function),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [KeyboardEvent]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:returntype", void 0)
], AmountPage.prototype, "handleKeyboardEvent", null);
AmountPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-amount',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/amount/amount.html"*/'<ion-header>\n  <ion-navbar [hideBackButton]="useAsModal">\n    <ion-buttons left *ngIf="useAsModal">\n      <button class="close-container disable-hover" (click)="closeModal()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-buttons right>\n      <button class="send-max" *ngIf="isSendMaxButtonShown()" (click)="sendMax()" clear wide-header-bar-button ion-button>\n        <span translate>Send max</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content class="add-bottom-safe-area" no-bounce>\n  <div class="container">\n    <div class="amount-content" [ngClass]="{\'amount-content-fixed\': fromBuyCrypto}">\n      <div class="expression-container">\n        <span *ngIf="expression; else noExpression" class="ellipsis expression" [ngClass]="{\'small-font\': useSmallFontSize}">\n          <span *ngIf="isNumber(expression)">{{expression | number:\'1.0-6\'}}</span>\n          <span *ngIf="!isNumber(expression)">{{expression}}</span>\n        </span>\n        <ng-template #noExpression>\n          <span class="expression">\n            {{ \'0\' }}\n          </span>\n        </ng-template>\n        <span class="unit" [ngClass]="{\'small-font\': useSmallFontSize}" [hidden]="globalResult">{{unit}}</span>\n      </div>\n      <div class="amount" [hidden]="!globalResult">{{globalResult}} {{unit}}</div>\n      <div class="result" *ngIf="!fromBuyCrypto">&asymp;\n        <span *ngIf="fiatCode === alternativeUnit">{{alternativeAmount || \'0.00\'}}</span>\n        <span *ngIf="fiatCode !== alternativeUnit">{{alternativeAmount || \'0\'}}</span>\n        {{alternativeUnit}}\n      </div>\n    </div>\n\n    <div class="amount-switcher-margin" [ngClass]="{\'fix-modal-switcher\': useAsModal}" *ngIf="!fromBuyCrypto">\n      <div class="amount-switcher">\n        <div class="switcher" (click)="changeUnit()" [hidden]="fixedUnit" tappable>\n          <img class="switcher__icon" src="assets/img/icon-swap.svg">\n          <div class="switcher__label">{{unit}}</div>\n        </div>\n      </div>\n    </div>\n\n    <form class="amount-switcher-margin" [ngClass]="{\'fix-modal-switcher\': useAsModal}" [formGroup]="quoteForm" *ngIf="this.quoteForm && fromBuyCrypto">\n      <div class="amount-switcher">\n        <ion-select class="switcher select-options" [selectOptions]="selectOptions" okText="{{okText}}" cancelText="{{cancelText}}" formControlName="altCurrency" (ionChange)="altCurrencyChange()">\n          <ion-option *ngFor="let fiatAltCurrency of altCurrenciesToShow" [value]="fiatAltCurrency">{{ fiatAltCurrency }}</ion-option>\n          <ion-option *ngFor="let fiatAltCurrency of altCurrenciesToShow2" [value]="fiatAltCurrency">{{ fiatAltCurrency }}</ion-option>\n        </ion-select>\n      </div>\n    </form>\n\n    <div class="bottom-absolute">\n      <pin-pad (keystroke)="pushDigit($event)" type="amount" [integersOnly]="onlyIntegers"></pin-pad>\n\n      <button ion-button class="button-standard button-primary" [disabled]="!expression || !allowSend" (click)="finish()">\n        <span>{{\'Continue\' | translate}}</span>\n      </button>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/send/amount/amount.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_electron_electron__["a" /* ElectronProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_rate_rate__["b" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ChangeDetectorRef"],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_simplex_simplex__["a" /* SimplexProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_21__ngx_translate_core__["f" /* TranslateService */]])
], AmountPage);

//# sourceMappingURL=amount.js.map

/***/ }),

/***/ 860:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BlockHeader = __webpack_require__(356);
var BufferUtil = __webpack_require__(48);
var BufferReader = __webpack_require__(160);
var BufferWriter = __webpack_require__(93);
var Hash = __webpack_require__(74);
var JSUtil = __webpack_require__(59);
var Transaction = __webpack_require__(353);
var errors = __webpack_require__(115);
var $ = __webpack_require__(35);

/**
 * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock
 * @returns {MerkleBlock}
 * @constructor
 */
function MerkleBlock(arg) {
  /* jshint maxstatements: 18 */

  if (!(this instanceof MerkleBlock)) {
    return new MerkleBlock(arg);
  }

  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = MerkleBlock._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    var header;
    if(arg.header instanceof BlockHeader) {
      header = arg.header;
    } else {
      header = BlockHeader.fromObject(arg.header);
    }
    info = {
      /**
       * @name MerkleBlock#header
       * @type {BlockHeader}
       */
      header: header,
      /**
       * @name MerkleBlock#numTransactions
       * @type {Number}
       */
      numTransactions: arg.numTransactions,
      /**
       * @name MerkleBlock#hashes
       * @type {String[]}
       */
      hashes: arg.hashes,
      /**
       * @name MerkleBlock#flags
       * @type {Number[]}
       */
      flags: arg.flags
    };
  } else {
    throw new TypeError('Unrecognized argument for MerkleBlock');
  }
  _.extend(this,info);
  this._flagBitsUsed = 0;
  this._hashesUsed = 0;

  return this;
}

/**
 * @param {Buffer} - MerkleBlock data in a Buffer object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBuffer = function fromBuffer(buf) {
  return MerkleBlock.fromBufferReader(BufferReader(buf));
};

/**
 * @param {BufferReader} - MerkleBlock data in a BufferReader object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBufferReader = function fromBufferReader(br) {
  return new MerkleBlock(MerkleBlock._fromBufferReader(br));
};

/**
 * @returns {Buffer} - A buffer of the block
 */
MerkleBlock.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock
 */
MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.write(this.header.toBuffer());
  bw.writeUInt32LE(this.numTransactions);
  bw.writeVarintNum(this.hashes.length);
  for (var i = 0; i < this.hashes.length; i++) {
    bw.write(Buffer.from(this.hashes[i], 'hex'));
  }
  bw.writeVarintNum(this.flags.length);
  for (i = 0; i < this.flags.length; i++) {
    bw.writeUInt8(this.flags[i]);
  }
  return bw;
};

/**
 * @returns {Object} - A plain object with the MerkleBlock properties
 */
MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {
  return {
    header: this.header.toObject(),
    numTransactions: this.numTransactions,
    hashes: this.hashes,
    flags: this.flags
  };
};

/**
 * Verify that the MerkleBlock is valid
 * @returns {Boolean} - True/False whether this MerkleBlock is Valid
 */
MerkleBlock.prototype.validMerkleTree = function validMerkleTree() {
  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if(this.hashes.length > this.numTransactions) {
    return false;
  }

  // Can't have more flag bits than num hashes
  if(this.flags.length * 8 < this.hashes.length) {
    return false;
  }

  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var root = this._traverseMerkleTree(height, 0, opts);
  if(opts.hashesUsed !== this.hashes.length) {
    return false;
  }
  return BufferUtil.equals(root, this.header.merkleRoot);
};

/**
 * Return a list of all the txs hash that match the filter
 * @returns {Array} - txs hash that match the filter
 */
MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {
  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if(this.hashes.length > this.numTransactions) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }

  // Can't have more flag bits than num hashes
  if(this.flags.length * 8 < this.hashes.length) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }

  // If there is only one hash the filter do not match any txs in the block
  if(this.hashes.length === 1) {
    return [];
  };

  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var txs = this._traverseMerkleTree(height, 0, opts, true);
  if(opts.hashesUsed !== this.hashes.length) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }
  return txs;
};

/**
 * Traverse a the tree in this MerkleBlock, validating it along the way
 * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()
 * @param {Number} - depth - Current height
 * @param {Number} - pos - Current position in the tree
 * @param {Object} - opts - Object with values that need to be mutated throughout the traversal
 * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash
 * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0
 * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0
 * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter
 * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height
 * @returns {Array} - transactions found during traversal that match the filter
 * @private
 */
MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {
  /* jshint maxcomplexity:  12*/
  /* jshint maxstatements: 20 */

  opts = opts || {};
  opts.txs = opts.txs || [];
  opts.flagBitsUsed = opts.flagBitsUsed || 0;
  opts.hashesUsed = opts.hashesUsed || 0;
  var checkForTxs = checkForTxs || false;

  if(opts.flagBitsUsed > this.flags.length * 8) {
    return null;
  }
  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;
  if(depth === 0 || !isParentOfMatch) {
    if(opts.hashesUsed >= this.hashes.length) {
      return null;
    }
    var hash = this.hashes[opts.hashesUsed++];
    if(depth === 0 && isParentOfMatch) {
      opts.txs.push(hash);
    }
    return Buffer.from(hash, 'hex');
  } else {
    var left = this._traverseMerkleTree(depth-1, pos*2, opts);
    var right = left;
    if(pos*2+1 < this._calcTreeWidth(depth-1)) {
      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);
    }
    if (checkForTxs){
      return opts.txs;
    } else {
      return Hash.sha256sha256(new Buffer.concat([left, right]));
    };
  }
};

/** Calculates the width of a merkle tree at a given height.
 *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()
 * @param {Number} - Height at which we want the tree width
 * @returns {Number} - Width of the tree at a given height
 * @private
 */
MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {
  return (this.numTransactions + (1 << height) - 1) >> height;
};

/** Calculates the height of the merkle tree in this MerkleBlock
 * @param {Number} - Height at which we want the tree width
 * @returns {Number} - Height of the merkle tree in this MerkleBlock
 * @private
 */
MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {
  var height = 0;
  while (this._calcTreeWidth(height) > 1) {
    height++;
  }
  return height;
};

/**
 * @param {Transaction|String} - Transaction or Transaction ID Hash
 * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not
 * @private
 */
MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {
  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');
  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',
      'Invalid tx given, tx must be a "string" or "Transaction"');

  var hash = tx;
  if(tx instanceof Transaction) {
    // We need to reverse the id hash for the lookup
    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');
  }

  var txs = [];
  var height = this._calcTreeHeight();
  this._traverseMerkleTree(height, 0, { txs: txs });
  return txs.indexOf(hash) !== -1;
};

/**
 * @param {Buffer} - MerkleBlock data
 * @returns {Object} - An Object representing merkleblock data
 * @private
 */
MerkleBlock._fromBufferReader = function _fromBufferReader(br) {
  $.checkState(!br.finished(), 'No merkleblock data received');
  var info = {};
  info.header = BlockHeader.fromBufferReader(br);
  info.numTransactions = br.readUInt32LE();
  var numHashes = br.readVarintNum();
  info.hashes = [];
  for (var i = 0; i < numHashes; i++) {
    info.hashes.push(br.read(32).toString('hex'));
  }
  var numFlags = br.readVarintNum();
  info.flags = [];
  for (i = 0; i < numFlags; i++) {
    info.flags.push(br.readUInt8());
  }
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
MerkleBlock.fromObject = function fromObject(obj) {
  return new MerkleBlock(obj);
};

module.exports = MerkleBlock;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 861:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {


var assert = __webpack_require__(12);
var buffer = __webpack_require__(2);
var _ = __webpack_require__(1);
var $ = __webpack_require__(35);

var BN = __webpack_require__(73);
var Base58 = __webpack_require__(352);
var Base58Check = __webpack_require__(267);
var Hash = __webpack_require__(74);
var Network = __webpack_require__(199);
var Point = __webpack_require__(216);
var PrivateKey = __webpack_require__(266);
var Random = __webpack_require__(355);

var errors = __webpack_require__(115);
var hdErrors = errors.HDPrivateKey;
var BufferUtil = __webpack_require__(48);
var JSUtil = __webpack_require__(59);

var MINIMUM_ENTROPY_BITS = 128;
var BITS_TO_BYTES = 1 / 8;
var MAXIMUM_ENTROPY_BITS = 512;


/**
 * Represents an instance of an hierarchically derived private key.
 *
 * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
 *
 * @constructor
 * @param {string|Buffer|Object} arg
 */
function HDPrivateKey(arg) {
  /* jshint maxcomplexity: 10 */
  if (arg instanceof HDPrivateKey) {
    return arg;
  }
  if (!(this instanceof HDPrivateKey)) {
    return new HDPrivateKey(arg);
  }
  if (!arg) {
    return this._generateRandomly();
  }

  if (Network.get(arg)) {
    return this._generateRandomly(arg);
  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
    if (HDPrivateKey.isValidSerialized(arg)) {
      this._buildFromSerialized(arg);
    } else if (JSUtil.isValidJSON(arg)) {
      this._buildFromJSON(arg);
    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
      this._buildFromSerialized(arg.toString());
    } else {
      throw HDPrivateKey.getSerializedError(arg);
    }
  } else if (_.isObject(arg)) {
    this._buildFromObject(arg);
  } else {
    throw new hdErrors.UnrecognizedArgument(arg);
  }
}

/**
 * Verifies that a given path is valid.
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 * @return {boolean}
 */
HDPrivateKey.isValidPath = function(arg, hardened) {
  if (_.isString(arg)) {
    var indexes = HDPrivateKey._getDerivationIndexes(arg);
    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);
  }

  if (_.isNumber(arg)) {
    if (arg < HDPrivateKey.Hardened && hardened === true) {
      arg += HDPrivateKey.Hardened;
    }
    return arg >= 0 && arg < HDPrivateKey.MaxIndex;
  }

  return false;
};

/**
 * Internal function that splits a string path into a derivation index array.
 * It will return null if the string path is malformed.
 * It does not validate if indexes are in bounds.
 *
 * @param {string} path
 * @return {Array}
 */
HDPrivateKey._getDerivationIndexes = function(path) {
  var steps = path.split('/');

  // Special cases:
  if (_.includes(HDPrivateKey.RootElementAlias, path)) {
    return [];
  }

  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {
    return null;
  }

  var indexes = steps.slice(1).map(function(step) {
    var isHardened = step.slice(-1) === '\'';
    if (isHardened) {
      step = step.slice(0, -1);
    }
    if (!step || step[0] === '-') {
      return NaN;
    }
    var index = +step; // cast to number
    if (isHardened) {
      index += HDPrivateKey.Hardened;
    }

    return index;
  });

  return _.some(indexes, isNaN) ? null : indexes;
};

/**
 * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant
 *
 *
 * Get a derived child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
 * derivation.
 *
 * If the first argument is a number, the child with that index will be
 * derived. If the second argument is truthy, the hardened version will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPrivateKey('xprv...');
 * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);
 * var copy_of_child_0_1_2h = parent.derive("m/0/1/2'");
 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
 * ```
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.derive = function(arg, hardened) {
  return this.deriveNonCompliantChild(arg, hardened);
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Get a derived child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
 * derivation.
 *
 * If the first argument is a number, the child with that index will be
 * derived. If the second argument is truthy, the hardened version will be
 * derived. See the example usage for clarification.
 *
 * WARNING: The `nonCompliant` option should NOT be used, except for older implementation
 * that used a derivation strategy that used a non-zero padded private key.
 *
 * @example
 * ```javascript
 * var parent = new HDPrivateKey('xprv...');
 * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);
 * var copy_of_child_0_1_2h = parent.deriveChild("m/0/1/2'");
 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
 * ```
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.deriveChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

/**
 * WARNING: This method will not be officially supported until v1.0.0
 *
 *
 * WARNING: If this is a new implementation you should NOT use this method, you should be using
 * `derive` instead.
 *
 * This method is explicitly for use and compatibility with an implementation that
 * was not compliant with BIP32 regarding the derivation algorithm. The private key
 * must be 32 bytes hashing, and this implementation will use the non-zero padded
 * serialization of a private key, such that it's still possible to derive the privateKey
 * to recover those funds.
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened, true);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg, true);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

HDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {
  /* jshint maxstatements: 20 */
  /* jshint maxcomplexity: 10 */
  if (!HDPrivateKey.isValidPath(index, hardened)) {
    throw new hdErrors.InvalidPath(index);
  }

  hardened = index >= HDPrivateKey.Hardened ? true : hardened;
  if (index < HDPrivateKey.Hardened && hardened === true) {
    index += HDPrivateKey.Hardened;
  }

  var indexBuffer = BufferUtil.integerAsBuffer(index);
  var data;
  if (hardened && nonCompliant) {
    // The private key serialization in this case will not be exactly 32 bytes and can be
    // any value less, and the value is not zero-padded.
    var nonZeroPadded = this.privateKey.bn.toBuffer();
    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);
  } else if (hardened) {
    // This will use a 32 byte zero padded serialization of the private key
    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});
    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');
    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);
  } else {
    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
  }
  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
  var leftPart = BN.fromBuffer(hash.slice(0, 32), {
    size: 32
  });
  var chainCode = hash.slice(32, 64);

  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({
    size: 32
  });

  if (!PrivateKey.isValid(privateKey)) {
    // Index at this point is already hardened, we can pass null as the hardened arg
    return this._deriveWithNumber(index + 1, null, nonCompliant);
  }

  var derived = new HDPrivateKey({
    network: this.network,
    depth: this.depth + 1,
    parentFingerPrint: this.fingerPrint,
    childIndex: index,
    chainCode: chainCode,
    privateKey: privateKey
  });

  return derived;
};

HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {
  if (!HDPrivateKey.isValidPath(path)) {
    throw new hdErrors.InvalidPath(path);
  }

  var indexes = HDPrivateKey._getDerivationIndexes(path);
  var derived = indexes.reduce(function(prev, index) {
    return prev._deriveWithNumber(index, null, nonCompliant);
  }, this);

  return derived;
};

/**
 * Verifies that a given serialized private key in base58 with checksum format
 * is valid.
 *
 * @param {string|Buffer} data - the serialized private key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {boolean}
 */
HDPrivateKey.isValidSerialized = function(data, network) {
  return !HDPrivateKey.getSerializedError(data, network);
};

/**
 * Checks what's the error that causes the validation of a serialized private key
 * in base58 with checksum to fail.
 *
 * @param {string|Buffer} data - the serialized private key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {errors.InvalidArgument|null}
 */
HDPrivateKey.getSerializedError = function(data, network) {
  /* jshint maxcomplexity: 10 */
  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
    return new hdErrors.UnrecognizedArgument('Expected string or buffer');
  }
  if (!Base58.validCharacters(data)) {
    return new errors.InvalidB58Char('(unknown)', data);
  }
  try {
    data = Base58Check.decode(data);
  } catch (e) {
    return new errors.InvalidB58Checksum(data);
  }
  if (data.length !== HDPrivateKey.DataLength) {
    return new hdErrors.InvalidLength(data);
  }
  if (!_.isUndefined(network)) {
    var error = HDPrivateKey._validateNetwork(data, network);
    if (error) {
      return error;
    }
  }
  return null;
};

HDPrivateKey._validateNetwork = function(data, networkArg) {
  var network = Network.get(networkArg);
  if (!network) {
    return new errors.InvalidNetworkArgument(networkArg);
  }
  var version = data.slice(0, 4);
  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {
    return new errors.InvalidNetwork(version);
  }
  return null;
};

HDPrivateKey.fromString = function(arg) {
  $.checkArgument(_.isString(arg), 'No valid string was provided');
  return new HDPrivateKey(arg);
};

HDPrivateKey.fromObject = function(arg) {
  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
  return new HDPrivateKey(arg);
};

HDPrivateKey.prototype._buildFromJSON = function(arg) {
  return this._buildFromObject(JSON.parse(arg));
};

HDPrivateKey.prototype._buildFromObject = function(arg) {
  /* jshint maxcomplexity: 12 */
  // TODO: Type validation
  var buffers = {
    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,
    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,
    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined
  };
  return this._buildFromBuffers(buffers);
};

HDPrivateKey.prototype._buildFromSerialized = function(arg) {
  var decoded = Base58Check.decode(arg);
  var buffers = {
    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,
      HDPrivateKey.ParentFingerPrintEnd),
    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
    xprivkey: arg
  };
  return this._buildFromBuffers(buffers);
};

HDPrivateKey.prototype._generateRandomly = function(network) {
  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);
};

/**
 * Generate a private key from a seed, as described in BIP32
 *
 * @param {string|Buffer} hexa
 * @param {*} network
 * @return HDPrivateKey
 */
HDPrivateKey.fromSeed = function(hexa, network) {
  /* jshint maxcomplexity: 8 */
  if (JSUtil.isHexaString(hexa)) {
    hexa = Buffer.from(hexa, 'hex');
  }
  if (!Buffer.isBuffer(hexa)) {
    throw new hdErrors.InvalidEntropyArgument(hexa);
  }
  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
  }
  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
  }
  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));

  return new HDPrivateKey({
    network: Network.get(network) || Network.defaultNetwork,
    depth: 0,
    parentFingerPrint: 0,
    childIndex: 0,
    privateKey: hash.slice(0, 32),
    chainCode: hash.slice(32, 64)
  });
};



HDPrivateKey.prototype._calcHDPublicKey = function() {
  if (!this._hdPublicKey) {
    var HDPublicKey = __webpack_require__(862);
    this._hdPublicKey = new HDPublicKey(this);
  }
};

/**
 * Receives a object with buffers in all the properties and populates the
 * internal structure
 *
 * @param {Object} arg
 * @param {buffer.Buffer} arg.version
 * @param {buffer.Buffer} arg.depth
 * @param {buffer.Buffer} arg.parentFingerPrint
 * @param {buffer.Buffer} arg.childIndex
 * @param {buffer.Buffer} arg.chainCode
 * @param {buffer.Buffer} arg.privateKey
 * @param {buffer.Buffer} arg.checksum
 * @param {string=} arg.xprivkey - if set, don't recalculate the base58
 *      representation
 * @return {HDPrivateKey} this
 */
HDPrivateKey.prototype._buildFromBuffers = function(arg) {
  /* jshint maxcomplexity: 8 */
  /* jshint maxstatements: 20 */

  HDPrivateKey._validateBufferArguments(arg);

  JSUtil.defineImmutable(this, {
    _buffers: arg
  });

  var sequence = [
    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
    BufferUtil.emptyBuffer(1), arg.privateKey
  ];
  var concat = buffer.Buffer.concat(sequence);
  if (!arg.checksum || !arg.checksum.length) {
    arg.checksum = Base58Check.checksum(concat);
  } else {
    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {
      throw new errors.InvalidB58Checksum(concat);
    }
  }

  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
  var xprivkey;
  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));
  arg.xprivkey = Buffer.from(xprivkey);

  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);
  var publicKey = privateKey.toPublicKey();
  var size = HDPrivateKey.ParentFingerPrintSize;
  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

  JSUtil.defineImmutable(this, {
    xprivkey: xprivkey,
    network: network,
    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
    privateKey: privateKey,
    publicKey: publicKey,
    fingerPrint: fingerPrint
  });

  this._hdPublicKey = null;

  Object.defineProperty(this, 'hdPublicKey', {
    configurable: false,
    enumerable: true,
    get: function() {
      this._calcHDPublicKey();
      return this._hdPublicKey;
    }
  });
  Object.defineProperty(this, 'xpubkey', {
    configurable: false,
    enumerable: true,
    get: function() {
      this._calcHDPublicKey();
      return this._hdPublicKey.xpubkey;
    }
  });
  return this;
};

HDPrivateKey._validateBufferArguments = function(arg) {
  var checkBuffer = function(name, size) {
    var buff = arg[name];
    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');
    assert(
      buff.length === size,
      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
    );
  };
  checkBuffer('version', HDPrivateKey.VersionSize);
  checkBuffer('depth', HDPrivateKey.DepthSize);
  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);
  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);
  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);
  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);
  if (arg.checksum && arg.checksum.length) {
    checkBuffer('checksum', HDPrivateKey.CheckSumSize);
  }
};

/**
 * Returns the string representation of this private key (a string starting
 * with "xprv..."
 *
 * @return string
 */
HDPrivateKey.prototype.toString = function() {
  return this.xprivkey;
};

/**
 * Returns the console representation of this extended private key.
 * @return string
 */
HDPrivateKey.prototype.inspect = function() {
  return '<HDPrivateKey: ' + this.xprivkey + '>';
};

/**
 * Returns a plain object with a representation of this private key.
 *
 * Fields include:<ul>
 * <li> network: either 'livenet' or 'testnet'
 * <li> depth: a number ranging from 0 to 255
 * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the
 * <li>     associated public key
 * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash
 * <li>     of this parent's associated public key or zero.
 * <li> childIndex: the index from which this child was derived (or zero)
 * <li> chainCode: an hexa string representing a number used in the derivation
 * <li> privateKey: the private key associated, in hexa representation
 * <li> xprivkey: the representation of this extended private key in checksum
 * <li>     base58 format
 * <li> checksum: the base58 checksum of xprivkey
 * </ul>
 *  @return {Object}
 */
HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {
  return {
    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,
    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
    privateKey: this.privateKey.toBuffer().toString('hex'),
    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
    xprivkey: this.xprivkey
  };
};

/**
 * Build a HDPrivateKey from a buffer
 *
 * @param {Buffer} arg
 * @return {HDPrivateKey}
 */
HDPrivateKey.fromBuffer = function(arg) {
  return new HDPrivateKey(arg.toString());
};

/**
 * Returns a buffer representation of the HDPrivateKey
 *
 * @return {string}
 */
HDPrivateKey.prototype.toBuffer = function() {
  return BufferUtil.copy(this._buffers.xprivkey);
};

HDPrivateKey.DefaultDepth = 0;
HDPrivateKey.DefaultFingerprint = 0;
HDPrivateKey.DefaultChildIndex = 0;
HDPrivateKey.Hardened = 0x80000000;
HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;

HDPrivateKey.RootElementAlias = ['m', 'M', 'm\'', 'M\''];

HDPrivateKey.VersionSize = 4;
HDPrivateKey.DepthSize = 1;
HDPrivateKey.ParentFingerPrintSize = 4;
HDPrivateKey.ChildIndexSize = 4;
HDPrivateKey.ChainCodeSize = 32;
HDPrivateKey.PrivateKeySize = 32;
HDPrivateKey.CheckSumSize = 4;

HDPrivateKey.DataLength = 78;
HDPrivateKey.SerializedByteSize = 82;

HDPrivateKey.VersionStart = 0;
HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;

assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);

module.exports = HDPrivateKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 862:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(35);

var BN = __webpack_require__(73);
var Base58 = __webpack_require__(352);
var Base58Check = __webpack_require__(267);
var Hash = __webpack_require__(74);
var HDPrivateKey = __webpack_require__(861);
var Network = __webpack_require__(199);
var Point = __webpack_require__(216);
var PublicKey = __webpack_require__(139);

var bitcoreErrors = __webpack_require__(115);
var errors = bitcoreErrors;
var hdErrors = bitcoreErrors.HDPublicKey;
var assert = __webpack_require__(12);

var JSUtil = __webpack_require__(59);
var BufferUtil = __webpack_require__(48);

/**
 * The representation of an hierarchically derived public key.
 *
 * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
 *
 * @constructor
 * @param {Object|string|Buffer} arg
 */
function HDPublicKey(arg) {
  /* jshint maxcomplexity: 12 */
  /* jshint maxstatements: 20 */
  if (arg instanceof HDPublicKey) {
    return arg;
  }
  if (!(this instanceof HDPublicKey)) {
    return new HDPublicKey(arg);
  }
  if (arg) {
    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
      var error = HDPublicKey.getSerializedError(arg);
      if (!error) {
        return this._buildFromSerialized(arg);
      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
        return this._buildFromSerialized(arg.toString());
      } else {
        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
          return new HDPrivateKey(arg).hdPublicKey;
        }
        throw error;
      }
    } else {
      if (_.isObject(arg)) {
        if (arg instanceof HDPrivateKey) {
          return this._buildFromPrivate(arg);
        } else {
          return this._buildFromObject(arg);
        }
      } else {
        throw new hdErrors.UnrecognizedArgument(arg);
      }
    }
  } else {
    throw new hdErrors.MustSupplyArgument();
  }
}

/**
 * Verifies that a given path is valid.
 *
 * @param {string|number} arg
 * @return {boolean}
 */
HDPublicKey.isValidPath = function(arg) {
  if (_.isString(arg)) {
    var indexes = HDPrivateKey._getDerivationIndexes(arg);
    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);
  }

  if (_.isNumber(arg)) {
    return arg >= 0 && arg < HDPublicKey.Hardened;
  }

  return false;
};

/**
 * WARNING: This method is deprecated. Use deriveChild instead.
 *
 *
 * Get a derivated child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same public key), "m/0/1/40/2/1000".
 *
 * Note that hardened keys can't be derived from a public extended key.
 *
 * If the first argument is a number, the child with that index will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPublicKey('xpub...');
 * var child_0_1_2 = parent.derive(0).derive(1).derive(2);
 * var copy_of_child_0_1_2 = parent.derive("m/0/1/2");
 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
 * ```
 *
 * @param {string|number} arg
 */
HDPublicKey.prototype.derive = function(arg, hardened) {
  return this.deriveChild(arg, hardened);
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Get a derivated child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same public key), "m/0/1/40/2/1000".
 *
 * Note that hardened keys can't be derived from a public extended key.
 *
 * If the first argument is a number, the child with that index will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPublicKey('xpub...');
 * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);
 * var copy_of_child_0_1_2 = parent.deriveChild("m/0/1/2");
 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
 * ```
 *
 * @param {string|number} arg
 */
HDPublicKey.prototype.deriveChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

HDPublicKey.prototype._deriveWithNumber = function(index, hardened) {
  if (index >= HDPublicKey.Hardened || hardened) {
    throw new hdErrors.InvalidIndexCantDeriveHardened();
  }
  if (index < 0) {
    throw new hdErrors.InvalidPath(index);
  }

  var indexBuffer = BufferUtil.integerAsBuffer(index);
  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});
  var chainCode = hash.slice(32, 64);

  var publicKey;
  try {
    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));
  } catch (e) {
    return this._deriveWithNumber(index + 1);
  }

  var derived = new HDPublicKey({
    network: this.network,
    depth: this.depth + 1,
    parentFingerPrint: this.fingerPrint,
    childIndex: index,
    chainCode: chainCode,
    publicKey: publicKey
  });

  return derived;
};

HDPublicKey.prototype._deriveFromString = function(path) {
  /* jshint maxcomplexity: 8 */
  if (_.includes(path, "'")) {
    throw new hdErrors.InvalidIndexCantDeriveHardened();
  } else if (!HDPublicKey.isValidPath(path)) {
    throw new hdErrors.InvalidPath(path);
  }

  var indexes = HDPrivateKey._getDerivationIndexes(path);
  var derived = indexes.reduce(function(prev, index) {
    return prev._deriveWithNumber(index);
  }, this);

  return derived;
};

/**
 * Verifies that a given serialized public key in base58 with checksum format
 * is valid.
 *
 * @param {string|Buffer} data - the serialized public key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {boolean}
 */
HDPublicKey.isValidSerialized = function(data, network) {
  return _.isNull(HDPublicKey.getSerializedError(data, network));
};

/**
 * Checks what's the error that causes the validation of a serialized public key
 * in base58 with checksum to fail.
 *
 * @param {string|Buffer} data - the serialized public key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {errors|null}
 */
HDPublicKey.getSerializedError = function(data, network) {
  /* jshint maxcomplexity: 10 */
  /* jshint maxstatements: 20 */
  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
    return new hdErrors.UnrecognizedArgument('expected buffer or string');
  }
  if (!Base58.validCharacters(data)) {
    return new errors.InvalidB58Char('(unknown)', data);
  }
  try {
    data = Base58Check.decode(data);
  } catch (e) {
    return new errors.InvalidB58Checksum(data);
  }
  if (data.length !== HDPublicKey.DataSize) {
    return new hdErrors.InvalidLength(data);
  }
  if (!_.isUndefined(network)) {
    var error = HDPublicKey._validateNetwork(data, network);
    if (error) {
      return error;
    }
  }
  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));
  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {
    return new hdErrors.ArgumentIsPrivateExtended();
  }
  return null;
};

HDPublicKey._validateNetwork = function(data, networkArg) {
  var network = Network.get(networkArg);
  if (!network) {
    return new errors.InvalidNetworkArgument(networkArg);
  }
  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {
    return new errors.InvalidNetwork(version);
  }
  return null;
};

HDPublicKey.prototype._buildFromPrivate = function (arg) {
  var args = _.clone(arg._buffers);
  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));
  args.publicKey = Point.pointToCompressed(point);
  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);
  args.privateKey = undefined;
  args.checksum = undefined;
  args.xprivkey = undefined;
  return this._buildFromBuffers(args);
};

HDPublicKey.prototype._buildFromObject = function(arg) {
  /* jshint maxcomplexity: 10 */
  // TODO: Type validation
  var buffers = {
    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,
    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :
      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum
  };
  return this._buildFromBuffers(buffers);
};

HDPublicKey.prototype._buildFromSerialized = function(arg) {
  var decoded = Base58Check.decode(arg);
  var buffers = {
    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,
                                     HDPublicKey.ParentFingerPrintEnd),
    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
    xpubkey: arg
  };
  return this._buildFromBuffers(buffers);
};

/**
 * Receives a object with buffers in all the properties and populates the
 * internal structure
 *
 * @param {Object} arg
 * @param {buffer.Buffer} arg.version
 * @param {buffer.Buffer} arg.depth
 * @param {buffer.Buffer} arg.parentFingerPrint
 * @param {buffer.Buffer} arg.childIndex
 * @param {buffer.Buffer} arg.chainCode
 * @param {buffer.Buffer} arg.publicKey
 * @param {buffer.Buffer} arg.checksum
 * @param {string=} arg.xpubkey - if set, don't recalculate the base58
 *      representation
 * @return {HDPublicKey} this
 */
HDPublicKey.prototype._buildFromBuffers = function(arg) {
  /* jshint maxcomplexity: 8 */
  /* jshint maxstatements: 20 */

  HDPublicKey._validateBufferArguments(arg);

  JSUtil.defineImmutable(this, {
    _buffers: arg
  });

  var sequence = [
    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
    arg.publicKey
  ];
  var concat = BufferUtil.concat(sequence);
  var checksum = Base58Check.checksum(concat);
  if (!arg.checksum || !arg.checksum.length) {
    arg.checksum = checksum;
  } else {
    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {
      throw new errors.InvalidB58Checksum(concat, checksum);
    }
  }
  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));

  var xpubkey;
  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));
  arg.xpubkey = Buffer.from(xpubkey);

  var publicKey = new PublicKey(arg.publicKey, {network: network});
  var size = HDPublicKey.ParentFingerPrintSize;
  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

  JSUtil.defineImmutable(this, {
    xpubkey: xpubkey,
    network: network,
    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
    publicKey: publicKey,
    fingerPrint: fingerPrint
  });

  return this;
};

HDPublicKey._validateBufferArguments = function(arg) {
  var checkBuffer = function(name, size) {
    var buff = arg[name];
    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\'s ' + typeof buff);
    assert(
      buff.length === size,
      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
    );
  };
  checkBuffer('version', HDPublicKey.VersionSize);
  checkBuffer('depth', HDPublicKey.DepthSize);
  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);
  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);
  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);
  checkBuffer('publicKey', HDPublicKey.PublicKeySize);
  if (arg.checksum && arg.checksum.length) {
    checkBuffer('checksum', HDPublicKey.CheckSumSize);
  }
};

HDPublicKey.fromString = function(arg) {
  $.checkArgument(_.isString(arg), 'No valid string was provided');
  return new HDPublicKey(arg);
};

HDPublicKey.fromObject = function(arg) {
  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
  return new HDPublicKey(arg);
};

/**
 * Returns the base58 checked representation of the public key
 * @return {string} a string starting with "xpub..." in livenet
 */
HDPublicKey.prototype.toString = function() {
  return this.xpubkey;
};

/**
 * Returns the console representation of this extended public key.
 * @return string
 */
HDPublicKey.prototype.inspect = function() {
  return '<HDPublicKey: ' + this.xpubkey + '>';
};

/**
 * Returns a plain JavaScript object with information to reconstruct a key.
 *
 * Fields are: <ul>
 *  <li> network: 'livenet' or 'testnet'
 *  <li> depth: a number from 0 to 255, the depth to the master extended key
 *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key
 *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's
 *  <li>     parent's public key
 *  <li> childIndex: index with which this key was derived
 *  <li> chainCode: string in hexa encoding used for derivation
 *  <li> publicKey: string, hexa encoded, in compressed key format
 *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
 *  <li> xpubkey: the string with the base58 representation of this extended key
 *  <li> checksum: the base58 checksum of xpubkey
 * </ul>
 */
HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {
  return {
    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
    publicKey: this.publicKey.toString(),
    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
    xpubkey: this.xpubkey
  };
};

/**
 * Create a HDPublicKey from a buffer argument
 *
 * @param {Buffer} arg
 * @return {HDPublicKey}
 */
HDPublicKey.fromBuffer = function(arg) {
  return new HDPublicKey(arg);
};

/**
 * Return a buffer representation of the xpubkey
 *
 * @return {Buffer}
 */
HDPublicKey.prototype.toBuffer = function() {
  return BufferUtil.copy(this._buffers.xpubkey);
};

HDPublicKey.Hardened = 0x80000000;
HDPublicKey.RootElementAlias = ['m', 'M'];

HDPublicKey.VersionSize = 4;
HDPublicKey.DepthSize = 1;
HDPublicKey.ParentFingerPrintSize = 4;
HDPublicKey.ChildIndexSize = 4;
HDPublicKey.ChainCodeSize = 32;
HDPublicKey.PublicKeySize = 33;
HDPublicKey.CheckSumSize = 4;

HDPublicKey.DataSize = 78;
HDPublicKey.SerializedByteSize = 82;

HDPublicKey.VersionStart           = 0;
HDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
HDPublicKey.DepthStart             = HDPublicKey.VersionEnd;
HDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
HDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
HDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;
HDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
HDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;
HDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
HDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;
HDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
HDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;
HDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;

assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);

module.exports = HDPublicKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 863:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var Address = __webpack_require__(142);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var Hash = __webpack_require__(76);
var Opcode = __webpack_require__(464);
var PublicKey = __webpack_require__(141);
var Signature = __webpack_require__(105);
var Networks = __webpack_require__(200);
var $ = __webpack_require__(36);
var _ = __webpack_require__(1);
var errors = __webpack_require__(116);
var buffer = __webpack_require__(2);
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);

/**
 * A bitcoin transaction script. Each transaction's inputs and outputs
 * has a script that is evaluated to validate it's spending.
 *
 * See https://en.bitcoin.it/wiki/Script
 *
 * @constructor
 * @param {Object|string|Buffer=} from optional data to populate script
 */
var Script = function Script(from) {
  if (!(this instanceof Script)) {
    return new Script(from);
  }
  this.chunks = [];

  if (BufferUtil.isBuffer(from)) {
    return Script.fromBuffer(from);
  } else if (from instanceof Address) {
    return Script.fromAddress(from);
  } else if (from instanceof Script) {
    return Script.fromBuffer(from.toBuffer());
  } else if (_.isString(from)) {
    return Script.fromString(from);
  } else if (_.isObject(from) && _.isArray(from.chunks)) {
    this.set(from);
  }
};

Script.prototype.set = function(obj) {
  $.checkArgument(_.isObject(obj));
  $.checkArgument(_.isArray(obj.chunks));
  this.chunks = obj.chunks;
  return this;
};

Script.fromBuffer = function(buffer) {
  var script = new Script();
  script.chunks = [];

  var br = new BufferReader(buffer);
  while (!br.finished()) {
    try {
      var opcodenum = br.readUInt8();

      var len, buf;
      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
        len = opcodenum;
        script.chunks.push({
          buf: br.read(len),
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
        len = br.readUInt8();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
        len = br.readUInt16LE();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
        len = br.readUInt32LE();
        buf = br.read(len);
        script.chunks.push({
          buf: buf,
          len: len,
          opcodenum: opcodenum
        });
      } else {
        script.chunks.push({
          opcodenum: opcodenum
        });
      }
    } catch (e) {
      if (e instanceof RangeError) {
        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));
      }
      throw e;
    }
  }

  return script;
};

Script.prototype.toBuffer = function() {
  var bw = new BufferWriter();

  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    var opcodenum = chunk.opcodenum;
    bw.writeUInt8(chunk.opcodenum);
    if (chunk.buf) {
      if (opcodenum < Opcode.OP_PUSHDATA1) {
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
        bw.writeUInt8(chunk.len);
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
        bw.writeUInt16LE(chunk.len);
        bw.write(chunk.buf);
      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
        bw.writeUInt32LE(chunk.len);
        bw.write(chunk.buf);
      }
    }
  }

  return bw.concat();
};

Script.fromASM = function(str) {
  var script = new Script();
  script.chunks = [];

  var tokens = str.split(' ');
  var i = 0;
  while (i < tokens.length) {
    var token = tokens[i];
    var opcode = Opcode(token);
    var opcodenum = opcode.toNumber();

    if (_.isUndefined(opcodenum)) {
      var buf = Buffer.from(tokens[i], 'hex');
      script.chunks.push({
        buf: buf,
        len: buf.length,
        opcodenum: buf.length
      });
      i = i + 1;
    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      script.chunks.push({
        buf: Buffer.from(tokens[i + 2], 'hex'),
        len: parseInt(tokens[i + 1]),
        opcodenum: opcodenum
      });
      i = i + 3;
    } else {
      script.chunks.push({
        opcodenum: opcodenum
      });
      i = i + 1;
    }
  }
  return script;
};

Script.fromHex = function(str) {
  return new Script(Buffer.from(str, 'hex'));
};

Script.fromString = function(str) {
  if (JSUtil.isHexa(str) || str.length === 0) {
    return new Script(Buffer.from(str, 'hex'));
  }
  var script = new Script();
  script.chunks = [];

  var tokens = str.split(' ');
  var i = 0;
  while (i < tokens.length) {
    var token = tokens[i];
    var opcode = Opcode(token);
    var opcodenum = opcode.toNumber();

    if (_.isUndefined(opcodenum)) {
      opcodenum = parseInt(token);
      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
        script.chunks.push({
          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),
          len: opcodenum,
          opcodenum: opcodenum
        });
        i = i + 2;
      } else {
        throw new Error('Invalid script: ' + JSON.stringify(str));
      }
    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      if (tokens[i + 2].slice(0, 2) !== '0x') {
        throw new Error('Pushdata data must start with 0x');
      }
      script.chunks.push({
        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),
        len: parseInt(tokens[i + 1]),
        opcodenum: opcodenum
      });
      i = i + 3;
    } else {
      script.chunks.push({
        opcodenum: opcodenum
      });
      i = i + 1;
    }
  }
  return script;
};

Script.prototype._chunkToString = function(chunk, type) {
  var opcodenum = chunk.opcodenum;
  var asm = (type === 'asm');
  var str = '';
  if (!chunk.buf) {
    // no data chunk
    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {
      if (asm) {
        // A few cases where the opcode name differs from reverseMap
        // aside from 1 to 16 data pushes.
        if (opcodenum === 0) {
          // OP_0 -> 0
          str = str + ' 0';
        } else if(opcodenum === 79) {
          // OP_1NEGATE -> 1
          str = str + ' -1';
        } else {
          str = str + ' ' + Opcode(opcodenum).toString();
        }
      } else {
        str = str + ' ' + Opcode(opcodenum).toString();
      }
    } else {
      var numstr = opcodenum.toString(16);
      if (numstr.length % 2 !== 0) {
        numstr = '0' + numstr;
      }
      if (asm) {
        str = str + ' ' + numstr;
      } else {
        str = str + ' ' + '0x' + numstr;
      }
    }
  } else {
    // data chunk
    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||
      opcodenum === Opcode.OP_PUSHDATA2 ||
      opcodenum === Opcode.OP_PUSHDATA4) {
      str = str + ' ' + Opcode(opcodenum).toString();
    }
    if (chunk.len > 0) {
      if (asm) {
        str = str + ' ' + chunk.buf.toString('hex');
      } else {
        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');
      }
    }
  }
  return str;
};

Script.prototype.toASM = function() {
  var str = '';
  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    str += this._chunkToString(chunk, 'asm');
  }

  return str.substr(1);
};

Script.prototype.toString = function() {
  var str = '';
  for (var i = 0; i < this.chunks.length; i++) {
    var chunk = this.chunks[i];
    str += this._chunkToString(chunk);
  }

  return str.substr(1);
};

Script.prototype.toHex = function() {
  return this.toBuffer().toString('hex');
};

Script.prototype.inspect = function() {
  return '<Script: ' + this.toString() + '>';
};

// script classification methods

/**
 * @returns {boolean} if this is a pay to pubkey hash output script
 */
Script.prototype.isPublicKeyHashOut = function() {
  return !!(this.chunks.length === 5 &&
    this.chunks[0].opcodenum === Opcode.OP_DUP &&
    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&
    this.chunks[2].buf &&
    this.chunks[2].buf.length === 20 &&
    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&
    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);
};

/**
 * @returns {boolean} if this is a pay to public key hash input script
 */
Script.prototype.isPublicKeyHashIn = function() {
  if (this.chunks.length === 2) {
    var signatureBuf = this.chunks[0].buf;
    var pubkeyBuf = this.chunks[1].buf;
    if (signatureBuf &&
        signatureBuf.length &&
        signatureBuf[0] === 0x30 &&
        pubkeyBuf &&
        pubkeyBuf.length
       ) {
      var version = pubkeyBuf[0];
      if ((version === 0x04 ||
           version === 0x06 ||
           version === 0x07) && pubkeyBuf.length === 65) {
        return true;
      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
        return true;
      }
    }
  }
  return false;
};

Script.prototype.getPublicKey = function() {
  $.checkState(this.isPublicKeyOut(), 'Can\'t retrieve PublicKey from a non-PK output');
  return this.chunks[0].buf;
};

Script.prototype.getPublicKeyHash = function() {
  if (this.isPublicKeyHashOut()) {
    return this.chunks[2].buf;
  } else if (this.isWitnessPublicKeyHashOut()) {
    return this.chunks[1].buf;
  } else {
    throw new Error('Can\'t retrieve PublicKeyHash from a non-PKH output');
  }
};

/**
 * @returns {boolean} if this is a public key output script
 */
Script.prototype.isPublicKeyOut = function() {
  if (this.chunks.length === 2 &&
      this.chunks[0].buf &&
      this.chunks[0].buf.length &&
      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {
    var pubkeyBuf = this.chunks[0].buf;
    var version = pubkeyBuf[0];
    var isVersion = false;
    if ((version === 0x04 ||
         version === 0x06 ||
         version === 0x07) && pubkeyBuf.length === 65) {
      isVersion = true;
    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {
      isVersion = true;
    }
    if (isVersion) {
      return PublicKey.isValid(pubkeyBuf);
    }
  }
  return false;
};

/**
 * @returns {boolean} if this is a pay to public key input script
 */
Script.prototype.isPublicKeyIn = function() {
  if (this.chunks.length === 1) {
    var signatureBuf = this.chunks[0].buf;
    if (signatureBuf &&
        signatureBuf.length &&
        signatureBuf[0] === 0x30) {
      return true;
    }
  }
  return false;
};

/**
 * @returns {boolean} if this is a p2sh output script
 */
Script.prototype.isScriptHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 23 &&
    buf[0] === Opcode.OP_HASH160 &&
    buf[1] === 0x14 &&
    buf[buf.length - 1] === Opcode.OP_EQUAL);
};

/**
 * @returns {boolean} if this is a p2wsh output script
 */
Script.prototype.isWitnessScriptHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 34 && buf[0] === 0 && buf[1] === 32);
};

/**
 * @returns {boolean} if this is a p2wpkh output script
 */
Script.prototype.isWitnessPublicKeyHashOut = function() {
  var buf = this.toBuffer();
  return (buf.length === 22 && buf[0] === 0 && buf[1] === 20);
};

/**
 * @param {Object=} values - The return values
 * @param {Number} values.version - Set with the witness version
 * @param {Buffer} values.program - Set with the witness program
 * @returns {boolean} if this is a p2wpkh output script
 */
Script.prototype.isWitnessProgram = function(values) {
  if (!values) {
    values = {};
  }
  var buf = this.toBuffer();
  if (buf.length < 4 || buf.length > 42) {
    return false;
  }
  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {
    return false;
  }

  if (buf.length === buf[1] + 2) {
    values.version = buf[0];
    values.program = buf.slice(2, buf.length);
    return true;
  }

  return false;
};

/**
 * @returns {boolean} if this is a p2sh input script
 * Note that these are frequently indistinguishable from pubkeyhashin
 */
Script.prototype.isScriptHashIn = function() {
  if (this.chunks.length <= 1) {
    return false;
  }
  var redeemChunk = this.chunks[this.chunks.length - 1];
  var redeemBuf = redeemChunk.buf;
  if (!redeemBuf) {
    return false;
  }

  var redeemScript;
  try {
    redeemScript = Script.fromBuffer(redeemBuf);
  } catch (e) {
    if (e instanceof errors.Script.InvalidBuffer) {
      return false;
    }
    throw e;
  }
  var type = redeemScript.classify();
  return type !== Script.types.UNKNOWN;
};

/**
 * @returns {boolean} if this is a mutlsig output script
 */
Script.prototype.isMultisigOut = function() {
  return (this.chunks.length > 3 &&
    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&
    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
      return obj.buf && BufferUtil.isBuffer(obj.buf);
    }) &&
    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&
    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);
};


/**
 * @returns {boolean} if this is a multisig input script
 */
Script.prototype.isMultisigIn = function() {
  return this.chunks.length >= 2 &&
    this.chunks[0].opcodenum === 0 &&
    this.chunks.slice(1, this.chunks.length).every(function(obj) {
      return obj.buf &&
        BufferUtil.isBuffer(obj.buf) &&
        Signature.isTxDER(obj.buf);
    });
};

/**
 * @returns {boolean} true if this is a valid standard OP_RETURN output
 */
Script.prototype.isDataOut = function() {
  return this.chunks.length >= 1 &&
    this.chunks[0].opcodenum === Opcode.OP_RETURN &&
    (this.chunks.length === 1 ||
      (this.chunks.length === 2 &&
        this.chunks[1].buf &&
        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&
        this.chunks[1].length === this.chunks.len));
};

/**
 * Retrieve the associated data for this script.
 * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.
 * In the case of a standard OP_RETURN, return the data
 * @returns {Buffer}
 */
Script.prototype.getData = function() {
  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut()) {
    if (_.isUndefined(this.chunks[1])) {
      return Buffer.alloc(0);
    } else {
      return Buffer.from(this.chunks[1].buf);
    }
  }
  if (this.isPublicKeyHashOut()) {
    return Buffer.from(this.chunks[2].buf);
  }
  throw new Error('Unrecognized script type to get data from');
};

/**
 * @returns {boolean} if the script is only composed of data pushing
 * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)
 */
Script.prototype.isPushOnly = function() {
  return _.every(this.chunks, function(chunk) {
    return chunk.opcodenum <= Opcode.OP_16;
  });
};


Script.types = {};
Script.types.UNKNOWN = 'Unknown';
Script.types.PUBKEY_OUT = 'Pay to public key';
Script.types.PUBKEY_IN = 'Spend from public key';
Script.types.PUBKEYHASH_OUT = 'Pay to public key hash';
Script.types.PUBKEYHASH_IN = 'Spend from public key hash';
Script.types.SCRIPTHASH_OUT = 'Pay to script hash';
Script.types.SCRIPTHASH_IN = 'Spend from script hash';
Script.types.MULTISIG_OUT = 'Pay to multisig';
Script.types.MULTISIG_IN = 'Spend from multisig';
Script.types.DATA_OUT = 'Data push';

Script.OP_RETURN_STANDARD_SIZE = 80;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classify = function() {
  if (this._isInput) {
    return this.classifyInput();
  } else if (this._isOutput) {
    return this.classifyOutput();
  } else {
    var outputType = this.classifyOutput();
    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();
  }
};

Script.outputIdentifiers = {};
Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classifyOutput = function() {
  for (var type in Script.outputIdentifiers) {
    if (Script.outputIdentifiers[type].bind(this)()) {
      return Script.types[type];
    }
  }
  return Script.types.UNKNOWN;
};

Script.inputIdentifiers = {};
Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;

/**
 * @returns {object} The Script type if it is a known form,
 * or Script.UNKNOWN if it isn't
 */
Script.prototype.classifyInput = function() {
  for (var type in Script.inputIdentifiers) {
    if (Script.inputIdentifiers[type].bind(this)()) {
      return Script.types[type];
    }
  }
  return Script.types.UNKNOWN;
};


/**
 * @returns {boolean} if script is one of the known types
 */
Script.prototype.isStandard = function() {
  // TODO: Add BIP62 compliance
  return this.classify() !== Script.types.UNKNOWN;
};


// Script construction methods

/**
 * Adds a script element at the start of the script.
 * @param {*} obj a string, number, Opcode, Buffer, or object to add
 * @returns {Script} this script instance
 */
Script.prototype.prepend = function(obj) {
  this._addByType(obj, true);
  return this;
};

/**
 * Compares a script with another script
 */
Script.prototype.equals = function(script) {
  $.checkState(script instanceof Script, 'Must provide another script');
  if (this.chunks.length !== script.chunks.length) {
    return false;
  }
  var i;
  for (i = 0; i < this.chunks.length; i++) {
    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {
      return false;
    }
    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {
      return false;
    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {
      return false;
    }
  }
  return true;
};

/**
 * Adds a script element to the end of the script.
 *
 * @param {*} obj a string, number, Opcode, Buffer, or object to add
 * @returns {Script} this script instance
 *
 */
Script.prototype.add = function(obj) {
  this._addByType(obj, false);
  return this;
};

Script.prototype._addByType = function(obj, prepend) {
  if (typeof obj === 'string') {
    this._addOpcode(obj, prepend);
  } else if (typeof obj === 'number') {
    this._addOpcode(obj, prepend);
  } else if (obj instanceof Opcode) {
    this._addOpcode(obj, prepend);
  } else if (BufferUtil.isBuffer(obj)) {
    this._addBuffer(obj, prepend);
  } else if (obj instanceof Script) {
    this.chunks = this.chunks.concat(obj.chunks);
  } else if (typeof obj === 'object') {
    this._insertAtPosition(obj, prepend);
  } else {
    throw new Error('Invalid script chunk');
  }
};

Script.prototype._insertAtPosition = function(op, prepend) {
  if (prepend) {
    this.chunks.unshift(op);
  } else {
    this.chunks.push(op);
  }
};

Script.prototype._addOpcode = function(opcode, prepend) {
  var op;
  if (typeof opcode === 'number') {
    op = opcode;
  } else if (opcode instanceof Opcode) {
    op = opcode.toNumber();
  } else {
    op = Opcode(opcode).toNumber();
  }
  this._insertAtPosition({
    opcodenum: op
  }, prepend);
  return this;
};

Script.prototype._addBuffer = function(buf, prepend) {
  var opcodenum;
  var len = buf.length;
  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
    opcodenum = len;
  } else if (len < Math.pow(2, 8)) {
    opcodenum = Opcode.OP_PUSHDATA1;
  } else if (len < Math.pow(2, 16)) {
    opcodenum = Opcode.OP_PUSHDATA2;
  } else if (len < Math.pow(2, 32)) {
    opcodenum = Opcode.OP_PUSHDATA4;
  } else {
    throw new Error('You can\'t push that much data');
  }
  this._insertAtPosition({
    buf: buf,
    len: len,
    opcodenum: opcodenum
  }, prepend);
  return this;
};

Script.prototype.hasCodeseparators = function() {
  for (var i = 0; i < this.chunks.length; i++) {
    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {
      return true;
    }
  }
  return false;
};

Script.prototype.removeCodeseparators = function() {
  var chunks = [];
  for (var i = 0; i < this.chunks.length; i++) {
    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
      chunks.push(this.chunks[i]);
    }
  }
  this.chunks = chunks;
  return this;
};

// high level script builder methods

/**
 * @returns {Script} a new Multisig output script for given public keys,
 * requiring m of those public keys to spend
 * @param {PublicKey[]} publicKeys - list of all public keys controlling the output
 * @param {number} threshold - amount of required signatures to spend the output
 * @param {Object=} opts - Several options:
 *        - noSorting: defaults to false, if true, don't sort the given
 *                      public keys before creating the script
 */
Script.buildMultisigOut = function(publicKeys, threshold, opts) {
  $.checkArgument(threshold <= publicKeys.length,
    'Number of required signatures must be less than or equal to the number of public keys');
  opts = opts || {};
  var script = new Script();
  script.add(Opcode.smallInt(threshold));
  publicKeys = _.map(publicKeys, PublicKey);
  var sorted = publicKeys;
  if (!opts.noSorting) {
    sorted = _.sortBy(publicKeys, function(publicKey) {
      return publicKey.toString('hex');
    });
  }
  for (var i = 0; i < sorted.length; i++) {
    var publicKey = sorted[i];
    script.add(publicKey.toBuffer());
  }
  script.add(Opcode.smallInt(publicKeys.length));
  script.add(Opcode.OP_CHECKMULTISIG);
  return script;
};

Script.buildWitnessMultisigOutFromScript = function(script) {
  if (script instanceof Script) {
    var s = new Script();
    s.add(Opcode.OP_0);
    s.add(Hash.sha256(script.toBuffer()));
    return s;
  } else {
    throw new TypeError('First argument is expected to be a p2sh script');
  }
};

/**
 * A new Multisig input script for the given public keys, requiring m of those public keys to spend
 *
 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
 * @param {number} threshold amount of required signatures to spend the output
 * @param {Array} signatures and array of signature buffers to append to the script
 * @param {Object=} opts
 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
 *
 * @returns {Script}
 */
Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {
  $.checkArgument(_.isArray(pubkeys));
  $.checkArgument(_.isNumber(threshold));
  $.checkArgument(_.isArray(signatures));
  opts = opts || {};
  var s = new Script();
  s.add(Opcode.OP_0);
  _.each(signatures, function(signature) {
    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');
    // TODO: allow signatures to be an array of Signature objects
    s.add(signature);
  });
  return s;
};

/**
 * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend
 *
 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
 * @param {number} threshold amount of required signatures to spend the output
 * @param {Array} signatures and array of signature buffers to append to the script
 * @param {Object=} opts
 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
 *
 * @returns {Script}
 */
Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
  $.checkArgument(_.isArray(pubkeys));
  $.checkArgument(_.isNumber(threshold));
  $.checkArgument(_.isArray(signatures));
  opts = opts || {};
  var s = new Script();
  s.add(Opcode.OP_0);
  _.each(signatures, function(signature) {
    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');
    // TODO: allow signatures to be an array of Signature objects
    s.add(signature);
  });
  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
  return s;
};

/**
 * @returns {Script} a new pay to public key hash output for the given
 * address or public key
 * @param {(Address|PublicKey)} to - destination address or public key
 */
Script.buildPublicKeyHashOut = function(to) {
  $.checkArgument(!_.isUndefined(to));
  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
  if (to instanceof PublicKey) {
    to = to.toAddress();
  } else if (_.isString(to)) {
    to = new Address(to);
  }
  var s = new Script();
  s.add(Opcode.OP_DUP)
    .add(Opcode.OP_HASH160)
    .add(to.hashBuffer)
    .add(Opcode.OP_EQUALVERIFY)
    .add(Opcode.OP_CHECKSIG);
  s._network = to.network;
  return s;
};

/**
 * @returns {Script} a new pay to witness v0 output for the given
 * address
 * @param {(Address|PublicKey)} to - destination address
 */
Script.buildWitnessV0Out = function(to) {
  $.checkArgument(!_.isUndefined(to));
  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
  if (to instanceof PublicKey) {
    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);
  } else if (_.isString(to)) {
    to = new Address(to);
  }
  var s = new Script();
  s.add(Opcode.OP_0)
    .add(to.hashBuffer);
  s._network = to.network;
  return s;
};

/**
 * @returns {Script} a new pay to public key output for the given
 *  public key
 */
Script.buildPublicKeyOut = function(pubkey) {
  $.checkArgument(pubkey instanceof PublicKey);
  var s = new Script();
  s.add(pubkey.toBuffer())
    .add(Opcode.OP_CHECKSIG);
  return s;
};

/**
 * @returns {Script} a new OP_RETURN script with data
 * @param {(string|Buffer)} data - the data to embed in the output
 * @param {(string)} encoding - the type of encoding of the string
 */
Script.buildDataOut = function(data, encoding) {
  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));
  if (_.isString(data)) {
    data = Buffer.from(data, encoding);
  }
  var s = new Script();
  s.add(Opcode.OP_RETURN);
  if (!_.isUndefined(data)) {
    s.add(data);
  }
  return s;
};

/**
 * @param {Script|Address} script - the redeemScript for the new p2sh output.
 *    It can also be a p2sh address
 * @returns {Script} new pay to script hash script for given script
 */
Script.buildScriptHashOut = function(script) {
  $.checkArgument(script instanceof Script ||
    (script instanceof Address && script.isPayToScriptHash()));
  var s = new Script();
  s.add(Opcode.OP_HASH160)
    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))
    .add(Opcode.OP_EQUAL);

  s._network = script._network || script.network;
  return s;
};

/**
 * Builds a scriptSig (a script for an input) that signs a public key output script.
 *
 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
 */
Script.buildPublicKeyIn = function(signature, sigtype) {
  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
  if (signature instanceof Signature) {
    signature = signature.toBuffer();
  }
  var script = new Script();
  script.add(BufferUtil.concat([
    signature,
    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
  ]));
  return script;
};

/**
 * Builds a scriptSig (a script for an input) that signs a public key hash
 * output script.
 *
 * @param {Buffer|string|PublicKey} publicKey
 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding
 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
 */
Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {
  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
  if (signature instanceof Signature) {
    signature = signature.toBuffer();
  }
  var script = new Script()
    .add(BufferUtil.concat([
      signature,
      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
    ]))
    .add(new PublicKey(publicKey).toBuffer());
  return script;
};

/**
 * @returns {Script} an empty script
 */
Script.empty = function() {
  return new Script();
};

/**
 * @returns {Script} a new pay to script hash script that pays to this script
 */
Script.prototype.toScriptHashOut = function() {
  return Script.buildScriptHashOut(this);
};

/**
 * @return {Script} an output script built from the address
 */
Script.fromAddress = function(address) {
  address = Address(address);
  if (address.isPayToScriptHash()) {
    return Script.buildScriptHashOut(address);
  } else if (address.isPayToPublicKeyHash()) {
    return Script.buildPublicKeyHashOut(address);
  } else if (address.isPayToWitnessPublicKeyHash()) {
    return Script.buildWitnessV0Out(address);
  } else if (address.isPayToWitnessScriptHash()) {
    return Script.buildWitnessV0Out(address);
  }
  throw new errors.Script.UnrecognizedAddress(address);
};

/**
 * Will return the associated address information object
 * @return {Address|boolean}
 */
Script.prototype.getAddressInfo = function(opts) {
  if (this._isInput) {
    return this._getInputAddressInfo();
  } else if (this._isOutput) {
    return this._getOutputAddressInfo();
  } else {
    var info = this._getOutputAddressInfo();
    if (!info) {
      return this._getInputAddressInfo();
    }
    return info;
  }
};

/**
 * Will return the associated output scriptPubKey address information object
 * @return {Address|boolean}
 * @private
 */
Script.prototype._getOutputAddressInfo = function() {
  var info = {};
  if (this.isScriptHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToScriptHash;
  } else if (this.isPublicKeyHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToPublicKeyHash;
  } else if (this.isWitnessScriptHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToWitnessScriptHash;
  } else if (this.isWitnessPublicKeyHashOut()) {
    info.hashBuffer = this.getData();
    info.type = Address.PayToWitnessPublicKeyHash;
  } else {
    return false;
  }
  return info;
};

/**
 * Will return the associated input scriptSig address information object
 * @return {Address|boolean}
 * @private
 */
Script.prototype._getInputAddressInfo = function() {
  var info = {};
  if (this.isPublicKeyHashIn()) {
    // hash the publickey found in the scriptSig
    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);
    info.type = Address.PayToPublicKeyHash;
  } else if (this.isScriptHashIn()) {
    // hash the redeemscript found at the end of the scriptSig
    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
    info.type = Address.PayToScriptHash;
  } else {
    return false;
  }
  return info;
};

/**
 * @param {Network=} network
 * @return {Address|boolean} the associated address for this script if possible, or false
 */
Script.prototype.toAddress = function(network) {
  var info = this.getAddressInfo();
  if (!info) {
    return false;
  }
  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
  return new Address(info);
};

/**
 * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,
 * typically used with push data chunks.  Note that this will find and delete
 * not just the same data, but the same data with the same push data op as
 * produced by default. i.e., if a pushdata in a tx does not use the minimal
 * pushdata op, then when you try to remove the data it is pushing, it will not
 * be removed, because they do not use the same pushdata op.
 */
Script.prototype.findAndDelete = function(script) {
  var buf = script.toBuffer();
  var hex = buf.toString('hex');
  for (var i = 0; i < this.chunks.length; i++) {
    var script2 = Script({
      chunks: [this.chunks[i]]
    });
    var buf2 = script2.toBuffer();
    var hex2 = buf2.toString('hex');
    if (hex === hex2) {
      this.chunks.splice(i, 1);
    }
  }
  return this;
};

/**
 * Comes from bitcoind's script interpreter CheckMinimalPush function
 * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.
 */
Script.prototype.checkMinimalPush = function(i) {
  var chunk = this.chunks[i];
  var buf = chunk.buf;
  var opcodenum = chunk.opcodenum;
  if (!buf) {
    return true;
  }
  if (buf.length === 0) {
    // Could have used OP_0.
    return opcodenum === Opcode.OP_0;
  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
    // Could have used OP_1 .. OP_16.
    return opcodenum === Opcode.OP_1 + (buf[0] - 1);
  } else if (buf.length === 1 && buf[0] === 0x81) {
    // Could have used OP_1NEGATE
    return opcodenum === Opcode.OP_1NEGATE;
  } else if (buf.length <= 75) {
    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).
    return opcodenum === buf.length;
  } else if (buf.length <= 255) {
    // Could have used OP_PUSHDATA.
    return opcodenum === Opcode.OP_PUSHDATA1;
  } else if (buf.length <= 65535) {
    // Could have used OP_PUSHDATA2.
    return opcodenum === Opcode.OP_PUSHDATA2;
  }
  return true;
};

/**
 * Comes from bitcoind's script DecodeOP_N function
 * @param {number} opcode
 * @returns {number} numeric value in range of 0 to 16
 */
Script.prototype._decodeOP_N = function(opcode) {
  if (opcode === Opcode.OP_0) {
    return 0;
  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {
    return opcode - (Opcode.OP_1 - 1);
  } else {
    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));
  }
};

/**
 * Comes from bitcoind's script GetSigOpCount(boolean) function
 * @param {boolean} use current (true) or pre-version-0.6 (false) logic
 * @returns {number} number of signature operations required by this script
 */
Script.prototype.getSignatureOperationsCount = function(accurate) {
  accurate = (_.isUndefined(accurate) ? true : accurate);
  var self = this;
  var n = 0;
  var lastOpcode = Opcode.OP_INVALIDOPCODE;
  _.each(self.chunks, function getChunk(chunk) {
    var opcode = chunk.opcodenum;
    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {
      n++;
    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {
      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {
        n += self._decodeOP_N(lastOpcode);
      } else {
        n += 20;
      }
    }
    lastOpcode = opcode;
  });
  return n;
};

module.exports = Script;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 864:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(1);
var $ = __webpack_require__(36);
var JSUtil = __webpack_require__(60);

var Script = __webpack_require__(106);
var Address = __webpack_require__(142);
var Unit = __webpack_require__(467);

/**
 * Represents an unspent output information: its script, associated amount and address,
 * transaction id and output index.
 *
 * @constructor
 * @param {object} data
 * @param {string} data.txid the previous transaction id
 * @param {string=} data.txId alias for `txid`
 * @param {number} data.vout the index in the transaction
 * @param {number=} data.outputIndex alias for `vout`
 * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds
 * @param {string|Script=} data.script alias for `scriptPubKey`
 * @param {number} data.amount amount of bitcoins associated
 * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)
 * @param {string|Address=} data.address the associated address to the script, if provided
 */
function UnspentOutput(data) {
  /* jshint maxcomplexity: 20 */
  /* jshint maxstatements: 20 */
  if (!(this instanceof UnspentOutput)) {
    return new UnspentOutput(data);
  }
  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');
  var address = data.address ? new Address(data.address) : undefined;
  var txId = data.txid ? data.txid : data.txId;
  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
    // TODO: Use the errors library
    throw new Error('Invalid TXID in object', data);
  }
  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
  if (!_.isNumber(outputIndex)) {
    throw new Error('Invalid outputIndex, received ' + outputIndex);
  }
  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),
                  'Must provide the scriptPubKey for that output!');
  var script = new Script(data.scriptPubKey || data.script);
  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),
                      'Must provide an amount for the output');
  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;
  $.checkArgument(_.isNumber(amount), 'Amount must be a number');
  JSUtil.defineImmutable(this, {
    address: address,
    txId: txId,
    outputIndex: outputIndex,
    script: script,
    satoshis: amount
  });
}

/**
 * Provide an informative output when displaying this object in the console
 * @returns string
 */
UnspentOutput.prototype.inspect = function() {
  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +
         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';
};

/**
 * String representation: just "txid:index"
 * @returns string
 */
UnspentOutput.prototype.toString = function() {
  return this.txId + ':' + this.outputIndex;
};

/**
 * Deserialize an UnspentOutput from an object
 * @param {object|string} data
 * @return UnspentOutput
 */
UnspentOutput.fromObject = function(data) {
  return new UnspentOutput(data);
};

/**
 * Returns a plain object (no prototype or methods) with the associated info for this output
 * @return {object}
 */
UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {
  return {
    address: this.address ? this.address.toString() : undefined,
    txid: this.txId,
    vout: this.outputIndex,
    scriptPubKey: this.script.toBuffer().toString('hex'),
    amount: Unit.fromSatoshis(this.satoshis).toBTC()
  };
};

module.exports = UnspentOutput;


/***/ }),

/***/ 865:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var BlockHeader = __webpack_require__(363);
var BufferUtil = __webpack_require__(49);
var BufferReader = __webpack_require__(162);
var BufferWriter = __webpack_require__(94);
var Hash = __webpack_require__(76);
var JSUtil = __webpack_require__(60);
var Transaction = __webpack_require__(360);
var errors = __webpack_require__(116);
var $ = __webpack_require__(36);

/**
 * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with
 * the properties of the Block
 *
 * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock
 * @returns {MerkleBlock}
 * @constructor
 */
function MerkleBlock(arg) {
  /* jshint maxstatements: 18 */

  if (!(this instanceof MerkleBlock)) {
    return new MerkleBlock(arg);
  }

  var info = {};
  if (BufferUtil.isBuffer(arg)) {
    info = MerkleBlock._fromBufferReader(BufferReader(arg));
  } else if (_.isObject(arg)) {
    var header;
    if(arg.header instanceof BlockHeader) {
      header = arg.header;
    } else {
      header = BlockHeader.fromObject(arg.header);
    }
    info = {
      /**
       * @name MerkleBlock#header
       * @type {BlockHeader}
       */
      header: header,
      /**
       * @name MerkleBlock#numTransactions
       * @type {Number}
       */
      numTransactions: arg.numTransactions,
      /**
       * @name MerkleBlock#hashes
       * @type {String[]}
       */
      hashes: arg.hashes,
      /**
       * @name MerkleBlock#flags
       * @type {Number[]}
       */
      flags: arg.flags
    };
  } else {
    throw new TypeError('Unrecognized argument for MerkleBlock');
  }
  _.extend(this,info);
  this._flagBitsUsed = 0;
  this._hashesUsed = 0;

  return this;
}

/**
 * @param {Buffer} - MerkleBlock data in a Buffer object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBuffer = function fromBuffer(buf) {
  return MerkleBlock.fromBufferReader(BufferReader(buf));
};

/**
 * @param {BufferReader} - MerkleBlock data in a BufferReader object
 * @returns {MerkleBlock} - A MerkleBlock object
 */
MerkleBlock.fromBufferReader = function fromBufferReader(br) {
  return new MerkleBlock(MerkleBlock._fromBufferReader(br));
};

/**
 * @returns {Buffer} - A buffer of the block
 */
MerkleBlock.prototype.toBuffer = function toBuffer() {
  return this.toBufferWriter().concat();
};

/**
 * @param {BufferWriter} - An existing instance of BufferWriter
 * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock
 */
MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {
  if (!bw) {
    bw = new BufferWriter();
  }
  bw.write(this.header.toBuffer());
  bw.writeUInt32LE(this.numTransactions);
  bw.writeVarintNum(this.hashes.length);
  for (var i = 0; i < this.hashes.length; i++) {
    bw.write(Buffer.from(this.hashes[i], 'hex'));
  }
  bw.writeVarintNum(this.flags.length);
  for (i = 0; i < this.flags.length; i++) {
    bw.writeUInt8(this.flags[i]);
  }
  return bw;
};

/**
 * @returns {Object} - A plain object with the MerkleBlock properties
 */
MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {
  return {
    header: this.header.toObject(),
    numTransactions: this.numTransactions,
    hashes: this.hashes,
    flags: this.flags
  };
};

/**
 * Verify that the MerkleBlock is valid
 * @returns {Boolean} - True/False whether this MerkleBlock is Valid
 */
MerkleBlock.prototype.validMerkleTree = function validMerkleTree() {
  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if(this.hashes.length > this.numTransactions) {
    return false;
  }

  // Can't have more flag bits than num hashes
  if(this.flags.length * 8 < this.hashes.length) {
    return false;
  }

  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var root = this._traverseMerkleTree(height, 0, opts);
  if(opts.hashesUsed !== this.hashes.length) {
    return false;
  }
  return BufferUtil.equals(root, this.header.merkleRoot);
};

/**
 * Return a list of all the txs hash that match the filter
 * @returns {Array} - txs hash that match the filter
 */
MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {
  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');
  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');

  // Can't have more hashes than numTransactions
  if(this.hashes.length > this.numTransactions) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }

  // Can't have more flag bits than num hashes
  if(this.flags.length * 8 < this.hashes.length) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }

  // If there is only one hash the filter do not match any txs in the block
  if(this.hashes.length === 1) {
    return [];
  };

  var height = this._calcTreeHeight();
  var opts = { hashesUsed: 0, flagBitsUsed: 0 };
  var txs = this._traverseMerkleTree(height, 0, opts, true);
  if(opts.hashesUsed !== this.hashes.length) {
    throw new errors.MerkleBlock.InvalidMerkleTree();
  }
  return txs;
};

/**
 * Traverse a the tree in this MerkleBlock, validating it along the way
 * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()
 * @param {Number} - depth - Current height
 * @param {Number} - pos - Current position in the tree
 * @param {Object} - opts - Object with values that need to be mutated throughout the traversal
 * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash
 * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0
 * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0
 * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter
 * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height
 * @returns {Array} - transactions found during traversal that match the filter
 * @private
 */
MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {
  /* jshint maxcomplexity:  12*/
  /* jshint maxstatements: 20 */

  opts = opts || {};
  opts.txs = opts.txs || [];
  opts.flagBitsUsed = opts.flagBitsUsed || 0;
  opts.hashesUsed = opts.hashesUsed || 0;
  var checkForTxs = checkForTxs || false;

  if(opts.flagBitsUsed > this.flags.length * 8) {
    return null;
  }
  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;
  if(depth === 0 || !isParentOfMatch) {
    if(opts.hashesUsed >= this.hashes.length) {
      return null;
    }
    var hash = this.hashes[opts.hashesUsed++];
    if(depth === 0 && isParentOfMatch) {
      opts.txs.push(hash);
    }
    return Buffer.from(hash, 'hex');
  } else {
    var left = this._traverseMerkleTree(depth-1, pos*2, opts);
    var right = left;
    if(pos*2+1 < this._calcTreeWidth(depth-1)) {
      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);
    }
    if (checkForTxs){
      return opts.txs;
    } else {
      return Hash.sha256sha256(new Buffer.concat([left, right]));
    };
  }
};

/** Calculates the width of a merkle tree at a given height.
 *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()
 * @param {Number} - Height at which we want the tree width
 * @returns {Number} - Width of the tree at a given height
 * @private
 */
MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {
  return (this.numTransactions + (1 << height) - 1) >> height;
};

/** Calculates the height of the merkle tree in this MerkleBlock
 * @param {Number} - Height at which we want the tree width
 * @returns {Number} - Height of the merkle tree in this MerkleBlock
 * @private
 */
MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {
  var height = 0;
  while (this._calcTreeWidth(height) > 1) {
    height++;
  }
  return height;
};

/**
 * @param {Transaction|String} - Transaction or Transaction ID Hash
 * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not
 * @private
 */
MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {
  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');
  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',
      'Invalid tx given, tx must be a "string" or "Transaction"');

  var hash = tx;
  if(tx instanceof Transaction) {
    // We need to reverse the id hash for the lookup
    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');
  }

  var txs = [];
  var height = this._calcTreeHeight();
  this._traverseMerkleTree(height, 0, { txs: txs });
  return txs.indexOf(hash) !== -1;
};

/**
 * @param {Buffer} - MerkleBlock data
 * @returns {Object} - An Object representing merkleblock data
 * @private
 */
MerkleBlock._fromBufferReader = function _fromBufferReader(br) {
  $.checkState(!br.finished(), 'No merkleblock data received');
  var info = {};
  info.header = BlockHeader.fromBufferReader(br);
  info.numTransactions = br.readUInt32LE();
  var numHashes = br.readVarintNum();
  info.hashes = [];
  for (var i = 0; i < numHashes; i++) {
    info.hashes.push(br.read(32).toString('hex'));
  }
  var numFlags = br.readVarintNum();
  info.flags = [];
  for (i = 0; i < numFlags; i++) {
    info.flags.push(br.readUInt8());
  }
  return info;
};

/**
 * @param {Object} - A plain JavaScript object
 * @returns {Block} - An instance of block
 */
MerkleBlock.fromObject = function fromObject(obj) {
  return new MerkleBlock(obj);
};

module.exports = MerkleBlock;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 866:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {


var assert = __webpack_require__(12);
var buffer = __webpack_require__(2);
var _ = __webpack_require__(1);
var $ = __webpack_require__(36);

var BN = __webpack_require__(75);
var Base58 = __webpack_require__(359);
var Base58Check = __webpack_require__(271);
var Hash = __webpack_require__(76);
var Network = __webpack_require__(200);
var Point = __webpack_require__(217);
var PrivateKey = __webpack_require__(270);
var Random = __webpack_require__(362);

var errors = __webpack_require__(116);
var hdErrors = errors.HDPrivateKey;
var BufferUtil = __webpack_require__(49);
var JSUtil = __webpack_require__(60);

var MINIMUM_ENTROPY_BITS = 128;
var BITS_TO_BYTES = 1 / 8;
var MAXIMUM_ENTROPY_BITS = 512;


/**
 * Represents an instance of an hierarchically derived private key.
 *
 * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
 *
 * @constructor
 * @param {string|Buffer|Object} arg
 */
function HDPrivateKey(arg) {
  /* jshint maxcomplexity: 10 */
  if (arg instanceof HDPrivateKey) {
    return arg;
  }
  if (!(this instanceof HDPrivateKey)) {
    return new HDPrivateKey(arg);
  }
  if (!arg) {
    return this._generateRandomly();
  }

  if (Network.get(arg)) {
    return this._generateRandomly(arg);
  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
    if (HDPrivateKey.isValidSerialized(arg)) {
      this._buildFromSerialized(arg);
    } else if (JSUtil.isValidJSON(arg)) {
      this._buildFromJSON(arg);
    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
      this._buildFromSerialized(arg.toString());
    } else {
      throw HDPrivateKey.getSerializedError(arg);
    }
  } else if (_.isObject(arg)) {
    this._buildFromObject(arg);
  } else {
    throw new hdErrors.UnrecognizedArgument(arg);
  }
}

/**
 * Verifies that a given path is valid.
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 * @return {boolean}
 */
HDPrivateKey.isValidPath = function(arg, hardened) {
  if (_.isString(arg)) {
    var indexes = HDPrivateKey._getDerivationIndexes(arg);
    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);
  }

  if (_.isNumber(arg)) {
    if (arg < HDPrivateKey.Hardened && hardened === true) {
      arg += HDPrivateKey.Hardened;
    }
    return arg >= 0 && arg < HDPrivateKey.MaxIndex;
  }

  return false;
};

/**
 * Internal function that splits a string path into a derivation index array.
 * It will return null if the string path is malformed.
 * It does not validate if indexes are in bounds.
 *
 * @param {string} path
 * @return {Array}
 */
HDPrivateKey._getDerivationIndexes = function(path) {
  var steps = path.split('/');

  // Special cases:
  if (_.includes(HDPrivateKey.RootElementAlias, path)) {
    return [];
  }

  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {
    return null;
  }

  var indexes = steps.slice(1).map(function(step) {
    var isHardened = step.slice(-1) === '\'';
    if (isHardened) {
      step = step.slice(0, -1);
    }
    if (!step || step[0] === '-') {
      return NaN;
    }
    var index = +step; // cast to number
    if (isHardened) {
      index += HDPrivateKey.Hardened;
    }

    return index;
  });

  return _.some(indexes, isNaN) ? null : indexes;
};

/**
 * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant
 *
 *
 * Get a derived child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
 * derivation.
 *
 * If the first argument is a number, the child with that index will be
 * derived. If the second argument is truthy, the hardened version will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPrivateKey('xprv...');
 * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);
 * var copy_of_child_0_1_2h = parent.derive("m/0/1/2'");
 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
 * ```
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.derive = function(arg, hardened) {
  return this.deriveNonCompliantChild(arg, hardened);
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Get a derived child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
 * derivation.
 *
 * If the first argument is a number, the child with that index will be
 * derived. If the second argument is truthy, the hardened version will be
 * derived. See the example usage for clarification.
 *
 * WARNING: The `nonCompliant` option should NOT be used, except for older implementation
 * that used a derivation strategy that used a non-zero padded private key.
 *
 * @example
 * ```javascript
 * var parent = new HDPrivateKey('xprv...');
 * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);
 * var copy_of_child_0_1_2h = parent.deriveChild("m/0/1/2'");
 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
 * ```
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.deriveChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

/**
 * WARNING: This method will not be officially supported until v1.0.0
 *
 *
 * WARNING: If this is a new implementation you should NOT use this method, you should be using
 * `derive` instead.
 *
 * This method is explicitly for use and compatibility with an implementation that
 * was not compliant with BIP32 regarding the derivation algorithm. The private key
 * must be 32 bytes hashing, and this implementation will use the non-zero padded
 * serialization of a private key, such that it's still possible to derive the privateKey
 * to recover those funds.
 *
 * @param {string|number} arg
 * @param {boolean?} hardened
 */
HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened, true);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg, true);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

HDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {
  /* jshint maxstatements: 20 */
  /* jshint maxcomplexity: 10 */
  if (!HDPrivateKey.isValidPath(index, hardened)) {
    throw new hdErrors.InvalidPath(index);
  }

  hardened = index >= HDPrivateKey.Hardened ? true : hardened;
  if (index < HDPrivateKey.Hardened && hardened === true) {
    index += HDPrivateKey.Hardened;
  }

  var indexBuffer = BufferUtil.integerAsBuffer(index);
  var data;
  if (hardened && nonCompliant) {
    // The private key serialization in this case will not be exactly 32 bytes and can be
    // any value less, and the value is not zero-padded.
    var nonZeroPadded = this.privateKey.bn.toBuffer();
    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);
  } else if (hardened) {
    // This will use a 32 byte zero padded serialization of the private key
    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});
    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');
    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);
  } else {
    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
  }
  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
  var leftPart = BN.fromBuffer(hash.slice(0, 32), {
    size: 32
  });
  var chainCode = hash.slice(32, 64);

  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({
    size: 32
  });

  if (!PrivateKey.isValid(privateKey)) {
    // Index at this point is already hardened, we can pass null as the hardened arg
    return this._deriveWithNumber(index + 1, null, nonCompliant);
  }

  var derived = new HDPrivateKey({
    network: this.network,
    depth: this.depth + 1,
    parentFingerPrint: this.fingerPrint,
    childIndex: index,
    chainCode: chainCode,
    privateKey: privateKey
  });

  return derived;
};

HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {
  if (!HDPrivateKey.isValidPath(path)) {
    throw new hdErrors.InvalidPath(path);
  }

  var indexes = HDPrivateKey._getDerivationIndexes(path);
  var derived = indexes.reduce(function(prev, index) {
    return prev._deriveWithNumber(index, null, nonCompliant);
  }, this);

  return derived;
};

/**
 * Verifies that a given serialized private key in base58 with checksum format
 * is valid.
 *
 * @param {string|Buffer} data - the serialized private key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {boolean}
 */
HDPrivateKey.isValidSerialized = function(data, network) {
  return !HDPrivateKey.getSerializedError(data, network);
};

/**
 * Checks what's the error that causes the validation of a serialized private key
 * in base58 with checksum to fail.
 *
 * @param {string|Buffer} data - the serialized private key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {errors.InvalidArgument|null}
 */
HDPrivateKey.getSerializedError = function(data, network) {
  /* jshint maxcomplexity: 10 */
  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
    return new hdErrors.UnrecognizedArgument('Expected string or buffer');
  }
  if (!Base58.validCharacters(data)) {
    return new errors.InvalidB58Char('(unknown)', data);
  }
  try {
    data = Base58Check.decode(data);
  } catch (e) {
    return new errors.InvalidB58Checksum(data);
  }
  if (data.length !== HDPrivateKey.DataLength) {
    return new hdErrors.InvalidLength(data);
  }
  if (!_.isUndefined(network)) {
    var error = HDPrivateKey._validateNetwork(data, network);
    if (error) {
      return error;
    }
  }
  return null;
};

HDPrivateKey._validateNetwork = function(data, networkArg) {
  var network = Network.get(networkArg);
  if (!network) {
    return new errors.InvalidNetworkArgument(networkArg);
  }
  var version = data.slice(0, 4);
  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {
    return new errors.InvalidNetwork(version);
  }
  return null;
};

HDPrivateKey.fromString = function(arg) {
  $.checkArgument(_.isString(arg), 'No valid string was provided');
  return new HDPrivateKey(arg);
};

HDPrivateKey.fromObject = function(arg) {
  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
  return new HDPrivateKey(arg);
};

HDPrivateKey.prototype._buildFromJSON = function(arg) {
  return this._buildFromObject(JSON.parse(arg));
};

HDPrivateKey.prototype._buildFromObject = function(arg) {
  /* jshint maxcomplexity: 12 */
  // TODO: Type validation
  var buffers = {
    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,
    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,
    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined
  };
  return this._buildFromBuffers(buffers);
};

HDPrivateKey.prototype._buildFromSerialized = function(arg) {
  var decoded = Base58Check.decode(arg);
  var buffers = {
    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,
      HDPrivateKey.ParentFingerPrintEnd),
    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
    xprivkey: arg
  };
  return this._buildFromBuffers(buffers);
};

HDPrivateKey.prototype._generateRandomly = function(network) {
  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);
};

/**
 * Generate a private key from a seed, as described in BIP32
 *
 * @param {string|Buffer} hexa
 * @param {*} network
 * @return HDPrivateKey
 */
HDPrivateKey.fromSeed = function(hexa, network) {
  /* jshint maxcomplexity: 8 */
  if (JSUtil.isHexaString(hexa)) {
    hexa = Buffer.from(hexa, 'hex');
  }
  if (!Buffer.isBuffer(hexa)) {
    throw new hdErrors.InvalidEntropyArgument(hexa);
  }
  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
  }
  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
  }
  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));

  return new HDPrivateKey({
    network: Network.get(network) || Network.defaultNetwork,
    depth: 0,
    parentFingerPrint: 0,
    childIndex: 0,
    privateKey: hash.slice(0, 32),
    chainCode: hash.slice(32, 64)
  });
};



HDPrivateKey.prototype._calcHDPublicKey = function() {
  if (!this._hdPublicKey) {
    var HDPublicKey = __webpack_require__(867);
    this._hdPublicKey = new HDPublicKey(this);
  }
};

/**
 * Receives a object with buffers in all the properties and populates the
 * internal structure
 *
 * @param {Object} arg
 * @param {buffer.Buffer} arg.version
 * @param {buffer.Buffer} arg.depth
 * @param {buffer.Buffer} arg.parentFingerPrint
 * @param {buffer.Buffer} arg.childIndex
 * @param {buffer.Buffer} arg.chainCode
 * @param {buffer.Buffer} arg.privateKey
 * @param {buffer.Buffer} arg.checksum
 * @param {string=} arg.xprivkey - if set, don't recalculate the base58
 *      representation
 * @return {HDPrivateKey} this
 */
HDPrivateKey.prototype._buildFromBuffers = function(arg) {
  /* jshint maxcomplexity: 8 */
  /* jshint maxstatements: 20 */

  HDPrivateKey._validateBufferArguments(arg);

  JSUtil.defineImmutable(this, {
    _buffers: arg
  });

  var sequence = [
    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
    BufferUtil.emptyBuffer(1), arg.privateKey
  ];
  var concat = buffer.Buffer.concat(sequence);
  if (!arg.checksum || !arg.checksum.length) {
    arg.checksum = Base58Check.checksum(concat);
  } else {
    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {
      throw new errors.InvalidB58Checksum(concat);
    }
  }

  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
  var xprivkey;
  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));
  arg.xprivkey = Buffer.from(xprivkey);

  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);
  var publicKey = privateKey.toPublicKey();
  var size = HDPrivateKey.ParentFingerPrintSize;
  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

  JSUtil.defineImmutable(this, {
    xprivkey: xprivkey,
    network: network,
    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
    privateKey: privateKey,
    publicKey: publicKey,
    fingerPrint: fingerPrint
  });

  this._hdPublicKey = null;

  Object.defineProperty(this, 'hdPublicKey', {
    configurable: false,
    enumerable: true,
    get: function() {
      this._calcHDPublicKey();
      return this._hdPublicKey;
    }
  });
  Object.defineProperty(this, 'xpubkey', {
    configurable: false,
    enumerable: true,
    get: function() {
      this._calcHDPublicKey();
      return this._hdPublicKey.xpubkey;
    }
  });
  return this;
};

HDPrivateKey._validateBufferArguments = function(arg) {
  var checkBuffer = function(name, size) {
    var buff = arg[name];
    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');
    assert(
      buff.length === size,
      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
    );
  };
  checkBuffer('version', HDPrivateKey.VersionSize);
  checkBuffer('depth', HDPrivateKey.DepthSize);
  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);
  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);
  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);
  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);
  if (arg.checksum && arg.checksum.length) {
    checkBuffer('checksum', HDPrivateKey.CheckSumSize);
  }
};

/**
 * Returns the string representation of this private key (a string starting
 * with "xprv..."
 *
 * @return string
 */
HDPrivateKey.prototype.toString = function() {
  return this.xprivkey;
};

/**
 * Returns the console representation of this extended private key.
 * @return string
 */
HDPrivateKey.prototype.inspect = function() {
  return '<HDPrivateKey: ' + this.xprivkey + '>';
};

/**
 * Returns a plain object with a representation of this private key.
 *
 * Fields include:<ul>
 * <li> network: either 'livenet' or 'testnet'
 * <li> depth: a number ranging from 0 to 255
 * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the
 * <li>     associated public key
 * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash
 * <li>     of this parent's associated public key or zero.
 * <li> childIndex: the index from which this child was derived (or zero)
 * <li> chainCode: an hexa string representing a number used in the derivation
 * <li> privateKey: the private key associated, in hexa representation
 * <li> xprivkey: the representation of this extended private key in checksum
 * <li>     base58 format
 * <li> checksum: the base58 checksum of xprivkey
 * </ul>
 *  @return {Object}
 */
HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {
  return {
    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,
    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
    privateKey: this.privateKey.toBuffer().toString('hex'),
    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
    xprivkey: this.xprivkey
  };
};

/**
 * Build a HDPrivateKey from a buffer
 *
 * @param {Buffer} arg
 * @return {HDPrivateKey}
 */
HDPrivateKey.fromBuffer = function(arg) {
  return new HDPrivateKey(arg.toString());
};

/**
 * Returns a buffer representation of the HDPrivateKey
 *
 * @return {string}
 */
HDPrivateKey.prototype.toBuffer = function() {
  return BufferUtil.copy(this._buffers.xprivkey);
};

HDPrivateKey.DefaultDepth = 0;
HDPrivateKey.DefaultFingerprint = 0;
HDPrivateKey.DefaultChildIndex = 0;
HDPrivateKey.Hardened = 0x80000000;
HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;

HDPrivateKey.RootElementAlias = ['m', 'M', 'm\'', 'M\''];

HDPrivateKey.VersionSize = 4;
HDPrivateKey.DepthSize = 1;
HDPrivateKey.ParentFingerPrintSize = 4;
HDPrivateKey.ChildIndexSize = 4;
HDPrivateKey.ChainCodeSize = 32;
HDPrivateKey.PrivateKeySize = 32;
HDPrivateKey.CheckSumSize = 4;

HDPrivateKey.DataLength = 78;
HDPrivateKey.SerializedByteSize = 82;

HDPrivateKey.VersionStart = 0;
HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;

assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);

module.exports = HDPrivateKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 867:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _ = __webpack_require__(1);
var $ = __webpack_require__(36);

var BN = __webpack_require__(75);
var Base58 = __webpack_require__(359);
var Base58Check = __webpack_require__(271);
var Hash = __webpack_require__(76);
var HDPrivateKey = __webpack_require__(866);
var Network = __webpack_require__(200);
var Point = __webpack_require__(217);
var PublicKey = __webpack_require__(141);

var bitcoreErrors = __webpack_require__(116);
var errors = bitcoreErrors;
var hdErrors = bitcoreErrors.HDPublicKey;
var assert = __webpack_require__(12);

var JSUtil = __webpack_require__(60);
var BufferUtil = __webpack_require__(49);

/**
 * The representation of an hierarchically derived public key.
 *
 * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
 *
 * @constructor
 * @param {Object|string|Buffer} arg
 */
function HDPublicKey(arg) {
  /* jshint maxcomplexity: 12 */
  /* jshint maxstatements: 20 */
  if (arg instanceof HDPublicKey) {
    return arg;
  }
  if (!(this instanceof HDPublicKey)) {
    return new HDPublicKey(arg);
  }
  if (arg) {
    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
      var error = HDPublicKey.getSerializedError(arg);
      if (!error) {
        return this._buildFromSerialized(arg);
      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
        return this._buildFromSerialized(arg.toString());
      } else {
        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
          return new HDPrivateKey(arg).hdPublicKey;
        }
        throw error;
      }
    } else {
      if (_.isObject(arg)) {
        if (arg instanceof HDPrivateKey) {
          return this._buildFromPrivate(arg);
        } else {
          return this._buildFromObject(arg);
        }
      } else {
        throw new hdErrors.UnrecognizedArgument(arg);
      }
    }
  } else {
    throw new hdErrors.MustSupplyArgument();
  }
}

/**
 * Verifies that a given path is valid.
 *
 * @param {string|number} arg
 * @return {boolean}
 */
HDPublicKey.isValidPath = function(arg) {
  if (_.isString(arg)) {
    var indexes = HDPrivateKey._getDerivationIndexes(arg);
    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);
  }

  if (_.isNumber(arg)) {
    return arg >= 0 && arg < HDPublicKey.Hardened;
  }

  return false;
};

/**
 * WARNING: This method is deprecated. Use deriveChild instead.
 *
 *
 * Get a derivated child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same public key), "m/0/1/40/2/1000".
 *
 * Note that hardened keys can't be derived from a public extended key.
 *
 * If the first argument is a number, the child with that index will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPublicKey('xpub...');
 * var child_0_1_2 = parent.derive(0).derive(1).derive(2);
 * var copy_of_child_0_1_2 = parent.derive("m/0/1/2");
 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
 * ```
 *
 * @param {string|number} arg
 */
HDPublicKey.prototype.derive = function(arg, hardened) {
  return this.deriveChild(arg, hardened);
};

/**
 * WARNING: This method will not be officially supported until v1.0.0.
 *
 *
 * Get a derivated child based on a string or number.
 *
 * If the first argument is a string, it's parsed as the full path of
 * derivation. Valid values for this argument include "m" (which returns the
 * same public key), "m/0/1/40/2/1000".
 *
 * Note that hardened keys can't be derived from a public extended key.
 *
 * If the first argument is a number, the child with that index will be
 * derived. See the example usage for clarification.
 *
 * @example
 * ```javascript
 * var parent = new HDPublicKey('xpub...');
 * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);
 * var copy_of_child_0_1_2 = parent.deriveChild("m/0/1/2");
 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
 * ```
 *
 * @param {string|number} arg
 */
HDPublicKey.prototype.deriveChild = function(arg, hardened) {
  if (_.isNumber(arg)) {
    return this._deriveWithNumber(arg, hardened);
  } else if (_.isString(arg)) {
    return this._deriveFromString(arg);
  } else {
    throw new hdErrors.InvalidDerivationArgument(arg);
  }
};

HDPublicKey.prototype._deriveWithNumber = function(index, hardened) {
  if (index >= HDPublicKey.Hardened || hardened) {
    throw new hdErrors.InvalidIndexCantDeriveHardened();
  }
  if (index < 0) {
    throw new hdErrors.InvalidPath(index);
  }

  var indexBuffer = BufferUtil.integerAsBuffer(index);
  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});
  var chainCode = hash.slice(32, 64);

  var publicKey;
  try {
    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));
  } catch (e) {
    return this._deriveWithNumber(index + 1);
  }

  var derived = new HDPublicKey({
    network: this.network,
    depth: this.depth + 1,
    parentFingerPrint: this.fingerPrint,
    childIndex: index,
    chainCode: chainCode,
    publicKey: publicKey
  });

  return derived;
};

HDPublicKey.prototype._deriveFromString = function(path) {
  /* jshint maxcomplexity: 8 */
  if (_.includes(path, "'")) {
    throw new hdErrors.InvalidIndexCantDeriveHardened();
  } else if (!HDPublicKey.isValidPath(path)) {
    throw new hdErrors.InvalidPath(path);
  }

  var indexes = HDPrivateKey._getDerivationIndexes(path);
  var derived = indexes.reduce(function(prev, index) {
    return prev._deriveWithNumber(index);
  }, this);

  return derived;
};

/**
 * Verifies that a given serialized public key in base58 with checksum format
 * is valid.
 *
 * @param {string|Buffer} data - the serialized public key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {boolean}
 */
HDPublicKey.isValidSerialized = function(data, network) {
  return _.isNull(HDPublicKey.getSerializedError(data, network));
};

/**
 * Checks what's the error that causes the validation of a serialized public key
 * in base58 with checksum to fail.
 *
 * @param {string|Buffer} data - the serialized public key
 * @param {string|Network=} network - optional, if present, checks that the
 *     network provided matches the network serialized.
 * @return {errors|null}
 */
HDPublicKey.getSerializedError = function(data, network) {
  /* jshint maxcomplexity: 10 */
  /* jshint maxstatements: 20 */
  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
    return new hdErrors.UnrecognizedArgument('expected buffer or string');
  }
  if (!Base58.validCharacters(data)) {
    return new errors.InvalidB58Char('(unknown)', data);
  }
  try {
    data = Base58Check.decode(data);
  } catch (e) {
    return new errors.InvalidB58Checksum(data);
  }
  if (data.length !== HDPublicKey.DataSize) {
    return new hdErrors.InvalidLength(data);
  }
  if (!_.isUndefined(network)) {
    var error = HDPublicKey._validateNetwork(data, network);
    if (error) {
      return error;
    }
  }
  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));
  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {
    return new hdErrors.ArgumentIsPrivateExtended();
  }
  return null;
};

HDPublicKey._validateNetwork = function(data, networkArg) {
  var network = Network.get(networkArg);
  if (!network) {
    return new errors.InvalidNetworkArgument(networkArg);
  }
  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {
    return new errors.InvalidNetwork(version);
  }
  return null;
};

HDPublicKey.prototype._buildFromPrivate = function (arg) {
  var args = _.clone(arg._buffers);
  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));
  args.publicKey = Point.pointToCompressed(point);
  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);
  args.privateKey = undefined;
  args.checksum = undefined;
  args.xprivkey = undefined;
  return this._buildFromBuffers(args);
};

HDPublicKey.prototype._buildFromObject = function(arg) {
  /* jshint maxcomplexity: 10 */
  // TODO: Type validation
  var buffers = {
    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,
    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :
      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum
  };
  return this._buildFromBuffers(buffers);
};

HDPublicKey.prototype._buildFromSerialized = function(arg) {
  var decoded = Base58Check.decode(arg);
  var buffers = {
    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,
                                     HDPublicKey.ParentFingerPrintEnd),
    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
    xpubkey: arg
  };
  return this._buildFromBuffers(buffers);
};

/**
 * Receives a object with buffers in all the properties and populates the
 * internal structure
 *
 * @param {Object} arg
 * @param {buffer.Buffer} arg.version
 * @param {buffer.Buffer} arg.depth
 * @param {buffer.Buffer} arg.parentFingerPrint
 * @param {buffer.Buffer} arg.childIndex
 * @param {buffer.Buffer} arg.chainCode
 * @param {buffer.Buffer} arg.publicKey
 * @param {buffer.Buffer} arg.checksum
 * @param {string=} arg.xpubkey - if set, don't recalculate the base58
 *      representation
 * @return {HDPublicKey} this
 */
HDPublicKey.prototype._buildFromBuffers = function(arg) {
  /* jshint maxcomplexity: 8 */
  /* jshint maxstatements: 20 */

  HDPublicKey._validateBufferArguments(arg);

  JSUtil.defineImmutable(this, {
    _buffers: arg
  });

  var sequence = [
    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
    arg.publicKey
  ];
  var concat = BufferUtil.concat(sequence);
  var checksum = Base58Check.checksum(concat);
  if (!arg.checksum || !arg.checksum.length) {
    arg.checksum = checksum;
  } else {
    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {
      throw new errors.InvalidB58Checksum(concat, checksum);
    }
  }
  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));

  var xpubkey;
  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));
  arg.xpubkey = Buffer.from(xpubkey);

  var publicKey = new PublicKey(arg.publicKey, {network: network});
  var size = HDPublicKey.ParentFingerPrintSize;
  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

  JSUtil.defineImmutable(this, {
    xpubkey: xpubkey,
    network: network,
    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
    publicKey: publicKey,
    fingerPrint: fingerPrint
  });

  return this;
};

HDPublicKey._validateBufferArguments = function(arg) {
  var checkBuffer = function(name, size) {
    var buff = arg[name];
    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\'s ' + typeof buff);
    assert(
      buff.length === size,
      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
    );
  };
  checkBuffer('version', HDPublicKey.VersionSize);
  checkBuffer('depth', HDPublicKey.DepthSize);
  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);
  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);
  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);
  checkBuffer('publicKey', HDPublicKey.PublicKeySize);
  if (arg.checksum && arg.checksum.length) {
    checkBuffer('checksum', HDPublicKey.CheckSumSize);
  }
};

HDPublicKey.fromString = function(arg) {
  $.checkArgument(_.isString(arg), 'No valid string was provided');
  return new HDPublicKey(arg);
};

HDPublicKey.fromObject = function(arg) {
  $.checkArgument(_.isObject(arg), 'No valid argument was provided');
  return new HDPublicKey(arg);
};

/**
 * Returns the base58 checked representation of the public key
 * @return {string} a string starting with "xpub..." in livenet
 */
HDPublicKey.prototype.toString = function() {
  return this.xpubkey;
};

/**
 * Returns the console representation of this extended public key.
 * @return string
 */
HDPublicKey.prototype.inspect = function() {
  return '<HDPublicKey: ' + this.xpubkey + '>';
};

/**
 * Returns a plain JavaScript object with information to reconstruct a key.
 *
 * Fields are: <ul>
 *  <li> network: 'livenet' or 'testnet'
 *  <li> depth: a number from 0 to 255, the depth to the master extended key
 *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key
 *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's
 *  <li>     parent's public key
 *  <li> childIndex: index with which this key was derived
 *  <li> chainCode: string in hexa encoding used for derivation
 *  <li> publicKey: string, hexa encoded, in compressed key format
 *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
 *  <li> xpubkey: the string with the base58 representation of this extended key
 *  <li> checksum: the base58 checksum of xpubkey
 * </ul>
 */
HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {
  return {
    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
    publicKey: this.publicKey.toString(),
    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
    xpubkey: this.xpubkey
  };
};

/**
 * Create a HDPublicKey from a buffer argument
 *
 * @param {Buffer} arg
 * @return {HDPublicKey}
 */
HDPublicKey.fromBuffer = function(arg) {
  return new HDPublicKey(arg);
};

/**
 * Return a buffer representation of the xpubkey
 *
 * @return {Buffer}
 */
HDPublicKey.prototype.toBuffer = function() {
  return BufferUtil.copy(this._buffers.xpubkey);
};

HDPublicKey.Hardened = 0x80000000;
HDPublicKey.RootElementAlias = ['m', 'M'];

HDPublicKey.VersionSize = 4;
HDPublicKey.DepthSize = 1;
HDPublicKey.ParentFingerPrintSize = 4;
HDPublicKey.ChildIndexSize = 4;
HDPublicKey.ChainCodeSize = 32;
HDPublicKey.PublicKeySize = 33;
HDPublicKey.CheckSumSize = 4;

HDPublicKey.DataSize = 78;
HDPublicKey.SerializedByteSize = 82;

HDPublicKey.VersionStart           = 0;
HDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
HDPublicKey.DepthStart             = HDPublicKey.VersionEnd;
HDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
HDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
HDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;
HDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
HDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;
HDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
HDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;
HDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
HDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;
HDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;

assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);

module.exports = HDPublicKey;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 89:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/http.js
var esm5_http = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/ionic-image-loader/dist/index.js + 4 modules
var dist = __webpack_require__(409);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// EXTERNAL MODULE: ./node_modules/rxjs/Rx.js
var Rx = __webpack_require__(90);
var Rx_default = /*#__PURE__*/__webpack_require__.n(Rx);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/from.js
var from = __webpack_require__(414);
var from_default = /*#__PURE__*/__webpack_require__.n(from);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromPromise.js
var fromPromise = __webpack_require__(411);
var fromPromise_default = /*#__PURE__*/__webpack_require__.n(fromPromise);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js
var of = __webpack_require__(236);
var of_default = /*#__PURE__*/__webpack_require__.n(of);

// EXTERNAL MODULE: ./node_modules/rxjs/observable/timer.js
var timer = __webpack_require__(239);
var timer_default = /*#__PURE__*/__webpack_require__.n(timer);

// EXTERNAL MODULE: ./node_modules/rxjs/operators.js
var operators = __webpack_require__(133);
var operators_default = /*#__PURE__*/__webpack_require__.n(operators);

// CONCATENATED MODULE: ./src/utils.ts
function promiseSerial(tasks) {
    return tasks.reduce((promise, currentTask) => promise.then(result => currentTask().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
}
//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ./src/providers/analytics/analytics.ts
var analytics = __webpack_require__(68);

// EXTERNAL MODULE: ./src/providers/config/config.ts
var config_config = __webpack_require__(11);

// EXTERNAL MODULE: ./src/providers/email-notifications/email-notifications.ts
var email_notifications = __webpack_require__(291);

// EXTERNAL MODULE: ./src/providers/home-integrations/home-integrations.ts
var home_integrations = __webpack_require__(79);

// EXTERNAL MODULE: ./src/providers/invoice/invoice.ts
var invoice = __webpack_require__(949);

// EXTERNAL MODULE: ./src/providers/location/location.ts
var location_location = __webpack_require__(383);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger_logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/persistence/persistence.ts + 3 modules
var persistence = __webpack_require__(20);

// EXTERNAL MODULE: ./src/providers/platform/platform.ts
var platform = __webpack_require__(13);

// EXTERNAL MODULE: ./src/providers/time/time.ts
var time = __webpack_require__(209);

// EXTERNAL MODULE: ./src/providers/tkcoin-id/tkcoin-id.ts
var tkcoin_id = __webpack_require__(380);

// CONCATENATED MODULE: ./src/providers/gift-card/gift-card.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return gift_card_GiftCardProvider; });
/* harmony export (immutable) */ __webpack_exports__["b"] = getActivationFee;
/* unused harmony export filterDisplayableConfig */
/* unused harmony export sortByDescendingDate */
/* harmony export (immutable) */ __webpack_exports__["g"] = sortByDisplayName;
/* unused harmony export getDisplayNameSortValue */
/* unused harmony export setNullableCardFields */
/* unused harmony export getCardsFromInvoiceMap */
/* harmony export (immutable) */ __webpack_exports__["f"] = hasVisibleDiscount;
/* harmony export (immutable) */ __webpack_exports__["e"] = hasPromotion;
/* harmony export (immutable) */ __webpack_exports__["c"] = getPromo;
/* harmony export (immutable) */ __webpack_exports__["d"] = getVisibleDiscount;
























let gift_card_GiftCardProvider = class GiftCardProvider extends invoice["a" /* InvoiceProvider */] {
    constructor(analyticsProvider, tkcoinIdProvider, configProvider, events, imageLoader, homeIntegrationsProvider, timeProvider, emailNotificationsProvider, http, logger, persistenceProvider, platformProvider, locationProvider) {
        super(emailNotificationsProvider, http, logger, persistenceProvider);
        this.analyticsProvider = analyticsProvider;
        this.tkcoinIdProvider = tkcoinIdProvider;
        this.configProvider = configProvider;
        this.events = events;
        this.imageLoader = imageLoader;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.timeProvider = timeProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.locationProvider = locationProvider;
        this.cardUpdatesSubject = new Rx["Subject"]();
        this.cardUpdates$ = this.cardUpdatesSubject.asObservable();
        this.fallbackIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAyCAQAAAA38nkBAAAADklEQVR42mP8/4Vx8CEAn9BhqacD+5kAAAAASUVORK5CYII=';
        this.logger.debug('GiftCardProvider initialized');
        this.listenForAuthChanges();
    }
    listenForAuthChanges() {
        this.events.subscribe('TKCoinId/Connected', () => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.persistenceProvider.setTKCoinIdSettings(this.getNetwork(), {
                syncGiftCardPurchases: true
            });
            yield Object(timer["timer"])(1000).toPromise();
            yield this.getSupportedCardConfigMap(true);
        }));
        this.events.subscribe('TKCoinId/Disconnected', () => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.getSupportedCardConfigMap(true);
        }));
        this.events.subscribe('TKCoinId/SettingsChanged', () => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.getSupportedCardConfigMap(true);
        }));
    }
    getCardConfig(cardName) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const cardConfigMap = yield this.getSupportedCardConfigMap();
            return cardConfigMap[cardName];
        });
    }
    getSupportedCardConfigMap(bustCache = false) {
        if (bustCache) {
            this.clearCardConfigCache();
        }
        return this.supportedCardMapPromise
            ? this.supportedCardMapPromise
            : this.fetchCardConfigMap();
    }
    clearCardConfigCache() {
        this.supportedCardMapPromise = undefined;
        this.availableCardsPromise = undefined;
    }
    fetchCardConfigMap() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.supportedCardMapPromise = this.getSupportedCards().then(availableCards => availableCards.reduce((map, cardConfig) => (Object.assign({}, map, { [cardConfig.name]: cardConfig })), {}));
            return this.supportedCardMapPromise;
        });
    }
    getCardMap(cardName, fetchTimeout = 6000) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const network = this.getNetwork();
            const map = yield Promise.race([
                this.persistenceProvider.getGiftCards(cardName, network),
                Object(timer["timer"])(fetchTimeout)
                    .toPromise()
                    .then(() => {
                    throw new Error('timeout');
                })
            ]).catch(err => {
                if (err && err.message === 'timeout') {
                    this.logger.debug(`${cardName} gift cards took longer than ${fetchTimeout}ms to load`);
                    return {};
                }
                throw err;
            });
            return map || {};
        });
    }
    shouldSyncGiftCardPurchasesWithTKCoinId() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const [user, userSettings] = yield Promise.all([
                this.persistenceProvider.getTKCoinIdUserInfo(this.getNetwork()),
                this.persistenceProvider.getTKCoinIdSettings(this.getNetwork())
            ]);
            return user && userSettings && userSettings.syncGiftCardPurchases;
        });
    }
    getUserEmail() {
        const getTKCoinIdInfo = this.persistenceProvider.getTKCoinIdUserInfo(this.getNetwork());
        const getGiftCardUserInfo = this.persistenceProvider.getGiftCardUserInfo();
        const shouldSync = this.shouldSyncGiftCardPurchasesWithTKCoinId();
        return Promise.all([shouldSync, getTKCoinIdInfo, getGiftCardUserInfo])
            .then(([shouldSync, ...rest]) => {
            const [tkcoinIdEmail, giftCardEmail] = rest
                .map(result => (lodash["isString"](result) ? JSON.parse(result) : result))
                .map(jsonResult => jsonResult && jsonResult.email);
            return ((shouldSync && tkcoinIdEmail) ||
                giftCardEmail ||
                this.emailNotificationsProvider.getEmailIfEnabled());
        })
            .catch(_ => { });
    }
    createBitpayInvoice(data, attempt = 1) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.logger.info('TKCoin Creating Invoice: try... ' + attempt);
            const params = {
                brand: data.cardName,
                currency: data.currency,
                amount: data.amount,
                clientId: data.uuid,
                discounts: data.discounts,
                email: data.email,
                phone: data.phone
            };
            const shouldSync = yield this.shouldSyncGiftCardPurchasesWithTKCoinId();
            const promise = shouldSync
                ? this.createAuthenticatedBitpayInvoice.bind(this)
                : this.createUnauthenticatedBitpayInvoice.bind(this);
            const cardOrder = yield promise(params).catch((err) => tslib_es6["__awaiter"](this, void 0, void 0, function* () {
                this.logger.error('TKCoin Create Invoice: ERROR', JSON.stringify(err));
                if (attempt <= 5 && err.status == 403) {
                    yield new Promise(resolve => setTimeout(resolve, 3000 * attempt));
                    return this.createBitpayInvoice(data, ++attempt);
                }
                else
                    throw err;
            }));
            this.logger.info('TKCoin Create Invoice: SUCCESS');
            return cardOrder;
        });
    }
    createUnauthenticatedBitpayInvoice(params) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const url = `${this.getApiPath()}/pay`;
            const headers = new esm5_http["c" /* HttpHeaders */]({
                'Content-Type': 'application/json'
            });
            return this.http.post(url, params, { headers }).toPromise();
        });
    }
    createAuthenticatedBitpayInvoice(params) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const user = yield this.persistenceProvider.getTKCoinIdUserInfo(this.getNetwork());
            return this.tkcoinIdProvider.apiCall('createGiftCardInvoice', Object.assign({}, params, { email: user.email }));
        });
    }
    getActiveCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const [configMap, giftCardMap] = yield Promise.all([
                this.getSupportedCardConfigMap(),
                this.persistenceProvider.getActiveGiftCards(this.getNetwork())
            ]);
            const validSchema = giftCardMap && Object.keys(giftCardMap).every(key => key !== 'undefined');
            return !giftCardMap || !validSchema
                ? this.refreshActiveGiftCards()
                : getCardsFromInvoiceMap(giftCardMap, configMap);
        });
    }
    getPurchasedCards(cardName, fetchTimeout = 3000) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const [configMap, giftCardMap] = yield Promise.all([
                this.getSupportedCardConfigMap(),
                this.getCardMap(cardName, fetchTimeout)
            ]);
            return getCardsFromInvoiceMap(giftCardMap, configMap);
        });
    }
    saveCard(giftCard, opts) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const oldGiftCards = yield this.getCardMap(giftCard.name);
            const newMap = this.getNewSaveableGiftCardMap(oldGiftCards, giftCard, opts);
            const savePromise = this.persistCards(giftCard.name, newMap);
            yield Promise.all([savePromise, this.updateActiveCards([giftCard], opts)]);
        });
    }
    hideDiscountItem() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            return this.persistenceProvider.setHideGiftCardDiscountItem(true);
        });
    }
    getAllCardsOfBrand(cardBrand) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            const cardConfigs = supportedCards.filter(cardConfig => cardConfig.displayName === cardBrand);
            const cardPromises = cardConfigs.map(cardConfig => this.getPurchasedCards(cardConfig.name));
            const cardsGroup = yield Promise.all(cardPromises);
            return cardsGroup
                .reduce((allCards, brandCards) => allCards.concat(brandCards), [])
                .sort(sortByDescendingDate);
        });
    }
    getRecentlyPurchasedBrandNames() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const purchasedBrands = yield this.getPurchasedBrands();
            this.logger.debug('got purchased brands');
            const recentlyPurchasedBrands = purchasedBrands
                .map(cards => cards.sort(sortByDescendingDate))
                .sort((a, b) => sortByDescendingDate(a[0], b[0]));
            return recentlyPurchasedBrands
                .map(brandCards => brandCards[0].displayName)
                .slice(0, 6);
        });
    }
    getPurchasedBrands() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            this.logger.debug('got supportedCards in getPurchasedBrands');
            const supportedCardNames = supportedCards.map(c => c.name);
            const purchasedCardPromises = supportedCardNames.map(cardName => this.getPurchasedCards(cardName));
            const purchasedCards = yield Promise.all(purchasedCardPromises);
            this.logger.debug('got purchasedCards in getPurchasedBrands');
            return purchasedCards
                .filter(brand => brand.length)
                .sort((a, b) => sortByDisplayName(a[0], b[0]));
        });
    }
    updateActiveCards(giftCardsToUpdate, opts = {}) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            let oldActiveGiftCards = (yield this.persistenceProvider.getActiveGiftCards(this.getNetwork())) ||
                {};
            if (typeof oldActiveGiftCards !== 'object') {
                oldActiveGiftCards = {};
            }
            const newMap = giftCardsToUpdate.reduce((updatedMap, c) => this.getNewSaveableGiftCardMap(updatedMap, c, {
                remove: c.archived || opts.remove
            }), oldActiveGiftCards);
            return this.persistenceProvider.setActiveGiftCards(this.getNetwork(), JSON.stringify(newMap));
        });
    }
    clearActiveGiftCards() {
        return this.persistenceProvider.setActiveGiftCards(this.getNetwork(), JSON.stringify({}));
    }
    persistCards(cardName, newMap) {
        return this.persistenceProvider.setGiftCards(cardName, this.getNetwork(), JSON.stringify(newMap));
    }
    saveGiftCard(giftCard, opts) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const originalCard = (yield this.getPurchasedCards(giftCard.name)).find(c => c.invoiceId === giftCard.invoiceId);
            const cardChanged = !originalCard ||
                originalCard.status !== giftCard.status ||
                originalCard.archived !== giftCard.archived ||
                originalCard.barcodeImage !== giftCard.barcodeImage;
            const shouldNotify = cardChanged && giftCard.status !== 'UNREDEEMED';
            yield this.saveCard(giftCard, opts);
            shouldNotify && this.cardUpdatesSubject.next(giftCard);
        });
    }
    getNewSaveableGiftCardMap(oldGiftCards, gc, opts) {
        if (lodash["isString"](oldGiftCards)) {
            oldGiftCards = JSON.parse(oldGiftCards);
        }
        if (lodash["isString"](gc)) {
            gc = JSON.parse(gc);
        }
        const isValidMap = gcMap => Object.keys(gcMap || {}).every(invoiceId => invoiceId.length > 15 && oldGiftCards[invoiceId].currency);
        let newMap = isValidMap(oldGiftCards) ? oldGiftCards : {};
        newMap[gc.invoiceId] = gc;
        if (opts && (opts.error || opts.status)) {
            newMap[gc.invoiceId] = lodash["assign"](newMap[gc.invoiceId], opts);
        }
        if (opts && opts.remove) {
            delete newMap[gc.invoiceId];
        }
        return newMap;
    }
    archiveCard(card) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            card.archived = true;
            yield this.saveGiftCard(card);
        });
    }
    unarchiveCard(card) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            card.archived = false;
            yield this.saveGiftCard(card);
        });
    }
    archiveAllCards(cardName) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const activeCards = (yield this.getPurchasedCards(cardName)).filter(c => !c.archived);
            const oldGiftCards = yield this.getCardMap(cardName);
            const invoiceIds = Object.keys(oldGiftCards);
            const newMap = invoiceIds.reduce((newMap, invoiceId) => {
                const card = oldGiftCards[invoiceId];
                card.archived = true;
                return this.getNewSaveableGiftCardMap(newMap, card);
            }, oldGiftCards);
            yield Promise.all([
                this.persistCards(cardName, newMap),
                this.updateActiveCards(activeCards.map(c => (Object.assign({}, c, { archived: true }))))
            ]);
            activeCards
                .map(c => (Object.assign({}, c, { archived: true })))
                .forEach(c => this.cardUpdatesSubject.next(c));
        });
    }
    createGiftCard(data) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const dataSrc = {
                brand: data.name,
                clientId: data.uuid,
                invoiceId: data.invoiceId,
                accessKey: data.accessKey
            };
            const name = data.name;
            const cardConfig = yield this.getCardConfig(name);
            const url = `${this.getApiPath()}/redeem`;
            return this.http
                .post(url, dataSrc)
                .catch(err => {
                this.logger.error(`${cardConfig.name} Gift Card Create/Update: ${err.message}`);
                const errMessage = err.error && err.error.message;
                const pendingMessages = [
                    'Card creation delayed',
                    'Invoice is unpaid or payment has not confirmed'
                ];
                return pendingMessages.indexOf(errMessage) > -1 ||
                    errMessage.indexOf('Please wait') > -1
                    ? Object(of["of"])(Object.assign({}, data, { status: 'PENDING' }))
                    : Rx["Observable"].throw(err);
            })
                .map((res) => {
                const status = res.claimCode || res.claimLink ? 'SUCCESS' : 'PENDING';
                const fullCard = Object.assign({}, data, res, { name,
                    status });
                this.logger.info(`${cardConfig.name} Gift Card Create/Update: ${fullCard.status}`);
                return fullCard;
            })
                .toPromise();
        });
    }
    updatePendingGiftCards(cards) {
        const cardsNeedingUpdate = cards.filter(card => this.checkIfCardNeedsUpdate(card));
        return Object(from["from"])(cardsNeedingUpdate).pipe(Object(operators["switchMap"])(card => Object(fromPromise["fromPromise"])(this.createGiftCard(card)).catch(err => {
            this.logger.error('Error creating gift card:', err);
            this.logger.error('Gift card: ', JSON.stringify(card, null, 4));
            return Object(of["of"])(Object.assign({}, card, { status: 'FAILURE' }));
        })), Object(operators["switchMap"])(card => card.status === 'UNREDEEMED' || card.status === 'PENDING'
            ? Object(fromPromise["fromPromise"])(this.getTKCoinInvoice(card.invoiceId).then(invoice => (Object.assign({}, card, { status: (card.status === 'PENDING' ||
                    (card.status === 'UNREDEEMED' &&
                        invoice.status !== 'new')) &&
                    invoice.status !== 'expired' &&
                    invoice.status !== 'invalid'
                    ? 'PENDING'
                    : 'expired' }))))
            : Object(of["of"])(card)), Object(operators["switchMap"])(updatedCard => this.updatePreviouslyPendingCard(updatedCard)), Object(operators["switchMap"])(updatedCard => {
            this.logger.debug('Gift card updated');
            return Object(of["of"])(updatedCard);
        }));
    }
    updatePreviouslyPendingCard(updatedCard) {
        return Object(fromPromise["fromPromise"])(this.saveGiftCard(updatedCard, {
            remove: updatedCard.status === 'expired'
        }).then(() => updatedCard));
    }
    checkIfCardNeedsUpdate(card) {
        if (!card.invoiceId) {
            return false;
        }
        // Continues normal flow (update card)
        if (card.status === 'PENDING' ||
            card.status === 'UNREDEEMED' ||
            card.status === 'invalid' ||
            (!card.claimCode && !card.claimLink)) {
            return true;
        }
        // Check if card status FAILURE for 24 hours
        if (card.status === 'FAILURE' &&
            this.timeProvider.withinPastDay(card.date)) {
            return true;
        }
        // Success: do not update
        return false;
    }
    getSupportedCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const [availableCards, cachedApiCardConfig] = yield Promise.all([
                this.getAvailableCards().catch(err => {
                    this.logger.error('Error calling getAvailableCards in getSupportedCards', err);
                    this.clearCardConfigCache();
                    return [];
                }),
                this.getCachedApiCardConfig().catch(_ => ({}))
            ]);
            const cachedCardNames = Object.keys(cachedApiCardConfig);
            const availableCardNames = availableCards.map(c => c.name);
            const uniqueCardNames = Array.from(new Set([...availableCardNames, ...cachedCardNames]));
            const supportedCards = uniqueCardNames
                .map(cardName => {
                const freshConfig = availableCards.find(c => c.name === cardName);
                const cachedConfig = appendFallbackImages(cachedApiCardConfig[cardName]);
                const config = freshConfig || cachedConfig;
                const displayName = config.displayName || config.brand || config.name;
                return Object.assign({}, config, { displayName });
            })
                .filter(filterDisplayableConfig)
                .sort(sortByDisplayName);
            return supportedCards;
        });
    }
    getSupportedCardMap() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            return supportedCards.reduce((map, cardConfig) => (Object.assign({}, map, { [cardConfig.name]: cardConfig })), {});
        });
    }
    refreshActiveGiftCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield this.clearActiveGiftCards();
            const purchasedBrands = yield this.getPurchasedBrands();
            const activeCardsGroupedByBrand = purchasedBrands.filter(cards => cards.filter(c => !c.archived).length);
            const activeCards = activeCardsGroupedByBrand
                .reduce((allCards, brandCards) => [...allCards, ...brandCards], [])
                .filter(c => !c.archived);
            yield this.updateActiveCards(activeCards);
            return activeCards;
        });
    }
    fetchAvailableCardMap() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const shouldSync = yield this.shouldSyncGiftCardPurchasesWithTKCoinId();
            const userInfo = yield this.persistenceProvider.getTKCoinIdUserInfo(this.getNetwork());
            const incentiveLevelId = userInfo && userInfo.incentiveLevelId;
            const availableCardMap = shouldSync && incentiveLevelId
                ? yield this.getGiftCardCatalog(incentiveLevelId)
                : yield this.getGiftCardCatalog();
            this.cacheApiCardConfig(availableCardMap);
            this.logger.debug('fetched available card map', shouldSync ? 'synced' : 'unsynced');
            return availableCardMap;
        });
    }
    getGiftCardCatalog(incentiveLevelId = '') {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const country = yield this.locationProvider.getCountry();
            const url = `${this.credentials.TKCOIN_API_URL}/gift-cards/catalog/${country}${incentiveLevelId ? `/${incentiveLevelId}` : ''}`;
            return this.http.get(url).toPromise();
        });
    }
    cacheApiCardConfig(availableCardMap) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const cardNames = Object.keys(availableCardMap);
            const previousCache = yield this.persistenceProvider.getGiftCardConfigCache(this.getNetwork());
            const apiCardConfigCache = getCardConfigFromApiConfigMap(availableCardMap, this.platformProvider.isCordova).reduce((configMap, apiCardConfigMap, index) => {
                const name = cardNames[index];
                return Object.assign({}, configMap, { [name]: apiCardConfigMap });
            }, {});
            const newCache = Object.assign({}, previousCache, apiCardConfigCache);
            if (JSON.stringify(previousCache) !== JSON.stringify(newCache)) {
                yield this.persistenceProvider.setGiftCardConfigCache(this.getNetwork(), newCache);
            }
        });
    }
    fetchCachedApiCardConfig() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.cachedApiCardConfigPromise = this.persistenceProvider.getGiftCardConfigCache(this.getNetwork());
            return this.cachedApiCardConfigPromise;
        });
    }
    getCachedApiCardConfig() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const config = this.cachedApiCardConfigPromise
                ? yield this.cachedApiCardConfigPromise
                : yield this.fetchCachedApiCardConfig();
            this.logger.debug('got cached api card config');
            return config || {};
        });
    }
    savePhone(phone, phoneCountryInfo) {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            yield Promise.all([
                this.persistenceProvider.setPhone(phone),
                this.persistenceProvider.setPhoneCountryInfo(phoneCountryInfo)
            ]);
        });
    }
    getPhoneAndCountryCode() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const [phone, phoneCountryInfo] = yield Promise.all([
                this.persistenceProvider.getPhone(),
                this.persistenceProvider.getPhoneCountryInfo()
            ]);
            return {
                phone: phone && `${phone}`,
                phoneCountryInfo: phoneCountryInfo || {
                    phoneCountryCode: '',
                    countryIsoCode: ''
                }
            };
        });
    }
    getAvailableCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            return this.availableCardsPromise
                ? this.availableCardsPromise
                : this.fetchAvailableCards();
        });
    }
    fetchAvailableCards() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            this.availableCardsPromise = Promise.all([
                this.fetchAvailableCardMap()
            ]).then(([availableCardMap]) => getCardConfigFromApiConfigMap(availableCardMap, this.platformProvider.isCordova)
                .map(apiCardConfig => (Object.assign({}, apiCardConfig, { displayName: apiCardConfig.displayName || apiCardConfig.name, tags: apiCardConfig.tags || [] })))
                .filter(filterDisplayableConfig)
                .sort(sortByDisplayName));
            return this.availableCardsPromise;
        });
    }
    preloadImages() {
        return tslib_es6["__awaiter"](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            const imagesPerCard = supportedCards
                .map(c => [c.icon, c.cardImage])
                .filter(images => images[0] && images[1]);
            const fetchBatches = imagesPerCard.map(images => () => tslib_es6["__awaiter"](this, void 0, void 0, function* () { return Promise.all(images.map(i => this.imageLoader.preload(i))); }));
            yield promiseSerial(fetchBatches);
        });
    }
    logEvent(eventName, eventParams) {
        if (this.getNetwork() !== persistence["a" /* Network */].livenet)
            return;
        this.analyticsProvider.logEvent(eventName, eventParams);
    }
    getPromoEventParams(promotedCard, context) {
        const discount = promotedCard.discounts && promotedCard.discounts[0];
        const promo = promotedCard.promotions && promotedCard.promotions[0];
        return Object.assign({ brand: promotedCard.name, name: (discount && discount.code) || promo.shortDescription, context, type: (discount && discount.type) || 'promo' }, (discount && { discountAmount: discount && discount.amount }));
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'giftcards',
            title: 'Gift Cards',
            icon: 'assets/img/gift-cards/gift-cards-icon.svg',
            show: !!this.configProvider.get().showIntegration['giftcards'],
            type: 'card'
        });
    }
};
gift_card_GiftCardProvider = tslib_es6["__decorate"]([
    Object(core["Injectable"])(),
    tslib_es6["__metadata"]("design:paramtypes", [analytics["a" /* AnalyticsProvider */],
        tkcoin_id["a" /* TKCoinIdProvider */],
        config_config["a" /* ConfigProvider */],
        ionic_angular["f" /* Events */],
        dist["a" /* ImageLoader */],
        home_integrations["a" /* HomeIntegrationsProvider */],
        time["a" /* TimeProvider */],
        email_notifications["a" /* EmailNotificationsProvider */],
        esm5_http["a" /* HttpClient */],
        logger_logger["a" /* Logger */],
        persistence["b" /* PersistenceProvider */],
        platform["a" /* PlatformProvider */],
        location_location["a" /* LocationProvider */]])
], gift_card_GiftCardProvider);

function getCardConfigFromApiConfigMap(availableCardMap, isCordova) {
    const cardNames = Object.keys(availableCardMap);
    const availableCards = cardNames
        .filter(cardName => availableCardMap[cardName] && availableCardMap[cardName].length)
        .map(cardName => getCardConfigFromApiBrandConfig(cardName, availableCardMap[cardName]))
        .map(cardConfig => removeDiscountsIfNotMobile(cardConfig, isCordova));
    return availableCards;
}
function removeDiscountsIfNotMobile(cardConfig, isCordova) {
    return Object.assign({}, cardConfig, { discounts: isCordova ? cardConfig.discounts : undefined, promotions: isCordova ? cardConfig.promotions : undefined });
}
function getCardConfigFromApiBrandConfig(cardName, apiBrandConfig) {
    const cards = apiBrandConfig;
    const [firstCard] = cards;
    const { currency } = firstCard;
    const range = cards.find(c => !!(c.maxAmount || c.minAmount) && c.currency === currency);
    const fixed = cards.filter(c => c.amount && c.currency);
    const supportedAmounts = fixed
        .reduce((newSupportedAmounts, currentCard) => [
        ...newSupportedAmounts,
        currentCard.amount
    ], [])
        .sort((a, b) => a - b);
    const activationFees = cards
        .filter(c => c.activationFees)
        .reduce((allFees, card) => allFees.concat(card.activationFees), []);
    const { amount, type, maxAmount, minAmount } = firstCard, config = tslib_es6["__rest"](firstCard, ["amount", "type", "maxAmount", "minAmount"]);
    const baseConfig = Object.assign({}, config, { name: cardName, activationFees });
    return range
        ? Object.assign({}, baseConfig, { minAmount: range.minAmount < 1 ? 1 : range.minAmount, maxAmount: range.maxAmount }) : Object.assign({}, baseConfig, { supportedAmounts });
}
function getActivationFee(amount, cardConfig) {
    const activationFees = (cardConfig && cardConfig.activationFees) || [];
    const fixedFee = activationFees.find(fee => fee.type === 'fixed' &&
        amount >= fee.amountRange.min &&
        amount <= fee.amountRange.max);
    return (fixedFee && fixedFee.fee) || 0;
}
function filterDisplayableConfig(cardConfig) {
    return (cardConfig.logo &&
        cardConfig.icon &&
        cardConfig.cardImage &&
        !cardConfig.hidden);
}
function sortByDescendingDate(a, b) {
    return a.date < b.date ? 1 : -1;
}
function sortByDisplayName(a, b) {
    const aSortValue = getDisplayNameSortValue(a.displayName);
    const bSortValue = getDisplayNameSortValue(b.displayName);
    return aSortValue > bSortValue ? 1 : -1;
}
function getDisplayNameSortValue(displayName) {
    const startsNumeric = value => /^[0-9]$/.test(value.charAt(0));
    const name = displayName.toLowerCase();
    return `${startsNumeric(name) ? 'zzz' : ''}${name}`;
}
function setNullableCardFields(card, cardConfig) {
    return Object.assign({}, card, { name: cardConfig.name, displayName: cardConfig.displayName, currency: card.currency || getCurrencyFromLegacySavedCard(cardConfig.name) });
}
function getCardsFromInvoiceMap(invoiceMap, configMap) {
    return Object.keys(invoiceMap)
        .map(invoiceId => invoiceMap[invoiceId])
        .filter(card => card.invoiceId && configMap[card.name])
        .map(card => setNullableCardFields(card, configMap[card.name]))
        .sort(sortByDescendingDate);
}
function hasVisibleDiscount(cardConfig) {
    return !!getVisibleDiscount(cardConfig);
}
function hasPromotion(cardConfig) {
    return !!(cardConfig.promotions && cardConfig.promotions[0]);
}
function getPromo(cardConfig) {
    return (getVisibleDiscount(cardConfig) ||
        (cardConfig.promotions && cardConfig.promotions[0]));
}
function getVisibleDiscount(cardConfig) {
    const discounts = cardConfig.discounts;
    const supportedDiscountTypes = ['flatrate', 'percentage'];
    return (discounts &&
        discounts.find(d => supportedDiscountTypes.includes(d.type) && !d.hidden));
}
function appendFallbackImages(cardConfig) {
    // For cards bought outside of the user's current IP catalog area before server-side
    // catalog management was implemented and card images were stored locally.
    const getBrandImagePath = brandName => {
        const cardImagePath = `https://tkcoin.org/gift-cards/assets/`;
        const brandImageDirectory = brandName
            .toLowerCase()
            .replace(/[^0-9a-z]/gi, '');
        return `${cardImagePath}${brandImageDirectory}/`;
    };
    const getImagesForBrand = brandName => {
        const imagePath = getBrandImagePath(brandName);
        return {
            cardImage: `${imagePath}card.png`,
            icon: `${imagePath}icon.svg`,
            logo: `${imagePath}logo.svg`
        };
    };
    const needsFallback = cardConfig &&
        cardConfig.cardImage &&
        !cardConfig.cardImage.includes('https://tkcoin.org');
    return needsFallback
        ? Object.assign({}, cardConfig, getImagesForBrand(cardConfig.name)) : cardConfig;
}
function getCurrencyFromLegacySavedCard(cardName) {
    switch (cardName) {
        case 'Amazon.com':
            return 'USD';
        case 'Amazon.co.jp':
            return 'JPY';
        case 'Mercado Livre':
            return 'BRL';
        default:
            return 'USD';
    }
}
//# sourceMappingURL=gift-card.js.map

/***/ }),

/***/ 927:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__ = __webpack_require__(225);





let ActionSheetComponent = class ActionSheetComponent {
    constructor(domProvider, platform, zone) {
        this.domProvider = domProvider;
        this.platform = platform;
        this.zone = zone;
        this.maxHeight = '90vh';
        this.minHeight = 'unset';
        this.transitionDuration = 250;
        this.slideIn = false;
    }
    ngOnInit() {
        this.overrideHardwareBackButton();
    }
    present(componentRef, params = {
            maxHeight: '90vh',
            minHeight: 'unset'
        }) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.parentComponentRef = componentRef;
            yield __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"].timer(50).toPromise();
            this.zone.run(() => {
                this.maxHeight = params.maxHeight;
                this.minHeight = params.minHeight;
                this.slideIn = true;
            });
        });
    }
    dismiss(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.zone.run(() => (this.slideIn = false));
            this.dismissFunction && this.dismissFunction(data);
            yield __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"].timer(this.transitionDuration).toPromise();
            this.domProvider.removeComponent(this.parentComponentRef);
        });
    }
    overrideHardwareBackButton() {
        this.deregisterBackButtonAction = this.platform.registerBackButtonAction(() => this.dismiss());
    }
    ngOnDestroy() {
        this.deregisterBackButtonAction();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["HostBinding"])('class.open'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Boolean)
], ActionSheetComponent.prototype, "slideIn", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Boolean)
], ActionSheetComponent.prototype, "fromTop", void 0);
ActionSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'action-sheet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-sheet/action-sheet.html"*/'<div class="backdrop" [ngClass]="{\'backdrop-fade-in\': slideIn}" (click)="dismiss()"></div>\n<div class="action-sheet" [ngStyle]="{\'max-height\': maxHeight, \'min-height\': minHeight}"\n  [ngClass]="{\'opened\': slideIn, \'closed-top\': !slideIn && fromTop, \'closed-bottom\': !slideIn && !fromTop, \'action-sheet-top\': fromTop, \'action-sheet-bottom\': !fromTop}">\n  <ng-content></ng-content>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/action-sheet/action-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__["a" /* DomProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]])
], ActionSheetComponent);

//# sourceMappingURL=action-sheet.js.map

/***/ }),

/***/ 928:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmailComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__ = __webpack_require__(107);





let EmailComponent = class EmailComponent extends __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(externalLinkProvider) {
        super();
        this.externalLinkProvider = externalLinkProvider;
        this.emailForm = new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["c" /* FormGroup */]({
            email: new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["b" /* FormControl */]('', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required,
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].pattern(/(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-Za-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/)
            ])),
            agreement: new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["b" /* FormControl */](false, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].requiredTrue)
        });
    }
    ionViewDidLoad() {
        this.emailForm.setValue({
            email: ''
        });
    }
    optionClicked() {
        this.dismiss(this.emailForm.value.email);
    }
    openPolicy() {
        let url = 'https://tkcoin.org/about/privacy';
        this.externalLinkProvider.open(url);
    }
};
EmailComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'email-component',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/email-component/email-component.html"*/'<action-sheet>\n  <div class="padding">\n    <div class="title">\n      <span translate>Contact Information</span>\n    </div>\n    <div class="sub-title">\n      <span translate>Please provide your email address to receive payment notifications</span>\n    </div>\n    <form [formGroup]="emailForm">\n      <ion-item class="form__form-item form__form__dark form--border-overwrite">\n        <ion-label floating>{{ \'Email address\' | translate }}</ion-label>\n        <ion-input mode="md" formControlName="email" type="email"></ion-input>\n      </ion-item>\n\n      <ion-item class="form__form-item form__form-toggle" no-lines>\n        <ion-label (click)="openPolicy()" class="form__form-toggle__label">\n          {{\'By giving my email address, I give explicit consent to TKCoin to use it to contact me about payment issues.\' | translate}}\n            <span class="form__form__link" translate> Privacy Notice</span>\n        </ion-label>\n        <ion-toggle formControlName="agreement" color="success"></ion-toggle>\n      </ion-item>\n    </form>\n  </div>\n\n  <div class="padding-bottom">\n    <button ion-button class="button-standard" [disabled]="emailForm.invalid" (click)="optionClicked()">\n      {{\'Save\' | translate}}\n    </button>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/email-component/email-component.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], EmailComponent);

//# sourceMappingURL=email-component.js.map

/***/ }),

/***/ 929:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EncryptPasswordComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_info_sheet_info_sheet__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_dom_dom__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__action_sheet_action_sheet_parent__ = __webpack_require__(107);







let EncryptPasswordComponent = class EncryptPasswordComponent extends __WEBPACK_IMPORTED_MODULE_6__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(domProvider, fb, appProvider) {
        super();
        this.domProvider = domProvider;
        this.fb = fb;
        this.appProvider = appProvider;
        this.passwordInputType = 'password';
        this.confirmPasswordInputType = 'password';
        this.isCopay = this.appProvider.info.name === 'copay';
        this.encryptPasswordForm = this.fb.group({
            password: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required],
            confirmPassword: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required]
        }, { validator: this.matchingPasswords('password', 'confirmPassword') });
    }
    matchingPasswords(passwordKey, confirmPasswordKey) {
        return (group) => {
            const password = group.controls[passwordKey];
            const confirmPassword = group.controls[confirmPasswordKey];
            if (password.value !== confirmPassword.value) {
                return {
                    mismatchedPasswords: true
                };
            }
            return undefined;
        };
    }
    showInfoSheet() {
        const infoSheet = this.createInfoSheet('encrypt-password-warning');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.dismiss();
            }
        });
    }
    createInfoSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_3__components_info_sheet_info_sheet__["b" /* InfoSheetComponent */], type, params)
            .instance;
    }
    setupSheet(componentType, sheetType, params) {
        const sheet = this.domProvider.appendComponentToBody(componentType);
        sheet.instance.componentRef = sheet;
        sheet.instance.sheetType = sheetType;
        sheet.instance.params = params;
        return sheet;
    }
    next() {
        this.showForm = true;
    }
    confirm(password) {
        this.dismiss(password);
    }
};
EncryptPasswordComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'encrypt-password',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/encrypt-password/encrypt-password.html"*/'<action-sheet>\n  <div class="encrypt-password" *ngIf="!showForm">\n    <div class="encrypt-password-info">\n      <div class="img-container">\n        <img src="assets/img/icon-encrypt.svg" />\n      </div>\n      <div class="info">\n        <h3 class="title" translate>Add Encryption?</h3>\n        <div class="text" translate>\n          An encrypted passphrase is an extra layer of security that can prevent hackers from accessing your cryptocurrency if this device were ever stolen or compromised by malicious software.\n        </div>\n      </div>\n    </div>\n    <div class="footer">\n      <button ion-button class="button-standard no-margin-bottom" (click)="showForm = !showForm">\n        {{\'Yes\' | translate}}\n      </button>\n      <button ion-button clear color="primary" class="button-standard" (click)="showInfoSheet()">\n        {{\'No\' | translate}}\n      </button>\n    </div>\n  </div>\n\n  <div class="encrypt-password" *ngIf="showForm">\n    <div class="encrypt-password-form">\n      <div class="slide-title">\n        {{\'Add Encryption\' | translate}}\n      </div>\n      <form [formGroup]="encryptPasswordForm">\n        <ion-item>\n          <ion-label floating>{{\'Passphrase\' | translate}}</ion-label>\n          <ion-input [type]="passwordInputType" formControlName="password"></ion-input>\n          <button ion-button clear item-end (click)="passwordInputType = (passwordInputType == \'password\') ? \'text\' : \'password\';">\n            <ion-icon [name]="(passwordInputType == \'password\') ? \'md-eye-off\' : \'md-eye\'"></ion-icon>\n          </button>\n        </ion-item>\n        <ion-item>\n          <ion-label floating>{{\'Confirm Passphrase\' | translate}}</ion-label>\n          <ion-input [type]="confirmPasswordInputType" formControlName="confirmPassword"></ion-input>\n          <button ion-button clear item-end (click)="confirmPasswordInputType = (confirmPasswordInputType == \'password\') ? \'text\' : \'password\';">\n            <ion-icon *ngIf="encryptPasswordForm.controls.confirmPassword.touched && encryptPasswordForm.hasError(\'mismatchedPasswords\') && encryptPasswordForm.controls.password.valid" name="md-alert"></ion-icon>\n            <ion-icon [name]="(confirmPasswordInputType == \'password\') ? \'md-eye-off\' : \'md-eye\'"></ion-icon>\n          </button>\n        </ion-item>\n        <ion-item class="no-lines">\n          <span *ngIf="encryptPasswordForm.controls.confirmPassword.touched && encryptPasswordForm.hasError(\'mismatchedPasswords\') && encryptPasswordForm.controls.password.valid" ion-text color="error" translate>Passphrases do not match</span>\n        </ion-item>\n      </form>\n      <label-tip type="info" header="no-header">\n        <div label-tip-body>\n          {{\'Enter an alphanumeric passphrase to encrypt your wallet\' | translate }}\n          <span *ngIf="!isCopay"> {{\'For best security this should not match your TKCoin ID password.\' | translate }}</span>\n        </div>\n      </label-tip>\n    </div>\n    <div class="footer">\n      <button ion-button type="submit" class="button-standard no-margin-bottom" [disabled]="!encryptPasswordForm.valid" (click)="confirm(encryptPasswordForm.value.password)">\n        {{\'Continue\' | translate}}\n      </button>\n      <button ion-button clear color="primary" class="button-standard" (click)="showInfoSheet()">\n        {{\'Never mind\' | translate}}\n      </button>\n    </div>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/encrypt-password/encrypt-password.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_dom_dom__["a" /* DomProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */]])
], EncryptPasswordComponent);

//# sourceMappingURL=encrypt-password.js.map

/***/ }),

/***/ 93:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var bufferUtil = __webpack_require__(48);
var assert = __webpack_require__(12);

var BufferWriter = function BufferWriter(obj) {
  if (!(this instanceof BufferWriter))
    return new BufferWriter(obj);
  this.bufLen = 0;
  if (obj)
    this.set(obj);
  else
    this.bufs = [];
};

BufferWriter.prototype.set = function(obj) {
  this.bufs = obj.bufs || this.bufs || [];
  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);
  return this;
};

BufferWriter.prototype.toBuffer = function() {
  return this.concat();
};

BufferWriter.prototype.concat = function() {
  return Buffer.concat(this.bufs, this.bufLen);
};

BufferWriter.prototype.write = function(buf) {
  assert(bufferUtil.isBuffer(buf));
  this.bufs.push(buf);
  this.bufLen += buf.length;
  return this;
};

BufferWriter.prototype.writeReverse = function(buf) {
  assert(bufferUtil.isBuffer(buf));
  this.bufs.push(bufferUtil.reverse(buf));
  this.bufLen += buf.length;
  return this;
};

BufferWriter.prototype.writeUInt8 = function(n) {
  var buf = Buffer.alloc(1);
  buf.writeUInt8(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt16BE = function(n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16BE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt16LE = function(n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt32BE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32BE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeInt32LE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeInt32LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt32LE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt64BEBN = function(bn) {
  var buf = bn.toBuffer({size: 8});
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt64LEBN = function(bn) {
  var buf = bn.toBuffer({size: 8});
  this.writeReverse(buf);
  return this;
};

BufferWriter.prototype.writeVarintNum = function(n) {
  var buf = BufferWriter.varintBufNum(n);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeVarintBN = function(bn) {
  var buf = BufferWriter.varintBufBN(bn);
  this.write(buf);
  return this;
};

BufferWriter.varintBufNum = function(n) {
  var buf = undefined;
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    buf = Buffer.alloc(1 + 8);
    buf.writeUInt8(255, 0);
    buf.writeInt32LE(n & -1, 1);
    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
  }
  return buf;
};

BufferWriter.varintBufBN = function(bn) {
  var buf = undefined;
  var n = bn.toNumber();
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    var bw = new BufferWriter();
    bw.writeUInt8(255);
    bw.writeUInt64LEBN(bn);
    var buf = bw.concat();
  }
  return buf;
};

module.exports = BufferWriter;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 930:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AlertType */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InfoSheetTemplate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__);



var AlertType;
(function (AlertType) {
    AlertType["info"] = "info";
    AlertType["success"] = "success";
    AlertType["warning"] = "warning";
    AlertType["danger"] = "danger";
    AlertType["love"] = "love";
    AlertType["safeguard"] = "safeguard";
})(AlertType || (AlertType = {}));
let InfoSheetTemplate = class InfoSheetTemplate {
    constructor() {
        this.type = AlertType.info;
        this.dismissSubject = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__["Subject"]();
        this.onDismiss = this.dismissSubject.asObservable();
    }
    dismiss(option) {
        this.dismissSubject.next(option);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", String)
], InfoSheetTemplate.prototype, "type", void 0);
InfoSheetTemplate = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'info-sheet-template',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/info-sheet/info-sheet-template.html"*/'<div class="confirm-sheet">\n  <div class="sheet-title">\n    <div class="title-icon">\n      <img *ngIf="type === \'success\'" src="assets/img/green-check-circled.svg">\n      <img *ngIf="type === \'info\'" src="assets/img/icon-info-blue.svg">\n      <img *ngIf="type === \'warning\'" src="assets/img/icon-warning-circled.svg">\n      <img *ngIf="type === \'danger\'" src="assets/img/icon-danger.svg">\n      <img *ngIf="type === \'love\'" src="assets/img/icon-heart.svg">\n      <img *ngIf="type === \'safeguard\'" src="assets/img/icon-safeguard.svg">\n    </div>\n    <ng-content select="[sheet-title-text]"></ng-content>\n  </div>\n  <div class="sheet-text">\n    <ng-content select="[sheet-text]"></ng-content>\n  </div>\n  <div class="sheet-btn-group">\n    <div class="sheet-btn" [ngClass]="{blue: type === \'info\' || type === \'love\', yellow: type === \'warning\', red: type === \'danger\'}" (click)="dismiss(true)">\n      <ng-content select="[sheet-button-text]"></ng-content>\n    </div>\n    <div class="sheet-second-btn" [ngClass]="{primary: type == \'danger\'}" (click)="dismiss(false)">\n      <ng-content select="[sheet-second-button-text]"></ng-content>\n    </div>\n  </div>\n</div>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/info-sheet/info-sheet-template.html"*/
    })
], InfoSheetTemplate);

//# sourceMappingURL=info-sheet-template.js.map

/***/ }),

/***/ 931:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__ = __webpack_require__(107);





let IncomingDataMenuComponent = class IncomingDataMenuComponent extends __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(currencyProvider, platformProvider) {
        super();
        this.currencyProvider = currencyProvider;
        this.platformProvider = platformProvider;
        this.isCordova = this.platformProvider.isCordova;
    }
    ngOnInit() {
        this.data = this.params.data.data;
        this.type = this.params.data.type;
        this.coin = this.params.data.coin;
        this.coinName = this.coin && this.currencyProvider.getCoinName(this.coin);
        this.fromHomeCard = this.params.data.fromHomeCard;
    }
    close(redirTo, value) {
        this.dismiss({ redirTo, value, coin: this.coin });
    }
};
IncomingDataMenuComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'incoming-data-menu',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/incoming-data-menu/incoming-data-menu.html"*/'<action-sheet>\n  <ion-list class="bp-list" *ngIf="type === \'bitcoinAddress\' || type === \'ethereumAddress\' || type === \'rippleAddress\' || type === \'dogecoinAddress\'">\n    <ion-item-divider *ngIf="coinName">{{\'{coinName} Address\' | translate: { coinName: coinName } }}</ion-item-divider>\n    <ion-item>\n      {{data}}\n      <ion-icon item-start>\n        <img src="assets/img/icon-{{coin}}-small.svg" alt="Coin">\n      </ion-icon>\n    </ion-item>\n    <button ion-item (click)="close(\'AddressbookAddPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-contacts.svg">\n      </ion-icon>\n      <span translate>Add as a contact</span>\n    </button>\n    <button ion-item (click)="close(\'AmountPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-send-alt.svg">\n      </ion-icon>\n      <span translate>Send payment to this address</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list class="bp-list" *ngIf="type === \'text\'">\n    <ion-item-divider>{{\'Text\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n    </ion-item>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list class="bp-list" *ngIf="type === \'privateKey\'">\n    <ion-item-divider>{{\'Private Key\' | translate}}</ion-item-divider>\n    <ion-item>{{data}}</ion-item>\n    <button ion-item (click)="close(\'PaperWalletPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-import.svg">\n      </ion-icon>\n      <span translate>Sweep paper wallet</span>\n    </button>\n    <button *ngIf="!fromHomeCard" ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <button ion-button clear color="danger" class="button-standard" (click)="close(null, null)">\n    {{\'Close\' | translate}}\n  </button>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/incoming-data-menu/incoming-data-menu.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__["a" /* PlatformProvider */]])
], IncomingDataMenuComponent);

//# sourceMappingURL=incoming-data-menu.js.map

/***/ }),

/***/ 932:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MemoComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(107);




let MemoComponent = class MemoComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(formBuilder) {
        super();
        this.formBuilder = formBuilder;
        this.memoForm = this.formBuilder.group({
            memo: ['']
        });
    }
    ngOnInit() {
        this.memoForm.setValue({
            memo: this.params.memo || ''
        });
    }
    optionClicked() {
        this.dismiss(this.memoForm.value.memo);
    }
};
MemoComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'memo-component',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/memo-component/memo-component.html"*/'<action-sheet>\n  <div class="title">\n    <span translate>Memo</span>\n  </div>\n  <form [formGroup]="memoForm">\n    <ion-textarea placeholder="{{\'Enter a transaction memo\' | translate}}" formControlName="memo" autocomplete="off" autocorrect="off"></ion-textarea>\n  </form>\n\n  <button ion-button class="button-standard safe-area" [disabled]="memoForm.invalid" (click)="optionClicked()">\n    {{\'Save\' | translate}}\n  </button>\n</action-sheet>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/memo-component/memo-component.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */]])
], MemoComponent);

//# sourceMappingURL=memo-component.js.map

/***/ }),

/***/ 933:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MinerFeeWarningComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__ = __webpack_require__(107);





let MinerFeeWarningComponent = class MinerFeeWarningComponent extends __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(appProvider, externalLinkProvider) {
        super();
        this.appProvider = appProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.appName = this.appProvider.info.nameCase;
    }
    confirm() {
        this.dismiss();
    }
    openExternalLink() {
        const url = '';
        'https://support.tkcoin.org/hc/en-us/articles/115004439366-Why-is-my-recommended-bitcoin-miner-fee-so-high-';
        this.externalLinkProvider.open(url);
    }
};
MinerFeeWarningComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'miner-fee-warning',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/miner-fee-warning/miner-fee-warning.html"*/'<action-sheet>\n  <div class="miner-fee">\n    <div class="miner-fee-info">\n      <div class="img-container">\n        <img src="assets/img/miners.svg" />\n      </div>\n      <div class="info">\n        <h3 class="title" translate>Transaction fees are currently high</h3>\n        <div class="text" translate>\n          Due to high demand, miner fees are high. Fees are paid to miners who process transactions and are not paid to {{appName}}.\n        </div>\n      </div>\n    </div>\n    <div class="footer">\n      <button ion-button class="button-standard no-margin-bottom" (click)="confirm()">\n        {{\'OK\' | translate}}\n      </button>\n      <button ion-button clear color="primary" class="button-standard" (click)="openExternalLink()">\n        {{\'Learn about miner fees\' | translate}}\n      </button>\n    </div>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/miner-fee-warning/miner-fee-warning.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], MinerFeeWarningComponent);

//# sourceMappingURL=miner-fee-warning.js.map

/***/ }),

/***/ 934:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NeedsBackupComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_info_sheet_info_sheet__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__ = __webpack_require__(225);





let NeedsBackupComponent = class NeedsBackupComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(domProvider) {
        super();
        this.domProvider = domProvider;
    }
    createInfoSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_2__components_info_sheet_info_sheet__["b" /* InfoSheetComponent */], type, params)
            .instance;
    }
    setupSheet(componentType, sheetType, params) {
        const sheet = this.domProvider.appendComponentToBody(componentType);
        sheet.instance.componentRef = sheet;
        sheet.instance.sheetType = sheetType;
        sheet.instance.params = params;
        return sheet;
    }
};
NeedsBackupComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'needs-backup',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/needs-backup/needs-backup.html"*/'<action-sheet>\n  <div class="prompt-user-fullscreen-container">\n    <div class="prompt-user">\n      <div class="title-icon">\n        <img src="assets/img/single-folded-content.svg" />\n      </div>\n      <div class="title-info">\n        <span translate>Needs Backup</span>\n      </div>\n      <div class="subtitle-info">\n        <span translate>Before retrieving your wallet address, it\'s recommended that you first write down your recovery phrase and store it securely so that your wallet can be recovered in the case your device was lost or stolen.</span>\n      </div>\n      <button ion-button class="button-standard safe-area" (click)="dismiss(\'goToBackup\')">\n        {{\'Write Down Recovery Phrase\' | translate}}\n      </button>\n    </div>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/needs-backup/needs-backup.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__["a" /* DomProvider */]])
], NeedsBackupComponent);

//# sourceMappingURL=needs-backup.js.map

/***/ }),

/***/ 935:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OptionsSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__ = __webpack_require__(319);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__ = __webpack_require__(13);





let OptionsSheetComponent = class OptionsSheetComponent extends __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(platformProvider, statusBar) {
        super();
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
    }
    ngOnInit() {
        if (this.platformProvider.isIOS) {
            this.statusBar.hide();
        }
    }
    ngOnDestroy() {
        if (this.platformProvider.isIOS) {
            this.statusBar.show();
        }
    }
    optionClicked(option) {
        this.dismiss(option);
    }
};
OptionsSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'options-sheet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/options-sheet/options-sheet.html"*/'<action-sheet fromTop="true">\n  <ion-list class="bp-list" [ngSwitch]="sheetType">\n    <div *ngSwitchCase="\'wallet-options\'">\n      <button ion-item (click)="optionClicked(\'request-amount\')" *ngIf="params.showRequest">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/specific-amount.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Request Specific Amount</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'share-address\')" *ngIf="params.showShare">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/icon-share.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Share Address</span>\n        </ion-label>\n      </button>\n    </div>\n\n    <div *ngSwitchCase="\'gift-card-options\'">\n      <button ion-item (click)="optionClicked(\'archive\')" *ngIf="!params.card.archived">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/notebook.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Archive Card</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'unarchive\')" *ngIf="params.card.archived">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/notebook.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Unarchive Card</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'view-invoice\')">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/invoice-icon.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>View Invoice</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'share-code\')" *ngIf="params.showShare">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/icon-share.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Share Claim Code</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'print-card\')" *ngIf="!params.hidePrint">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/printer-p.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Print Card</span>\n        </ion-label>\n      </button>\n    </div>\n\n    <div *ngSwitchCase="\'address-book\'">\n      <button ion-item (click)="optionClicked(\'send-to-contact\')">\n        <ion-icon class="item-img icon-settings" name="send" item-start></ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Send {{params?.coin}} to contact</span>\n        </ion-label>\n      </button>\n\n      <button ion-item (click)="optionClicked(\'delete-contact\')">\n        <ion-icon class="item-img icon-settings" name="trash" item-start></ion-icon>\n        <ion-label>\n          <span class="main-label danger" translate>Delete</span>\n        </ion-label>\n      </button>\n    </div>\n\n    <div *ngSwitchCase="\'send-options\'">\n      <button ion-item *ngIf="params?.isMultiSend" (click)="optionClicked(\'multi-send\')">\n        <ion-icon class="item-img icon-settings" name="people" item-start></ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Transfer to Multiple Recipients</span>\n        </ion-label>\n      </button>\n\n      <button ion-item *ngIf="params?.isUtxoCoin" (click)="optionClicked(\'select-inputs\')">\n        <ion-icon class="item-img icon-settings" item-start>\n          <img src="assets/img/tab-icons/ico-send.svg">\n        </ion-icon>\n        <ion-label>\n          <span class="main-label" translate>Select inputs for transaction</span>\n        </ion-label>\n      </button>\n    </div>\n  </ion-list>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/options-sheet/options-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__["a" /* StatusBar */]])
], OptionsSheetComponent);

//# sourceMappingURL=options-sheet.js.map

/***/ }),

/***/ 936:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PhoneSheet; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_phone_phone__ = __webpack_require__(937);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet_parent__ = __webpack_require__(107);






let PhoneSheet = class PhoneSheet extends __WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor() {
        super();
        this.searchQuery = '';
        this.searchQuerySubject = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        this.searchQuerySubject.pipe(Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["debounceTime"])(300)).subscribe(query => {
            this.searchQuery = query;
            this.updateCountryList();
        });
    }
    ngOnInit() {
        this.updateCountryList();
    }
    onSearch(query) {
        this.searchQuerySubject.next(query);
    }
    selectCountry(country) {
        this.dismiss(country);
    }
    updateCountryList() {
        const allCountries = Object(__WEBPACK_IMPORTED_MODULE_4__providers_phone_phone__["a" /* getPhoneCountryCodes */])(this.params.allowedPhoneCountries);
        this.countries = this.searchQuery
            ? allCountries.filter(country => country.name.toLowerCase().includes(this.searchQuery.toLowerCase()))
            : allCountries;
    }
};
PhoneSheet = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'phone-sheet',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/phone-sheet/phone-sheet.html"*/'<action-sheet>\n  <div class="padding">\n    <div class="title"><span translate>Select Your Country</span></div>\n    <search-bar\n      placeholder="{{ \'Search for a country\' | translate }}"\n      (search)="onSearch($event.target.value)"\n    >\n    </search-bar>\n    <div class="countries">\n      <div\n        *ngFor="let country of countries"\n        class="country"\n        tappable\n        (click)="selectCountry(country)"\n      >\n        <div class="country__label">\n          <span class="country__label__emoji">{{country.emoji}}</span>\n          {{country.name}}\n        </div>\n        <div class="country__code">+{{country.phone}}</div>\n      </div>\n    </div>\n  </div>\n</action-sheet>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/phone-sheet/phone-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], PhoneSheet);

//# sourceMappingURL=phone-sheet.js.map

/***/ }),

/***/ 937:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getPhoneCountryCodes;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_countries_list__ = __webpack_require__(938);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_countries_list___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_countries_list__);

function getPhoneCountryCodes(allowedPhoneCountries) {
    const countryCodes = Object.keys(__WEBPACK_IMPORTED_MODULE_0_countries_list__["countries"]);
    const countryList = Object.values(__WEBPACK_IMPORTED_MODULE_0_countries_list__["countries"]);
    const countryListWithCodes = countryList
        .map((country, index) => (Object.assign({}, country, { countryCode: countryCodes[index] })))
        .filter(country => allowedPhoneCountries
        ? allowedPhoneCountries.includes(country.countryCode)
        : true);
    const countriesWithMultiplePhoneCodes = countryListWithCodes
        .filter(country => country.phone.includes(','))
        .map(country => {
        const codes = country.phone.split(',');
        return codes.map(code => (Object.assign({}, country, { phone: code })));
    });
    const countriesWithSinglePhoneCode = countryListWithCodes.filter(country => !country.phone.includes(','));
    const multiplePhoneCodesFlattened = [].concat.apply([], countriesWithMultiplePhoneCodes);
    return countriesWithSinglePhoneCode
        .concat(multiplePhoneCodesFlattened)
        .sort((a, b) => (a.name < b.name ? -1 : 1));
}
//# sourceMappingURL=phone.js.map

/***/ }),

/***/ 939:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletReceiveComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_Observable__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__components_info_sheet_info_sheet__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_dom_dom__ = __webpack_require__(225);



// Providers











let WalletReceiveComponent = class WalletReceiveComponent extends __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(logger, walletProvider, events, bwcErrorProvider, platform, currencyProvider, addressProvider, domProvider, configProvider) {
        super();
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.events = events;
        this.bwcErrorProvider = bwcErrorProvider;
        this.platform = platform;
        this.currencyProvider = currencyProvider;
        this.addressProvider = addressProvider;
        this.domProvider = domProvider;
        this.configProvider = configProvider;
        this.retryCount = 0;
        this.bwsEventHandler = (walletId, type, n) => {
            if (this.wallet.credentials.walletId == walletId &&
                type == 'NewIncomingTx' &&
                n.data) {
                let addr = this.address.indexOf(':') > -1
                    ? this.address.split(':')[1]
                    : this.address;
                if (n.data.address == addr)
                    this.setAddress(true);
            }
        };
    }
    ngOnInit() {
        this.wallet = this.params.wallet;
        this.useLegacyQrCode = this.configProvider.get().legacyQrCode.show;
        this.bchAddrFormat = 'cashAddress';
        this.disclaimerAccepted = false;
        this.setAddress();
    }
    ionViewWillLeave() {
        this.onResumeSubscription.unsubscribe();
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.setAddress();
            this.events.subscribe('bwsEvent', this.bwsEventHandler);
        });
    }
    setAddress(newAddr, failed) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!this.wallet ||
                !this.wallet.isComplete() ||
                (this.wallet.needsBackup && this.wallet.network == 'livenet'))
                return;
            this.loading = newAddr || __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](this.address) ? true : false;
            this.walletProvider
                .getAddress(this.wallet, newAddr)
                .then(addr => {
                this.newAddressError = false;
                this.loading = false;
                if (!addr)
                    return;
                const address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, addr);
                if (this.address && this.address != address) {
                    this.playAnimation = true;
                }
                if (this.wallet.coin === 'bch')
                    this.bchCashAddress = address;
                this.updateQrAddress(address, newAddr);
            })
                .catch(err => {
                this.logger.warn('Retrying to create new adress:' + ++this.retryCount);
                // TODO FIX: REMOVE || this.retryCount >= 0
                if (this.retryCount > 3 || this.retryCount >= 0) {
                    this.retryCount = 0;
                    this.loading = false;
                    this.dismiss(err);
                }
                else if (err == 'INVALID_ADDRESS') {
                    // Generate new address if the first one is invalid ( fix for concatenated addresses )
                    if (!failed) {
                        this.setAddress(newAddr, true);
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Receive'));
                        return;
                    }
                    this.setAddress(false); // failed to generate new address -> get last saved address
                }
                else {
                    this.setAddress(false); // failed to generate new address -> get last saved address
                }
                this.logger.warn(this.bwcErrorProvider.msg(err, 'Receive'));
            });
        });
    }
    updateQrAddress(address, newAddr) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.wallet.coin === 'bch') {
                address =
                    this.bchAddrFormat === 'legacy'
                        ? this.addressProvider.getLegacyBchAddressFormat(this.bchCashAddress)
                        : this.bchCashAddress;
            }
            if (newAddr) {
                yield __WEBPACK_IMPORTED_MODULE_11_rxjs_Observable__["Observable"].timer(400).toPromise();
            }
            this.address = address;
            yield __WEBPACK_IMPORTED_MODULE_11_rxjs_Observable__["Observable"].timer(200).toPromise();
            this.playAnimation = false;
        });
    }
    setQrAddress() {
        if (this.bchAddrFormat === 'legacy')
            this.showFirstWarning();
        else {
            this.disclaimerAccepted = false;
            this.updateQrAddress(this.bchCashAddress, false);
        }
    }
    createInfoSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_12__components_info_sheet_info_sheet__["b" /* InfoSheetComponent */], type, params)
            .instance;
    }
    setupSheet(componentType, sheetType, params) {
        const sheet = this.domProvider.appendComponentToBody(componentType);
        sheet.instance.componentRef = sheet;
        sheet.instance.sheetType = sheetType;
        sheet.instance.params = params;
        return sheet;
    }
    showFirstWarning() {
        const infoSheet = this.createInfoSheet('bch-legacy-warning-1');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.showSecondWarning();
            }
            else {
                this.disclaimerAccepted = false;
                this.bchAddrFormat = 'cashAddress';
            }
        });
    }
    showSecondWarning() {
        const infoSheet = this.createInfoSheet('bch-legacy-warning-2');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                const legacyAddr = this.addressProvider.getLegacyBchAddressFormat(this.bchCashAddress);
                this.disclaimerAccepted = true;
                this.updateQrAddress(legacyAddr, false);
            }
            else {
                this.disclaimerAccepted = false;
                this.bchAddrFormat = 'cashAddress';
            }
        });
    }
};
WalletReceiveComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-receive',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-receive/wallet-receive.html"*/'<action-sheet>\n  <div *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup && (!newAddressError || address)">\n    <ion-row class="addr-header" align-items-center>\n      <ion-col text-left>\n        <span class="addr-title" translate>\n          Address\n        </span>\n      </ion-col>\n      <div class="addr-buttons">\n        <button *ngIf="!(wallet?.cachedStatus && wallet?.cachedStatus.wallet && wallet?.cachedStatus.wallet.singleAddress)" ion-button clear icon-only color="primary" class="addr-update" (click)="setAddress(true)">\n          <span ion-text color="primary" translate>\n            <img *ngIf="!loading" class="spin-icon" [ngClass]="{\'spin-backwards\': playAnimation}" src="assets/img/right.svg" width="12" />\n            <div *ngIf="loading" [ngClass]="{\'spin-fast\': loading}" class="spinner"></div>\n          </span>\n        </button>\n      </div>\n    </ion-row>\n    <div *ngIf="wallet.coin === \'bch\'" padding-bottom padding-left padding-right>\n      <ion-segment [(ngModel)]="bchAddrFormat" (ionChange)="setQrAddress($event)">\n        <ion-segment-button value="cashAddress">\n          Cash Address\n        </ion-segment-button>\n        <ion-segment-button value="legacy">\n          Legacy\n        </ion-segment-button>\n      </ion-segment>\n    </div>\n\n    <div class="addr-content" [ngClass]="{\'blur\': bchAddrFormat === \'legacy\' && !disclaimerAccepted}">\n      <div class="addr-container">\n        <div class="text-address ellipsis">\n          <img *ngIf="address" class="copy-to-clip" copy-to-clipboard="{{ address }}" src="assets/img/paste-clipboard.svg" width="18" />\n          <div *ngIf="!address" [ngClass]="{\'fade-in-out\': playAnimation}" class="address-text">\n            <span class="address-placeholder" translate>Generating new address...</span>\n          </div>\n          <div *ngIf="address" [ngClass]="{\'fade-in-out\': playAnimation}" class="address-text ellipsis">\n            <span copy-to-clipboard="{{ address }}">{{ address }}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class="qr-container" *ngIf="wallet && wallet?.isComplete() && !wallet?.needsBackup" [ngClass]="{\'blur\': bchAddrFormat === \'legacy\' && !disclaimerAccepted}">\n      <div class="prompt-user" *ngIf="newAddressError && !address">\n        <div class="title-icon larger-icon">\n          <img src="assets/img/ghost-straight-face.svg" />\n        </div>\n        <div class="title-info">\n          <span translate>Something goes wrong...</span>\n        </div>\n        <button ion-button class="button-standard" (click)="setAddress(true)">\n          {{\'Generate New Address\' | translate}}\n        </button>\n      </div>\n      <bp-qr-code *ngIf="address && !newAddressError  && !useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ address }}" contents="{{ address }}" mask-x-to-y-ratio="1">\n        <img [ngClass]="{\'testnet\': wallet.network === \'testnet\', \'background_xrp\': wallet.coin === \'xrp\'}" src="assets/img/currencies/{{ wallet.coin }}.svg" slot="icon" />\n      </bp-qr-code>\n      <div *ngIf="address && useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ address }}">\n        <ngx-qrcode hide-toast="true" qrc-value="{{ address }}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n      </div>\n    </div>\n    <div class="line-divider"></div>\n    <div text-center>\n      <button ion-button clear class="safe-area" (click)="dismiss()">\n        {{ \'CLOSE\' | translate }}\n      </button>\n    </div>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-receive/wallet-receive.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_9_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_9_ionic_angular__["p" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_dom_dom__["a" /* DomProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */]])
], WalletReceiveComponent);

//# sourceMappingURL=wallet-receive.js.map

/***/ }),

/***/ 94:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var bufferUtil = __webpack_require__(49);
var assert = __webpack_require__(12);

var BufferWriter = function BufferWriter(obj) {
  if (!(this instanceof BufferWriter))
    return new BufferWriter(obj);
  this.bufLen = 0;
  if (obj)
    this.set(obj);
  else
    this.bufs = [];
};

BufferWriter.prototype.set = function(obj) {
  this.bufs = obj.bufs || this.bufs || [];
  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);
  return this;
};

BufferWriter.prototype.toBuffer = function() {
  return this.concat();
};

BufferWriter.prototype.concat = function() {
  return Buffer.concat(this.bufs, this.bufLen);
};

BufferWriter.prototype.write = function(buf) {
  assert(bufferUtil.isBuffer(buf));
  this.bufs.push(buf);
  this.bufLen += buf.length;
  return this;
};

BufferWriter.prototype.writeReverse = function(buf) {
  assert(bufferUtil.isBuffer(buf));
  this.bufs.push(bufferUtil.reverse(buf));
  this.bufLen += buf.length;
  return this;
};

BufferWriter.prototype.writeUInt8 = function(n) {
  var buf = Buffer.alloc(1);
  buf.writeUInt8(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt16BE = function(n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16BE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt16LE = function(n) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt32BE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32BE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeInt32LE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeInt32LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt32LE = function(n) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32LE(n, 0);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt64BEBN = function(bn) {
  var buf = bn.toBuffer({size: 8});
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeUInt64LEBN = function(bn) {
  var buf = bn.toBuffer({size: 8});
  this.writeReverse(buf);
  return this;
};

BufferWriter.prototype.writeVarintNum = function(n) {
  var buf = BufferWriter.varintBufNum(n);
  this.write(buf);
  return this;
};

BufferWriter.prototype.writeVarintBN = function(bn) {
  var buf = BufferWriter.varintBufBN(bn);
  this.write(buf);
  return this;
};

BufferWriter.varintBufNum = function(n) {
  var buf = undefined;
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    buf = Buffer.alloc(1 + 8);
    buf.writeUInt8(255, 0);
    buf.writeInt32LE(n & -1, 1);
    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
  }
  return buf;
};

BufferWriter.varintBufBN = function(bn) {
  var buf = undefined;
  var n = bn.toNumber();
  if (n < 253) {
    buf = Buffer.alloc(1);
    buf.writeUInt8(n, 0);
  } else if (n < 0x10000) {
    buf = Buffer.alloc(1 + 2);
    buf.writeUInt8(253, 0);
    buf.writeUInt16LE(n, 1);
  } else if (n < 0x100000000) {
    buf = Buffer.alloc(1 + 4);
    buf.writeUInt8(254, 0);
    buf.writeUInt32LE(n, 1);
  } else {
    var bw = new BufferWriter();
    bw.writeUInt8(255);
    bw.writeUInt64LEBN(bn);
    var buf = bw.concat();
  }
  return buf;
};

module.exports = BufferWriter;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 940:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSelectorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(107);




let WalletSelectorComponent = class WalletSelectorComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor() {
        super();
    }
    ngOnInit() {
        this.title = this.params.title;
        this.selectedWalletId = this.params.selectedWalletId;
        this.coinbaseData = this.params.coinbaseData;
        this.separateWallets();
    }
    separateWallets() {
        const wallets = this.params.wallets;
        this.walletsByKeys = __WEBPACK_IMPORTED_MODULE_2_lodash__["values"](__WEBPACK_IMPORTED_MODULE_2_lodash__["groupBy"](wallets, 'keyId'));
    }
    optionClicked(option, isCoinbaseAccount) {
        if (!isCoinbaseAccount)
            this.dismiss(option);
        else {
            const optionClicked = {
                accountSelected: __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.coinbaseData.availableAccounts, ac => ac.id == option),
                isCoinbaseAccount
            };
            this.dismiss(optionClicked);
        }
    }
};
WalletSelectorComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-selector',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-selector/wallet-selector.html"*/'<action-sheet>\n  <div class="bp-header">\n    <ion-title>{{ title }}</ion-title>\n  </div>\n  <div *ngIf="(walletsByKeys && walletsByKeys[0]) || coinbaseData; else noWallets">\n    <div *ngFor="let walletsByKey of walletsByKeys">\n      <ion-list no-lines class="bp-list">\n        <div class="key-divider">\n          <ion-icon>\n            <img src="assets/img/settings-icons/icon-key.svg" width="15">\n          </ion-icon>\n          <span>{{ walletsByKey[0].walletGroupName }}</span>\n        </div>\n        <div *ngFor="let wallet of walletsByKey" (click)="optionClicked(wallet)">\n          <wallet-item-content [wallet]="wallet"></wallet-item-content>\n        </div>\n      </ion-list>\n    </div>\n    <div *ngIf="coinbaseData && coinbaseData.availableAccounts && coinbaseData.availableAccounts.length">\n      <ion-list no-lines class="bp-list">\n        <div class="key-divider">\n          <ion-icon>\n            <img src="assets/img/coinbase/coinbase-icon.png" width="20" />\n          </ion-icon>\n          <span *ngIf="coinbaseData.user">{{ coinbaseData.user.name }}\'s Coinbase Account</span>\n        </div>\n        <div *ngFor="let ac of coinbaseData.availableAccounts">\n          <ion-list no-lines class="bp-list">\n            <button ion-item detail-none (click)="optionClicked(ac.id, true)">\n              <coin-icon [coin]="ac.currency.code.toLowerCase()" [network]="livenet" item-left></coin-icon>\n              <ion-label>\n                {{ac.name}}\n              </ion-label>\n              <ion-note item-end>\n                <div class="main-note">{{ac.balance.amount | number:\'1.2-8\'}}</div>\n                <div class="secondary-note" *ngIf="ac.nativeCurrencyStr">\n                  {{ ac.nativeCurrencyStr }}\n                </div>\n              </ion-note>\n            </button>\n          </ion-list>\n        </div>\n      </ion-list>\n    </div>\n  </div>\n  <ng-template #noWallets>\n    <div class="no-wallets">\n      {{\'No wallets available\' | translate}}\n    </div>\n  </ng-template>\n  <ion-item-divider></ion-item-divider>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-selector/wallet-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], WalletSelectorComponent);

//# sourceMappingURL=wallet-selector.js.map

/***/ }),

/***/ 941:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTabOptionsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__ = __webpack_require__(107);



let WalletTabOptionsComponent = class WalletTabOptionsComponent extends __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor() {
        super();
    }
    ngOnInit() {
        this.walletsGroups = this.params.walletsGroups;
    }
};
WalletTabOptionsComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-tab-options-component',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-tab-options/wallet-tab-options.html"*/'<action-sheet fromTop="true">\n  <ion-list class="bp-list">\n    <button *ngIf="walletsGroups?.length == 1" ion-item (click)="dismiss({redirTo: \'AddPage\',keyId: walletsGroups[0][0]?.credentials.keyId})">\n      <ion-icon class="item-img icon-settings" item-start>\n        <img src="assets/img/add-wallet/add-wallet.svg">\n      </ion-icon>\n      <ion-label>\n        <span class="main-label" translate>Create a new wallet</span>\n      </ion-label>\n    </button>\n    <button ion-item (click)="dismiss({redirTo: \'AddPage\'})">\n      <ion-icon class="item-img icon-settings" item-start>\n        <img src="assets/img/plus-gray.svg">\n      </ion-icon>\n      <ion-label>\n        <span class="main-label" translate>Create or Import a Key</span>\n      </ion-label>\n    </button>\n  </ion-list>\n</action-sheet>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/components/wallet-tab-options/wallet-tab-options.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], WalletTabOptionsComponent);

//# sourceMappingURL=wallet-tab-options.js.map

/***/ }),

/***/ 942:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const crypto = __webpack_require__(52);
const bs58 = __webpack_require__(91);
const BitAuth = {};

BitAuth.PREFIX = Buffer.from('0f02', 'hex');

/**
 * Will return a key pair and identity
 *
 * @returns {Object} An object with keys: created, priv, pub and sin
 */
BitAuth.generateSin = function() {
  const pair = BitAuth._generateRandomPair();
  const sin = BitAuth.getSinFromPublicKey(pair[1]);
  return {
    created: Math.round(Date.now() / 1000),
    priv: pair[0],
    pub: pair[1],
    sin: sin
  };
};

/**
 * Will return a public key from a private key
 *
 * @param {String} privkey A private key in hex
 * @returns {String} A compressed public key in hex
 */
BitAuth.getPublicKeyFromPrivateKey = function(privkey) {
  const pub = BitAuth._getPublicKeyFromPrivateKey(privkey);
  return pub.toString('hex');
};

/**
 * Will return a SIN from a compressed public key
 *
 * @param {String} pubkey A public key in hex
 * @returns {String} A SIN identity
 */
BitAuth.getSinFromPublicKey = function(pubkey) {
  let pubkeyBuffer;
  if (!Buffer.isBuffer(pubkey)) {
    pubkeyBuffer = Buffer.from(pubkey, 'hex');
  } else {
    pubkeyBuffer = pubkey;
  }

  // sha256 hash the pubkey
  const pubHash = crypto.createHash('sha256').update(pubkeyBuffer).digest();

  // get the ripemd160 hash of the pubkey
  const pubRipe = crypto.createHash('rmd160').update(pubHash).digest();

  // add the version
  const pubPrefixed = Buffer.concat([BitAuth.PREFIX, pubRipe]);

  // two rounds of hashing to generate the checksum
  const hash1 = crypto.createHash('sha256').update(pubPrefixed).digest();
  const checksumTotal = crypto.createHash('sha256').update(hash1).digest();

  // slice the hash to arrive at the checksum
  const checksum = checksumTotal.slice(0, 4);

  // add the checksum to the ripemd160 pubkey
  const pubWithChecksum = Buffer.concat([pubPrefixed, checksum]);

  // encode into base58 to get SIN
  return bs58.encode(pubWithChecksum);
};

/**
 * Will sign a string of data with a private key
 *
 * @param {String} data - A string of data to be signed
 * @param {String} privkey - A private key in hex
 * @returns {String} signature - A DER signature in hex
 */
BitAuth.sign = function(data, privkey) {
  let dataBuffer;
  if (!Buffer.isBuffer(data)) {
    dataBuffer = Buffer.from(data, 'utf8');
  } else {
    dataBuffer = data;
  }
  const hashBuffer = crypto.createHash('sha256').update(dataBuffer).digest();
  return BitAuth._sign(hashBuffer, privkey);
};

/**
 * Will verify a signature
 *
 * @param {String} data - A string of data that has been signed
 * @param {String} pubkey - The compressed public key in hex that has signed the data
 * @param {String} hexsignature - A DER signature in hex
 * @returns {Function|Boolean} - If the signature is valid
 */
BitAuth.verifySignature = function(data, pubkey, hexsignature, callback) {
  let dataBuffer;
  if (!Buffer.isBuffer(data)) {
    dataBuffer = Buffer.from(data, 'utf8');
  } else {
    dataBuffer = data;
  }
  const hashBuffer = crypto.createHash('sha256').update(dataBuffer).digest();
  let signatureBuffer;
  if (!Buffer.isBuffer(hexsignature)) {
    signatureBuffer = Buffer.from(hexsignature, 'hex');
  } else {
    signatureBuffer = hexsignature;
  }
  const valid = BitAuth._verifySignature(hashBuffer, signatureBuffer, pubkey);

  if (callback) {
    return callback(null, valid);
  }
  return valid;
};

/**
 * Will verify that a SIN is valid
 *
 * @param {String} sin - A SIN identity
 * @param {function} callback
 * @returns {Function|Boolean} - If the SIN identity is valid
 */
BitAuth.validateSin = function(sin, callback) {

  let pubWithChecksum;

  // check for non-base58 characters
  try {
    pubWithChecksum = Buffer.from(bs58.decode(sin), 'hex').toString('hex');
  } catch (err) {
    if (callback) {
      return callback(err);
    }
    return false;
  }

  // check the version
  if (pubWithChecksum.slice(0, 4) !== '0f02') {
    if (callback) {
      return callback(new Error('Invalid prefix or SIN version'));
    }
    return false;
  }

  // get the checksum
  const checksum = pubWithChecksum.slice(
    pubWithChecksum.length - 8,
    pubWithChecksum.length
  );
  const pubPrefixed = pubWithChecksum.slice(0, pubWithChecksum.length - 8);

  // two rounds of hashing to generate the checksum
  const hash1 = crypto.createHash('sha256').update(Buffer.from(pubPrefixed, 'hex')).digest();
  const checksumTotal = crypto.createHash('sha256').update(hash1).digest('hex');

  // check the checksum
  if (checksumTotal.slice(0, 8) === checksum) {
    if (callback) {
      return callback(null);
    }
    return true;
  } else {
    if (callback) {
      return callback(new Error('Checksum does not match'));
    }
    return false;
  }
};

module.exports = BitAuth;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 943:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const secp256k1 = __webpack_require__(371);
const BitAuth = __webpack_require__(942);
const crypto = __webpack_require__(52);

BitAuth._generateRandomPair = function() {
  const privateKeyBuffer = crypto.randomBytes(32); // may throw error if entropy sources drained
  const publicKeyBuffer = Buffer.from(secp256k1.publicKeyCreate(privateKeyBuffer, true));
  return [privateKeyBuffer.toString('hex'), publicKeyBuffer.toString('hex')];
};

BitAuth._getPublicKeyFromPrivateKey = function(privkey) {
  let privateKeyBuffer;
  if (Buffer.isBuffer(privkey)) {
    privateKeyBuffer = privkey;
  } else {
    privateKeyBuffer = Buffer.from(privkey, 'hex');
  }
  return Buffer.from(secp256k1.publicKeyCreate(privateKeyBuffer, true));
};

BitAuth._sign = function(hashBuffer, privkey) {
  let privkeyBuffer;
  if (Buffer.isBuffer(privkey)) {
    privkeyBuffer = privkey;
  } else {
    privkeyBuffer = Buffer.from(privkey, 'hex');
  }
  var signatureInfo = secp256k1.ecdsaSign(hashBuffer, privkeyBuffer);
  return Buffer.from(secp256k1.signatureExport(signatureInfo.signature));
};

BitAuth._verifySignature = function(hashBuffer, signatureBuffer, pubkey) {
  let pubkeyBuffer;
  const signature = secp256k1.signatureNormalize(secp256k1.signatureImport(signatureBuffer));
  if (!Buffer.isBuffer(pubkey)){
    pubkeyBuffer = Buffer.from(pubkey, 'hex');
  } else {
    pubkeyBuffer = pubkey;
  }
  return !!secp256k1.ecdsaVerify(signature, hashBuffer, pubkeyBuffer);
};

module.exports = BitAuth;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),

/***/ 944:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppleWalletProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_apple_wallet_ng__ = __webpack_require__(792);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_apple_wallet_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_apple_wallet_ng__);




let AppleWalletProvider = class AppleWalletProvider {
    constructor(logger, appleWallet) {
        this.logger = logger;
        this.appleWallet = appleWallet;
        this.logger.debug('AppleWalletProvider initialized');
    }
    available() {
        return this.appleWallet.available();
    }
    startAddPaymentPass(params) {
        return this.appleWallet.startAddPaymentPass(params);
    }
    completeAddPaymentPass(params) {
        return this.appleWallet.completeAddPaymentPass(params);
    }
    checkPairedDevicesBySuffix(cardSuffix) {
        return this.appleWallet.checkPairedDevicesBySuffix(cardSuffix);
    }
    graphRequest(headers, json) {
        return this.appleWallet.graphRequest(headers, json);
    }
};
AppleWalletProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */], __WEBPACK_IMPORTED_MODULE_3_apple_wallet_ng__["AppleWalletNg"]])
], AppleWalletProvider);

//# sourceMappingURL=apple-wallet.js.map

/***/ }),

/***/ 945:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_download_download__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__key_key__ = __webpack_require__(98);



// Providers






let BackupProvider = class BackupProvider {
    constructor(appProvider, bwcProvider, configProvider, downloadProvider, logger, profileProvider, keyProvider) {
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.downloadProvider = downloadProvider;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.keyProvider = keyProvider;
        this.logger.debug('BackupProvider initialized');
    }
    walletDownload(walletId, opts, password) {
        return new Promise((resolve, reject) => {
            let config = this.configProvider.get();
            let wallet = this.profileProvider.getWallet(walletId);
            let ew = this.walletExport(walletId, opts, password);
            if (!ew)
                return reject('Could not create backup');
            let walletName = wallet.credentials.walletName || wallet.credentials.walletId;
            let alias = config.aliasFor && config.aliasFor[wallet.credentials.walletId];
            if (alias) {
                walletName = alias + ' [' + walletName + ']';
            }
            if (opts.noSign)
                walletName = walletName + '-noSign';
            let filename = walletName + '-' + this.appProvider.info.nameCase + 'backup.aes.json';
            this.downloadProvider.download(ew, filename).then(() => {
                return resolve();
            });
        });
    }
    walletExport(walletId, opts, password) {
        if (!password) {
            return null;
        }
        let wallet = this.profileProvider.getWallet(walletId);
        try {
            opts = opts ? opts : {};
            let b = {};
            b.credentials = JSON.parse(wallet.toString(opts));
            if (b.credentials.keyId && opts.noSign) {
                delete b.credentials.keyId;
            }
            if (wallet.canSign && !opts.noSign) {
                const k = this.keyProvider.getKey(wallet.credentials.keyId).toObj();
                if (opts.password) {
                    const k1 = this.keyProvider
                        .get(wallet.credentials.keyId, opts.password)
                        .toObj();
                    k.mnemonic = k1.mnemonic;
                    k.xPrivKey = k1.xPrivKey;
                    delete k.xPrivKeyEncrypted;
                    delete k.mnemonicEncrypted;
                }
                b.key = k;
            }
            if (opts.addressBook)
                b.addressBook = opts.addressBook;
            b = JSON.stringify(b);
            return this.bwcProvider.getSJCL().encrypt(password, b, {
                iter: 10000
            });
        }
        catch (err) {
            this.logger.error('Error exporting wallet: ', err);
            return null;
        }
    }
};
BackupProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_download_download__["a" /* DownloadProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__key_key__["a" /* KeyProvider */]])
], BackupProvider);

//# sourceMappingURL=backup.js.map

/***/ }),

/***/ 946:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfettiProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


const defaultColors = ['#a864fd', '#29cdff', '#78ff44', '#ff718d', '#fdff6a'];
let ConfettiProvider = class ConfettiProvider {
    constructor() { }
    createElements(root, elementCount, colors) {
        return Array.from({ length: elementCount }).map((_, index) => {
            const element = document.createElement('div');
            const color = colors[index % colors.length];
            element.style['background-color'] = color;
            element.style.width = '10px';
            element.style.height = '10px';
            element.style.position = 'absolute';
            element.style.zIndex = '1000';
            root.appendChild(element);
            return element;
        });
    }
    randomPhysics(angle, spread, startVelocity, random) {
        const radAngle = angle * (Math.PI / 180);
        const radSpread = spread * (Math.PI / 180);
        return {
            x: 0,
            y: 0,
            wobble: random() * 10,
            velocity: startVelocity * 0.5 + random() * startVelocity,
            angle2D: -radAngle + (0.5 * radSpread - random() * radSpread),
            angle3D: -(Math.PI / 4) + random() * (Math.PI / 2),
            tiltAngle: random() * Math.PI
        };
    }
    updateFetti(fetti, progress, decay) {
        fetti.physics.x += Math.cos(fetti.physics.angle2D) * fetti.physics.velocity;
        fetti.physics.y += Math.sin(fetti.physics.angle2D) * fetti.physics.velocity;
        fetti.physics.z += Math.sin(fetti.physics.angle3D) * fetti.physics.velocity;
        fetti.physics.wobble += 0.1;
        fetti.physics.velocity *= decay;
        fetti.physics.y += 3;
        fetti.physics.tiltAngle += 0.1;
        const { x, y, tiltAngle, wobble } = fetti.physics;
        const wobbleX = x + 10 * Math.cos(wobble);
        const wobbleY = y + 10 * Math.sin(wobble);
        const transform = `translate3d(${wobbleX}px, ${wobbleY}px, 0) rotate3d(1, 1, 1, ${tiltAngle}rad)`;
        fetti.element.style.transform = transform;
        fetti.element.style.opacity = 1 - progress;
    }
    animate(root, fettis, decay) {
        const totalTicks = 200;
        let tick = 0;
        const update = () => {
            fettis.forEach(fetti => this.updateFetti(fetti, tick / totalTicks, decay));
            tick += 1;
            if (tick < totalTicks) {
                requestAnimationFrame(update);
            }
            else {
                fettis.forEach(fetti => {
                    if (fetti.element.parentNode === root) {
                        return root.removeChild(fetti.element);
                    }
                });
            }
        };
        requestAnimationFrame(update);
    }
    confetti(root, { angle = 90, decay = 0.9, spread = 45, startVelocity = 45, elementCount = 50, colors = defaultColors, random = Math.random } = {}) {
        const elements = this.createElements(root, elementCount, colors);
        const fettis = elements.map(element => ({
            element,
            physics: this.randomPhysics(angle, spread, startVelocity, random)
        }));
        this.animate(root, fettis, decay);
    }
};
ConfettiProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [])
], ConfettiProvider);

//# sourceMappingURL=confetti.js.map

/***/ }),

/***/ 947:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export fetchDirectIntegrations */
/* unused harmony export convertToArray */
/* unused harmony export convertObjectsToArrays */
/* unused harmony export fetchDirectory */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectoryProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger_logger__ = __webpack_require__(7);



const getDirectIntegrations = (res) => Object.keys(res).map(name => (Object.assign({}, res[name], { name })));
/* unused harmony export getDirectIntegrations */

function fetchDirectIntegrations() {
    return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
        return fetch(`https://tkcoin.org/merchant-directory/integrations`)
            .then(res => res.json())
            .then((merchantMap) => getDirectIntegrations(merchantMap));
    });
}
function convertToArray(object) {
    return Object.keys(object).map(key => (Object.assign({ name: key }, object[key])));
}
function convertObjectsToArrays(directory) {
    const categories = convertToArray(directory.categories);
    const curated = convertToArray(directory.curated);
    const newDirectory = { curated, categories };
    return newDirectory;
}
function fetchDirectory() {
    return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
        const directory = yield fetch(`https://tkcoin.org/merchant-directory/directory`).then(res => res.json());
        const newDirectory = convertObjectsToArrays(directory);
        return newDirectory;
    });
}
let DirectoryProvider = class DirectoryProvider {
    constructor(logger) {
        this.logger = logger;
    }
    fetchDirectIntegrations() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const directIntegrations = yield fetchDirectIntegrations();
            this.logger.debug('fetched Direct Integrations');
            return directIntegrations;
        });
    }
    fetchDirectory() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const directory = yield fetchDirectory();
            this.logger.debug('fetched Directory');
            return directory;
        });
    }
};
DirectoryProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__logger_logger__["a" /* Logger */]])
], DirectoryProvider);

//# sourceMappingURL=directory.js.map

/***/ }),

/***/ 948:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);



// providers


let FeedbackProvider = class FeedbackProvider {
    constructor(http, logger, appProvider) {
        this.http = http;
        this.logger = logger;
        this.appProvider = appProvider;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.feedbackSheetURL
                ? this.appProvider.servicesInfo.feedbackSheetURL
                : null;
    }
    send(dataSrc) {
        return new Promise((resolve, reject) => {
            if (!this.URL)
                return resolve();
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            });
            const urlSearchParams = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["d" /* HttpParams */]()
                .set('Email', dataSrc.email)
                .set('Feedback', dataSrc.feedback)
                .set('Score', dataSrc.score)
                .set('AppVersion', dataSrc.appVersion)
                .set('Platform', dataSrc.platform)
                .set('DeviceVersion', dataSrc.deviceVersion);
            this.http
                .post(this.URL, null, {
                params: urlSearchParams,
                headers
            })
                .subscribe(() => {
                this.logger.info('SUCCESS: Feedback sent');
                return resolve();
            }, err => {
                this.logger.warn('ERROR: Feedback sent anyway.');
                return reject(err);
            });
        });
    }
    isVersionUpdated(currentVersion, savedVersion) {
        let verifyTagFormat = tag => {
            let regex = /^v?\d+\.\d+\.\d+$/i;
            return regex.exec(tag);
        };
        let formatTagNumber = tag => {
            let formattedNumber = tag.replace(/^v/i, '').split('.');
            return {
                major: +formattedNumber[0],
                minor: +formattedNumber[1],
                patch: +formattedNumber[2]
            };
        };
        if (!verifyTagFormat(currentVersion)) {
            return 'Cannot verify the format of version tag: ' + currentVersion;
        }
        if (!verifyTagFormat(savedVersion)) {
            return ('Cannot verify the format of the saved version tag: ' + savedVersion);
        }
        let current = formatTagNumber(currentVersion);
        let saved = formatTagNumber(savedVersion);
        if (saved.major == current.major) {
            return true;
        }
        return false;
    }
};
FeedbackProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */]])
], FeedbackProvider);

//# sourceMappingURL=feedback.js.map

/***/ }),

/***/ 949:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InvoiceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__email_notifications_email_notifications__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__ = __webpack_require__(20);






let InvoiceProvider = class InvoiceProvider {
    constructor(emailNotificationsProvider, http, logger, persistenceProvider) {
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.credentials = {
            NETWORK: __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__["a" /* Network */].livenet,
            TKCOIN_API_URL: 'https://tkcoin.org'
        };
        this.logger.debug('InvoiceProvider initialized');
    }
    setNetwork(network) {
        this.credentials.NETWORK = __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__["a" /* Network */][network];
        this.credentials.TKCOIN_API_URL =
            network === __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__["a" /* Network */].livenet
                ? 'https://tkcoin.org'
                : 'https://test.tkcoin.org';
        this.logger.log(`invoice provider initialized with ${network}`);
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    getApiPath() {
        return `${this.credentials.TKCOIN_API_URL}/gift-cards`;
    }
    getTKCoinInvoice(id) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const res = yield this.http
                .get(`${this.credentials.TKCOIN_API_URL}/invoices/${id}`)
                .toPromise()
                .catch(err => {
                this.logger.error('TKCoin Get Invoice: ERROR ' + err.error.message);
                throw err.error.message;
            });
            this.logger.info('TKCoin Get Invoice: SUCCESS');
            return res.data;
        });
    }
    emailIsValid(email) {
        const validEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(email);
        return validEmail;
    }
    storeEmail(email) {
        this.setUserInfo({ email });
    }
    setUserInfo(data) {
        this.persistenceProvider.setGiftCardUserInfo(JSON.stringify(data));
    }
};
InvoiceProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__["b" /* PersistenceProvider */]])
], InvoiceProvider);

//# sourceMappingURL=invoice.js.map

/***/ }),

/***/ 950:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguageLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gettext_parser__ = __webpack_require__(1955);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gettext_parser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_gettext_parser__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(13);








let LanguageLoader = class LanguageLoader {
    constructor(http, file, platformProvider) {
        this.http = http;
        this.file = file;
        this.platformProvider = platformProvider;
        this.domain = '';
        this._prefix = 'assets/i18n/';
        this._suffix = '.po';
    }
    getTranslation(lang) {
        if (this.platformProvider.isCordova) {
            return __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].fromPromise(this.file
                .readAsText(this.file.applicationDirectory + 'www/', `${this._prefix}/${lang}${this._suffix}`)
                .then(data => {
                return this.parse(data);
            }));
        }
        else {
            return this.http
                .get(`${this._prefix}/${lang}${this._suffix}`, { responseType: 'text' })
                .pipe(Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__["map"])((contents) => this.parse(contents)));
        }
    }
    parse(contents) {
        let translations = {};
        const po = __WEBPACK_IMPORTED_MODULE_4_gettext_parser__["po"].parse(contents, 'utf-8');
        if (!po.translations.hasOwnProperty(this.domain)) {
            return translations;
        }
        Object.keys(po.translations[this.domain]).forEach(key => {
            const translation = po.translations[this.domain][key].msgstr.pop();
            if (key.length > 0 && translation.length > 0) {
                translations[key] = translation;
            }
        });
        return translations;
    }
};
LanguageLoader = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */]])
], LanguageLoader);

//# sourceMappingURL=language-loader.js.map

/***/ }),

/***/ 953:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gift_card_gift_card__ = __webpack_require__(89);



let TabProvider = class TabProvider {
    constructor(giftCardProvider) {
        this.giftCardProvider = giftCardProvider;
    }
    prefetchGiftCards() {
        this.activeGiftCardsPromise = this.giftCardProvider.getActiveCards();
        return this.activeGiftCardsPromise;
    }
};
TabProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__gift_card_gift_card__["a" /* GiftCardProvider */]])
], TabProvider);

//# sourceMappingURL=tab.js.map

/***/ }),

/***/ 968:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const ETH_STANDARD_PATH = "m/44'/60'/0'/0";
/* unused harmony export ETH_STANDARD_PATH */

const MAINNET_CHAIN_ID = 1;
/* harmony export (immutable) */ __webpack_exports__["b"] = MAINNET_CHAIN_ID;

const ROPSTEN_CHAIN_ID = 3;
/* unused harmony export ROPSTEN_CHAIN_ID */

const RINKEBY_CHAIN_ID = 4;
/* unused harmony export RINKEBY_CHAIN_ID */

const GOERLI_CHAIN_ID = 5;
/* unused harmony export GOERLI_CHAIN_ID */

const KOVAN_CHAIN_ID = 42;
/* harmony export (immutable) */ __webpack_exports__["a"] = KOVAN_CHAIN_ID;

const supportedProviders = [
    {
        name: 'Ethereum Mainnet',
        short_name: 'eth',
        chain: 'ETH',
        network: 'mainnet',
        chain_id: 1,
        network_id: 1,
        rpc_url: 'https://mainnet.infura.io/v3/%API_KEY%',
        native_currency: {
            symbol: 'ETH',
            name: 'Ether',
            decimals: '18',
            contractAddress: '',
            balance: ''
        }
    },
    {
        name: 'Ethereum Kovan',
        short_name: 'kov',
        chain: 'ETH',
        network: 'kovan',
        chain_id: 42,
        network_id: 42,
        rpc_url: 'https://kovan.infura.io/v3/%API_KEY%',
        native_currency: {
            symbol: 'ETH',
            name: 'Ether',
            decimals: '18',
            contractAddress: '',
            balance: ''
        }
    }
];
/* harmony export (immutable) */ __webpack_exports__["c"] = supportedProviders;

//# sourceMappingURL=web3-providers.js.map

/***/ }),

/***/ 969:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NewFeatureData; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__in_app_browser_card__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__location_location__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(13);











let NewFeatureData = class NewFeatureData {
    constructor(appProv, locationProv, platProv, translate, persistenceProvider, iabCardProvider, events, logger) {
        this.appProv = appProv;
        this.locationProv = locationProv;
        this.platProv = platProv;
        this.translate = translate;
        this.persistenceProvider = persistenceProvider;
        this.iabCardProvider = iabCardProvider;
        this.events = events;
        this.logger = logger;
        this.NETWORK = 'livenet';
        this.persistenceProvider.getNetwork().then((network) => {
            if (network) {
                this.NETWORK = network;
            }
            this.logger.log(`persistence initialized with ${this.NETWORK}`);
        });
        this.feature_list = [
            {
                majorversion: 12,
                minorversion: 0,
                app: ['tkcoin'],
                platform: ['cordova'],
                dummy: this.translate.instant('dummy'),
                features: [
                    {
                        title: 'Trading now supported!',
                        details: 'Now you can quickly and safely exchange funds from one crypto wallet to another.',
                        image: { path: 'assets/img/new-feature/12/12-1.png' }
                    },
                    {
                        title: 'Exchange directly from your wallets',
                        details: 'Now you can quickly and safely exchange funds from one crypto wallet to another.',
                        image: { path: 'assets/img/new-feature/12/12-2.png' }
                    },
                    {
                        title: 'DAI and WBTC added',
                        details: 'Store, Send, and Receive some of the top crypto assets used in Decentralized Finance (DeFi). DAI is a USD pegged stable coin and WBTC is an ERC20 token pegged to Bitcoin.',
                        image: { path: 'assets/img/new-feature/12/12-3.png' }
                    },
                    {
                        title: 'Interact with DeFi and other DApps',
                        details: 'Try it out by selecting WalletConnect from settings, then scanning a DApp or DeFi QR code.',
                        image: { path: 'assets/img/new-feature/12/12-4.png' }
                    }
                ]
            },
            {
                majorversion: 12,
                minorversion: 1,
                app: ['tkcoin'],
                platform: ['ios'],
                dummy: this.translate.instant('dummy'),
                country: ['US'],
                features: [
                    {
                        title: 'Connect to Apple Pay',
                        details: "Now it's easy to use your TKCoin Mastercard with Apple Pay making payments in stores, in apps, and online even easier.",
                        image: { path: 'assets/img/new-feature/12.1/12.1-1.png' }
                    },
                    {
                        title: 'Setup your virtual card',
                        details: 'To get started, go to your card settings and select Add to Apple Wallet',
                        image: { path: 'assets/img/new-feature/12.1/12.1-2.png' },
                        tryit: (viewCtrl) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                            yield viewCtrl.dismiss({ done: true });
                            const cards = yield this.persistenceProvider.getBitpayDebitCards(this.NETWORK);
                            const virtualCard = cards.find(c => c.provider === 'galileo' && c.cardType === 'virtual');
                            if (virtualCard) {
                                // go to card settings directly
                                this.iabCardProvider.loadingWrapper(() => {
                                    this.iabCardProvider.show();
                                    setTimeout(() => {
                                        this.iabCardProvider.sendMessage({
                                            message: `openSettings?${virtualCard.id}`
                                        }, () => { });
                                    });
                                });
                            }
                            else {
                                // new signup - * using events over navCtrl due to dependency issue
                                this.events.publish('IncomingDataRedir', {
                                    name: 'TKCoinCardIntroPage'
                                });
                            }
                        })
                    }
                ]
            },
            {
                majorversion: 12,
                minorversion: 3,
                app: ['*'],
                platform: ['*'],
                dummy: this.translate.instant('dummy'),
                features: [
                    {
                        slideTitle: '',
                        title: 'Dogecoin added',
                        details: 'Store, buy, send and receive Dogecoin, an open source peer-to-peer digital currency favored by Shiba Inus worldwide.',
                        image: {
                            path: 'assets/img/new-feature/12.3/12-3-doge.svg',
                            fitClass: true
                        }
                    }
                ]
            }
        ];
    }
    get() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.locationProv.countryPromise.then(data => (this.country = data));
            const list = this.feature_list.filter(vs => vs.majorversion === this.appProv.version.major &&
                vs.minorversion === this.appProv.version.minor &&
                (vs.app.length == 0 ||
                    vs.app[0] === '*' ||
                    vs.app.find(app => app === String(this.appProv.info.name).toLocaleLowerCase())) &&
                (vs.platform.length == 0 ||
                    vs.platform[0] === '*' ||
                    vs.platform.find(plat => this.platProv.getPlatform() === plat)) &&
                (!vs.country ||
                    vs.country[0] === '*' ||
                    vs.country.indexOf(this.country) != -1) &&
                vs.features.length > 0);
            return list && list.length > 0
                ? __WEBPACK_IMPORTED_MODULE_4_lodash___default.a.orderBy(list, ['majorversion', 'minorversion'], ['desc', 'desc'])[0]
                : undefined;
        });
    }
};
NewFeatureData = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__location_location__["a" /* LocationProvider */],
        __WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_6__in_app_browser_card__["a" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__logger_logger__["a" /* Logger */]])
], NewFeatureData);

//# sourceMappingURL=new-feature-data.js.map

/***/ }),

/***/ 97:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);


// Providers


let AddressProvider = class AddressProvider {
    constructor(bwcProvider, logger) {
        this.bwcProvider = bwcProvider;
        this.logger = logger;
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.bitcoreEdu = this.bwcProvider.getBitcoreEdu();
        this.bitcoreTik = this.bwcProvider.getBitcoreTik();
        this.bitcoreDoge = this.bwcProvider.getBitcoreDoge();
        this.core = this.bwcProvider.getCore();
    }
    translateToCashAddress(addressToTranslate) {
        var addressObj = this.bitcore.Address(addressToTranslate).toObject();
        const cashAdrr = this.bitcoreCash.Address.fromObject(addressObj).toCashAddress();
        this.logger.info(`converted: ${addressToTranslate} -> ${cashAdrr}`);
        return cashAdrr;
    }
    extractAddress(str) {
        const extractedAddress = str.replace(/^[a-z]+:/i, '').replace(/\?.*/, '');
        return extractedAddress;
    }
    getCoinAndNetwork(str, network = 'livenet') {
        const address = this.extractAddress(str);
        try {
            network = this.bitcore.Address(address).network.name;
            return { coin: 'btc', network };
        }
        catch (e) {
            try {
                network = this.bitcoreEdu.Address(address).network.name;
                return { coin: 'edu', network };
            }
            catch (e) {
                try {
                    network = this.bitcoreTik.Address(address).network.name;
                    return { coin: 'tik', network };
                }
                catch (e) {
                    try {
                        network = this.bitcoreCash.Address(address).network.name;
                        return { coin: 'bch', network };
                    }
                    catch (e) {
                        try {
                            const isValidEthAddress = this.core.Validation.validateAddress('ETH', network, address);
                            if (isValidEthAddress) {
                                return { coin: 'eth', network };
                            }
                            else {
                                throw isValidEthAddress;
                            }
                        }
                        catch (e) {
                            try {
                                const isValidXrpAddress = this.core.Validation.validateAddress('XRP', network, address);
                                if (isValidXrpAddress) {
                                    return { coin: 'xrp', network };
                                }
                                else {
                                    throw isValidXrpAddress;
                                }
                            }
                            catch (e) {
                                try {
                                    network = this.bitcoreDoge.Address(address).network.name;
                                    return { coin: 'doge', network };
                                }
                                catch (e) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    isValid(str) {
        if (!str)
            return false;
        // Check if the input is a valid uri or address
        const URI = this.bitcore.URI;
        const Address = this.bitcore.Address;
        const AddressEdu = this.bitcoreEdu.Address;
        const URIEdu = this.bitcoreEdu.URI;
        const AddressTik = this.bitcoreTik.Address;
        const URITik = this.bitcoreTik.URI;
        const AddressCash = this.bitcoreCash.Address;
        const URICash = this.bitcoreCash.URI;
        const AddressDoge = this.bitcoreDoge.Address;
        const URIDoge = this.bitcoreDoge.URI;
        const { Validation } = this.core;
        // Bip21 uri
        if (URI.isValid(str))
            return true;
        if (URICash.isValid(str))
            return true;
        if (URIEdu.isValid(str))
            return true;
        if (URITik.isValid(str))
            return true;
        if (URIDoge.isValid(str))
            return true;
        if (Validation.validateUri('ETH', str))
            return true;
        if (Validation.validateUri('XRP', str))
            return true;
        // Regular Address: try Bitcoin and Bitcoin Cash
        if (Address.isValid(str, 'livenet'))
            return true;
        if (Address.isValid(str, 'testnet'))
            return true;
        if (AddressEdu.isValid(str, 'livenet'))
            return true;
        if (AddressEdu.isValid(str, 'testnet'))
            return true;
        if (AddressTik.isValid(str, 'livenet'))
            return true;
        if (AddressTik.isValid(str, 'testnet'))
            return true;
        if (AddressCash.isValid(str, 'livenet'))
            return true;
        if (AddressCash.isValid(str, 'testnet'))
            return true;
        if (AddressDoge.isValid(str, 'livenet'))
            return true;
        if (AddressDoge.isValid(str, 'testnet'))
            return true;
        if (Validation.validateAddress('XRP', 'livenet', str))
            return true;
        if (Validation.validateAddress('ETH', 'livenet', str))
            return true;
        return false;
    }
    getLegacyBchAddressFormat(addr) {
        const a = this.bitcoreCash.Address(addr).toObject();
        return this.bitcore.Address.fromObject(a).toString();
    }
};
AddressProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_bwc_bwc__["a" /* BwcProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], AddressProvider);

//# sourceMappingURL=address.js.map

/***/ }),

/***/ 970:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardPhasesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__);




let CardPhasesProvider = class CardPhasesProvider {
    constructor(http) {
        this.http = http;
        this.allowedCountries = [
            'US',
            'AX',
            'AL',
            'AD',
            'AI',
            'AG',
            'AR',
            'AM',
            'AW',
            'AU',
            'AT',
            'AZ',
            'BS',
            'BH',
            'BB',
            'BY',
            'BE',
            'BZ',
            'BM',
            'BT',
            'BQ',
            'BA',
            'BR',
            'BN',
            'BG',
            'CA',
            'KY',
            'CL',
            'CN',
            'CO',
            'CR',
            'HR',
            'CW',
            'CY',
            'CZ',
            'DK',
            'DM',
            'DO',
            'EC',
            'SV',
            'EE',
            'FK',
            'FO',
            'FI',
            'FR',
            'GF',
            'GE',
            'DE',
            'GI',
            'GR',
            'GL',
            'GD',
            'GP',
            'GT',
            'GG',
            'GY',
            'HK',
            'HU',
            'IS',
            'ID',
            'IE',
            'IM',
            'IL',
            'IT',
            'JM',
            'JP',
            'JE',
            'JO',
            'KZ',
            'KR',
            'KW',
            'LV',
            'LI',
            'LT',
            'LU',
            'MK',
            'MY',
            'MV',
            'MT',
            'MQ',
            'MU',
            'MX',
            'MD',
            'MC',
            'MN',
            'ME',
            'MA',
            'NP',
            'NL',
            'NZ',
            'NI',
            'NO',
            'OM',
            'PA',
            'PG',
            'PY',
            'PE',
            'PH',
            'PL',
            'PT',
            'QA',
            'RE',
            'RO',
            'RU',
            'KN',
            'LC',
            'MF',
            'VC',
            'SM',
            'SA',
            'RS',
            'SC',
            'SG',
            'SX',
            'SK',
            'SI',
            'SB',
            'ZA',
            'ES',
            'SR',
            'SE',
            'CH',
            'TW',
            'TH',
            'TT',
            'TR',
            'TC',
            'UA',
            'AE',
            'GB',
            'UY',
            'VG'
        ];
        this.otherCardCountries = ['AU', 'MX', 'CA'];
    }
    getSession() {
        const url = 'https://tkcoin.org/visa-api/session';
        return this.http.get(url);
    }
    notify(email, country) {
        const url = 'https://tkcoin.org/api/v2';
        let httpHeaders = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]();
        httpHeaders = httpHeaders.set('Content-Type', 'application/json; charset=utf-8');
        const options = {
            headers: httpHeaders
        };
        let params = {
            email,
            country,
            cardType: country === 'US' ? 'USCard' : 'EuropeCard',
            created: new Date(),
            topic: 'debitCard'
        };
        if (this.otherCardCountries.includes(country)) {
            params = Object.assign({}, params, { cardType: 'OtherCard' });
        }
        const body = {
            method: 'interested',
            params: JSON.stringify(params)
        };
        return this.http.post(url, body, options);
    }
    countries() {
        const url = 'https://tkcoin.org/countries';
        return this.http.get(url).pipe(Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["filter"])(c => this.allowedCountries.indexOf(c['shortCode']) !== -1), Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["map"])(c => {
            return {
                label: c['name'],
                value: c['shortCode']
            };
        }));
    }
};
CardPhasesProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */]])
], CardPhasesProvider);

//# sourceMappingURL=card-phases.js.map

/***/ }),

/***/ 971:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js
var core = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/@ngx-translate/core.es5.js
var core_es5 = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ionic-angular/index.js + 191 modules
var ionic_angular = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(1);
var lodash_default = /*#__PURE__*/__webpack_require__.n(lodash);

// EXTERNAL MODULE: ./src/providers/address/address.ts
var address_address = __webpack_require__(97);

// CONCATENATED MODULE: ./src/providers/currency/gnosisFactories.ts
const GnosisFactories = {
    testnet: '0x2C992817e0152A65937527B774c7A99a84603045',
    livenet: '0x6e95C8E8557AbC08b46F3c347bA06F8dC012763f'
};
//# sourceMappingURL=gnosisFactories.js.map
// EXTERNAL MODULE: ./src/providers/errors/errors.ts
var errors = __webpack_require__(41);

// EXTERNAL MODULE: ./src/providers/incoming-data/incoming-data.ts
var incoming_data = __webpack_require__(126);

// EXTERNAL MODULE: ./src/providers/logger/logger.ts
var logger = __webpack_require__(7);

// EXTERNAL MODULE: ./src/providers/wallet/wallet.ts
var wallet = __webpack_require__(31);

// EXTERNAL MODULE: ./src/pages/scan/scan.ts
var scan = __webpack_require__(129);

// CONCATENATED MODULE: ./src/pages/add/create-eth-multisig/create-eth-multisig.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return create_eth_multisig_CreateEthMultisigPage; });





// Providers






// Pages

let create_eth_multisig_CreateEthMultisigPage = class CreateEthMultisigPage {
    constructor(addressProvider, errorsProvider, events, incomingDataProvider, logger, navParams, translate, walletProvider, navCtrl) {
        this.addressProvider = addressProvider;
        this.errorsProvider = errorsProvider;
        this.events = events;
        this.incomingDataProvider = incomingDataProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.translate = translate;
        this.walletProvider = walletProvider;
        this.navCtrl = navCtrl;
        this.multisigAddresses = [];
        this.search = '';
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
        this.pairedWallet = this.navParams.data.pairedWallet;
        this.n = this.navParams.data.n;
        this.m = this.navParams.data.m;
        this.events.subscribe('Local/AddressScanEthMultisig', this.updateAddressHandler);
        this.walletProvider.getAddress(this.pairedWallet, false).then(address => {
            this.multisigAddresses = [address];
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CreateEthMultisigPage');
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScanEthMultisig', this.updateAddressHandler);
    }
    processInput() {
        const validDataTypeMap = ['EthereumAddress'];
        if (this.search && this.search.trim() != '') {
            const parsedData = this.incomingDataProvider.parseData(this.search);
            if (parsedData && lodash["indexOf"](validDataTypeMap, parsedData.type) != -1) {
                const isValid = this.checkCoinAndNetwork(this.search);
                if (isValid) {
                    setTimeout(() => {
                        this.invalidAddress = false;
                        this.addAddress(this.search);
                    }, 100);
                }
                else {
                    this.invalidAddress = true;
                    const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
                    this.showErrorMessage(msg);
                }
            }
            else {
                this.invalidAddress = true;
            }
        }
    }
    cleanSearch() {
        this.search = '';
    }
    openScanner() {
        this.navCtrl.push(scan["a" /* ScanPage */], { fromEthMultisig: true });
    }
    checkCoinAndNetwork(address) {
        const addrData = this.addressProvider.getCoinAndNetwork(address, this.pairedWallet.network);
        const isValid = Boolean(addrData &&
            this.pairedWallet.coin == addrData.coin &&
            this.pairedWallet.network == addrData.network);
        return isValid;
    }
    showErrorMessage(msg) {
        const title = this.translate.instant('Error');
        this.errorsProvider.showDefaultError(msg, title, () => {
            this.cleanSearch();
        });
    }
    addAddress(address) {
        if (!address)
            return;
        if (this.n == this.multisigAddresses.length) {
            const msg = this.translate.instant('The maximum number of Copayers has already been reached');
            this.showErrorMessage(msg);
            this.cleanSearch();
            return;
        }
        if (lodash["includes"](this.multisigAddresses, address)) {
            const msg = this.translate.instant('Address already added');
            this.showErrorMessage(msg);
            this.cleanSearch();
            return;
        }
        this.multisigAddresses.push(address);
        this.cleanSearch();
    }
    removeAddress(index) {
        this.multisigAddresses.splice(index, 1);
    }
    goToConfirm() {
        const amount = 0;
        const network = this.navParams.data.testnetEnabled ? 'testnet' : 'livenet';
        let nextView = {
            name: 'ConfirmPage',
            params: {
                walletName: this.navParams.data.walletName,
                walletId: this.pairedWallet.credentials.walletId,
                amount,
                description: this.translate.instant('ETH Multisig Wallet creation'),
                multisigAddresses: this.multisigAddresses,
                requiredConfirmations: this.m,
                totalCopayers: this.n,
                coin: this.pairedWallet.coin,
                network,
                isEthMultisigInstantiation: true,
                multisigContractAddress: GnosisFactories[network],
                toAddress: GnosisFactories[network] // address gnosis multisig contract
            }
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
};
create_eth_multisig_CreateEthMultisigPage = tslib_es6["__decorate"]([
    Object(core["Component"])({
        selector: 'page-create-eth-multisig',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/create-eth-multisig/create-eth-multisig.html"*/'<wide-header-page title="{{ \'Add copayers\' | translate }}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="goToConfirm()" [disabled]="n != multisigAddresses.length" ion-button>\n      <span translate>Create</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item class="linked-wallet">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Linked to (Copayer 1)</span>\n          </div>\n        </ion-label>\n\n        <ion-note item-end>\n          <ion-row align-items-center class="wallet" *ngIf="pairedWallet">\n            <ion-col>\n              <coin-icon [coin]="pairedWallet.coin" [network]="pairedWallet.network"></coin-icon>\n            </ion-col>\n\n            <ion-col>\n              <span class="note-container ellipsis">{{pairedWallet.name}}</span>\n            </ion-col>\n          </ion-row>\n        </ion-note>\n      </ion-item>\n      <label-tip type="info" header="no-header" class="no-arrowhead">\n        <div label-tip-body>\n          {{\'You are creating a {m}-{n} wallet. And you need all {m} copayers addresses at creation time.\' | translate: { n: n, m: m } }}\n        </div>\n      </label-tip>\n      <ion-item-divider>{{ \'Copayers\' | translate }} </ion-item-divider>\n      <div *ngIf="n > multisigAddresses.length" class="multisig-input">\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Enter copayer address\' }}" [(ngModel)]="search" (ionChange)="processInput(search)"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="cleanSearch()"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n      </div>\n\n      <ion-item *ngFor="let addr of multisigAddresses; let idx = index">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Copayer {{idx+1}}</span>\n          </div>\n        </ion-label>\n\n        <ion-note item-end>\n          <div class="payment-proposal-to">\n            <div class="background-content" copy-to-clipboard="{{ addr }}">\n              <img class="coin-img" src="assets/img/currencies/eth.svg" [ngClass]="{\'testnet\': pairedWallet.network === \'testnet\'}" alt="Coin" />\n              <span>{{addr | shortenedAddress}}</span>\n            </div>\n          </div>\n        </ion-note>\n        <ion-icon *ngIf="idx != 0" class="close-icon pointer" name="ios-close-outline" item-right (click)="removeAddress(idx)"></ion-icon>\n      </ion-item>\n    </ion-list>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/add/create-eth-multisig/create-eth-multisig.html"*/
    }),
    tslib_es6["__metadata"]("design:paramtypes", [address_address["a" /* AddressProvider */],
        errors["a" /* ErrorsProvider */],
        ionic_angular["f" /* Events */],
        incoming_data["a" /* IncomingDataProvider */],
        logger["a" /* Logger */],
        ionic_angular["n" /* NavParams */],
        core_es5["f" /* TranslateService */],
        wallet["a" /* WalletProvider */],
        ionic_angular["m" /* NavController */]])
], create_eth_multisig_CreateEthMultisigPage);

//# sourceMappingURL=create-eth-multisig.js.map

/***/ }),

/***/ 972:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupGamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__onboarding_add_funds_add_funds__ = __webpack_require__(973);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(17);




// pages


// providers






let BackupGamePage = class BackupGamePage {
    constructor(navCtrl, navParams, logger, profileProvider, bwcProvider, actionSheetProvider, keyProvider, persistenceProvider, events) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.bwcProvider = bwcProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.persistenceProvider = persistenceProvider;
        this.events = events;
        this.mnemonicWords = this.navParams.data.words;
        this.keys = this.navParams.data.keys;
        this.keyId = this.navParams.data.keyId;
        this.setFlow();
    }
    ionViewDidLoad() {
        if (this.gameSlides)
            this.gameSlides.lockSwipes(true);
        this.wideHeader.navBar.backButtonClick = () => {
            if (this.customWords.length > 0) {
                this.clear();
            }
            else {
                this.navCtrl.pop();
            }
        };
    }
    shuffledWords(words) {
        const sort = __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](words);
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](sort, w => {
            return {
                word: w,
                selected: false
            };
        });
    }
    addButton(index, item) {
        const newWord = {
            word: item.word,
            prevIndex: index
        };
        this.customWords.push(newWord);
        this.shuffledMnemonicWords[index].selected = true;
        this.shouldContinue();
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slideNext();
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    removeButton(index, item) {
        this.customWords.splice(index, 1);
        this.shuffledMnemonicWords[item.prevIndex].selected = false;
        this.shouldContinue();
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slidePrev();
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    shouldContinue() {
        this.selectComplete =
            this.customWords.length === this.shuffledMnemonicWords.length
                ? true
                : false;
    }
    clear() {
        this.customWords = [];
        this.shuffledMnemonicWords.forEach(word => {
            word.selected = false;
        });
        this.selectComplete = false;
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slideTo(0);
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    setFlow() {
        if (!this.mnemonicWords)
            return;
        this.shuffledMnemonicWords = this.shuffledWords(this.mnemonicWords);
        this.mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(this.keyId);
        this.useIdeograms = this.mnemonicWords.indexOf('\u3000') >= 0;
        this.password = '';
        this.customWords = [];
        this.selectComplete = false;
    }
    finalStep() {
        const customWordList = __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.customWords, 'word');
        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEqual"](this.mnemonicWords, customWordList)) {
            this.showErrorInfoSheet('Mnemonic string mismatch');
            return;
        }
        if (this.mnemonicHasPassphrase) {
            const keyClient = this.bwcProvider.getKey();
            const separator = this.useIdeograms ? '\u3000' : ' ';
            const customSentence = customWordList.join(separator);
            const password = this.password || '';
            let key;
            try {
                key = new keyClient({
                    seedType: 'mnemonic',
                    seedData: customSentence,
                    useLegacyCoinType: false,
                    useLegacyPurpose: false,
                    passphrase: password
                });
            }
            catch (err) {
                this.showErrorInfoSheet(err);
                return;
            }
            if (key.get().xPrivKey != this.keys.xPrivKey) {
                this.showErrorInfoSheet('Private key mismatch');
                return;
            }
        }
        this.profileProvider.setBackupGroupFlag(this.keyId);
        const opts = {
            keyId: this.keyId,
            showHidden: true
        };
        const wallets = this.profileProvider.getWalletsFromGroup(opts);
        wallets.forEach(w => {
            this.profileProvider.setWalletBackup(w.credentials.walletId);
        });
        this.showSuccessInfoSheet();
    }
    showSuccessInfoSheet() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('correct-recovery-prhase');
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            if (this.navParams.data.isOnboardingFlow) {
                this.persistenceProvider
                    .getCopayDisclaimerFlag()
                    .then(disclaimerAgreed => {
                    disclaimerAgreed
                        ? this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__onboarding_add_funds_add_funds__["a" /* AddFundsPage */], { keyId: this.keyId })
                        : this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */], { keyId: this.keyId });
                });
            }
            else
                this.navCtrl.popToRoot().then(() => {
                    this.events.publish('Local/FetchWallets');
                });
        });
    }
    showErrorInfoSheet(err) {
        this.logger.warn('Failed to verify backup: ', err);
        const infoSheet = this.actionSheetProvider.createInfoSheet('incorrect-recovery-prhase');
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            this.clear();
            this.setFlow();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('gameSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* Slides */])
], BackupGamePage.prototype, "gameSlides", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('wideHeader'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], BackupGamePage.prototype, "wideHeader", void 0);
BackupGamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-backup-game',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/backup/backup-game/backup-game.html"*/'<wide-header-page title="{{\'Verify Your Phrase\' | translate}}" #wideHeader>\n  <div page-content>\n    <div class="grid-container">\n      <div class="key-container" [hidden]="mnemonicHasPassphrase && selectComplete">\n        <div class="word-container">\n          <ion-slides #gameSlides class="word-slides" slidesPerView="2" spaceBetween="20" centeredSlides="true">\n            <ion-slide *ngFor="let mnemonicWord of mnemonicWords; let i = index">\n              <div class="word">\n                <span *ngIf="customWords && customWords[i]">{{customWords[i].word}}</span>\n                <div class="dash-line"></div>\n              </div>\n              <div class="word-number">\n                {{i + 1}} / {{mnemonicWords.length}}\n              </div>\n            </ion-slide>\n          </ion-slides>\n        </div>\n      </div>\n\n      <div class="mnemonic-words-container" [hidden]="mnemonicHasPassphrase && selectComplete">\n        <div class="mnemonic-words" *ngIf="!selectComplete">\n          <div class="bottom-title" translate>Tap each word in the correct order.</div>\n          <div class="words">\n            <button class="button-secondary" ion-button *ngFor="let shuffledWord of shuffledMnemonicWords; let i = index" (click)="addButton(i, shuffledWord)" [disabled]="shuffledWord.selected">{{shuffledWord.word}}</button>\n          </div>\n        </div>\n        <div *ngIf="selectComplete" class="confirm-container">\n          <div translate>Is this correct?</div>\n          <button *ngIf="selectComplete" ion-button class="button-standard no-margin-bottom" (click)="finalStep()">\n            {{\'Confirm\' | translate}}\n          </button>\n          <button ion-button clear class="button-standard" (click)="clear()">\n            {{\'Clear\' | translate}}\n          </button>\n        </div>\n      </div>\n\n      <div [hidden]="!mnemonicHasPassphrase || !(mnemonicHasPassphrase && selectComplete)">\n        <div class="key-container">\n          <div class="password">\n            <div class="password-title" translate>\n              In order to verify your wallet recovery phrase, please type your password.\n            </div>\n            <ion-item>\n              <ion-label stacked translate>Password</ion-label>\n              <ion-input type="password" id="password" [(ngModel)]="password" autocapitalize="off" spellcheck="false">\n              </ion-input>\n            </ion-item>\n            <div class="password-text">\n              <span class="assertive" translate>This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.</span>\n            </div>\n          </div>\n        </div>\n\n        <div class="bottom-absolute" *ngIf="mnemonicHasPassphrase">\n          <button [disabled]="!password" ion-button class="button-standard" (click)="finalStep()">\n            {{\'Confirm\' | translate}}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/backup/backup-game/backup-game.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["f" /* Events */]])
], BackupGamePage);

//# sourceMappingURL=backup-game.js.map

/***/ }),

/***/ 973:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddFundsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_add_import_wallet_import_wallet__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pages_integrations_coinbase_coinbase__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__pages_onboarding_recovery_key_recovery_key__ = __webpack_require__(390);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pages_send_amount_amount__ = __webpack_require__(86);



// Providers






// Pages




let AddFundsPage = class AddFundsPage {
    constructor(navCtrl, navParams, logger, profileProvider, analyticsProvider, configProvider, actionSheetProvider, platformProvider, viewCtrl) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.analyticsProvider = analyticsProvider;
        this.configProvider = configProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.platformProvider = platformProvider;
        this.viewCtrl = viewCtrl;
        this.keyId = this.navParams.data.keyId;
        this.showCoinbase = !this.platformProvider.isMacApp();
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddFundsPage');
    }
    ionViewWillEnter() {
        this.needsBackup = this.keyId ? this.checkIfNeedsBackup() : false;
    }
    checkIfNeedsBackup() {
        const walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        return walletsGroup.needsBackup;
    }
    goToCoinbase() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__pages_integrations_coinbase_coinbase__["a" /* CoinbasePage */], { isOnboardingFlow: true });
    }
    goToAmountPage() {
        if (this.needsBackup) {
            this.showInfoSheet();
            return;
        }
        this.analyticsProvider.logEvent('buy_crypto_button_clicked', {
            from: 'addFundsPage'
        });
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__pages_send_amount_amount__["a" /* AmountPage */], {
            fromBuyCrypto: true,
            nextPage: 'CryptoOrderSummaryPage',
            currency: this.configProvider.get().wallet.settings.alternativeIsoCode
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__pages_add_import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
    showInfoSheet() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('key-verification-required');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__pages_onboarding_recovery_key_recovery_key__["a" /* RecoveryKeyPage */], {
                    keyId: this.keyId
                });
            }
        });
    }
};
AddFundsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-add-funds',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/add-funds/add-funds.html"*/'<wide-header-page title="{{ \'Lets add some funds\' | translate }}" hideBackButton="true">\n  <div page-content>\n    <ion-list no-lines>\n      <div class="option-container" (click)="goToCoinbase()" *ngIf="showCoinbase">\n        <ion-item>\n          <img src="assets/img/coinbase/coinbase-icon.png" class="coinbase-icon" />\n        </ion-item>\n        <div class="info">\n          <div class="title">\n            {{\'Connect with Coinbase\' | translate}}\n          </div>\n          <div class="note">\n            {{\'Easily deposit and withdraw funds.\' | translate}}\n          </div>\n        </div>\n      </div>\n      <div class="option-container" (click)="goToAmountPage()">\n        <ion-item>\n          <img src="assets/img/onboarding/all-coins.svg" />\n        </ion-item>\n        <div class="info">\n          <div class="title">\n            {{\'Buy Crypto\' | translate}}\n          </div>\n          <div class="note">\n            {{\'Buy crypto with a credit card.\' | translate}}\n          </div>\n        </div>\n      </div>\n      <div class="option-container" (click)="goToImportWallet()" *ngIf="needsBackup">\n        <ion-item>\n          <img src="assets/img/receive.svg" />\n        </ion-item>\n        <div class="info">\n          <div class="title">\n            {{\'Restore from backup\' | translate}}\n          </div>\n          <div class="note">\n            {{\'Add funds from an existing wallet.\' | translate}}\n          </div>\n        </div>\n      </div>\n    </ion-list>\n  </div>\n  <div footer-content>\n    <button ion-button color="primary" class="button-standard" (click)="close()">\n      {{"Ill do this later" | translate}}\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/onboarding/add-funds/add-funds.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], AddFundsPage);

//# sourceMappingURL=add-funds.js.map

/***/ }),

/***/ 974:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinSelectorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(27);



// Providers

let CoinSelectorPage = class CoinSelectorPage {
    constructor(currencyProvider, logger, viewCtrl, navParams) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.logger.debug('Coin selector initialized;');
        this.description = this.navParams.data.description;
        this.availableChains = this.currencyProvider.getAvailableChains();
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    selectedCoin(coin) {
        this.viewCtrl.dismiss({
            selectedCoin: coin
        });
    }
};
CoinSelectorPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coin-selector',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/coin-selector/coin-selector.html"*/'<wide-header-page title="{{\'Coin Selector\' | translate}}">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="selectedCoin()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div class="description" *ngIf="description">{{ description }}</div>\n    <ion-list class="settings-list bp-list">\n      <div *ngFor="let coin of availableChains" >\n        <!-- TODO FIX HIDE EVERY COIN BUT EDU/TIK-->\n        <button class="list-button" *ngIf="coin === \'edu\' || coin === \'tik\'" ion-item (click)="selectedCoin(coin)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{coin}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</div>\n        </button>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/includes/coin-selector/coin-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["t" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */]])
], CoinSelectorPage);

//# sourceMappingURL=coin-selector.js.map

/***/ }),

/***/ 975:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_animations__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__ = __webpack_require__(20);


// Providers




let CardsPage = class CardsPage {
    constructor(appProvider, platformProvider, homeIntegrationsProvider, bitPayProvider, giftCardProvider, persistenceProvider, tabProvider, events, iabCardProvider, changeRef, logger) {
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.bitPayProvider = bitPayProvider;
        this.giftCardProvider = giftCardProvider;
        this.persistenceProvider = persistenceProvider;
        this.tabProvider = tabProvider;
        this.events = events;
        this.iabCardProvider = iabCardProvider;
        this.changeRef = changeRef;
        this.logger = logger;
        this.showTKCoinCard = true;
        this.tapped = 0;
        this.initialized = false;
        this.waitList = true;
        this.NETWORK = this.bitPayProvider.getEnvironment().network;
        this.bitPayProvider.get('/countries', ({ data }) => {
            this.persistenceProvider.setCountries(data);
        }, () => { });
        this.events.subscribe('showHideUpdate', (status) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (status === 'inProgress') {
                this.initialized = false;
            }
            else {
                this.tkcoinCardItems = yield this.prepareDebitCards();
                setTimeout(() => {
                    this.initialized = true;
                    this.changeRef.detectChanges();
                });
            }
        }));
        this.events.subscribe('experimentUpdateStart', () => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.waitList = false;
            this.changeRef.detectChanges();
        }));
        this.events.subscribe('updateCards', (cards) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.tkcoinCardItems = yield this.prepareDebitCards(cards);
            this.changeRef.detectChanges();
        }));
        this.events.subscribe('TKCoinId/Disconnected', () => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.hasCards = false;
        }));
    }
    ionViewWillEnter() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.cardExperimentEnabled =
                (yield this.persistenceProvider.getCardExperimentFlag()) === 'enabled';
            if (this.cardExperimentEnabled) {
                this.waitList = false;
            }
            this.showGiftCards = this.homeIntegrationsProvider.shouldShowInHome('giftcards');
            this.showBitpayCardGetStarted = this.homeIntegrationsProvider.shouldShowInHome('debitcard');
            this.showTKCoinCard =
                !(this.appProvider.info._enabledExtensions.debitcard == 'false') &&
                    this.platformProvider.isCordova;
            this.tkcoinCardItems = yield this.prepareDebitCards();
            if (!this.tabReady) {
                this.throttledFetchAllCards();
            }
            this.tabReady = this.initialized = this.IABReady = true;
            this.changeRef.detectChanges();
        });
    }
    refresh(refresher) {
        setTimeout(() => {
            refresher.complete();
        }, 2000);
        this.throttledFetchAllCards();
    }
    prepareDebitCards(force) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.logger.log('prepare called');
            return new Promise((res) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                if (!this.platformProvider.isCordova) {
                    return res();
                }
                // retrieve cards from storage
                let cards = force ||
                    (yield this.persistenceProvider.getBitpayDebitCards(__WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__["a" /* Network */][this.NETWORK]));
                /*
                  Adding this check as a safety - intermittently, when storage is getting updated with cards
                  a race condition can happen where cards returns an empty array.
                */
                if (this.tkcoinCardItems && this.tkcoinCardItems.length && !cards.length)
                    return res(this.tkcoinCardItems);
                this.hasCards = cards.length > 0;
                if (!this.hasCards) {
                    return res();
                }
                // sort by provider
                this.iabCardProvider.sortCards(cards, ['galileo', 'firstView'], 'provider');
                const hasGalileo = cards.some(c => c.provider === 'galileo');
                // if all cards are hidden
                if (cards.every(c => !!c.hide)) {
                    // if galileo not found then show order card else hide it
                    if (!hasGalileo) {
                        this.showTKCoinCard = true;
                        this.showDisclaimer = true;
                    }
                    else {
                        this.showTKCoinCard = this.showDisclaimer = false;
                    }
                    return res(cards);
                }
                // if galileo then show disclaimer and remove add card ability
                if (hasGalileo) {
                    // only show cards that are active and if galileo only show virtual
                    cards = cards.filter(c => (c.provider === 'firstView' || c.cardType === 'virtual') &&
                        c.status === 'active');
                    this.showBitpayCardGetStarted = this.waitList = false;
                    this.showDisclaimer = !!cards
                        .filter(c => !c.hide)
                        .find(c => c.provider === 'galileo');
                    yield this.persistenceProvider.setReachedCardLimit(true);
                    this.events.publish('reachedCardLimit');
                }
                else {
                    if (this.waitList) {
                        // no MC so hide disclaimer
                        this.showDisclaimer = false;
                    }
                }
                this.showTKCoinCard = true;
                res(cards);
            }));
        });
    }
    fetchBitpayCardItems() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.hasCards && this.platformProvider.isCordova) {
                yield this.iabCardProvider.getBalances();
            }
        });
    }
    fetchActiveGiftCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.activeCards = yield this.tabProvider.activeGiftCardsPromise;
            const updatedActiveGiftCardsPromise = this.giftCardProvider.getActiveCards();
            this.activeCards = yield updatedActiveGiftCardsPromise;
            this.tabProvider.activeGiftCardsPromise = updatedActiveGiftCardsPromise;
        });
    }
    fetchAllCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            return Promise.all([
                this.fetchBitpayCardItems(),
                this.fetchActiveGiftCards()
            ]);
        });
    }
    throttledFetchAllCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (this.fetchLock) {
                this.logger.log('CARD - fetch already in progress');
                return;
            }
            this.logger.log('CARD - fetch started');
            this.fetchLock = true;
            yield this.fetchAllCards();
            this.logger.log('CARD - fetch complete');
            yield new Promise(res => setTimeout(res, 30000));
            this.fetchLock = false;
            this.logger.log('CARD - fetchLock reset');
        });
    }
    enableCard() {
        this.tapped++;
        if (this.tapped >= 10) {
            this.persistenceProvider.getCardExperimentFlag().then(res => {
                if (res === 'enabled') {
                    this.persistenceProvider.removeCardExperimentFlag();
                    this.persistenceProvider.setBitpayIdPairingFlag('disabled');
                    alert('Card experiment disabled. Restart the app.');
                }
                else {
                    this.persistenceProvider.setCardExperimentFlag('enabled');
                    this.persistenceProvider.setBitpayIdPairingFlag('enabled');
                    alert('Card experiment enabled.');
                }
                this.tapped = 0;
            });
        }
    }
};
CardsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-cards',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/cards/cards.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Cards\' | translate }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea>\n  <ion-refresher (ionRefresh)="refresh($event)" pullMin="90" pullMax="160">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title" (click)="enableCard()" tappable>\n        <expandable-header-primary>\n          {{ \'Cards\' | translate }}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ng-container *ngIf="tabReady">\n      <ng-container *ngIf="showTKCoinCard">\n        <tkcoin-card-home [cardExperimentEnabled]="cardExperimentEnabled" [tkcoinCardItems]="tkcoinCardItems"\n                          [hasCards]="hasCards" [network]="NETWORK" [waitList]="waitList" [initialized]="initialized"\n                          [showBitpayCardGetStarted]="showBitpayCardGetStarted"></tkcoin-card-home>\n      </ng-container>\n\n      <gift-cards *ngIf="showGiftCards && activeCards" [scrollArea]="scrollArea" [activeCards]="activeCards"></gift-cards>\n\n\n      <p class="card-terms" *ngIf="showTKCoinCard && showDisclaimer && initialized && !waitList" @fade>\n        *Network fees and miner fees may apply.<br><br>\n        BY USING THIS CARD YOU AGREE WITH THE TERMS AND CONDITIONS OF THE CARDHOLDER AGREEMENT AND FEE\n        SCHEDULE, IF ANY. This card is issued by Metropolitan Commercial Bank (Member FDIC) pursuant to a license from\n        Mastercard International. "Metropolitan Commercial Bank" and "Metropolitan" are registered trademarks of\n        Metropolitan Commercial Bank 2014.<br><br>\n        Mastercard is a registered trademark and the circles design is a trademark of Mastercard International\n        Incorporated.\n      </p>\n    </ng-container>\n\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/cards/cards.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["l" /* trigger */])('fade', [
                Object(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["k" /* transition */])(':enter', [
                    Object(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["j" /* style */])({
                        transform: 'translateY(20px)',
                        opacity: 0
                    }),
                    Object(__WEBPACK_IMPORTED_MODULE_2__angular_animations__["e" /* animate */])('400ms')
                ])
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["f" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_3" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["M" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_20" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["L" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["_21" /* TabProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ChangeDetectorRef"],
        __WEBPACK_IMPORTED_MODULE_4__providers__["W" /* Logger */]])
], CardsPage);

//# sourceMappingURL=cards.js.map

/***/ }),

/***/ 976:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__new_feature_new_feature__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__send_amount_amount__ = __webpack_require__(86);






// TODO FIX: Review this comments
// import { FormatCurrencyPipe } from '../../pipes/format-currency';
// Providers




// Pages
// TODO FIX Don't use splash screen
// import { SplashScreen } from '@ionic-native/splash-screen';

// import { ExchangeCryptoPage } from '../exchange-crypto/exchange-crypto';
// import { TKCoinCardIntroPage } from '../integrations/tkcoin-card/tkcoin-card-intro/tkcoin-card-intro';
// import { PhaseOneCardIntro } from '../integrations/tkcoin-card/tkcoin-card-phases/phase-one/phase-one-intro-page/phase-one-intro-page';
// import { CoinbasePage } from '../integrations/coinbase/coinbase';
// import { BuyCardPage } from '../integrations/gift-cards/buy-card/buy-card';
// import { CardCatalogPage } from '../integrations/gift-cards/card-catalog/card-catalog';

// import { AddFundsPage } from '../onboarding/add-funds/add-funds';

let HomePage = class HomePage {
    constructor(persistenceProvider, logger, analyticsProvider, appProvider, externalLinkProvider, 
        // TODO FIX: Review this comments
        // private formatCurrencyPipe: FormatCurrencyPipe,
        navCtrl, giftCardProvider, 
        // private merchantProvider: MerchantProvider,
        feedbackProvider, homeIntegrationsProvider, translate, configProvider, events, releaseProvider, 
        // TODO FIX: Review this comments
        // private bwcProvider: BwcProvider,
        platformProvider, modalCtrl, profileProvider, actionSheetProvider, 
        // private dynamicLinkProvider: DynamicLinksProvider,
        newFeatureData, emailProvider, popupProvider) {
        this.persistenceProvider = persistenceProvider;
        this.logger = logger;
        this.analyticsProvider = analyticsProvider;
        this.appProvider = appProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navCtrl = navCtrl;
        this.giftCardProvider = giftCardProvider;
        this.feedbackProvider = feedbackProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.translate = translate;
        this.configProvider = configProvider;
        this.events = events;
        this.releaseProvider = releaseProvider;
        this.platformProvider = platformProvider;
        this.modalCtrl = modalCtrl;
        this.profileProvider = profileProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.newFeatureData = newFeatureData;
        this.emailProvider = emailProvider;
        this.popupProvider = popupProvider;
        this.tapped = 0;
        this.advertisements = [];
        this.productionAds = [];
        this.testingAds = [];
        this.showTotalBalance = true;
        this.newReleaseAvailable = false;
        this.showCoinbase = false;
        this.logger.info('Loaded: HomePage');
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.subscribeEvents();
        this.persistenceProvider
            .getCardExperimentFlag()
            .then(status => (this.cardExperimentEnabled = status === 'enabled'));
        this.persistenceProvider
            .getTestingAdvertisments()
            .then(testing => (this.testingAdsEnabled = testing === 'enabled'));
        // this.isCordova = this.platformProvider.isCordova;
        this.pagesMap = {};
    }
    showNewFeatureSlides() {
        if (this.appProvider.isLockModalOpen)
            return;
        this.events.unsubscribe('Local/showNewFeaturesSlides');
        const disclaimerAccepted = this.profileProvider.profile.disclaimerAccepted;
        const currentVs = this.appProvider.version.major + '.' + this.appProvider.version.minor;
        if (!disclaimerAccepted) {
            // first time using the App -> don't show
            this.persistenceProvider.setNewFeatureSlidesFlag(currentVs);
            return;
        }
        this.persistenceProvider.getNewFeatureSlidesFlag().then(value => {
            if (!value || String(value) !== currentVs) {
                this.newFeatureData.get().then(feature_list => {
                    if (feature_list && feature_list.features.length > 0) {
                        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_11__new_feature_new_feature__["a" /* NewFeaturePage */], {
                            featureList: feature_list
                        });
                        modal.present();
                        modal.onDidDismiss(data => {
                            if (data) {
                                if (typeof data.done === 'boolean' && data.done === true) {
                                    this.persistenceProvider.setNewFeatureSlidesFlag(currentVs);
                                }
                                if (typeof data.data !== 'boolean') {
                                    this.events.publish('IncomingDataRedir', data.data);
                                }
                            }
                        });
                    }
                    else {
                        this.persistenceProvider.setNewFeatureSlidesFlag(currentVs);
                    }
                });
            }
        });
    }
    ionViewWillEnter() {
        const config = this.configProvider.get();
        this.totalBalanceAlternativeIsoCode =
            config.wallet.settings.alternativeIsoCode;
        this.events.publish('Local/showNewFeaturesSlides');
        this.checkFeedbackInfo();
        this.showTotalBalance = config.totalBalance.show;
        if (this.showTotalBalance)
            this.updateTotalBalance(this.appProvider.homeBalance);
        if (this.platformProvider.isElectron)
            this.checkNewRelease();
        this.showCoinbase = !!config.showIntegration['coinbase'];
        this.setIntegrations();
        // TODO FIX: Review this comments
        // this.setMerchantDirectoryAdvertisement();
        // this.loadAds();
        // this.fetchAdvertisements();
        // this.fetchGiftCardAdvertisement();
        /*
        this.persistenceProvider.getDynamicLink().then((deepLink: string) => {
          if (deepLink) {
            this.persistenceProvider.setOnboardingFlowFlag('disabled');
            this.persistenceProvider.removeDynamicLink();
            this.dynamicLinkProvider.processDeepLink(deepLink);
          } else {
            this.persistenceProvider
              .getOnboardingFlowFlag()
              .then((value: string) => {
                if (value === 'enabled' && this.appProvider.info.name !== 'copay')
                  this.openAddFunds();
              });
          }
        });
        */
    }
    ionViewDidLoad() {
        this.preFetchWallets();
        // this.merchantProvider.getMerchants();
        // Required delay to improve performance loading
        setTimeout(() => {
            this.checkEmailLawCompliance();
            // TODO FIX: Review this comments
            // this.checkAltCurrency(); // Check if the alternative currency setted is no longer supported
        }, 2000);
    }
    // TODO FIX: Review this comments
    /*
    private loadAds() {
      const client = this.bwcProvider.getClient(null, {});
  
      client.getAdvertisements(
        { testing: this.testingAdsEnabled },
        (err, ads) => {
          if (err) throw err;
  
          if (this.testingAdsEnabled) {
            _.forEach(ads, ad => {
              const alreadyVisible = this.testingAds.find(
                a => a.name === ad.name
              );
              this.persistenceProvider
                .getAdvertisementDismissed(ad.name)
                .then((value: string) => {
                  if (value === 'dismissed') {
                    return;
                  }
  
                  let link = this.getAdPageOrLink(ad.linkUrl);
  
                  !alreadyVisible &&
                    this.verifySignature(ad) &&
                    ad.isTesting &&
                    this.testingAds.push({
                      name: ad.name,
                      advertisementId: ad.advertisementId,
                      country: ad.country,
                      title: ad.title,
                      body: ad.body,
                      app: ad.app,
                      linkText: ad.linkText,
                      link,
                      imgSrc: ad.imgUrl,
                      signature: ad.signature,
                      isTesting: ad.isTesting,
                      dismissible: true
                    });
                  this.showAdvertisements = true;
                });
            });
          } else {
            _.forEach(ads, ad => {
              const alreadyVisible = this.advertisements.find(
                a => a.name === ad.name
              );
              this.persistenceProvider
                .getAdvertisementDismissed(ad.name)
                .then((value: string) => {
                  if (value === 'dismissed') {
                    return;
                  }
  
                  let link = this.getAdPageOrLink(ad.linkUrl);
  
                  !alreadyVisible &&
                    this.verifySignature(ad) &&
                    this.advertisements.push({
                      name: ad.name,
                      country: ad.country,
                      advertisementId: ad.advertisementId,
                      title: ad.title,
                      body: ad.body,
                      app: ad.app,
                      linkText: ad.linkText,
                      link,
                      imgSrc: ad.imgUrl,
                      signature: ad.signature,
                      isTesting: ad.isTesting,
                      dismissible: true
                    });
                  this.showAdvertisements = true;
                });
            });
          }
        }
      );
    }
    */
    getAdPageOrLink(link) {
        let linkTo;
        // link is of formate page:PAGE_TITLE or url e.g. https://google.com
        if (link.startsWith('page:')) {
            let pageArray = link.split(':');
            let pageTitle = pageArray[1];
            if (pageTitle in this.pagesMap) {
                linkTo = this.pagesMap[pageTitle];
                return linkTo;
            }
        }
        else if (link.startsWith('https://')) {
            linkTo = link;
        }
        return linkTo;
    }
    // TODO FIX: Review this comments
    /*
    private setMerchantDirectoryAdvertisement() {
    const alreadyVisible = this.advertisements.find(
      a => a.name === 'merchant-directory'
    );
    !alreadyVisible &&
      this.advertisements.push({
        name: 'merchant-directory',
        title: this.translate.instant('Merchant Directory'),
        body: this.translate.instant(
          'Learn where you can spend your crypto today.'
        ),
        app: 'tkcoin',
        linkText: this.translate.instant('View Directory'),
        link: 'https://tkcoin.org/directory/?hideGiftCards=true',
        imgSrc: 'assets/img/icon-merch-dir.svg',
        isTesting: false,
        dismissible: true
      });
    this.showAdvertisements = true;
  }
  private verifySignature(ad): boolean {
    var adMessage = JSON.stringify({
      advertisementId: ad.advertisementId,
      name: ad.name,
      title: ad.title,
      type: 'standard',
      country: ad.country,
      body: ad.body,
      imgUrl: ad.imgUrl,
      linkText: ad.linkText,
      linkUrl: ad.linkUrl,
      app: ad.app
    });

    const config = this.configProvider.getDefaults();
    const pubKey = config.adPubKey.pubkey;
    if (!pubKey) return false;

    const b = this.bwcProvider.getBitcore();
    const ECDSA = b.crypto.ECDSA;
    const Hash = b.crypto.Hash;

    const sigObj = b.crypto.Signature.fromString(ad.signature);
    const _hashbuf = Hash.sha256(Buffer.from(adMessage));
    const verificationResult = ECDSA.verify(
      _hashbuf,
      sigObj,
      new b.PublicKey(pubKey),
      'little'
    );

    return verificationResult;
  }
  */
    updateTotalBalance(data) {
        if (!data)
            return;
        this.zone.run(() => {
            this.totalBalanceAlternative = data.totalBalanceAlternative;
            this.totalBalanceChange = data.totalBalanceChange;
            this.totalBalanceAlternativeIsoCode = data.totalBalanceAlternativeIsoCode;
        });
    }
    setTotalBalance(data) {
        this.updateTotalBalance(data);
        this.appProvider.homeBalance = data;
        this.persistenceProvider.setTotalBalance(data);
    }
    subscribeEvents() {
        this.events.subscribe('Local/HomeBalance', data => {
            if (data && this.showTotalBalance)
                this.setTotalBalance(data);
            else {
                this.totalBalanceAlternative = '0';
            }
            this.fetchingStatus = false;
        });
        this.events.subscribe('Local/ServerMessages', data => {
            this.serverMessages = __WEBPACK_IMPORTED_MODULE_4_lodash__["orderBy"](data.serverMessages, ['priority'], ['asc']);
            this.serverMessages.forEach(serverMessage => {
                this.checkServerMessage(serverMessage);
            });
        });
        this.events.subscribe('Local/AccessDenied', () => {
            this.accessDenied = true;
        });
        // TODO FIX: Review this comments
        /*
        this.events.subscribe(
          'CardAdvertisementUpdate',
          ({ status, cards, cardExperimentEnabled }) => {
            const hasGalileo = cards && cards.some(c => c.provider === 'galileo');
            switch (status) {
              case 'connected':
                hasGalileo
                  ? this.removeAdvertisement('tkcoin-card')
                  : this.addTKCoinCard();
                break;
              case 'disconnected':
                this.addTKCoinCard();
                break;
              default:
                this.cardExperimentEnabled = cardExperimentEnabled;
                if (!hasGalileo) this.addTKCoinCard();
            }
          }
        );
        */
        this.events.subscribe('Local/TestAdsToggle', testAdsStatus => {
            this.testingAdsEnabled = testAdsStatus;
        });
        this.events.subscribe('Local/ConnectionError', () => {
            this.fetchingStatus = false;
        });
        this.events.subscribe('Local/showNewFeaturesSlides', () => {
            this.showNewFeatureSlides();
        });
    }
    preFetchWallets() {
        // Avoid heavy tasks that can slow down the unlocking experience
        if (this.appProvider.isLockModalOpen)
            return;
        this.fetchingStatus = true;
        this.events.publish('Local/FetchWallets');
    }
    setIntegrations() {
        // Show integrations
        this.showBuyCryptoOption = false;
        this.showExchangeCryptoOption = false;
        this.showShoppingOption = false;
        const integrations = this.homeIntegrationsProvider
            .get()
            .filter(i => i.show);
        integrations.forEach(x => {
            switch (x.name) {
                case 'buycrypto':
                    this.showBuyCryptoOption = true;
                    break;
                case 'exchangecrypto':
                    this.showExchangeCryptoOption = true;
                    break;
                case 'giftcards':
                    // TODO FIX: Review this comments
                    // this.showShoppingOption = true;
                    // this.setGiftCardAdvertisement();
                    break;
                case 'coinbase':
                    this.showCoinbase =
                        x.linked == false && !this.platformProvider.isMacApp();
                    // TODO FIX: Review this comments
                    // this.hasOldCoinbaseSession = x.oldLinked;
                    // if (this.showCoinbase) this.addCoinbase();
                    break;
            }
        });
    }
    // TODO FIX: Review this comments
    /*
    private setGiftCardAdvertisement() {
      const alreadyVisible = this.advertisements.find(
        a => a.name === 'amazon-gift-cards'
      );
      !alreadyVisible &&
        !this.platformProvider.isMacApp() &&
        this.advertisements.unshift({
          name: 'amazon-gift-cards',
          title: this.translate.instant('Shop at Amazon'),
          body: this.translate.instant(
            'Leverage your crypto with an amazon.com gift card.'
          ),
          app: 'tkcoin',
          linkText: this.translate.instant('Buy Now'),
          link: CardCatalogPage,
          isTesting: false,
          imgSrc: 'assets/img/amazon.svg',
          dismissible: true
        });
      this.showAdvertisements = true;
    }
    */
    // TODO FIX: Review this comments
    /*
    private addTKCoinCard() {
      if (!this.isCordova) return;
      this.persistenceProvider
        .getAdvertisementDismissed('tkcoin-card')
        .then((value: string) => {
          if (value === 'dismissed') {
            return;
          }
          const card: Advertisement = this.cardExperimentEnabled
            ? {
                name: 'tkcoin-card',
                title: this.translate.instant('Get the BitPay Card'),
                body: this.translate.instant(
                  'Designed for people who want to live life on crypto.'
                ),
                app: 'tkcoin',
                linkText: this.translate.instant('Order Now'),
                link: TKCoinCardIntroPage,
                isTesting: false,
                dismissible: true,
                imgSrc: 'assets/img/tkcoin-card/tkcoin-card-mc-angled-plain.svg'
              }
            : {
                name: 'tkcoin-card',
                title: this.translate.instant('Coming soon'),
                body: this.translate.instant(
                  'Join the waitlist and be first to experience the new card.'
                ),
                app: 'tkcoin',
                linkText: this.translate.instant('Notify Me'),
                link: PhaseOneCardIntro,
                isTesting: false,
                dismissible: true,
                imgSrc: 'assets/img/icon-bpcard.svg'
              };
          const alreadyVisible = this.advertisements.find(
            a => a.name === 'tkcoin-card'
          );
          !alreadyVisible && this.advertisements.unshift(card);
        });
    }
    */
    // TODO FIX: Review this comments
    /*
    private addCoinbase() {
      const alreadyVisible = this.advertisements.find(a => a.name === 'coinbase');
      !alreadyVisible &&
        this.advertisements.unshift({
          name: 'coinbase',
          title: this.hasOldCoinbaseSession
            ? this.translate.instant('Coinbase updated!')
            : this.translate.instant('Connect your Coinbase!'),
          body: this.hasOldCoinbaseSession
            ? this.translate.instant(
                'Reconnect to quickly withdraw and deposit funds.'
              )
            : this.translate.instant('Easily deposit and withdraw funds.'),
          app: 'tkcoin',
          linkText: this.hasOldCoinbaseSession
            ? this.translate.instant('Reconnect Account')
            : this.translate.instant('Connect Account'),
          link: CoinbasePage,
          dismissible: true,
          isTesting: false,
          imgSrc: 'assets/img/coinbase/coinbase-icon.png'
        });
      this.showAdvertisements = true;
    }
    */
    // TODO FIX: Review this comments
    /*
    private async addGiftCardDiscount(discountedCard: CardConfig) {
      const discount = discountedCard.discounts[0];
      const discountText =
        discount.type === 'flatrate'
          ? `${this.formatCurrencyPipe.transform(
              discount.amount,
              discountedCard.currency,
              'minimal'
            )}`
          : `${discount.amount}%`;
      const advertisementName = getGiftCardAdvertisementName(discountedCard);
      const alreadyVisible = this.advertisements.find(
        a => a.name === advertisementName
      );
      const isDismissed =
        (await this.checkIfDismissed(advertisementName)) == 'dismissed'
          ? true
          : false;
      !alreadyVisible &&
        !isDismissed &&
        this.advertisements.unshift({
          name: advertisementName,
          title: `${discountText} off ${discountedCard.displayName}`,
          body: `Save ${discountText} off ${discountedCard.displayName} gift cards. Limited time offer.`,
          app: 'tkcoin',
          linkText: 'Buy Now',
          link: BuyCardPage,
          linkParams: { cardConfig: discountedCard },
          isTesting: false,
          dismissible: true,
          imgSrc: discountedCard.icon
        });
    }
    
    private async addGiftCardPromotion(promotedCard: CardConfig) {
      const promo = promotedCard.promotions[0];
      const advertisementName = promo.shortDescription;
      const alreadyVisible = this.advertisements.find(
        a => a.name === advertisementName
      );
      const isDismissed =
        (await this.checkIfDismissed(advertisementName)) == 'dismissed'
          ? true
          : false;
      !alreadyVisible &&
        !isDismissed &&
        this.advertisements.unshift({
          name: advertisementName,
          title: promo.title,
          body: promo.description,
          app: 'tkcoin',
          linkText: promo.cta || 'Buy Now',
          link: BuyCardPage,
          linkParams: { cardConfig: promotedCard },
          isTesting: false,
          dismissible: true,
          imgSrc: promo.icon
        });
    }
  
    private async fetchGiftCardAdvertisement() {
      const availableCards = await this.giftCardProvider.getAvailableCards();
      const discountedCard = availableCards.find(cardConfig =>
        hasVisibleDiscount(cardConfig)
      );
      const promotedCard = availableCards.find(card => hasPromotion(card));
      if (discountedCard) {
        this.addGiftCardDiscount(discountedCard);
      } else if (promotedCard) {
        this.addGiftCardPromotion(promotedCard);
      }
    }
    
    private checkIfDismissed(name: string): Promise<any> {
      return this.persistenceProvider.getAdvertisementDismissed(name);
    }
    */
    slideChanged() {
        const slideIndex = this.slides && this.slides.getActiveIndex();
        const activeAd = this.advertisements[slideIndex] || { linkParams: {} };
        const cardConfig = activeAd.linkParams && activeAd.linkParams.cardConfig;
        cardConfig && this.logPresentedWithGiftCardPromoEvent(cardConfig);
    }
    doRefresh(refresher) {
        // TODO FIX: Review this comments
        // this.loadAds();
        // this.fetchAdvertisements();
        this.preFetchWallets();
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
    removeServerMessage(id) {
        this.serverMessages = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.serverMessages, s => s.id !== id);
    }
    dismissServerMessage(serverMessage) {
        this.showServerMessage = false;
        this.logger.debug(`Server message id: ${serverMessage.id} dismissed`);
        this.persistenceProvider.setServerMessageDismissed(serverMessage.id);
        this.removeServerMessage(serverMessage.id);
    }
    dismissNewReleaseMessage() {
        this.newReleaseAvailable = false;
        this.logger.debug(`New release message dismissed. version: ${this.newReleaseVersion}`);
        this.persistenceProvider.setNewReleaseMessageDismissed(this.newReleaseVersion);
    }
    checkServerMessage(serverMessage) {
        if (serverMessage.app && serverMessage.app != this.appProvider.info.name) {
            this.removeServerMessage(serverMessage.id);
            return;
        }
        this.persistenceProvider
            .getServerMessageDismissed(serverMessage.id)
            .then((value) => {
            if (value === 'dismissed') {
                this.removeServerMessage(serverMessage.id);
                return;
            }
            this.showServerMessage = true;
        });
    }
    openServerMessageLink(url) {
        this.externalLinkProvider.open(url);
    }
    // TODO FIX: Review this comments
    /*
    private fetchAdvertisements(): void {
      this.advertisements.forEach(advertisement => {
        this.logger.debug('Add advertisement: ', advertisement.name);
        if (
          advertisement.app &&
          advertisement.app != this.appProvider.info.name
        ) {
          this.removeAdvertisement(advertisement.name);
          this.logger.debug('Removed advertisement: ', advertisement.name);
          return;
        }
        this.persistenceProvider
          .getAdvertisementDismissed(advertisement.name)
          .then((value: string) => {
            if (
              value === 'dismissed' ||
              (!this.showCoinbase && advertisement.name == 'coinbase')
            ) {
              this.removeAdvertisement(advertisement.name);
              this.logger.debug('Removed advertisement: ', advertisement.name);
              return;
            }
          });
      });
    }
    */
    logPresentedWithGiftCardPromoEvent(promotedCard) {
        this.giftCardProvider.logEvent('presentedWithGiftCardPromo', this.giftCardProvider.getPromoEventParams(promotedCard, 'Home Tab Advertisement'));
    }
    dismissAdvertisement(advertisement) {
        this.logger.debug(`Advertisement: ${advertisement.name} dismissed`);
        this.persistenceProvider.setAdvertisementDismissed(advertisement.name);
        this.removeAdvertisement(advertisement.name);
    }
    removeAdvertisement(name) {
        if (this.testingAdsEnabled) {
            this.testingAds = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.testingAds, adv => adv.name !== name);
        }
        else {
            this.advertisements = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.advertisements, adv => adv.name !== name);
            if (this.advertisements.length == 0)
                this.showAdvertisements = false;
        }
        if (this.slides)
            this.slides.slideTo(0, 500);
    }
    goTo(page, params = {}) {
        if (typeof page === 'string' && page.indexOf('https://') === 0) {
            this.externalLinkProvider.open(page);
        }
        else {
            this.navCtrl.push(page, params);
        }
        // TODO FIX: Review this comments
        /*
        if (page === BuyCardPage) {
          this.giftCardProvider.logEvent(
            'clickedGiftCardPromo',
            this.giftCardProvider.getPromoEventParams(
              params.cardConfig,
              'Home Tab Advertisement'
            )
          );
        }
        */
    }
    // TODO FIX: Review this comments
    /*
    public goToShop() {
      this.navCtrl.push(CardCatalogPage);
    }
    */
    goToAmountPage() {
        this.analyticsProvider.logEvent('buy_crypto_button_clicked', {
            from: 'homePage'
        });
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__send_amount_amount__["a" /* AmountPage */], {
            fromBuyCrypto: true,
            nextPage: 'CryptoOrderSummaryPage',
            currency: this.configProvider.get().wallet.settings.alternativeIsoCode
        });
    }
    // TODO FIX: Review this comments
    /*
    public goToExchangeCryptoPage() {
      this.analyticsProvider.logEvent('exchange_crypto_button_clicked', {
        from: 'homePage'
      });
      this.navCtrl.push(ExchangeCryptoPage, {
        currency: this.configProvider.get().wallet.settings.alternativeIsoCode
      });
    }
    */
    checkNewRelease() {
        this.persistenceProvider
            .getNewReleaseMessageDismissed()
            .then(dismissedVersion => {
            this.releaseProvider.getLatestAppVersion().then((data) => {
                if (data && data.version === dismissedVersion)
                    return;
                this.newReleaseVersion = data.version;
                this.newReleaseAvailable = this.releaseProvider.newReleaseAvailable(data.version);
            });
        });
    }
    checkFeedbackInfo() {
        this.persistenceProvider.getFeedbackInfo().then(info => {
            if (!info) {
                this.initFeedBackInfo();
            }
            else {
                const feedbackInfo = info;
                // Check if current version is greater than saved version
                const currentVersion = this.appProvider.info.version;
                const savedVersion = feedbackInfo.version;
                const isVersionUpdated = this.feedbackProvider.isVersionUpdated(currentVersion, savedVersion);
                if (!isVersionUpdated) {
                    this.initFeedBackInfo();
                    return;
                }
                const now = __WEBPACK_IMPORTED_MODULE_5_moment__().unix();
                const timeExceeded = now - feedbackInfo.time >= 24 * 7 * 60 * 60;
                this.showRateCard = timeExceeded && !feedbackInfo.sent;
                /* TODO FIX: unneeded...
                 this.showCard.setShowRateCard(this.showRateCard);
                this.showCard.setShowSurveyCard(
                  timeExceeded && !feedbackInfo.surveyTaken
                );
                */
            }
        });
    }
    initFeedBackInfo() {
        this.persistenceProvider.setFeedbackInfo({
            time: __WEBPACK_IMPORTED_MODULE_5_moment__().unix(),
            version: this.appProvider.info.version,
            sent: false
        });
        this.showRateCard = false;
    }
    // TODO FIX: Review this comments
    /*
    public openCountryBannedLink(): void {
      const url =
        "https://github.com/tkcoin/copay/wiki/Why-can't-I-use-TKCoin's-services-in-my-country%3F";
      this.externalLinkProvider.open(url);
    }
    */
    toggleTestnet() {
        this.tapped++;
        if (this.tapped >= 10) {
            this.persistenceProvider
                .getNetwork()
                .then((currentNetwork) => {
                const newNetwork = !currentNetwork || currentNetwork === __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["a" /* Network */].livenet
                    ? __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["a" /* Network */].testnet
                    : __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["a" /* Network */].livenet;
                this.persistenceProvider.setNetwork(newNetwork);
                const infoSheet = this.actionSheetProvider.createInfoSheet('in-app-notification', {
                    title: 'Network Changed',
                    body: `Network changed to ${newNetwork}. Restarting app.`
                });
                infoSheet.present();
                infoSheet.onDidDismiss(() => {
                    window.location.reload();
                    // TOD FIX NOT show splash screen for iOS issues
                    // if (this.platformProvider.isCordova) this.splashScreen.show();
                });
                this.tapped = 0;
            });
        }
    }
    // TODO FIX: Review this comments
    /*
    private openAddFunds(): void {
      const wallets = this.profileProvider.getWallets();
      const modal = this.modalCtrl.create(AddFundsPage, {
        keyId: wallets[0].credentials.keyId
      });
      modal.present().then(() => {
        this.persistenceProvider.setOnboardingFlowFlag('disabled');
      });
    }
    */
    // TODO FIX: Review this comments
    /*
    private showInfoSheet(altCurrency): void {
      const infoSheet = this.actionSheetProvider.createInfoSheet(
        'unsupported-alt-currency',
        altCurrency
      );
      infoSheet.present();
      infoSheet.onDidDismiss(option => {
        if (option) {
          const settingsTabIndex = this.navCtrl.parent._tabs.length - 1; // The index of SettingsPage tab depends on the platform and distribution
          this.navCtrl.parent.select(settingsTabIndex);
          this.navCtrl.push(AltCurrencyPage);
        }
      });
    }
    */
    openEmailDisclaimer() {
        const message = this.translate.instant('By providing your email address, you give explicit consent to TKCoin to use your email address to send you email notifications about payments.');
        const title = this.translate.instant('Privacy Notice update');
        const okText = this.translate.instant('Accept');
        const cancelText = this.translate.instant('Disable notifications');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (ok) {
                // Accept new Privacy Notice
                this.persistenceProvider.setEmailLawCompliance('accepted');
            }
            else {
                // Disable email notifications
                this.persistenceProvider.setEmailLawCompliance('rejected');
                this.emailProvider.updateEmail({
                    enabled: false,
                    email: 'null@email'
                });
            }
        });
    }
    checkEmailLawCompliance() {
        setTimeout(() => {
            if (this.emailProvider.getEmailIfEnabled()) {
                this.persistenceProvider.getEmailLawCompliance().then(value => {
                    if (!value)
                        this.openEmailDisclaimer();
                });
            }
        }, 2000);
    }
    openQuieroEDU() {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('I want some EDU!');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        let url = 'https://tkcoin.org/quieroedu';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openQuieroTIK() {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('I want to mine TIK!');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        let url = 'https://tkcoin.org/quierotik';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('showCard'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], HomePage.prototype, "showCard", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Slides */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Slides */])
], HomePage.prototype, "slides", void 0);
HomePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-home',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/home/home.html"*/'<ion-header class="bp-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Home\' | translate }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea>\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160" enabled="true">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n    <ion-toolbar class="wide-header__title" (click)="toggleTestnet()" tappable>\n      <expandable-header-primary>\n        {{ \'Home\' | translate }}\n      </expandable-header-primary>\n    </ion-toolbar>\n  </expandable-header>\n  \n  <div class="message-background" *ngIf="accessDenied">\n    <div class="message-header no-dismissible"></div>\n    <div class="message-content">\n      <ion-row align-items-center>\n        <div class="message-icon"><img src="assets/img/icon-danger.svg" /></div>\n        <div class="message-title message-title-critical">\n          {{ \'Access denied\' | translate }}\n        </div>\n      </ion-row>\n      <div class="message-body">\n        Unfortunately, your country/region has banned the use or acceptance of\n        cryptocurrencies as a valid form of payment and we are therefore unable\n        to service you.\n      </div>\n      <!-- <div>\n        <div class="line-divider"></div>\n        <span class="message-button" (click)="openCountryBannedLink()" translate>Learn more</span>\n      </div> -->\n    </div>\n  </div>\n  <!--\n  <div class="message-background" *ngIf="newReleaseAvailable">\n    <div class="message-header">\n      <ion-row justify-content-end>\n        <button float-right ion-button clear icon-only color="grey" (click)="dismissNewReleaseMessage()">\n          <ion-icon name="close"></ion-icon>\n        </button>\n      </ion-row>\n    </div>\n    <div class="message-content">\n      <ion-row align-items-center>\n        <div class="message-icon"><img src="assets/img/icon-update.svg" /></div>\n        <div class="message-title">\n          {{ \'There is a new version available\' | translate }}\n        </div>\n      </ion-row>\n      <div class="message-body" translate>\n        An update to this app is available.\n      </div>\n    </div>\n  </div>\n  <div class="message-background" *ngIf="showServerMessage && serverMessages && serverMessages[0]">\n    <div class="message-header" [ngClass]="{\'no-dismissible\': !serverMessages[0].dismissible}">\n      <ion-row *ngIf="serverMessages[0].dismissible" justify-content-end>\n        <button float-right ion-button clear icon-only color="grey" (click)="dismissServerMessage(serverMessages[0])">\n          <ion-icon name="close"></ion-icon>\n        </button>\n      </ion-row>\n    </div>\n    <div class="message-content">\n      <ion-row align-items-center>\n        <div class="message-icon">\n          <img *ngIf="!serverMessages[0].category || serverMessages[0].category === \'info\'" src="assets/img/icon-info-blue.svg" />\n          <img *ngIf="serverMessages[0].category === \'critical\'" src="assets/img/icon-danger.svg" />\n        </div>\n        <div class="message-title" *ngIf="serverMessages[0].title" [ngClass]="{\n            \'message-title-info\': !serverMessages[0].category || serverMessages[0].category == \'info\',\n            \'message-title-critical\': serverMessages[0].category == \'critical\'\n          }">\n          {{ serverMessages[0].title }}\n        </div>\n      </ion-row>\n      <div class="message-body" *ngIf="serverMessages[0].body">\n        {{ serverMessages[0].body }}\n      </div>\n\n      <div *ngIf="serverMessages[0].link" (click)="openServerMessageLink(serverMessages[0].link)">\n        <div class="line-divider"></div>\n        <span class="message-button" *ngIf="serverMessages[0].linkText">{{ serverMessages[0].linkText }}</span>\n        <span class="message-button" translate *ngIf="!serverMessages[0].linkText">Learn more</span>\n      </div>\n    </div>\n  </div>\n  -->\n  <!--<page-feedback-card #showCard></page-feedback-card>-->\n\n  <div *ngIf="showTotalBalance" class="total-amount-container">\n    <div class="section-header" translate>Total cash value</div>\n    <div class="total-amount-value">\n      <span *ngIf="totalBalanceAlternative">\n        {{totalBalanceAlternative | number:\'1.2-2\'}} {{totalBalanceAlternativeIsoCode}}\n      </span>\n      <span *ngIf="fetchingStatus">\n        <ion-spinner></ion-spinner>\n      </span>\n    </div>\n    <!--\n    <div class="average-container">\n      <div *ngIf="totalBalanceChange || totalBalanceChange === 0" [ngClass]="totalBalanceChange >= 0 ? \'possitive-avg\' : \'negative-avg\'">\n        <span class="average"><span *ngIf="totalBalanceChange > 0">+</span>{{ totalBalanceChange | number: \'1.2-2\' }}%</span>\n      </div>\n      <span *ngIf="totalBalanceChange || totalBalanceChange === 0" class="date" translate>Last day</span>\n    </div>\n    -->\n  </div>\n  <!-- TODO FIX REMOVE UNNEEDED BUTTONS\n  <ion-list margin-bottom class="bp-list">\n    <button ion-item *ngIf="showShoppingOption" (click)="goToShop()">\n      <ion-label>\n        <div class="services-list-label" translate>Shop</div>\n      </ion-label>\n    </button>\n    <div *ngIf="showShoppingOption" class="line-divider"></div>\n    <button ion-item *ngIf="showBuyCryptoOption" (click)="goToAmountPage()">\n      <ion-label>\n        <div class="services-list-label" translate>Buy Crypto</div>\n      </ion-label>\n    </button>\n    <div class="line-divider" *ngIf="showBuyCryptoOption"></div>\n    <button ion-item *ngIf="showExchangeCryptoOption" (click)="goToExchangeCryptoPage()">\n      <ion-label>\n        <div class="services-list-label" translate>Exchange Crypto</div>\n      </ion-label>\n    </button>\n    <div class="line-divider" *ngIf="showExchangeCryptoOption"></div>\n  </ion-list>\n\n  <ion-slides *ngIf="showAdvertisements && advertisements && advertisements[0] && !testingAdsEnabled" pager="true" (ionSlideDidChange)="slideChanged()">\n    <ion-slide *ngFor="let advertisement of advertisements">\n      <div class="message-background no-margin">\n        <div class="message-header" *ngIf="advertisement.dismissible">\n          <ion-row justify-content-end>\n            <button float-right ion-button clear icon-only color="grey" (click)="dismissAdvertisement(advertisement)">\n              <ion-icon name="close"></ion-icon>\n            </button>\n          </ion-row>\n        </div>\n        <div class="message-content">\n          <ion-row align-items-center>\n            <ion-col align-self-start col-4>\n              <div class="message-img">\n                <img [ngClass]="{\'card-img\': advertisement.imgSrc === \'assets/img/tkcoin-card/tkcoin-card-mc-angled-plain.svg\'}" src="{{advertisement.imgSrc}}" />\n              </div>\n            </ion-col>\n            <ion-col col-8>\n              <div class="message-title message-title-adv" *ngIf="advertisement.title">\n                {{ advertisement.title }}\n              </div>\n              <div class="message-body message-body-adv" *ngIf="advertisement.body">\n                {{ advertisement.body }}\n              </div>\n            </ion-col>\n          </ion-row>\n          <div *ngIf="advertisement.link" (click)="goTo(advertisement.link, advertisement.linkParams)">\n            <div class="line-divider"></div>\n            <span class="message-button" *ngIf="advertisement.linkText">{{advertisement.linkText}}</span>\n          </div>\n        </div>\n      </div>\n    </ion-slide>\n  </ion-slides>\n\n  <ion-slides *ngIf="showAdvertisements && testingAds && testingAds[0] && testingAdsEnabled" pager="true" (ionSlideDidChange)="slideChanged()">\n    <ion-slide *ngFor="let advertisement of testingAds">\n      <div class="message-background no-margin">\n        <div class="message-header" *ngIf="advertisement.dismissible">\n          <ion-row justify-content-end>\n            <button float-right ion-button clear icon-only color="grey" (click)="dismissAdvertisement(advertisement)">\n              <ion-icon name="close"></ion-icon>\n            </button>\n          </ion-row>\n        </div>\n        <div class="message-content">\n          <ion-row align-items-center>\n            <ion-col align-self-start col-4>\n              <div class="message-img">\n                <img [ngClass]="{\'card-img\': advertisement.imgSrc === \'assets/img/tkcoin-card/tkcoin-card-visa.svg\'}" src="{{advertisement.imgSrc}}" />\n              </div>\n            </ion-col>\n            <ion-col col-8>\n              <div class="message-title message-title-adv" *ngIf="advertisement.title">\n                {{ advertisement.title }}\n              </div>\n              <div class="message-body message-body-adv" *ngIf="advertisement.body">\n                {{ advertisement.body }}\n              </div>\n            </ion-col>\n          </ion-row>\n          <div *ngIf="advertisement.link" (click)="goTo(advertisement.link, advertisement.linkParams)">\n            <div class="line-divider"></div>\n            <span class="message-button" *ngIf="advertisement.linkText">{{advertisement.linkText}}</span>\n          </div>\n        </div>\n      </div>\n    </ion-slide>\n  </ion-slides>\n  <div class="section-header">\n    <div translate>Exchange Rates</div>\n    <div translate class="date-label">1D</div>\n  </div>\n  <exchange-rates #exchangeRates></exchange-rates>\n  -->\n    <div class="section-header">\n      <div translate>Please remember</div>\n    </div>\n    <ion-content>\n      <div class="description-container">\n        <div class="title-icon larger-icon">\n          <img src="assets/img/onboarding/feature-education-2.svg">\n        </div>\n        <div>\n          <h3 class="title" translate>EDUCoin, the educational cryptocurrency</h3>\n          <div class="text" translate>\n            EDUCoin is NOT FOR SALE, it\'s free, nobody must sell it and you\'ll never have to pay for it! You can get some EDU by clicking on the button below\n          </div>\n          <ion-row justify-content-center class="background-button-content">\n            <div class="background-content">\n              <button ion-button clear (click)="openQuieroEDU()">\n                {{\'I want some EDU!\' | translate}}\n              </button>\n            </div>\n          </ion-row>\n          <ion-row justify-content-center class="background-button-content">\n            <div class="background-content">\n              <button ion-button clear (click)="openQuieroTIK()">\n                {{\'I want to mine TIK!\' | translate}}\n              </button>\n            </div>\n          </ion-row>\n        </div>\n      </div>\n    </ion-content>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/home/home.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers__["_2" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["f" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["E" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["L" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["H" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["M" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_9" /* ReleaseProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_3" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_5" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["Z" /* NewFeatureData */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["B" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_4" /* PopupProvider */]])
], HomePage);

// TODO FIX: Review this comments
/*
function getGiftCardAdvertisementName(discountedCard: CardConfig): string {
  return `${discountedCard.discounts[0].code}-${discountedCard.name}-gift-card-discount`;
}
*/ 
//# sourceMappingURL=home.js.map

/***/ }),

/***/ 977:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CountrySelectorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_tkcoin_tkcoin__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);



// Providers




let CountrySelectorPage = class CountrySelectorPage {
    constructor(logger, viewCtrl, persistenceProvider, navParams, bitPayProvider) {
        this.logger = logger;
        this.viewCtrl = viewCtrl;
        this.persistenceProvider = persistenceProvider;
        this.navParams = navParams;
        this.bitPayProvider = bitPayProvider;
        this.PAGE_COUNTER = 3;
        this.SHOW_LIMIT = 10;
        this.completeCountryList = [];
        this.countryList = [];
        this.commonCountriesList = [
            {
                name: 'United States',
                phonePrefix: '+1',
                shortCode: 'US',
                threeLetterCode: 'USA'
            }
        ];
        this.persistenceProvider.getLastCountryUsed().then(lastUsedCountry => {
            if (lastUsedCountry &&
                __WEBPACK_IMPORTED_MODULE_6_lodash__["isObject"](lastUsedCountry) &&
                lastUsedCountry.threeLetterCode != 'USA') {
                this.commonCountriesList.unshift(lastUsedCountry);
            }
        });
        this.EUCountries = [
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IS',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'NO',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE',
            'CH',
            'GB' // United Kingdom (Great Britain)
        ];
        this.completeCountryList = this.navParams.data.countryList;
        this.setEUCountries();
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CountrySelectorPage');
    }
    ionViewWillEnter() {
        this.useAsModal = this.navParams.data.useAsModal;
        if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](this.completeCountryList)) {
            this.bitPayProvider.get('/countries', ({ data }) => {
                this.persistenceProvider.setCountries(data);
                this.completeCountryList = data;
                this.setEUCountries();
                this.countryList = this.completeCountryList.slice(0, 20);
            }, () => { });
        }
        else {
            this.countryList = this.completeCountryList.slice(0, 20);
        }
    }
    loadCountries(loading) {
        if (this.countryList.length === this.completeCountryList.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.countryList = this.completeCountryList.slice(0, this.PAGE_COUNTER * this.SHOW_LIMIT);
            this.PAGE_COUNTER++;
            if (this.searchedCountry)
                this.findCountry();
            loading.complete();
        }, 300);
    }
    save(selectedCountry) {
        this.persistenceProvider.setLastCountryUsed(selectedCountry);
        this.viewCtrl.dismiss({ selectedCountry });
    }
    findCountry() {
        this.countryList = __WEBPACK_IMPORTED_MODULE_6_lodash__["filter"](this.completeCountryList, item => {
            var val = item.name;
            var val2 = item.threeLetterCode;
            return (__WEBPACK_IMPORTED_MODULE_6_lodash__["includes"](val.toLowerCase(), this.searchedCountry.toLowerCase()) ||
                __WEBPACK_IMPORTED_MODULE_6_lodash__["includes"](val2.toLowerCase(), this.searchedCountry.toLowerCase()));
        });
    }
    setEUCountries() {
        this.completeCountryList.forEach(country => {
            if (country.shortCode && this.EUCountries.includes(country.shortCode)) {
                country.EUCountry = true;
            }
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
CountrySelectorPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-country-selector',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/country-selector/country-selector.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-buttons left *ngIf="useAsModal">\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Country selector\' | translate }}\n      </div>\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n    <ion-toolbar class="wide-header__title">\n      <expandable-header-primary>\n        {{ \'Country selector\' | translate }}\n      </expandable-header-primary>\n    </ion-toolbar>\n  </expandable-header>\n\n  <ion-item class="search-container" no-lines padding>\n    <ion-input class="search-wrapper" placeholder="{{\'Search country\' | translate}}" [(ngModel)]="searchedCountry" (ngModelChange)="findCountry()"></ion-input>\n  </ion-item>\n  <ion-list class="bp-list">\n    <ion-item *ngFor="let country of commonCountriesList" (click)="save(country)">\n      {{ country.name }}\n      <span class="country" item-end>{{country.threeLetterCode}}</span>\n    </ion-item>\n  </ion-list>\n  <div class="line-divider"></div>\n  <div *ngIf="countryList[0] && commonCountriesList[0]" padding></div>\n  <ion-list class="bp-list">\n    <ion-item *ngFor="let country of countryList" (click)="save(country)">\n      {{ country.name }}\n      <ion-note item-end>\n        <ion-row align-items-center>\n          <ion-note item-end>{{country.threeLetterCode}}</ion-note>\n          <ion-icon item-end name="ios-arrow-forward-outline" color="light-grey"></ion-icon>\n        </ion-row>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-spinner class="loading" *ngIf="!countryList[0]" name="crescent"></ion-spinner>\n\n  <ion-infinite-scroll (ionInfinite)="loadCountries($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/country-selector/country-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_tkcoin_tkcoin__["a" /* TKCoinProvider */]])
], CountrySelectorPage);

//# sourceMappingURL=country-selector.js.map

/***/ }),

/***/ 978:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CryptoCoinSelectorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__environments__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_add_select_currency_select_currency__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pages_onboarding_recovery_key_recovery_key__ = __webpack_require__(390);






// Providers

// Pages


let CryptoCoinSelectorPage = class CryptoCoinSelectorPage {
    constructor(actionSheetProvider, buyCryptoProvider, logger, navCtrl, viewCtrl, profileProvider, currencyProvider, translate, errorsProvider, navParams) {
        this.actionSheetProvider = actionSheetProvider;
        this.buyCryptoProvider = buyCryptoProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.viewCtrl = viewCtrl;
        this.profileProvider = profileProvider;
        this.currencyProvider = currencyProvider;
        this.translate = translate;
        this.errorsProvider = errorsProvider;
        this.navParams = navParams;
        this.coins = [];
        // TODO: We temporarily remove Wyre from European Union countries. When the Simplex promotion ends we have to remove this condition
        const supportedCoins = this.navParams.data.isPromotionActiveForCountry
            ? this.buyCryptoProvider.getExchangeCoinsSupported('simplex')
            : this.buyCryptoProvider.getExchangeCoinsSupported();
        this.wallets = this.profileProvider.getWallets({
            network: __WEBPACK_IMPORTED_MODULE_5__environments__["a" /* default */].name == 'development' ? null : 'livenet',
            onlyComplete: true,
            coin: supportedCoins,
            backedUp: true
        });
        for (const coin of supportedCoins) {
            const c = {
                unitCode: coin,
                name: this.currencyProvider.getCoinName(coin),
                availableWallets: __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.wallets, w => w.coin === coin)
            };
            this.coins.push(c);
        }
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CryptoCoinSelectorPage');
    }
    ionViewWillEnter() {
        this.useAsModal = this.navParams.data.useAsModal;
        if (this.navParams.data.coin) {
            const coin = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.coins, ['unitCode', this.navParams.data.coin]);
            this.showWallets(coin);
        }
    }
    showWallets(coin) {
        const wallets = coin.availableWallets;
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallets)) {
            this.errorsProvider.showNoWalletError(coin.unitCode.toUpperCase(), option => {
                if (option) {
                    this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__pages_add_select_currency_select_currency__["a" /* SelectCurrencyPage */]);
                }
            });
        }
        else {
            const params = {
                wallets,
                selectedWalletId: null,
                title: this.translate.instant('Select wallet to deposit to')
            };
            const walletSelector = this.actionSheetProvider.createWalletSelector(params);
            walletSelector.present();
            walletSelector.onDidDismiss(wallet => {
                if (wallet && wallet.needsBackup) {
                    const infoSheet = this.actionSheetProvider.createInfoSheet('key-verification-required');
                    infoSheet.present();
                    infoSheet.onDidDismiss(option => {
                        if (option) {
                            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__pages_onboarding_recovery_key_recovery_key__["a" /* RecoveryKeyPage */], {
                                keyId: wallet.keyId
                            });
                        }
                    });
                }
                else {
                    this.onWalletSelect(wallet);
                }
            });
        }
    }
    onWalletSelect(wallet) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet)) {
            this.wallet = wallet;
            this.save();
        }
    }
    close() {
        this.viewCtrl.dismiss();
    }
    save() {
        this.viewCtrl.dismiss({ coin: this.wallet.coin, walletId: this.wallet.id });
    }
};
CryptoCoinSelectorPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-crypto-coin-selector',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-coin-selector/crypto-coin-selector.html"*/'<wide-header-page title="{{\'Select Coin\' | translate}}">\n  <ion-buttons left *ngIf="useAsModal">\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <div *ngFor="let coin of coins">\n        <button ion-item (click)="showWallets(coin)">\n          <ion-icon class="item-img" item-start>\n            <img src="assets/img/currencies/{{coin.unitCode}}.svg">\n          </ion-icon>\n          <ion-label>\n            <div class="main-label">{{coin.name}}</div>\n          </ion-label>\n          <ion-note item-end *ngIf="coin.availableWallets.length > 0">\n            <div class="available-wallets-container">\n              <span class="available-wallets-label">{{coin.availableWallets.length}} Wallet<span *ngIf="coin.availableWallets.length > 1">s</span></span>\n            </div>\n          </ion-note>\n        </button>\n        <div class="line-divider"></div>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-coin-selector/crypto-coin-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["j" /* BuyCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_5" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["t" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["C" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */]])
], CryptoCoinSelectorPage);

//# sourceMappingURL=crypto-coin-selector.js.map

/***/ }),

/***/ 979:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CryptoOffersPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_buy_crypto_buy_crypto__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_simplex_simplex__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_wyre_wyre__ = __webpack_require__(289);





// Providers














let CryptoOffersPage = class CryptoOffersPage {
    constructor(analyticsProvider, appProvider, buyCryptoProvider, logger, onGoingProcessProvider, navParams, simplexProvider, navCtrl, profileProvider, currencyProvider, configProvider, walletProvider, wyreProvider, externalLinkProvider, translate, popupProvider, themeProvider) {
        this.analyticsProvider = analyticsProvider;
        this.appProvider = appProvider;
        this.buyCryptoProvider = buyCryptoProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.navParams = navParams;
        this.simplexProvider = simplexProvider;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.currencyProvider = currencyProvider;
        this.configProvider = configProvider;
        this.walletProvider = walletProvider;
        this.wyreProvider = wyreProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.themeProvider = themeProvider;
        this.offers = {
            simplex: {
                amountReceiving: '0',
                showOffer: false,
                logoLight: 'assets/img/simplex/logo-simplex-color.svg',
                logoDark: 'assets/img/simplex/logo-simplex-dm.png',
                expanded: false
            },
            wyre: {
                amountReceiving: '0',
                showOffer: false,
                logoLight: 'assets/img/wyre/logo-wyre.svg',
                logoDark: 'assets/img/wyre/logo-wyre-dm.svg',
                expanded: false
            }
        };
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.paymentMethod = this.navParams.data.paymentMethod;
        this.selectedCountry = this.navParams.data.selectedCountry;
        this.coin = this.navParams.data.coin;
        const coinColor = this.currencyProvider.getTheme(this.coin).coinColor || '#e6f8e9';
        this.coinBorderColor = `2px solid ${coinColor}`;
        this.walletId = this.navParams.data.walletId;
        this.wallet = this.profileProvider.getWallet(this.walletId);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CryptoOffersPage');
    }
    ionViewWillEnter() {
        this.setFiatCurrency();
        this.offers.simplex.showOffer = this.buyCryptoProvider.isPaymentMethodSupported('simplex', this.paymentMethod, this.coin, this.currency);
        this.offers.wyre.showOffer =
            this.buyCryptoProvider.isPaymentMethodSupported('wyre', this.paymentMethod, this.coin, this.currency) && !this.navParams.data.isPromotionActiveForCountry; // TODO: We temporarily remove Wyre from European Union countries. When the Simplex promotion ends we have to remove this condition
        if (this.offers.simplex.showOffer)
            this.getSimplexQuote();
        if (this.offers.wyre.showOffer)
            this.getWyreQuote();
    }
    // GENERAL FUNCTIONS
    expandCard(offer) {
        const key = offer.key;
        if (!offer.value || !offer.value.fiatMoney)
            return;
        if (this.offers[key]) {
            this.offers[key].expanded = this.offers[key].expanded ? false : true;
        }
    }
    goTo(key) {
        switch (key) {
            case 'simplex':
                this.goToSimplexBuyPage();
                break;
            case 'wyre':
                this.goToWyreBuyPage();
                break;
        }
    }
    setPrefix(address, coin, network) {
        const prefix = this.currencyProvider.getProtocolPrefix(coin, network);
        const addr = `${prefix}:${address}`;
        return addr;
    }
    openPopUpConfirmation(exchange, url) {
        this.onGoingProcessProvider.clear();
        let title, message;
        switch (exchange) {
            case 'simplex':
                title = this.translate.instant('Continue to Simplex');
                message = this.translate.instant("In order to finish the payment process you will be redirected to Simplex's page");
                break;
            case 'wyre':
                title = this.translate.instant('Continue to Wyre');
                message = this.translate.instant("In order to finish the payment process you will be redirected to Wyre's page");
                break;
            default:
                title = this.translate.instant('Continue to the exchange page');
                message = this.translate.instant('In order to finish the payment process you will be redirected to the exchange page');
                break;
        }
        const okText = this.translate.instant('Continue');
        const cancelText = this.translate.instant('Go back');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                switch (exchange) {
                    case 'simplex':
                        this.continueToSimplex();
                        break;
                    case 'wyre':
                        this.continueToWyre(url);
                        break;
                    default:
                        this.externalLinkProvider.open(url);
                        break;
                }
                setTimeout(() => {
                    this.navCtrl.popToRoot();
                }, 2500);
            }
        });
    }
    setFiatCurrency() {
        if (this.currency === this.coin.toUpperCase()) {
            const config = this.configProvider.get();
            this.fiatCurrency = __WEBPACK_IMPORTED_MODULE_4_lodash__["includes"](this.simplexProvider.supportedFiatAltCurrencies, config.wallet.settings.alternativeIsoCode)
                ? config.wallet.settings.alternativeIsoCode
                : 'usd';
        }
        else {
            this.fiatCurrency = this.currency;
        }
    }
    goToEdit() {
        this.navCtrl.pop();
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    // SIMPLEX
    goToSimplexBuyPage() {
        if (this.offers.simplex.errorMsg)
            return;
        this.openPopUpConfirmation('simplex');
    }
    continueToSimplex() {
        this.walletProvider
            .getAddress(this.wallet, false)
            .then(address => {
            const quoteData = {
                quoteId: this.offers.simplex.quoteData.quote_id,
                currency: this.currency,
                fiatTotalAmount: this.offers.simplex.quoteData.fiat_money
                    .total_amount,
                cryptoAmount: this.offers.simplex.quoteData.digital_money.amount
            };
            this.simplexProvider
                .simplexPaymentRequest(this.wallet, address, quoteData)
                .then(req => {
                if (req && req.error && !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](req.error)) {
                    this.showSimplexError(req.error);
                    return;
                }
                this.logger.debug('Simplex creating payment request: SUCCESS');
                const remoteData = {
                    address,
                    api_host: req.api_host,
                    app_provider_id: req.app_provider_id,
                    order_id: req.order_id,
                    payment_id: req.payment_id
                };
                let newData = {
                    address,
                    created_on: Date.now(),
                    crypto_amount: this.offers.simplex.quoteData.digital_money.amount,
                    coin: this.wallet.coin.toUpperCase(),
                    fiat_base_amount: this.offers.simplex.quoteData.fiat_money
                        .base_amount,
                    fiat_total_amount: this.offers.simplex.quoteData.fiat_money
                        .total_amount,
                    fiat_total_amount_currency: this.currency,
                    order_id: req.order_id,
                    payment_id: req.payment_id,
                    status: 'paymentRequestSent',
                    user_id: this.wallet.id
                };
                this.simplexProvider
                    .saveSimplex(newData, null)
                    .then(() => {
                    this.logger.debug('Saved Simplex with status: ' + newData.status);
                    this.analyticsProvider.logEvent('buy_crypto_payment_request', {
                        exchange: 'simplex',
                        userId: this.wallet.id,
                        fiatAmount: this.amount,
                        fiatCurrency: this.currency.toUpperCase(),
                        paymentMethod: this.paymentMethod.method,
                        coin: this.wallet.coin
                    });
                    const paymentUrl = this.simplexProvider.getPaymentUrl(this.wallet, quoteData, remoteData);
                    this.openExternalLink(paymentUrl);
                    setTimeout(() => {
                        this.navCtrl.popToRoot();
                    }, 2500);
                })
                    .catch(err => {
                    this.showSimplexError(err);
                });
            })
                .catch(err => {
                this.showSimplexError(err);
            });
        })
            .catch(err => {
            return this.showSimplexError(err);
        });
    }
    getSimplexQuote() {
        this.logger.debug('Simplex getting quote');
        this.offers.simplex.amountLimits = this.simplexProvider.getFiatCurrencyLimits(this.fiatCurrency, this.coin);
        if (this.amount < this.offers.simplex.amountLimits.min ||
            this.amount > this.offers.simplex.amountLimits.max) {
            this.offers.simplex.errorMsg = `The ${this.fiatCurrency} amount must be between ${this.offers.simplex.amountLimits.min} and ${this.offers.simplex.amountLimits.max}`;
            return;
        }
        else {
            let paymentMethod = [];
            switch (this.paymentMethod.method) {
                case 'sepaBankTransfer':
                    paymentMethod.push('simplex_account');
                    break;
                default:
                    paymentMethod.push('credit_card');
                    break;
            }
            const data = {
                digital_currency: this.wallet.coin.toUpperCase(),
                fiat_currency: this.fiatCurrency,
                requested_currency: this.fiatCurrency,
                requested_amount: this.amount,
                end_user_id: this.walletId,
                payment_methods: paymentMethod
            };
            this.simplexProvider
                .getQuote(this.wallet, data)
                .then(data => {
                if (data && data.quote_id) {
                    this.offers.simplex.quoteData = data;
                    this.offers.simplex.amountCost = data.fiat_money.total_amount;
                    this.offers.simplex.buyAmount = data.fiat_money.base_amount;
                    this.offers.simplex.fee =
                        data.fiat_money.total_amount - data.fiat_money.base_amount;
                    this.offers.simplex.fiatMoney = Number(this.offers.simplex.buyAmount / data.digital_money.amount).toFixed(this.currencyProvider.getPrecision(this.coin).unitDecimals);
                    this.offers.simplex.amountReceiving = data.digital_money.amount.toString();
                    this.logger.debug('Simplex getting quote: SUCCESS');
                }
                else {
                    if (data.message && __WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](data.message)) {
                        this.logger.error('Simplex error: ' + data.message);
                    }
                    if (data.error && __WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](data.error)) {
                        this.logger.error('Simplex error: ' + data.error);
                        if (data.errors) {
                            this.logger.error(data.errors);
                        }
                    }
                    let err = this.translate.instant("Can't get rates at this moment. Please try again later");
                    this.showSimplexError(err);
                }
            })
                .catch(err => {
                this.logger.error('Simplex getting quote: FAILED');
                this.showSimplexError(err);
            });
        }
    }
    showSimplexError(err) {
        this.onGoingProcessProvider.clear();
        let msg = this.translate.instant('Could not get crypto offer. Please, try again later.');
        if (err) {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](err)) {
                msg = err;
            }
            else {
                if (err.error && err.error.error)
                    msg = err.error.error;
                else if (err.message)
                    msg = err.message;
            }
        }
        this.logger.error('Simplex error: ' + msg);
        this.offers.simplex.errorMsg = msg;
    }
    // WYRE
    goToWyreBuyPage() {
        if (this.offers.wyre.errorMsg)
            return;
        this.onGoingProcessProvider.set('processingOrderReservation');
        this.walletProvider
            .getAddress(this.wallet, false)
            .then(address => {
            let paymentMethod;
            switch (this.paymentMethod.method) {
                case 'applePay':
                    paymentMethod = 'apple-pay';
                    break;
                default:
                    paymentMethod = 'debit-card';
                    break;
            }
            const redirectUrl = this.appProvider.info.name +
                '://wyre?walletId=' +
                this.wallet.id +
                '&destAmount=' +
                this.offers.wyre.amountReceiving;
            const failureRedirectUrl = this.appProvider.info.name + '://wyreError';
            const dest = this.setPrefix(address, this.coin, this.wallet.network);
            const data = {
                sourceAmount: this.amount.toString(),
                dest,
                destCurrency: this.coin.toUpperCase(),
                lockFields: ['dest', 'destCurrency', 'country'],
                paymentMethod,
                sourceCurrency: this.currency.toUpperCase(),
                country: this.selectedCountry.shortCode,
                amountIncludeFees: true,
                redirectUrl,
                failureRedirectUrl
            };
            this.wyreProvider
                .walletOrderReservation(this.wallet, data)
                .then(data => {
                if (data &&
                    (data.exceptionId || (data.error && !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](data.error)))) {
                    this.showWyreError(data);
                    return;
                }
                const url = data.url;
                this.openPopUpConfirmation('wyre', url);
            })
                .catch(err => {
                this.showWyreError(err);
            });
        })
            .catch(err => {
            this.showWyreError(err);
        });
    }
    continueToWyre(url) {
        this.analyticsProvider.logEvent('buy_crypto_payment_request', {
            exchange: 'wyre',
            userId: this.wallet.id,
            fiatAmount: this.amount,
            fiatCurrency: this.currency.toUpperCase(),
            paymentMethod: this.paymentMethod.method,
            coin: this.wallet.coin
        });
        this.externalLinkProvider.open(url);
    }
    getWyreQuote() {
        this.logger.debug('Wyre getting quote');
        this.offers.wyre.amountLimits = this.wyreProvider.getFiatCurrencyLimits(this.fiatCurrency, this.coin, this.selectedCountry.shortCode);
        if (this.amount < this.offers.wyre.amountLimits.min ||
            this.amount > this.offers.wyre.amountLimits.max) {
            this.offers.wyre.errorMsg = `The ${this.fiatCurrency} daily amount must be between ${this.offers.wyre.amountLimits.min} and ${this.offers.wyre.amountLimits.max}`;
            return;
        }
        else {
            this.walletProvider
                .getAddress(this.wallet, false)
                .then(address => {
                const dest = this.setPrefix(address, this.coin, this.wallet.network);
                let walletType;
                switch (this.paymentMethod.method) {
                    case 'applePay':
                        walletType = 'APPLE_PAY';
                        break;
                    default:
                        walletType = 'DEBIT_CARD';
                        break;
                }
                const data = {
                    sourceAmount: this.amount.toString(),
                    sourceCurrency: this.currency.toUpperCase(),
                    destCurrency: this.coin.toUpperCase(),
                    dest,
                    country: this.selectedCountry.shortCode,
                    amountIncludeFees: true,
                    walletType
                };
                this.wyreProvider
                    .walletOrderQuotation(this.wallet, data)
                    .then((data) => {
                    if (data &&
                        (data.exceptionId || (data.error && !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](data.error)))) {
                        this.showWyreError(data);
                        return;
                    }
                    this.offers.wyre.amountCost = data.sourceAmount; // sourceAmount = Total amount (including fees)
                    this.offers.wyre.buyAmount = data.sourceAmountWithoutFees;
                    this.offers.wyre.fee =
                        data.sourceAmount - data.sourceAmountWithoutFees;
                    if (this.offers.wyre.fee < 0) {
                        const err = this.translate.instant(`Wyre has returned a wrong value for the fee. Fee: ${this.offers.wyre.fee}`);
                        this.showWyreError(err);
                        return;
                    }
                    this.offers.wyre.fiatMoney = Number(this.offers.wyre.buyAmount / data.destAmount).toFixed(8);
                    this.offers.wyre.amountReceiving = data.destAmount.toFixed(8);
                    this.logger.debug('Wyre getting quote: SUCCESS');
                })
                    .catch(err => {
                    this.logger.error('Wyre getting quote: FAILED');
                    this.showWyreError(err);
                });
            })
                .catch(err => {
                this.showWyreError(err);
            });
        }
    }
    showWyreError(err) {
        this.onGoingProcessProvider.clear();
        let msg = this.translate.instant('Could not get crypto offer. Please, try again later.');
        if (err) {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](err)) {
                msg = err;
            }
            else if (err.exceptionId && err.message) {
                this.logger.error('Wyre error: ' + err.message);
                if (err.errorCode) {
                    switch (err.errorCode) {
                        case 'validation.unsupportedCountry':
                            msg =
                                this.translate.instant('Country not supported: ') +
                                    this.selectedCountry.name;
                            break;
                        default:
                            msg = err.message;
                            break;
                    }
                }
                else
                    msg = err.message;
            }
        }
        this.logger.error('Crypto offer error: ' + msg);
        this.offers.wyre.errorMsg = msg;
    }
};
CryptoOffersPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-crypto-offers',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-offers/crypto-offers.html"*/'<wide-header-page title="{{\'Offers\' | translate}}">\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item>\n        <ion-row>\n          <ion-col>\n            <div class="summary-title" translate>Amount</div>\n            <div class="summary-description"><span *ngIf="currency === \'USD\'">$</span>{{amount}} <span *ngIf="currency !== \'USD\'">{{currency}}</span></div>\n          </ion-col>\n          <ion-col>\n            <div class="summary-title" translate>Crypto</div>\n            <div class="summary-description"><img class="coin-icon" src="assets/img/currencies/{{coin}}.svg" /> {{coin | uppercase}}</div>\n          </ion-col>\n          <ion-col col-4>\n            <div class="summary-title" translate>Payment Method</div>\n            <div class="summary-description">{{paymentMethod?.label}}</div>\n          </ion-col>\n          <ion-col align-self-center>\n            <div class="edit-container" (click)="goToEdit()">\n              <div class="edit-label" translate>\n                Edit\n              </div>\n            </div>\n          </ion-col>\n        </ion-row>\n      </ion-item>\n    </ion-list>\n\n    <div class="card-container" *ngFor="let offer of (offers | keys) | orderBy : [\'-amountReceiving\']">\n      <div translate class="offer-btn" *ngIf="offer.value.fiatMoney" (click)="goTo(offer.key)">\n        Buy\n      </div>\n      <div class="offer-card" (click)="expandCard(offer)" tappable *ngIf="offer.value.showOffer">\n        <div class="content" *ngIf="!offer.value.fiatMoney && !offer.value.errorMsg" class="loader">\n          <ion-spinner></ion-spinner>\n        </div>\n        <div class="content" translate *ngIf="offer.value.fiatMoney || offer.value.errorMsg">\n          <div *ngIf="offer.value.errorMsg">\n            <div class="main-label error-label">\n              <span class="error-title">Error: </span>\n              <span class="error-msg">\n                {{offer.value.errorMsg}}\n              </span>\n            </div>\n          </div>\n\n          <div class="visible-container">\n            <div class="visible-info">\n              <div *ngIf="offer.value.fiatMoney && !offer.value.errorMsg">\n                <div class="main-label">{{offer.value.amountReceiving }} {{coin | uppercase}}</div>\n                <div class="secondary-label">1 {{coin | uppercase}} = <span *ngIf="fiatCurrency?.toUpperCase() === \'USD\'">$</span>{{offer.value.fiatMoney | number:\'1.2-2\'}} <span *ngIf="fiatCurrency?.toUpperCase() !== \'USD\'">{{fiatCurrency}}</span></div>\n              </div>\n              <div class="provider">\n                <span translate class="secondary-label">Provided by</span>\n                <img [src]="themeProvider.currentAppTheme !== \'dark\' ? offer.value.logoLight : offer.value.logoDark">\n              </div>\n            </div>\n          </div>\n          <div class="extended-info" [ngClass]="{\'expanded\': offer.value.expanded}">\n            <ion-list class="bp-list">\n              <ion-item>\n                <ion-label>\n                  <div class="summary-item">\n                    <span>{{"Buy Amount" | translate}}</span>\n                  </div>\n                </ion-label>\n                <ion-note item-end>\n                  <div class="summary-item-detail">\n                    <span>\n                      <span *ngIf="fiatCurrency?.toUpperCase() === \'USD\'">$</span>{{ offer.value.buyAmount | number : \'1.2-2\' }} <span *ngIf="fiatCurrency?.toUpperCase() !== \'USD\'">{{fiatCurrency}}</span>\n                    </span>\n                  </div>\n                </ion-note>\n              </ion-item>\n              <div class="summary-item-detail-sec">\n                <span>{{ offer.value.amountReceiving }} {{coin | uppercase}}</span>\n              </div>\n              <ion-item>\n                <ion-label>\n                  <div class="summary-item">\n                    <span>{{"Fee" | translate}}</span>\n                  </div>\n                </ion-label>\n                <ion-note item-end>\n                  <div class="summary-item-detail">\n                    <span>\n                      <span *ngIf="fiatCurrency?.toUpperCase() === \'USD\'">$</span>{{ offer.value.fee | number : \'1.2-2\' }} <span *ngIf="fiatCurrency?.toUpperCase() !== \'USD\'">{{fiatCurrency}}</span>\n                    </span>\n                  </div>\n                </ion-note>\n              </ion-item>\n              <ion-item [ngStyle]="{\'border-top\': coinBorderColor}">\n                <ion-label>\n                  <div class="summary-item total">\n                    <span>{{"TOTAL" | translate}}</span>\n                  </div>\n                </ion-label>\n                <ion-note item-end>\n                  <div class="summary-item-detail total">\n                    <span>\n                      <span *ngIf="fiatCurrency?.toUpperCase() === \'USD\'">$</span>{{ offer.value.amountCost | number : \'1.2-2\' }} <span *ngIf="fiatCurrency?.toUpperCase() !== \'USD\'">{{fiatCurrency}}</span>\n                    </span>\n                  </div>\n                </ion-note>\n              </ion-item>\n            </ion-list>\n            <div class="terms">\n              <div *ngIf="offer.key == \'simplex\'">\n                <div>\n                  <span translate>What service fees am I paying?</span>\n                  <br>\n                  <span *ngIf="paymentMethod.method == \'sepaBankTransfer\'" translate>\n                    1.5% of the amount.\n                  </span>\n                  <span *ngIf="paymentMethod.method != \'sepaBankTransfer\'">\n                    <span translate>Can range from 2.5% to 5% of the transaction, depending on the volume of traffic (with a minimum of 10 USD or its equivalent in any other fiat currency) + 1% of the transaction.</span>\n                    <a (click)="openExternalLink(\'https://support.simplex.com/hc/en-gb/articles/360014078420-What-fees-am-I-paying-\')" translate>\n                      Read more\n                    </a>\n                  </span>\n                </div>\n                <div>\n                  <span translate>This service is provided by a third party, and you are subject to their </span>\n                  <a (click)="openExternalLink(\'https://www.simplex.com/terms-of-use/\')" translate>\n                    Terms of use\n                  </a>\n                </div>\n              </div>\n              <div *ngIf="offer.key == \'wyre\'">\n                <div>\n                  <span translate>What service fees am I paying?</span>\n                  <br>\n                  <span translate *ngIf="selectedCountry.shortCode == \'US\'">5 USD minimum fee or 2.9% of the amount + 0.30 USD, whichever is greater + Required miners fee.</span>\n                  <span translate *ngIf="selectedCountry.shortCode != \'US\'">5 USD minimum fee or 3.9% of the amount + 0.30 USD, whichever is greater + Required miners fee.</span>\n                  <span translate *ngIf="fiatCurrency?.toUpperCase() != \'USD\'">Or its equivalent in {{ fiatCurrency?.toUpperCase() }}.</span>\n                  &nbsp;\n                  <a (click)="openExternalLink(\'https://support.sendwyre.com/en/articles/3359160-wyre-card-processing-fees\')" translate>\n                    Read more\n                  </a>\n                </div>\n                <div>\n                  <span translate>This service is provided by a third party, and you are subject to their </span>\n                  <a (click)="openExternalLink(\'https://www.sendwyre.com/user-agreement/\')" translate>\n                    User Agreement\n                  </a>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n    <div class="terms-general">\n      <div translate>The final crypto amount you receive when the transaction is complete may differ because it is based on the exchange rates of the providers.</div>\n      <div translate>Additional third-party fees may apply.</div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-offers/crypto-offers.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_buy_crypto_buy_crypto__["a" /* BuyCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_15__providers_simplex_simplex__["a" /* SimplexProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_wyre_wyre__["a" /* WyreProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_theme_theme__["a" /* ThemeProvider */]])
], CryptoOffersPage);

//# sourceMappingURL=crypto-offers.js.map

/***/ }),

/***/ 98:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__popup_popup__ = __webpack_require__(25);




// Providers




let KeyProvider = class KeyProvider {
    constructor(logger, bwcProvider, popupProvider, persistenceProvider, translate) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.Key = this.bwcProvider.getKey();
        this.logger.debug('KeyProvider initialized');
        this.isDirty = false;
    }
    load() {
        this.logger.debug('loading keys');
        return this.persistenceProvider.getKeys().then((keys) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            if (!keys)
                this.logger.debug('no keys found');
            this.keys = [];
            keys = keys ? keys : [];
            this.logger.debug(`typeof keys: ${typeof keys}`);
            if (typeof keys === 'string') {
                this.logger.debug('typeof keys = string. Trying to parse.');
                try {
                    keys = JSON.parse(keys);
                }
                catch (_) {
                    this.logger.warn('Could not parse');
                }
            }
            this.logger.debug(`keys length: ${keys.length}`);
            keys.forEach(k => {
                this.logger.debug(`storage keyid: ${k.id}`);
                this.keys.push(new this.Key({
                    seedType: 'object',
                    seedData: k
                }));
            });
            return Promise.resolve();
        }));
    }
    storeKeysIfDirty() {
        if (!this.isDirty) {
            this.logger.debug('The keys have not been saved. Not dirty');
            return Promise.resolve();
        }
        const keysToAdd = [];
        this.keys.forEach(k => {
            keysToAdd.push(k.toObj(k));
        });
        return this.persistenceProvider.setKeys(keysToAdd).then(() => {
            this.isDirty = false;
            return Promise.resolve();
        });
    }
    addKey(keyToAdd, replaceKey) {
        if (!keyToAdd)
            return Promise.resolve();
        const keyObject = keyToAdd.toObj();
        const keyIndex = this.keys.findIndex(k => this.isMatch(keyToAdd, k));
        if (keyIndex >= 0) {
            // only for encrypt/decrypt
            if (replaceKey)
                this.keys.splice(keyIndex, 1, new this.Key({
                    seedType: 'object',
                    seedData: keyObject
                }));
            else {
                this.logger.debug('NO adding key (duplicate): ', keyToAdd.id);
                return Promise.resolve();
            }
        }
        else {
            this.keys.push(new this.Key({
                seedType: 'object',
                seedData: keyObject
            }));
        }
        this.isDirty = true;
        return this.storeKeysIfDirty();
    }
    addKeys(keysToAdd) {
        keysToAdd.forEach(keyToAdd => {
            const keyObject = keyToAdd.toObj();
            if (!this.keys.find(k => this.isMatch(keyObject, k))) {
                this.keys.push(new this.Key({
                    seedType: 'object',
                    seedData: keyObject
                }));
                this.isDirty = true;
            }
            else {
                this.logger.warn('Key already added');
            }
        });
        return this.storeKeysIfDirty();
    }
    getKey(keyId) {
        let selectedKey = this.keys.find(k => k.id == keyId);
        if (selectedKey) {
            return selectedKey;
        }
        else {
            this.logger.debug('No matches for key id: ' + keyId);
            return null;
        }
    }
    removeKey(keyId) {
        this.logger.debug('Removing key: ' + keyId);
        if (keyId === 'read-only')
            return Promise.resolve();
        const selectedKey = this.keys.findIndex(k => k.id == keyId);
        if (selectedKey >= 0) {
            this.keys.splice(selectedKey, 1);
            this.isDirty = true;
            return this.storeKeysIfDirty();
        }
        else {
            const err = 'No matches for key id: ' + keyId;
            this.logger.debug(err);
            return Promise.reject(err);
        }
    }
    // An alert dialog
    askPassword(warnMsg, title) {
        const opts = {
            type: 'password',
            useDanger: true
        };
        return this.popupProvider.ionicPrompt(title, warnMsg, opts);
    }
    encrypt(keyId) {
        const key = this.getKey(keyId);
        let title = this.translate.instant('Enter a new encrypt password');
        const warnMsg = this.translate.instant('Your wallet key will be encrypted. The encrypt password cannot be recovered. Be sure to write it down.');
        return this.askPassword(warnMsg, title).then((password) => {
            if (password == '' || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(this.translate.instant('No password'));
            }
            title = this.translate.instant('Confirm your new encrypt password');
            return this.askPassword(warnMsg, title).then((password2) => {
                if (password != password2 || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password2)) {
                    return Promise.reject(this.translate.instant('Password mismatch'));
                }
                try {
                    this.encryptPrivateKey(key, password);
                }
                catch (error) {
                    return Promise.reject(error);
                }
                return Promise.resolve();
            });
        });
    }
    showWarningNoEncrypt() {
        const title = this.translate.instant('Are you sure?');
        const msg = this.translate.instant('Without encryption, a thief or another application on this device may be able to access your funds.');
        const okText = this.translate.instant("I'm sure");
        const cancelText = this.translate.instant('Go Back');
        return this.popupProvider.ionicConfirm(title, msg, okText, cancelText);
    }
    decrypt(keyId) {
        const key = this.getKey(keyId);
        return this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
            if (password == '' || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(this.translate.instant('No password'));
            }
            try {
                this.decryptPrivateKey(key, password);
            }
            catch (e) {
                return Promise.reject('WRONG_PASSWORD');
            }
            return Promise.resolve();
        });
    }
    handleEncryptedWallet(keyId) {
        if (!keyId) {
            return Promise.resolve();
        }
        const key = this.getKey(keyId);
        const isPrivKeyEncrypted = this.isPrivKeyEncrypted(keyId);
        if (!isPrivKeyEncrypted)
            return Promise.resolve();
        return this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(new Error('PASSWORD_CANCELLED'));
            }
            else if (password == '') {
                return Promise.reject(new Error('NO_PASSWORD'));
            }
            else if (!key.checkPassword(password)) {
                return Promise.reject(new Error('WRONG_PASSWORD'));
            }
            else {
                return Promise.resolve(password);
            }
        });
    }
    isPrivKeyEncrypted(keyId) {
        if (!keyId)
            return false;
        const key = this.getKey(keyId);
        return key ? key.isPrivKeyEncrypted() : undefined;
    }
    isDeletedSeed(keyId) {
        const key = this.getKey(keyId);
        if (!key)
            return true;
        const keyObj = key.toObj();
        return !keyObj.mnemonic && !keyObj.mnemonicEncrypted;
    }
    mnemonicHasPassphrase(keyId) {
        if (!keyId)
            return false;
        const key = this.getKey(keyId).toObj();
        return key.mnemonicHasPassphrase;
    }
    get(keyId, password) {
        const key = this.getKey(keyId);
        return key.get(password);
    }
    getBaseAddressDerivationPath(keyId, opts) {
        const key = this.getKey(keyId);
        return key.getBaseAddressDerivationPath(opts);
    }
    encryptPrivateKey(key, password) {
        key.encrypt(password);
    }
    decryptPrivateKey(key, password) {
        key.decrypt(password);
    }
    sign(keyId, rootPath, txp, password) {
        if (!keyId) {
            this.logger.warn("Can't sign. No key provided");
            return;
        }
        const key = this.getKey(keyId);
        if (!key) {
            this.logger.warn(`Can't sign. The  key ${keyId} was no found.`);
            throw new Error(`Key ${keyId} not found on this device`);
        }
        return key.sign(rootPath, txp, password);
    }
    isMatch(key1, key2) {
        // return this.Key.match(key1, key2); TODO needs to be fixed on bwc
        if (key1.fingerPrint && key2.fingerPrint)
            return key1.fingerPrint === key2.fingerPrint;
        else
            return key1.id === key2.id;
    }
    getMatchedKey(key) {
        return this.keys.find(k => this.isMatch(key, k));
    }
};
KeyProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], KeyProvider);

//# sourceMappingURL=key.js.map

/***/ }),

/***/ 980:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CryptoPaymentMethodPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_buy_crypto_buy_crypto__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_buy_crypto_crypto_order_summary_crypto_order_summary__ = __webpack_require__(503);




// Providers



// Pages

let CryptoPaymentMethodPage = class CryptoPaymentMethodPage {
    constructor(logger, navParams, navCtrl, viewCtrl, buyCryptoProvider, themeProvider) {
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.viewCtrl = viewCtrl;
        this.buyCryptoProvider = buyCryptoProvider;
        this.themeProvider = themeProvider;
        this.coin = this.navParams.data.coin;
        this.country = this.navParams.data.selectedCountry;
        this.currency = this.navParams.data.currency;
        this.methods = this.buyCryptoProvider.paymentMethodsAvailable;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CryptoPaymentMethodPage');
        this.methods = __WEBPACK_IMPORTED_MODULE_3_lodash__["pickBy"](this.methods, m => {
            return (m.enabled &&
                (this.buyCryptoProvider.isPaymentMethodSupported('simplex', m, this.coin, this.currency) ||
                    (this.buyCryptoProvider.isPaymentMethodSupported('wyre', m, this.coin, this.currency) &&
                        !this.navParams.data.isPromotionActiveForCountry)) && // TODO: We temporarily remove Wyre from European Union countries. When the Simplex promotion ends we have to remove this condition
                (m.method != 'sepaBankTransfer' ||
                    (m.method == 'sepaBankTransfer' && this.country.EUCountry)));
        });
    }
    ionViewWillEnter() {
        this.useAsModal = this.navParams.data.useAsModal;
        if (!this.methodSelected)
            this.methodSelected = this.navParams.data.paymentMethod || 'creditCard';
    }
    showExchange(exchange, paymentMethod) {
        if (this.navParams.data.isPromotionActiveForCountry && exchange == 'wyre') {
            // TODO: We temporarily remove Wyre from European Union countries. When the Simplex promotion ends we have to remove this condition
            return false;
        }
        return this.buyCryptoProvider.isPaymentMethodSupported(exchange, paymentMethod, this.coin, this.currency);
    }
    goToOrderSummary() {
        const params = {
            coin: this.coin,
            currency: this.currency,
            network: this.navParams.data.network,
            walletId: this.navParams.data.walletId,
            paymentMethod: this.methods[this.methodSelected],
            amount: this.navParams.data.amount
        };
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__pages_buy_crypto_crypto_order_summary_crypto_order_summary__["a" /* CryptoOrderSummaryPage */], params);
    }
    close() {
        this.viewCtrl.dismiss();
    }
    save() {
        if (!this.useAsModal || !this.methodSelected)
            return;
        this.viewCtrl.dismiss({ paymentMethod: this.methods[this.methodSelected] });
    }
};
CryptoPaymentMethodPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-crypto-payment-method',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-payment-method/crypto-payment-method.html"*/'<wide-header-page title="{{\'Select Payment Method\' | translate}}">\n  <ion-buttons left *ngIf="useAsModal">\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list" radio-group [(ngModel)]="methodSelected">\n      <div *ngFor="let method of methods | keys">\n        <ion-item>\n          <ion-label>\n            <div class="main-label">{{method.value.label}}</div>\n            <div class="secondary-label" translate>Supported by</div>\n            <div>\n              <img *ngIf="showExchange(\'simplex\', method.value)" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/simplex/logo-simplex-color.svg\' : \'assets/img/simplex/logo-simplex-dm.png\'">\n              <img *ngIf="showExchange(\'wyre\', method.value)" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/wyre/logo-wyre.svg\' : \'assets/img/wyre/logo-wyre-dm.svg\'">\n            </div>\n          </ion-label>\n          <ion-radio (click)="save()" item-left value="{{method?.key}}" checked="methodSelected"></ion-radio>\n          <ion-icon item-end class="item-img">\n            <img src="{{method.value.imgSrc}}">\n          </ion-icon>\n        </ion-item>\n        <div class="line-divider"></div>\n      </div>\n    </ion-list>\n    <button *ngIf="!useAsModal" ion-button class="button-standard button-primary" (click)="goToOrderSummary()">\n      <span>{{\'View Order Summary\' | translate}}</span>\n    </button>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-payment-method/crypto-payment-method.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_buy_crypto_buy_crypto__["a" /* BuyCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_theme_theme__["a" /* ThemeProvider */]])
], CryptoPaymentMethodPage);

//# sourceMappingURL=crypto-payment-method.js.map

/***/ }),

/***/ 981:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseTxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(21);






let CoinbaseTxDetailsPage = class CoinbaseTxDetailsPage {
    constructor(viewCtrl, navParams, configProvider, externalLinkProvider, translate) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.translate = translate;
        this.tx = this.navParams.data.tx;
    }
    viewOnBlockchain() {
        const defaults = this.configProvider.getDefaults();
        const blockexplorerUrl = defaults.blockExplorerUrl[this.tx.amount.currency.toLowerCase()];
        const btx = this.tx;
        const network = 'mainnet/';
        const url = `https://${blockexplorerUrl}${network}tx/${btx.network.hash}`;
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Transaction');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
CoinbaseTxDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-tx-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/'<wide-header-page title="{{ tx.details.title }}" hideBackButton="true">\n  <ion-buttons left>\n    <button class="close-container disable-hover" (click)="close()" ion-button>\n      <ion-icon ios="md-close" md="md-close"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div class="coinbase-subtitle">{{ tx.details.subtitle }}</div>\n    <ion-list class="bp-list">\n      <ion-item>\n        <div class="header-container">\n          <div class="amount-label">\n            <div class="coinbase-amount">\n              {{tx.amount.amount | number:\'1.2-8\'}}\n              <span class="coinbase-coin">\n                {{tx.amount.currency}}\n              </span>\n            </div>\n            <div class="alternative">\n              {{tx.native_amount.amount | number:\'1.2-2\'}} {{tx.native_amount.currency}}\n            </div>\n          </div>\n        </div>\n      </ion-item>\n\n      <ion-item class="sub-title">\n        <ion-label>\n          <div class="main-label" translate>DETAILS</div>\n        </ion-label>\n      </ion-item>\n\n      <ion-item *ngIf="tx.to && tx.to.address">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>To</span>\n          </div>\n        </ion-label>\n        <ion-note copy-to-clipboard="{{ tx.to.address }}" item-end>\n          <div class="payment-proposal-to">\n            <img class="coin-img" src="assets/img/currencies/{{ tx.amount.currency.toLowerCase() }}.svg" alt="Coin" />\n            <span class="note-container ellipsis summary-item-detail">{{ tx.to.address }}</span>\n          </div>\n        </ion-note>\n      </ion-item>\n\n      <ion-item *ngIf="tx.description">\n        <ion-label>\n          <div class="summary-item">\n            <span translate>Notes</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">{{tx.description}}</span>\n        </ion-note>\n      </ion-item>\n\n      <div *ngIf="tx.network && tx.network != \'off_blockchain\'">\n        <ion-item *ngIf="tx.network.confirmations">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Confirmations</span>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <span class="note-container ellipsis summary-item-detail">\n              {{ tx.network.confirmations > 6 ? \'+6\' : tx.network.confirmations }}\n            </span>\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="tx.network.transaction_fee">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Fee</span>\n            </div>\n          </ion-label>\n          <ion-note item-end>\n            <span class="note-container ellipsis summary-item-detail">\n              {{ tx.network.transaction_fee.amount | number:\'1.2-8\' }} {{ tx.network.transaction_fee.currency }}\n            </span>\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="tx.network.hash">\n          <ion-label>\n            <div class="summary-item">\n              <span translate>Transaction ID</span>\n            </div>\n          </ion-label>\n          <ion-note copy-to-clipboard="{{ tx.network.hash }}" item-end>\n            <span class="note-container ellipsis summary-item-detail">{{ tx.network.hash }}</span>\n          </ion-note>\n        </ion-item>\n      </div>\n\n      <div class="line-divider"></div>\n\n      <ion-item>\n        <ion-label>\n          <div class="summary-item">\n            <span>{{ tx.created_at | date:\'medium\' }}</span>\n          </div>\n        </ion-label>\n        <ion-note item-end>\n          <span class="note-container ellipsis summary-item-detail">{{tx.status}}</span>\n        </ion-note>\n      </ion-item>\n\n      <ion-row *ngIf="tx.network && tx.network.hash" justify-content-center class="background-button-content">\n        <div class="background-content">\n          <button ion-button clear (click)="viewOnBlockchain()">\n            {{\'View on blockchain\' | translate}}\n          </button>\n        </div>\n      </ion-row>\n\n    </ion-list>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], CoinbaseTxDetailsPage);

//# sourceMappingURL=coinbase-tx-details.js.map

/***/ }),

/***/ 982:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PrintableCardComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pipes_format_currency__ = __webpack_require__(504);



let PrintableCardComponent = class PrintableCardComponent {
    constructor(formatCurrencyPipe) {
        this.formatCurrencyPipe = formatCurrencyPipe;
    }
    ngAfterViewInit() {
        this.initializeCanvas();
        this.writeText();
    }
    getPrintableImage() {
        this.drawCardImage();
        return this.ctx.canvas.toDataURL();
    }
    initializeCanvas() {
        this.ctx = this.canvas.nativeElement.getContext('2d');
        this.ctx.textAlign = 'center';
    }
    writeText() {
        const ctx = this.ctx;
        const x = this.ctx.canvas.width / 2;
        // Amount
        ctx.font = '30px Roboto';
        ctx.fillStyle = 'black';
        const amount = this.formatCurrencyPipe.transform(this.card.amount, this.card.currency);
        ctx.fillText(amount + '', x, yPos(0));
        const BARCODE_HEIGHT = 45;
        const barcodeHeight = this.card.barcodeImage ? BARCODE_HEIGHT : 0;
        // Labels
        ctx.font = '12px Roboto';
        ctx.fillStyle = 'gray';
        ctx.fillText('Claim Code', x, yPos(200));
        this.card.pin &&
            ctx.fillText('Pin', x, yPos(320 - BARCODE_HEIGHT + barcodeHeight));
        // Card Number & Pin
        ctx.font = '14px Roboto';
        ctx.fillStyle = 'black';
        ctx.fillText(this.card.claimCode, x, yPos(278 - BARCODE_HEIGHT + barcodeHeight));
        this.card.pin &&
            ctx.fillText(this.card.pin, x, yPos(348 - BARCODE_HEIGHT + barcodeHeight));
        // Terms
        const maxWidth = 320;
        const lineHeight = 11;
        const x2 = this.ctx.canvas.width / 2;
        const y = 400;
        ctx.font = '8px Roboto';
        ctx.fillStyle = '#a6a6a6';
        wrapText(ctx, this.cardConfig.terms, x2, yPos(y - BARCODE_HEIGHT + barcodeHeight), maxWidth, lineHeight);
    }
    drawBarcode() {
        const img = this.barcode.nativeElement;
        const ctx = this.ctx;
        const scale = 1;
        const image = img;
        var x1 = (ctx.canvas.width - image.width * scale) / 2;
        ctx.drawImage(image, x1, yPos(210), image.width * scale, image.height * scale);
    }
    drawCardImage() {
        const ctx = this.ctx;
        const image = this.cardImage.nativeElement;
        const scale = 0.55;
        const x = (ctx.canvas.width - image.width * scale) / 2;
        ctx.drawImage(image, x, yPos(35), image.width * scale, image.height * scale);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], PrintableCardComponent.prototype, "cardConfig", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], PrintableCardComponent.prototype, "card", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('canvas'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "canvas", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('barcode'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "barcode", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('cardImage'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "cardImage", void 0);
PrintableCardComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'printable-card',
        template: `
    <canvas #canvas width="595" height="842"></canvas>
    <img
      #barcode
      *ngIf="card.barcodeImage"
      [src]="card.barcodeImage"
      (load)="drawBarcode()"
    />
    <img
      #cardImage
      crossorigin="Anonymous"
      [src]="cardConfig.cardImage"
      (load)="drawCardImage()"
    />
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__pipes_format_currency__["a" /* FormatCurrencyPipe */]])
], PrintableCardComponent);

function yPos(y) {
    const topPadding = 150;
    return topPadding + y;
}
function wrapText(context, text, x, y, maxWidth, lineHeight) {
    var words = text.split(' ');
    var line = '';
    for (var n = 0; n < words.length; n++) {
        var testLine = line + words[n] + ' ';
        var metrics = context.measureText(testLine);
        var testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        }
        else {
            line = testLine;
        }
    }
    context.fillText(line, x, y);
}
//# sourceMappingURL=printable-card.js.map

/***/ }),

/***/ 983:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PhonePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_countries_list__ = __webpack_require__(938);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_countries_list___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_countries_list__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_phone_phone__ = __webpack_require__(937);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(391);









let PhonePage = class PhonePage {
    constructor(actionSheetProvider, externalLinkProvider, giftCardProvider, nav, navParams, locationProvider, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.giftCardProvider = giftCardProvider;
        this.nav = nav;
        this.navParams = navParams;
        this.locationProvider = locationProvider;
        this.platformProvider = platformProvider;
        this.title = 'Enable Mobile Payments?';
        this.phoneForm = new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["c" /* FormGroup */]({
            phone: new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["b" /* FormControl */]('', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].requiredTrue),
            agreement: new __WEBPACK_IMPORTED_MODULE_2__angular_forms__["b" /* FormControl */](false, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].requiredTrue)
        });
        if (this.platformProvider.isIOS)
            this.title = 'Enable Apple Pay?';
        else if (this.platformProvider.isAndroid)
            this.title = 'Enable Google Pay?';
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.cardConfig = this.navParams.get('cardConfig');
            const { phone, phoneCountryInfo: { phoneCountryCode, countryIsoCode } } = yield this.giftCardProvider.getPhoneAndCountryCode();
            const savedPhoneCountry = getSavedPhoneCountryCode(phoneCountryCode, countryIsoCode);
            const validSavedPhone = savedPhoneCountry &&
                (!this.cardConfig.allowedPhoneCountries ||
                    this.cardConfig.allowedPhoneCountries.includes(savedPhoneCountry.countryCode));
            validSavedPhone
                ? this.prefillPhone(phone, savedPhoneCountry)
                : yield this.initializeBlankPhoneInput();
            this.updateMaskAndValidators();
        });
    }
    initializeBlankPhoneInput() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const allowedPhoneCountries = this.cardConfig.allowedPhoneCountries;
            const userCountryCode = yield this.locationProvider.getCountry();
            this.initialCountryCode =
                allowedPhoneCountries && !allowedPhoneCountries.includes(userCountryCode)
                    ? allowedPhoneCountries[0]
                    : userCountryCode;
            this.country = Object(__WEBPACK_IMPORTED_MODULE_7__providers_phone_phone__["a" /* getPhoneCountryCodes */])().find(country => country.countryCode === this.initialCountryCode);
        });
    }
    prefillPhone(phone, phoneCountry) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.country = phoneCountry;
            this.phoneForm.setValue({
                phone: phone.replace(phoneCountry.phone, ''),
                agreement: false
            });
        });
    }
    openPolicy() {
        let url = 'https://tkcoin.org/about/privacy';
        this.externalLinkProvider.open(url);
    }
    openOnlyOneCountrySupportedSheet() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const countryCode = this.cardConfig.allowedPhoneCountries[0];
            const country = __WEBPACK_IMPORTED_MODULE_3_countries_list__["countries"][countryCode];
            const infoSheet = this.actionSheetProvider.createInfoSheet('one-phone-country', { country, countryCode });
            infoSheet.present();
        });
    }
    onCountryCodeClick() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            (this.cardConfig.allowedPhoneCountries || []).length === 1
                ? this.openOnlyOneCountrySupportedSheet()
                : this.openCountryCodeSheet();
        });
    }
    openCountryCodeSheet() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            const phoneSheet = this.actionSheetProvider.createPhoneSheet({
                allowedPhoneCountries: this.cardConfig.allowedPhoneCountries
            });
            const sheetHeight = this.platformProvider.isCordova
                ? this.platformProvider.isIOS
                    ? '50vh'
                    : '70vh'
                : '90vh';
            yield phoneSheet.present({
                maxHeight: sheetHeight,
                minHeight: sheetHeight
            });
            phoneSheet.onDidDismiss(country => {
                if (!country)
                    return;
                this.country = country;
                this.updateMaskAndValidators();
            });
        });
    }
    updateMaskAndValidators() {
        this.phoneMask = getPhoneMask(this.country.phone);
        this.phoneForm.get('phone').setValidators(getValidators(this.country));
    }
    next(decline) {
        const params = Object.assign({}, this.navParams.data, { phone: this.getPhoneValueFromForm(decline) });
        this.nav.push(__WEBPACK_IMPORTED_MODULE_8__confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */], params);
        if (!decline)
            this.giftCardProvider.savePhone(params.phone, {
                phoneCountryCode: this.country.phone,
                countryIsoCode: this.country.countryCode
            });
    }
    getPhoneValueFromForm(decline) {
        const number = this.phoneForm
            .get('phone')
            .value.replace(/\D/g, '')
            .replace(/\D/g, '');
        return number && !decline ? `${this.country.phone}${number}` : undefined;
    }
};
PhonePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'phone-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/phone/phone.html"*/'<wide-header-page [title]="title">\n  <div page-content>\n    <div class="padding">\n      <div class="sub-title">\n        <span translate\n          >If you would like to connect this card to\n          <span *ngIf="platformProvider.isIOS">Apple Pay</span\n          ><span *ngIf="platformProvider.isAndroid">Google Pay</span\n          ><span *ngIf="!platformProvider.isIOS && !platformProvider.isAndroid"\n            >Apple Pay or Google Pay</span\n          >, please provide your phone number.</span\n        >\n      </div>\n      <form [formGroup]="phoneForm">\n        <div class="phone-input">\n          <div\n            class="phone-input__country-code"\n            tappable\n            (click)="onCountryCodeClick()"\n            *ngIf="country"\n          >\n            <span class="phone-input__flag-emoji">{{country.emoji}}</span>\n            +{{country.phone}} <img src="assets/img/chevron-down.svg" />\n          </div>\n          <ion-input\n            mode="md"\n            formControlName="phone"\n            type="tel"\n            [ionMask]="phoneMask"\n            placeholder="Phone Number"\n          >\n          </ion-input>\n        </div>\n        <ion-item\n          class="form__form-item form__form-toggle"\n          style="padding-top: 10px"\n          no-lines\n        >\n          <ion-label class="form__form-toggle__label">\n            {{\'By giving my phone number, I give explicit consent to TKCoin to\n            use it to connect this card to Apple Pay or Google Pay.\' |\n            translate}}\n            <span class="form__form__link" (click)="openPolicy()" translate>\n              Privacy Notice</span\n            >\n          </ion-label>\n          <ion-toggle formControlName="agreement" color="success"></ion-toggle>\n        </ion-item>\n      </form>\n    </div>\n    <div class="padding-bottom" style="padding-bottom: 40px">\n      <button\n        ion-button\n        class="button-standard"\n        [disabled]="phoneForm.invalid"\n        (click)="next()"\n      >\n        {{\'Enable\' | translate}}\n      </button>\n      <div tappable class="no-thanks" (click)="next(true)">No thanks</div>\n    </div>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/phone/phone.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["L" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["V" /* LocationProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["_3" /* PlatformProvider */]])
], PhonePage);

function getValidators(country) {
    const isUS = country.phone === '1';
    return __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].compose([
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].required,
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].pattern(/[0-9]/),
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["h" /* Validators */].minLength(isUS ? 14 : 0)
    ]);
}
function getPhoneMask(phoneCountryCode) {
    const usMask = [
        '(',
        /[1-9]/,
        /\d/,
        /\d/,
        ')',
        ' ',
        /\d/,
        /\d/,
        /\d/,
        '-',
        /\d/,
        /\d/,
        /\d/,
        /\d/
    ];
    return phoneCountryCode === '1' ? usMask : Array(15).fill(/\d/);
}
function getSavedPhoneCountryCode(phoneCountryCode, countryIsoCode) {
    const countryCodes = Object(__WEBPACK_IMPORTED_MODULE_7__providers_phone_phone__["a" /* getPhoneCountryCodes */])();
    return countryCodes.find(countryCodeObj => countryCodeObj.phone === phoneCountryCode &&
        countryIsoCode === countryCodeObj.countryCode);
}
//# sourceMappingURL=phone.js.map

/***/ }),

/***/ 984:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomAmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(31);




// Native

// providers







let CustomAmountPage = class CustomAmountPage {
    constructor(currencyProvider, navParams, profileProvider, platformProvider, walletProvider, logger, socialSharing, txFormatProvider, actionSheetProvider, configProvider) {
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.txFormatProvider = txFormatProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        const walletId = this.navParams.data.id;
        this.showShareButton = this.platformProvider.isCordova;
        this.useLegacyQrCode = this.configProvider.get().legacyQrCode.show;
        this.wallet = this.profileProvider.getWallet(walletId);
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            this.address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, addr);
            const parsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, this.navParams.data.amount, this.navParams.data.currency);
            // Amount in USD or BTC
            const _amount = parsedAmount.amount;
            const _currency = parsedAmount.currency;
            this.amountUnitStr = parsedAmount.amountUnitStr;
            if (!__WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__["a" /* Coin */][_currency]) {
                // Convert to BTC or BCH
                const amountUnit = this.txFormatProvider.satToUnit(parsedAmount.amountSat, this.wallet.coin);
                var btcParsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, amountUnit, this.wallet.coin.toUpperCase());
                this.amountCoin = btcParsedAmount.amount;
                this.altAmountStr = btcParsedAmount.amountUnitStr;
            }
            else {
                this.amountCoin = _amount; // BTC or BCH
                this.altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, parsedAmount.amountSat);
            }
            let protoAddr;
            if (this.wallet.coin != 'bch') {
                protoAddr = this.walletProvider.getProtoAddress(this.wallet.coin, this.wallet.network, this.address);
            }
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin) ||
                this.wallet.coin === 'xrp') {
                this.qrAddress =
                    (protoAddr ? protoAddr : this.address) + '?amount=' + this.amountCoin;
            }
            else {
                this.qrAddress =
                    (protoAddr ? protoAddr : this.address) +
                        '?value=' +
                        parsedAmount.amountSat;
            }
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CustomAmountPage');
    }
    shareAddress() {
        this.socialSharing.share(this.qrAddress);
    }
    showPaymentRequestInfo() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('payment-request', {
            amount: this.amountUnitStr,
            name: this.wallet.name
        });
        infoSheet.present();
    }
};
CustomAmountPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-custom-amount',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/receive/custom-amount/custom-amount.html"*/'<wide-header-page title="{{ wallet.name }}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="shareAddress()" *ngIf="showShareButton" ion-button>\n      <ion-icon ios="ios-share-outline" md="md-share" class="pointer"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div *ngIf="wallet" class="receive-content">\n      <div class="title-container">\n        <span class="title">{{\'Payment Request\' | translate}}</span>\n        <ion-icon (click)="showPaymentRequestInfo()">\n          <img src="assets/img/icon-info-blue.svg">\n        </ion-icon>\n      </div>\n      <div class="addr-container">\n        <div class="text-address ellipsis">\n          <img class="copy-to-clip" copy-to-clipboard="{{ address }}" src="assets/img/paste-clipboard.svg" width="18" />\n          <div class="address-text ellipsis">\n            <span>{{ address }}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class="qr-card-amount">\n      <span>{{amountUnitStr}}</span>\n      <br>\n      <small>({{altAmountStr}})</small>\n    </div>\n    <div class="qr-container">\n      <bp-qr-code *ngIf="!useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ qrAddress }}" contents="{{ qrAddress }}" mask-x-to-y-ratio="1">\n        <img [ngClass]="{\'testnet\': wallet.network === \'testnet\', \'background_xrp\': wallet.coin === \'xrp\'}" src="assets/img/currencies/{{ wallet.coin }}.svg" slot="icon" />\n      </bp-qr-code>\n      <div *ngIf="useLegacyQrCode" class="card qr-card" copy-to-clipboard="{{ qrAddress }}">\n        <ngx-qrcode hide-toast="true" qrc-value="{{ qrAddress }}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n      </div>\n    </div>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/receive/custom-amount/custom-amount.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */]])
], CustomAmountPage);

//# sourceMappingURL=custom-amount.js.map

/***/ }),

/***/ 985:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseWithdrawPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__coinbase_coinbase_account_coinbase_account__ = __webpack_require__(392);






// providers






// pages


let CoinbaseWithdrawPage = class CoinbaseWithdrawPage {
    constructor(logger, coinbaseProvider, popupProvider, navCtrl, onGoingProcessProvider, navParams, profileProvider, modalCtrl, platformProvider, translate, walletProvider) {
        this.logger = logger;
        this.coinbaseProvider = coinbaseProvider;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.walletProvider = walletProvider;
        this.data = {};
        this.isCordova = this.platformProvider.isCordova;
        this.hideSlideButton = false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.description = this.navParams.data.description;
        this.accountId = this.navParams.data.id;
        this.coinbaseProvider.getAccount(this.accountId, this.data);
        this.wallet = this.profileProvider.getWallet(this.navParams.data.toWalletId);
        this.buttonText = this.isCordova
            ? this.translate.instant('Slide to withdraw')
            : this.translate.instant('Click to withdraw');
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CoinbaseWithdrawPage');
        this.navCtrl.swipeBackEnabled = false;
        if (this.isCordova) {
            window.addEventListener('keyboardWillShow', () => {
                this.hideSlideButton = true;
            });
            window.addEventListener('keyboardWillHide', () => {
                this.hideSlideButton = false;
            });
        }
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallet)) {
            this.showErrorAndBack(this.translate.instant('No wallet found'));
            return;
        }
        this.walletProvider.getAddress(this.wallet, false).then(address => {
            this.address = address;
        });
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider
            .ionicAlert(this.translate.instant('Error'), err)
            .then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
    }
    approve() {
        const tx = {
            to: this.address,
            amount: this.amount,
            currency: this.currency,
            description: this.description,
            destination_tag: this.destinationTag
        };
        this._sendTransaction(tx);
    }
    _sendTransaction(tx, code) {
        this.onGoingProcessProvider.set('sendingTx');
        this.coinbaseProvider
            .sendTransaction(this.accountId, tx, code)
            .then(data => {
            this.onGoingProcessProvider.clear();
            this.logger.info(data.data);
            this.coinbaseProvider.logEvent({
                method: 'withdraw',
                amount: tx.amount,
                currency: tx.currency
            });
            this.openFinishModal();
        })
            .catch(e => {
            this.onGoingProcessProvider.clear();
            if (e == '2fa') {
                const message = this.translate.instant('Enter 2-step verification');
                const opts = {
                    type: 'number',
                    enableBackdropDismiss: false
                };
                this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                    if (res === null) {
                        this.showErrorAndBack(this.translate.instant('Missing 2-step verification'));
                        return;
                    }
                    this._sendTransaction(tx, res);
                });
            }
            else {
                this.showErrorAndBack(e);
            }
        });
    }
    openFinishModal() {
        const finishText = this.translate.instant('Withdraw success');
        const finishComment = this.translate.instant('It could take a while to confirm transaction');
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_12__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(_ => {
            this.navCtrl.popToRoot({ animate: false }).then(_ => {
                this.navCtrl.parent.select(1);
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__coinbase_coinbase_account_coinbase_account__["a" /* CoinbaseAccountPage */], {
                    id: this.accountId
                }, { animate: false });
            });
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], CoinbaseWithdrawPage.prototype, "slideButton", void 0);
CoinbaseWithdrawPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-withdraw',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-withdraw/coinbase-withdraw.html"*/'<wide-header-page title="{{ \'Confirm Withdraw\' | translate }}" [hasSlideButton]="!hideSlideButton && isCordova">\n  <div page-content>\n  <ion-list class="bp-list">\n    <ion-item class="sub-title">\n      <ion-label>\n        <div class="main-label" translate>SUMMARY</div>\n      </ion-label>\n    </ion-item>\n\n    <ion-item *ngIf="wallet">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Transfer to</span>\n        </div>\n      </ion-label>\n\n      <ion-note item-end>\n        <ion-row align-items-center class="wallet">\n          <ion-col>\n            <coin-icon [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n          </ion-col>\n\n          <ion-col>\n            <div *ngIf="!address">...</div>\n            <div *ngIf="address" copy-to-clipboard="{{ address }}">\n              <span class="ellipsis" *ngIf="!wallet.name">{{address}}</span>\n              <span class="ellipsis" *ngIf="wallet.name">{{wallet.name}}</span>\n            </div>\n          </ion-col>\n        </ion-row>\n      </ion-note>\n    </ion-item>\n\n    <div class="line-divider"></div>\n\n    <button ion-item detail-none class="not-clickable">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Sending from</span>\n        </div>\n      </ion-label>\n      <ion-note item-end>\n        <ion-row align-items-center class="wallet">\n          <ion-col>\n            <ion-icon item-start>\n              <img src="assets/img/coinbase/coinbase-icon.png" width="32">\n            </ion-icon>\n          </ion-col>\n          <ion-col>\n            <span class="ellipsis">Coinbase: {{ data?.account?.name }}</span>\n          </ion-col>\n        </ion-row>\n      </ion-note>\n    </button>\n\n    <ion-item *ngIf="wallet.coin == \'xrp\'">\n      <ion-label stacked>{{\'Destination Tag\' | translate}}</ion-label>\n      <ion-input class="padded-input" type="number" placeholder="{{\'Enter a destination tag\' | translate}}" [(ngModel)]="destinationTag" name="destinationTag" autocomplete="off" autocorrect="off"></ion-input>\n    </ion-item>\n\n    <label-tip *ngIf="wallet.coin ==\'xrp\' && !destinationTag" type="info" header="no-header">\n      <div label-tip-body translate>\n        A Destination Tag is an optional number that corresponds to an invoice or a XRP account on an exchange.\n      </div>\n    </label-tip>\n\n    <ion-item *ngIf="description">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Description</span>\n        </div>\n      </ion-label>\n      <ion-note class="main-note" item-end>{{ description }}</ion-note>\n    </ion-item>\n\n    <div class="summary-line"></div>\n\n    <ion-item>\n      <ion-label>\n        <div class="main-label total-label">TOTAL</div>\n      </ion-label>\n      <ion-note item-end>\n        <div class="total-amount">\n          {{ amount }} {{ currency }}\n        </div>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n  </div>\n\n  <div footer-content>\n    <page-slide-to-accept #slideButton *ngIf="isCordova" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}" [disabled]="!wallet || !data || (wallet.coin == \'xrp\' && !destinationTag)" [buttonText]="buttonText" [isDogecoin]="wallet && wallet.coin == \'doge\'" (slideDone)="approve()">\n    </page-slide-to-accept>\n    <ion-toolbar *ngIf="!isCordova">\n      <button ion-button full class="button-footer" (click)="approve()" [disabled]="!wallet || !data || (wallet.coin == \'xrp\' && !destinationTag)">{{buttonText}}</button>\n    </ion-toolbar>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-withdraw/coinbase-withdraw.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */]])
], CoinbaseWithdrawPage);

//# sourceMappingURL=coinbase-withdraw.js.map

/***/ }),

/***/ 986:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinCardTopUpPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tkcoin_card__ = __webpack_require__(505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_fee_fee__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_on_going_process_on_going_process__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_paypro_paypro__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_profile_profile__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_tkcoin_card_tkcoin_card__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_tkcoin_tkcoin__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_tx_format_tx_format__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_wallet_wallet__ = __webpack_require__(31);






// Pages


// Provider




















const FEE_TOO_HIGH_LIMIT_PER = 15;
let TKCoinCardTopUpPage = class TKCoinCardTopUpPage {
    constructor(actionSheetProvider, bitPayCardProvider, bitPayProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, externalLinkProvider, incomingDataProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txFormatProvider, walletProvider, translate, platformProvider, feeProvider, payproProvider, iabCardProvider, errorsProvider, homeIntegrationsProvider, coinbaseProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.bitPayProvider = bitPayProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.payproProvider = payproProvider;
        this.iabCardProvider = iabCardProvider;
        this.errorsProvider = errorsProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.configWallet = this.configProvider.get().wallet;
        this.isCordova = this.platformProvider.isCordova;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: TKCoinCardTopUpPage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewDidEnter() {
        this.logCardAddToCartEvent();
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.cardId = this.navParams.data.id;
        this.useSendMax = this.navParams.data.useSendMax;
        this.currency = this.navParams.data.currency;
        this.amount = this.navParams.data.amount;
        let coin = __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__["a" /* Coin */][this.currency] ? __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__["a" /* Coin */][this.currency] : null;
        this.bitPayCardProvider
            .get({
            cardId: this.cardId,
            noBalance: true,
            noHistory: true
        })
            .then(card => {
            this.bitPayCardProvider.setCurrencySymbol(card[0]);
            this.brand = card[0].brand;
            this.lastFourDigits = card[0].lastFourDigits;
            this.currencySymbol = card[0].currencySymbol;
            this.currencyIsoCode = card[0].currency;
            this.brand === 'Mastercard'
                ? this.bitPayCardProvider.logEvent('mastercard_topup_amount', {
                    usdAmount: this.amount,
                    transactionCurrency: 'USD'
                })
                : this.bitPayCardProvider.logEvent('legacycard_topup_amount', {
                    usdAmount: this.amount,
                    transactionCurrency: 'USD'
                });
            const network = this.bitPayProvider.getEnvironment().network;
            const walletOptions = {
                onlyComplete: true,
                coin,
                network,
                hasFunds: true
            };
            if (__WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__["a" /* Coin */][this.currency]) {
                const { amountSat } = this.txFormatProvider.parseAmount(this.currency.toLowerCase(), this.amount, this.currency);
                this.wallets = this.profileProvider.getWallets(Object.assign({}, walletOptions, { minAmount: amountSat }));
            }
            else {
                this.wallets = this.profileProvider.getWallets(Object.assign({}, walletOptions, { minFiatCurrency: { amount: this.amount, currency: this.currency } }));
            }
            const pendingWallets = this.profileProvider.getWallets(Object.assign({}, walletOptions, { minPendingAmount: { amount: this.amount, currency: this.currency } }));
            this.setCoinbase(network);
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets) &&
                !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](pendingWallets) &&
                __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseAccounts)) {
                const subtitle = this.translate.instant('You do not have enough confirmed funds to make this payment. Please wait for your pending transactions to confirm.');
                const title = this.translate.instant('Not enough confirmed funds');
                this.errorsProvider.showDefaultError(subtitle, title);
                return;
            }
            else if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets) &&
                __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.coinbaseAccounts)) {
                this.errorsProvider.showNoWalletsAvailableInfo();
                return;
            }
            this.showWallets(); // Show wallet selector
        });
    }
    setCoinbase(network) {
        this.showCoinbase =
            this.homeIntegrationsProvider.shouldShowInHome('coinbase') &&
                this.coinbaseProvider.isLinked();
        if (!this.showCoinbase && network != 'livenet')
            return;
        this.coinbaseProvider.preFetchAllData();
        this.coinbaseAccounts = this.coinbaseProvider.coinbaseData
            ? this.coinbaseProvider.coinbaseData.accounts
            : [];
    }
    updateRates(coin) {
        this.bitPayCardProvider.getRatesFromCoin(coin.toUpperCase(), this.currencyIsoCode, (err, r) => {
            if (err)
                this.logger.error(err);
            this.rate = r.rate;
        });
    }
    _resetValues() {
        this.totalAmountStr = this.amount = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.createdTx = null;
    }
    showErrorAndBack(title, msg) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(title, msg) {
        return new Promise(resolve => {
            if (this.isCordova)
                this.slideButton.isConfirmed(false);
            title = title || this.translate.instant('Error');
            this.logger.error(msg);
            msg = msg && msg.errors ? msg.errors[0].message : msg;
            this.popupProvider.ionicAlert(title, msg).then(() => {
                return resolve();
            });
        });
    }
    satToFiat(coin, sat) {
        return new Promise(resolve => {
            this.txFormatProvider
                .toFiat(coin, sat, this.currencyIsoCode)
                .then((value) => {
                return resolve(value);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.logCardSetCheckoutOption(wallet);
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Paypro error: removing payment proposal');
                this.walletProvider.removeTx(wallet, txp).catch(() => {
                    this.logger.warn('Could not delete payment proposal');
                });
                return reject(err);
            });
        });
    }
    setTotalAmount(coin, amountSat, invoiceFeeSat = 0, networkFeeSat = 0) {
        const chain = this.currencyProvider.getChain(coin).toLowerCase();
        this.satToFiat(this.isERCToken ? coin : chain, amountSat).then((a) => {
            this.amount = Number(a);
            this.satToFiat(chain, invoiceFeeSat).then((i) => {
                this.invoiceFee = Number(i);
                this.satToFiat(chain, networkFeeSat).then((n) => {
                    this.networkFee = Number(n);
                    this.totalAmount = this.amount + this.invoiceFee + this.networkFee;
                });
            });
        });
    }
    isCryptoCurrencySupported(coin, invoice) {
        let COIN = coin.toUpperCase();
        if (!invoice['supportedTransactionCurrencies'][COIN])
            return false;
        return invoice['supportedTransactionCurrencies'][COIN].enabled;
    }
    createInvoice(data) {
        return new Promise((resolve, reject) => {
            this.bitPayCardProvider.topUp(this.cardId, data, (err, invoiceId) => {
                if (err) {
                    return reject({
                        title: 'Could not create the invoice',
                        message: err
                    });
                }
                this.bitPayCardProvider.getInvoice(invoiceId, (err, inv) => {
                    if (err) {
                        return reject({
                            title: 'Could not get the invoice',
                            message: err
                        });
                    }
                    return resolve(inv);
                });
            });
        });
    }
    createTx(wallet, invoice, message) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            const paymentCode = this.currencyProvider.getPaymentCode(wallet.coin);
            const protocolUrl = invoice.paymentCodes[COIN][paymentCode];
            const payProUrl = this.incomingDataProvider.getPayProUrl(protocolUrl);
            if (!payProUrl) {
                return reject({
                    title: this.translate.instant('Error fetching this invoice'),
                    message: this.translate.instant('Invalid URL')
                });
            }
            this.walletProvider
                .getAddress(wallet, false)
                .then(address => {
                const payload = {
                    address
                };
                this.payproProvider
                    .getPayProDetails({
                    paymentUrl: payProUrl,
                    coin: wallet.coin,
                    payload
                })
                    .then(details => {
                    const { instructions } = details;
                    this.logger.debug(`PayProDetails instructions amount ${__WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](instructions, 'amount')}`);
                    let txp = {
                        coin: wallet.coin,
                        amount: __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](instructions, 'amount'),
                        from: address,
                        toAddress: instructions[0].toAddress,
                        outputs: [],
                        message,
                        customData: {
                            service: 'debitcard'
                        },
                        payProUrl,
                        excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                            ? false
                            : true
                    };
                    for (const instruction of instructions) {
                        txp.outputs.push({
                            toAddress: instruction.toAddress,
                            amount: instruction.amount,
                            message: instruction.message,
                            data: instruction.data
                        });
                    }
                    if (wallet.coin === 'xrp' &&
                        instructions &&
                        instructions[0] &&
                        instructions[0].outputs &&
                        instructions[0].outputs[0] &&
                        instructions[0].outputs[0].invoiceID) {
                        txp.invoiceID = instructions[0].outputs[0].invoiceID;
                    }
                    if (wallet.credentials.token) {
                        txp.tokenAddress = wallet.credentials.token.address;
                    }
                    if (wallet.credentials.multisigEthInfo) {
                        txp.multisigContractAddress =
                            wallet.credentials.multisigEthInfo.multisigContractAddress;
                    }
                    if (details.requiredFeeRate) {
                        const requiredFeeRate = !this.currencyProvider.isUtxoCoin(wallet.coin)
                            ? details.requiredFeeRate
                            : Math.ceil(details.requiredFeeRate * 1000);
                        txp.feePerKb = requiredFeeRate;
                        this.logger.debug(`PayProDetails requiredFeeRate: ${details.requiredFeeRate}. Txp feePerKb: ${txp.feePerKb}`);
                        this.logger.debug('Using merchant fee rate (for debit card):' + txp.feePerKb);
                    }
                    else {
                        txp.feeLevel = this.feeProvider.getCoinCurrentFeeLevel(wallet.coin);
                    }
                    txp['origToAddress'] = txp.toAddress;
                    if (wallet.coin && wallet.coin == 'bch') {
                        txp.toAddress = this.bitcoreCash
                            .Address(txp.toAddress)
                            .toString(true);
                        txp.outputs[0].toAddress = txp.toAddress;
                    }
                    return this.walletProvider
                        .createTx(wallet, txp)
                        .then(ctxp => {
                        return resolve(ctxp);
                    })
                        .catch(err => {
                        return reject({
                            title: this.translate.instant('Could not create transaction'),
                            message: this.bwcErrorProvider.msg(err)
                        });
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getSendMaxInfo(wallet) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeRate(wallet.coin, wallet.credentials.network, this.feeProvider.getCoinCurrentFeeLevel(wallet.coin))
                .then(feePerKb => {
                this.walletProvider
                    .getSendMaxInfo(wallet, {
                    feePerKb,
                    excludeUnconfirmedUtxos: !this.configWallet.spendUnconfirmed,
                    returnInputs: true
                })
                    .then((resp) => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                    let tokenAddress, multisigContractAddress;
                    if (this.currencyProvider.isERCToken(wallet.coin)) {
                        tokenAddress = wallet.credentials.token.address;
                    }
                    if (this.wallet.credentials.multisigEthInfo) {
                        multisigContractAddress =
                            wallet.credentials.multisigEthInfo.multisigContractAddress;
                    }
                    if (tokenAddress || multisigContractAddress) {
                        try {
                            const { availableAmount } = yield this.walletProvider.getBalance(wallet, {
                                tokenAddress,
                                multisigContractAddress
                            });
                            return resolve({
                                sendMax: true,
                                amount: availableAmount,
                                inputs: resp.inputs,
                                fee: resp.fee,
                                feePerKb
                            });
                        }
                        catch (err) {
                            return reject(err);
                        }
                    }
                    return resolve({
                        sendMax: true,
                        amount: resp.amount,
                        inputs: resp.inputs,
                        fee: resp.fee,
                        feePerKb
                    });
                }))
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    calculateAmount(wallet) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            // Global variables defined beforeEnter
            let a = this.amount;
            let c = this.currency;
            if (this.useSendMax) {
                // Workaround to get invoiceFeeSat and payProFeeSat to calculate newAmountSat for the invoice
                // getSendMaxInfo to get *maxAmountSat* and *maxAmountFeeSat*
                // Create 1usd invoice to get payProUrl and *invoiceFeeSat*
                // getPayProDetails to get requiredFeeRate and calculate *payProFeeSat*
                // Get *transactionFee* comparing *maxAmountFeeSat* and *payProFeeSat*
                // Calculate newAmountSat = maxAmountSat - invoiceFeeSat - transactionFee
                this.logger.debug(`Calculating wallet send max`);
                this.getSendMaxInfo(wallet)
                    .then(maxValues => {
                    const maxAmountSat = maxValues.amount;
                    const maxAmountFeeSat = maxValues.feePerKb;
                    this.logger.debug(`getSendMaxInfo -> maxAmountSat: ${maxAmountSat} - maxAmountFeeSat: ${maxAmountFeeSat}`);
                    this.logger.debug(`Creating 1usd invoice`);
                    this.createInvoice({
                        invoicePrice: 1,
                        invoiceCurrency: 'USD',
                        transactionCurrency: COIN
                    })
                        .then(inv => {
                        // Check if COIN is enabled in this account
                        if (!this.isCryptoCurrencySupported(wallet.coin, inv)) {
                            return reject({
                                message: this.translate.instant('Top-up with this cryptocurrency is not enabled')
                            });
                        }
                        inv['minerFees'][COIN]['totalFee'] =
                            inv.minerFees[COIN].totalFee || 0;
                        const invoiceFeeSat = inv.minerFees[COIN].totalFee;
                        this.logger.debug(`createInvoice -> invoiceFeeSat: ${invoiceFeeSat}`);
                        const paymentCode = this.currencyProvider.getPaymentCode(wallet.coin);
                        const protocolUrl = inv.paymentCodes[COIN][paymentCode];
                        const payProUrl = this.incomingDataProvider.getPayProUrl(protocolUrl);
                        if (!payProUrl) {
                            return reject({
                                title: this.translate.instant('Error fetching this invoice'),
                                message: this.translate.instant('Invalid URL')
                            });
                        }
                        this.logger.debug(`createInvoice -> protocolUrl: ${payProUrl}`);
                        this.logger.debug(`Getting paypro details`);
                        this.walletProvider
                            .getAddress(wallet, false)
                            .then(address => {
                            const payload = {
                                address
                            };
                            this.payproProvider
                                .getPayProDetails({
                                paymentUrl: payProUrl,
                                coin: wallet.coin,
                                payload
                            })
                                .then(details => {
                                const payProFeeSat = !this.currencyProvider.isUtxoCoin(wallet.coin)
                                    ? details.requiredFeeRate
                                    : Math.ceil(details.requiredFeeRate * 1000);
                                this.logger.debug(`getPayProDetails -> payProFeeSat: ${payProFeeSat}`);
                                let transactionFee = payProFeeSat > maxAmountFeeSat
                                    ? payProFeeSat
                                    : maxAmountFeeSat;
                                this.logger.debug(`transactionFee: ${transactionFee}`);
                                let newAmountSat = maxAmountSat - invoiceFeeSat - transactionFee;
                                if (newAmountSat <= 0) {
                                    return reject({
                                        message: this.translate.instant('Insufficient funds for fee')
                                    });
                                }
                                this.logger.debug(`Calculating newAmountSat (newAmountSat = maxAmountSat - invoiceFeeSat - transactionFee). newAmountSat: ${newAmountSat}`);
                                return resolve({
                                    amount: newAmountSat,
                                    currency: 'sat'
                                });
                            })
                                .catch(err => {
                                throw {
                                    title: this.translate.instant('Error fetching this invoice'),
                                    message: this.bwcErrorProvider.msg(err)
                                };
                            });
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject({
                        title: null,
                        message: err
                    });
                });
            }
            else {
                return resolve({ amount: a, currency: c });
            }
        });
    }
    checkFeeHigh(amount, fee) {
        let per = (fee / (amount + fee)) * 100;
        if (per > FEE_TOO_HIGH_LIMIT_PER) {
            const minerFeeWarning = this.actionSheetProvider.createMinerFeeWarningComponent();
            minerFeeWarning.present({ maxHeight: '100%', minHeight: '100%' });
        }
    }
    logCardTopUpEvent(coin, isConfirm) {
        let cardTopupEventInfo = {
            usdAmount: this.amount,
            transactionCurrency: coin.toUpperCase()
        };
        const cardTopUpEventInfo = {
            usdAmount: this.amount,
            transactionCurrency: coin.toUpperCase()
        };
        let cardTopupAmountEventName = this.brand === 'Mastercard'
            ? 'mastercard_topup_amount'
            : 'legacycard_topup_amount';
        let cardTopupFinishEventName = this.brand === 'Mastercard'
            ? 'mastercard_topup_finish'
            : 'legacycard_topup_finish';
        !isConfirm
            ? this.bitPayCardProvider.logEvent(cardTopupAmountEventName, cardTopUpEventInfo)
            : this.bitPayCardProvider.logEvent(cardTopupFinishEventName, cardTopupEventInfo);
    }
    logCardPurchaseEvent() {
        this.brand === 'Mastercard'
            ? this.bitPayCardProvider.logEvent('purchase', {
                value: this.amount,
                items: [
                    {
                        name: 'mastercard',
                        category: 'debitCard',
                        quantity: 1,
                        price: this.amount
                    }
                ]
            })
            : this.bitPayCardProvider.logEvent('purchase', {
                value: this.amount,
                items: [
                    {
                        name: 'legacyCard',
                        category: 'debitCard',
                        quantity: 1,
                        price: this.amount
                    }
                ]
            });
    }
    initializeTopUp(wallet, parsedAmount) {
        let COIN = wallet.coin.toUpperCase();
        this.amountUnitStr = parsedAmount.amountUnitStr;
        var dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency
        };
        if (this.navParams.get('v2')) {
            const { amount, currency } = parsedAmount;
            let walletId;
            if (wallet && wallet.request && wallet.request.credentials) {
                walletId = wallet.request.credentials.walletId;
            }
            dataSrc = {
                invoicePrice: amount,
                invoiceCurrency: currency,
                transactionCurrency: COIN,
                walletId
            };
        }
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.logCardTopUpEvent(wallet.coin, false);
        this.logger.debug(`Creating invoice. amount: ${parsedAmount.amount} - currency: ${parsedAmount.currency}`);
        this.createInvoice(dataSrc)
            .then(invoice => {
            // Check if BTC or BCH is enabled in this account
            if (!this.isCryptoCurrencySupported(wallet.coin, invoice)) {
                let msg = this.translate.instant('Top-up with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            this.logger.debug(`Invoice fee. invoiceFeeSat: ${invoiceFeeSat}`);
            let message = this.amountUnitStr + ' to ' + this.lastFourDigits;
            // Set expiration time for this invoice
            if (invoice['expirationTime'])
                this.paymentTimeControl(invoice['expirationTime']);
            this.createTx(wallet, invoice, message)
                .then(ctxp => {
                this.onGoingProcessProvider.clear();
                // Save TX in memory
                this.createdTx = ctxp;
                this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount || parsedAmount.amountSat);
                if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                    // Warn: fee too high
                    this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
                }
                this.setTotalAmount(wallet.coin, parsedAmount.amountSat, Number(invoiceFeeSat), ctxp.fee);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
        });
    }
    initializeCoinbaseTopUp(account, parsedAmount) {
        let COIN = account.currency.code.toUpperCase();
        this.amountUnitStr = parsedAmount.amountUnitStr;
        var dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency
        };
        if (this.navParams.get('v2')) {
            const { amount, currency, coin } = parsedAmount;
            dataSrc = {
                invoicePrice: amount,
                invoiceCurrency: currency,
                transactionCurrency: coin.toUpperCase(),
                uuid: this.coinbaseProvider.coinbaseData.user.id,
                v2: true
            };
        }
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.logCardTopUpEvent(account.currency.code, false);
        this.logger.debug(`Creating invoice. amount: ${dataSrc.amount} - currency: ${dataSrc.currency}`);
        this.createInvoice(dataSrc)
            .then(invoice => {
            // Check if BTC or BCH is enabled in this account
            if (!this.isCryptoCurrencySupported(account.currency.code, invoice)) {
                let msg = this.translate.instant('Top-up with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            // Set expiration time for this invoice
            if (invoice['expirationTime'])
                this.paymentTimeControl(invoice['expirationTime']);
            this.onGoingProcessProvider.clear();
            // Save TX in memory
            this.createdTx = {};
            this.createdTx.invoiceId = invoice.id;
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(COIN.toLowerCase(), parsedAmount.amountSat);
            this.setTotalAmount(COIN.toLowerCase(), parsedAmount.amountSat);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
        });
    }
    logCardAddToCartEvent() {
        let cardName = this.brand === 'Mastercard' ? 'mastercard' : 'legacyCard';
        this.bitPayCardProvider.logEvent('add_to_cart', {
            items: [
                {
                    name: cardName,
                    category: 'debitCard'
                }
            ]
        });
    }
    topUpConfirm() {
        if (!this.createdTx) {
            this.showError(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        let title = this.translate.instant('Confirm');
        let message = 'Load ' + this.amountUnitStr;
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('topup');
            if (this.wallet) {
                this.publishAndSign(this.wallet, this.createdTx)
                    .then(() => {
                    this.logCardTopUpEvent(this.wallet.coin, true);
                    this.logCardPurchaseEvent();
                    this.onGoingProcessProvider.clear();
                    this.openFinishModal();
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    this._resetValues();
                    this.showError(this.translate.instant('Could not send transaction'), this.bwcErrorProvider.msg(err));
                });
            }
            else {
                this.topUpWithCoinbaseAccount();
            }
        });
    }
    topUpWithCoinbaseAccount(code) {
        this.onGoingProcessProvider.set('payingWithCoinbase');
        this.coinbaseProvider
            .payInvoice(this.createdTx.invoiceId, this.coinbaseAccount.currency.code, code)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.logCardTopUpEvent(this.coinbaseAccount.currency.code, true);
            this.logCardPurchaseEvent();
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err == '2fa') {
                const message = this.translate.instant('Enter 2-step verification');
                const opts = {
                    type: 'number',
                    enableBackdropDismiss: false
                };
                this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                    if (res === null) {
                        this.showError(null, this.translate.instant('Missing 2-step verification'));
                        return;
                    }
                    this.topUpWithCoinbaseAccount(res);
                });
            }
            else {
                this.onGoingProcessProvider.clear();
                this.showError(null, err);
            }
        });
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        this.countDown = setInterval(() => {
            this.setExpirationTime(expirationTime);
        }, 1000);
    }
    setExpirationTime(expirationTime) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (this.countDown) {
                clearInterval(this.countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    logCardSetCheckoutOption(wallet) {
        this.brand === 'Mastercard'
            ? this.bitPayCardProvider.logEvent('mastercard_set_checkout_option', {
                checkout_option: wallet.coin,
                checkout_step: 1
            })
            : this.bitPayCardProvider.logEvent('legacycard_set_checkout_option', {
                checkout_option: wallet.coin,
                checkout_step: 1
            });
    }
    onWalletSelect(option) {
        if (option.isCoinbaseAccount) {
            this.wallet = null;
            this.coinbaseAccount = option.accountSelected;
            const parsedAmount = this.txFormatProvider.parseAmount(option.accountSelected.currency.code.toLowerCase(), this.amount, this.currency);
            this.isERCToken = this.currencyProvider.isERCToken(option.accountSelected.currency.code.toLowerCase());
            if (this.countDown) {
                clearInterval(this.countDown);
            }
            if (!this.isERCToken) {
                // Update Rates
                this.updateRates(option.accountSelected.currency.code);
            }
            this.initializeCoinbaseTopUp(option.accountSelected, Object.assign({}, parsedAmount, { coin: option.accountSelected.currency.code }));
        }
        else {
            this.coinbaseAccount = null;
            const wallet = option;
            this.wallet = wallet;
            this.isERCToken = this.currencyProvider.isERCToken(this.wallet.coin);
            if (this.countDown) {
                clearInterval(this.countDown);
            }
            if (!this.isERCToken) {
                // Update Rates
                this.updateRates(wallet.coin);
            }
            this.onGoingProcessProvider.set('retrievingInputs');
            this.calculateAmount(wallet)
                .then(val => {
                let parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, val.amount, val.currency);
                this.initializeTopUp(wallet, Object.assign({}, parsedAmount, { coin: wallet.coin }));
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message).then(() => {
                    this.showWallets();
                });
            });
        }
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        let coinbaseData = { user: [], availableAccounts: [] };
        if (this.showCoinbase) {
            const minFiatCurrency = { amount: this.amount, currency: this.currency };
            coinbaseData = {
                user: this.coinbaseProvider.coinbaseData.user,
                availableAccounts: this.coinbaseProvider.getAvailableAccounts(null, minFiatCurrency)
            };
        }
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: this.translate.instant('From'),
            coinbaseData
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(option => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](option))
                this.onWalletSelect(option);
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        const finishComment = (this.wallet && this.wallet.credentials.m === 1) || this.coinbaseAccount
            ? this.translate.instant('Funds were added to debit card')
            : this.translate.instant('Transaction initiated');
        let finishText = '';
        const coin = this.wallet
            ? this.wallet.coin
            : this.coinbaseAccount.currency.code.toLowerCase();
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, coin }, { showBackdrop: true, enableBackdropDismiss: false });
        if (this.navParams.get('v2')) {
            this.iabCardProvider.updateCards();
            this.iabCardProvider.show();
            this.iabCardProvider.sendMessage({
                message: `topUpComplete?${this.cardId}`
            });
            setTimeout(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                yield this.navCtrl.popToRoot({ animate: false });
            }), 500);
        }
        else {
            modal.present();
            modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
                yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__tkcoin_card__["a" /* TKCoinCardPage */], { id: this.cardId }, { animate: false });
            }));
        }
    }
    openExternalLink(urlKey) {
        let url;
        let title;
        switch (urlKey) {
            case 'networkCost':
                url =
                    'https://support.tkcoin.org/hc/en-us/articles/115002990803-Why-Am-I-Being-Charged-an-Additional-Network-Cost-on-My-TKCoin-Invoice-';
                title = this.translate.instant('Network Cost');
                break;
            case 'minerFee':
                url =
                    'https://support.tkcoin.org/hc/en-us/articles/115003393863-What-are-bitcoin-miner-fees-Why-are-miner-fees-so-high-';
                title = this.translate.instant('Miner Fee');
                break;
        }
        let message = this.translate.instant('This information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, true, title, message, okText, cancelText);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:type", Object)
], TKCoinCardTopUpPage.prototype, "slideButton", void 0);
TKCoinCardTopUpPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tkcoin-card-topup',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-topup/tkcoin-card-topup.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">{{\'Add funds\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content [ngClass]="{\'add-padding-bottom\': isCordova}" no-bounce>\n  <ion-item>\n    <div class="tkcoin-title">\n      <ng-container *ngIf="brand === \'Mastercard\' else visa">\n        <img src="assets/img/tkcoin-card/tkcoin-card-mc.svg">\n        <span>BitPay Card</span>\n        <ion-note>\n          <span translate>Virtual</span>\n        </ion-note>\n        <ion-note>\n          <span translate>Physical</span>\n        </ion-note>\n      </ng-container>\n      <ng-template #visa>\n        <img src="assets/img/tkcoin-card/tkcoin-card-visa.svg">\n        <span>TKCoin Visa&reg; Card ({{lastFourDigits}})</span>\n      </ng-template>\n\n    </div>\n    <div class="amount-label">\n      <div class="amount">{{amountUnitStr}}</div>\n      <div class="alternative" *ngIf="wallet">\n        <span *ngIf="rate && !isERCToken">\n          @ {{rate | number:\'1.2-2\'}} {{currencyIsoCode}} per {{wallet.coin.toUpperCase()}}\n        </span>\n        <span *ngIf="!rate && !isERCToken">...</span>\n      </div>\n    </div>\n  </ion-item>\n\n  <div class="line-divider"></div>\n\n  <ion-list class="bp-list">\n\n    <ion-item class="sub-title">\n      <ion-label>\n        <div class="main-label" translate>SUMMARY</div>\n      </ion-label>\n    </ion-item>\n\n    <button ion-item detail-none (click)="showWallets()">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Sending from</span>\n        </div>\n      </ion-label>\n      <ion-note item-end>\n        <ion-row align-items-center class="wallet" *ngIf="wallet">\n          <ion-col>\n            <coin-icon [coin]="wallet.coin" [network]="wallet.network"></coin-icon>\n          </ion-col>\n\n          <ion-col>\n            <span class="note-container ellipsis">{{wallet.name}}</span>\n          </ion-col>\n        </ion-row>\n\n        <ion-row align-items-center class="wallet" *ngIf="coinbaseAccount">\n          <ion-col>\n            <ion-icon item-start>\n              <img src="assets/img/coinbase/coinbase-icon.png" width="32">\n            </ion-icon>\n          </ion-col>\n\n          <ion-col>\n            <span class="note-container ellipsis">{{coinbaseAccount.name}}</span>\n          </ion-col>\n        </ion-row>\n\n        <ion-row align-items-center class="wallet" *ngIf="!wallet && !coinbaseAccount">\n          <div translate>Select a wallet</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </ion-row>\n      </ion-note>\n    </button>\n\n    <div class="line-divider"></div>\n\n    <ion-item>\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Expires</span>\n        </div>\n      </ion-label>\n      <ion-note *ngIf="!paymentExpired" item-end><span [innerHTML]="remainingTimeStr"></span></ion-note>\n      <ion-note *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n    </ion-item>\n\n    <div class="line-divider"></div>\n\n    <ion-item>\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Funds to be added</span>\n        </div>\n      </ion-label>\n      <ion-note item-end>\n        <span *ngIf="amount">{{amount | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n        <span *ngIf="!amount">...</span>\n      </ion-note>\n    </ion-item>\n\n    <div *ngIf="invoiceFee && !coinbaseAccount" class="line-divider"></div>\n\n    <ion-item *ngIf="invoiceFee && !coinbaseAccount">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Network cost</span>\n          <ion-icon class="item-img info" (click)="openExternalLink(\'networkCost\')">\n            <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n          </ion-icon>\n        </div>\n      </ion-label>\n      <ion-note item-end>\n        <span>{{invoiceFee | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n      </ion-note>\n    </ion-item>\n\n    <div class="line-divider" *ngIf="!coinbaseAccount"></div>\n\n    <ion-item *ngIf="!coinbaseAccount">\n      <ion-label>\n        <div class="summary-item">\n          <span translate>Miner fee</span>\n          <ion-icon class="item-img info" (click)="openExternalLink(\'minerFee\')">\n            <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n          </ion-icon>\n        </div>\n      </ion-label>\n      <ion-note item-end>\n        <span>{{networkFee | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n      </ion-note>\n    </ion-item>\n\n    <div class="summary-line"></div>\n\n    <ion-item>\n      <ion-label>\n        <div class="main-label total-label">TOTAL</div>\n      </ion-label>\n      <ion-note item-end>\n        <div class="total-amount">\n          <span *ngIf="totalAmountStr && !isERCToken">{{totalAmountStr}}</span>\n          <span *ngIf="totalAmount && isERCToken">{{totalAmount | number:\'1.2-2\'}} {{currencyIsoCode}} </span>\n        </div>\n      </ion-note>\n    </ion-item>\n    <div *ngIf="totalAmount && !isERCToken" class="amount-details">\n      <div class="secondary-note">\n        {{totalAmount | number:\'1.2-2\'}} {{currencyIsoCode}}\n      </div>\n    </div>\n  </ion-list>\n  <div *ngIf="brand === \'Mastercard\'" class="card-terms">\n    BY USING THIS CARD YOU AGREE WITH THE TERMS AND CONDITIONS OF THE CARDHOLDER AGREEMENT AND FEE SCHEDULE, IF ANY. This card is issued by Metropolitan Commercial Bank (Member FDIC) pursuant to a license from Mastercard International. "Metropolitan Commercial Bank" and "Metropolitan" are registered trademarks of Metropolitan Commercial Bank 2014.<br><br>\n    Mastercard is a registered trademark and the circles design is a trademark of Mastercard International Incorporated.\n  </div>\n\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!((wallet || coinbaseAccount) && totalAmountStr) || paymentExpired" buttonText="{{\'Slide to confirm\' | translate}}" [isDogecoin]="wallet && wallet.coin == \'doge\'" (slideDone)="topUpConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="topUpConfirm()" [disabled]="!((wallet || coinbaseAccount) && totalAmountStr) ||paymentExpired">\n      {{\'Add funds\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-card-topup/tkcoin-card-topup.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_24__providers_tkcoin_card_tkcoin_card__["a" /* TKCoinCardProvider */],
        __WEBPACK_IMPORTED_MODULE_25__providers_tkcoin_tkcoin__["a" /* TKCoinProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["P" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_19__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_21__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["N" /* IABCardProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_errors_errors__["a" /* ErrorsProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_coinbase_coinbase__["a" /* CoinbaseProvider */]])
], TKCoinCardTopUpPage);

//# sourceMappingURL=tkcoin-card-topup.js.map

/***/ }),

/***/ 987:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CryptoSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_integrations_simplex_simplex__ = __webpack_require__(397);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_integrations_wyre_wyre__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_buy_crypto_buy_crypto__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_theme_theme__ = __webpack_require__(56);




// Pages


// Providers





let CryptoSettingsPage = class CryptoSettingsPage {
    constructor(configProvider, homeIntegrationsProvider, logger, navCtrl, buyCryptoProvider, themeProvider) {
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.buyCryptoProvider = buyCryptoProvider;
        this.themeProvider = themeProvider;
        this.serviceName = 'buycrypto';
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CryptoSettingsPage');
    }
    ionViewWillEnter() {
        this.buyCryptoProvider.getPaymentRequests().then(res => {
            this.simplexPaymentRequests = res.simplexPaymentRequests;
            this.wyrePaymentRequests = res.wyrePaymentRequests;
        });
    }
    goToSimplexPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__pages_integrations_simplex_simplex__["a" /* SimplexPage */]);
    }
    goToWyrePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__pages_integrations_wyre_wyre__["a" /* WyrePage */]);
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
};
CryptoSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-crypto-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-settings/crypto-settings.html"*/'<wide-header-page title="{{\'Buy Crypto Settings\' | translate}}">\n  <div page-content>\n    <ion-list class="bp-list top-padding">\n      <ion-item>\n        <ion-label>{{\'Show "Buy Crypto"\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n      </ion-item>\n      <div *ngIf="simplexPaymentRequests?.length || wyrePaymentRequests?.length">\n        <ion-item-divider>{{\'Used Exchanges\' | translate}}</ion-item-divider>\n        <ion-list class="bp-list">\n          <button *ngIf="simplexPaymentRequests?.length" ion-item (click)="goToSimplexPage()">\n            <ion-icon class="item-img" item-start>\n              <img [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/simplex/logo-simplex-color.svg\' : \'assets/img/simplex/logo-simplex-dm.png\'">\n            </ion-icon>\n          </button>\n          <button *ngIf="wyrePaymentRequests?.length" ion-item (click)="goToWyrePage()">\n            <ion-icon class="item-img" item-start>\n              <img [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/wyre/logo-wyre.svg\' : \'assets/img/wyre/logo-wyre-dm.svg\'">\n            </ion-icon>\n          </button>\n        </ion-list>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/buy-crypto/crypto-settings/crypto-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_buy_crypto_buy_crypto__["a" /* BuyCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_theme_theme__["a" /* ThemeProvider */]])
], CryptoSettingsPage);

//# sourceMappingURL=crypto-settings.js.map

/***/ }),

/***/ 988:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimplexDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_simplex_simplex__ = __webpack_require__(228);




// Providers




let SimplexDetailsPage = class SimplexDetailsPage {
    constructor(externalLinkProvider, logger, navParams, popupProvider, simplexProvider, translate, viewCtrl) {
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.simplexProvider = simplexProvider;
        this.translate = translate;
        this.viewCtrl = viewCtrl;
        this.paymentRequest = this.navParams.data.paymentRequestData;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SimplexDetailsPage');
    }
    remove() {
        const title = this.translate.instant('Removing Payment Request Data');
        const message = this.translate.instant("The data of this payment request will be deleted. Make sure you don't need it");
        const okText = this.translate.instant('Remove');
        const cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.simplexProvider
                    .saveSimplex(this.paymentRequest, {
                    remove: true
                })
                    .then(() => {
                    this.close();
                });
            }
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
SimplexDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-simplex-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/simplex/simplex-details/simplex-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">\n      {{\'Order Details\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="header-modal" *ngIf="paymentRequest">\n    <div class="title-modal" translate>\n      Approximate receiving amount\n    </div>\n\n    <div class="subtitle-modal">\n      <img class="icon-service" src="assets/img/simplex/icon-simplex.png" alt="Simplex" width="40">\n      {{ paymentRequest.crypto_amount | number:\'1.0-6\'}}\n      <span class="amount-unit">{{ paymentRequest.coin }}</span>\n    </div>\n  </div>\n\n  <ion-list class="bp-list" *ngIf="paymentRequest">\n    <ion-item-divider></ion-item-divider>\n    <ion-item *ngIf="paymentRequest.fiat_base_amount">\n      {{\'Approximate receiving fiat amount\' | translate}}\n      <ion-note item-end>\n        <span>\n          {{ paymentRequest.fiat_base_amount }} {{ paymentRequest.fiat_total_amount_currency }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <label-tip type="warn" header="no-header">\n      <div label-tip-body>\n        <div translate>The final crypto amount you receive when the transaction is complete may differ because it is based on Simplex\'s exchange rate.</div>\n      </div>\n    </label-tip>\n\n    <ion-item>\n      {{\'Paying\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!paymentRequest.fiat_total_amount">...</span>\n        <span *ngIf="paymentRequest.fiat_total_amount">\n          {{ paymentRequest.fiat_total_amount }} {{ paymentRequest.fiat_total_amount_currency }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Created\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!paymentRequest.created_on">...</span>\n        <span *ngIf="paymentRequest.created_on">\n          {{ paymentRequest.created_on | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="paymentRequest.status == \'success\' || paymentRequest.status == \'failed\'">\n      {{\'Status\' | translate}}\n      <ion-note item-end>\n        <span class="assertive" *ngIf="paymentRequest.status == \'failed\'" translate>Payment request rejected</span>\n        <span class="balanced" *ngIf="paymentRequest.status == \'success\'" translate>Payment request approved</span>\n      </ion-note>\n    </ion-item>\n\n    <label-tip type="info" header="no-header" *ngIf="paymentRequest.status == \'paymentRequestSent\' || paymentRequest.status == \'success\'">\n      <div label-tip-body>\n        <span translate>If you have successfully completed the entire payment process, remember that receiving crypto usually takes up to 1 hour.</span>\n        <br>\n        <br>\n        <a class="pointer" (click)="openExternalLink(\'https://payment-status.simplex.com/#/\')" translate>What is the status of my payment?</a>\n      </div>\n    </label-tip>\n\n    <ion-item>\n      {{\'Deposit address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.address">...</span>\n          <span *ngIf="paymentRequest.address" copy-to-clipboard="{{paymentRequest.address}}">\n            {{ paymentRequest.address }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item>\n      {{\'Payment ID\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.payment_id">...</span>\n          <span *ngIf="paymentRequest.payment_id" copy-to-clipboard="{{paymentRequest.payment_id}}">\n            {{ paymentRequest.payment_id }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item class="no-border">\n      {{\'Order ID\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.order_id">...</span>\n          <span *ngIf="paymentRequest.order_id" copy-to-clipboard="{{paymentRequest.order_id}}">\n            {{ paymentRequest.order_id }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n    <button class="assertive" ion-item detail-none text-center (click)="remove()">\n      {{\'Remove\' | translate}}\n    </button>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/simplex/simplex-details/simplex-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_simplex_simplex__["a" /* SimplexProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */]])
], SimplexDetailsPage);

//# sourceMappingURL=simplex-details.js.map

/***/ }),

/***/ 989:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WyreDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_theme_theme__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wyre_wyre__ = __webpack_require__(289);





// Providers





let WyreDetailsPage = class WyreDetailsPage {
    constructor(externalLinkProvider, logger, navParams, popupProvider, wyreProvider, translate, viewCtrl, themeProvider) {
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.wyreProvider = wyreProvider;
        this.translate = translate;
        this.viewCtrl = viewCtrl;
        this.themeProvider = themeProvider;
        this.paymentRequest = this.navParams.data.paymentRequestData;
        this.paymentRequest.fiatBaseAmount = this.paymentRequest.purchaseAmount
            ? this.paymentRequest.purchaseAmount
            : +this.paymentRequest.sourceAmount - +this.paymentRequest.fee;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WyreDetailsPage');
    }
    ionViewWillEnter() {
        if (this.paymentRequest.orderId &&
            (this.paymentRequest.status != 'success' ||
                !this.paymentRequest.transferId ||
                (this.paymentRequest.transferId &&
                    !this.paymentRequest.blockchainNetworkTx))) {
            this.logger.info('Wyre Details: trying to get order details data');
            this.wyreProvider
                .getWalletOrderDetails(this.paymentRequest.orderId)
                .then((orderData) => {
                this.logger.debug('Wyre get order details: SUCCESS!');
                this.logger.debug('order Data: ', orderData);
                if (orderData && !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](orderData)) {
                    switch (orderData.status) {
                        case 'RUNNING_CHECKS':
                            this.paymentRequest.status = 'paymentRequestSent';
                            break;
                        case 'PROCESSING':
                            this.paymentRequest.status = 'paymentRequestSent';
                            break;
                        case 'FAILED':
                            this.paymentRequest.status = 'failed';
                            break;
                        case 'COMPLETE':
                            this.paymentRequest.status = 'success';
                            break;
                        default:
                            this.paymentRequest.status = 'paymentRequestSent';
                            break;
                    }
                    this.paymentRequest.sourceAmount = orderData.sourceAmount;
                    this.paymentRequest.fee =
                        orderData.sourceAmount &&
                            orderData.purchaseAmount &&
                            orderData.sourceAmount - orderData.purchaseAmount >= 0
                            ? orderData.sourceAmount - orderData.purchaseAmount
                            : null; // Total fee (crypto fee + Wyre fee)
                    this.paymentRequest.destCurrency = orderData.destCurrency;
                    this.paymentRequest.sourceCurrency = orderData.sourceCurrency;
                    if (orderData.transferId) {
                        this.paymentRequest.transferId = orderData.transferId;
                        this.logger.info('Wyre Details: trying to get transaction info');
                        this.wyreProvider
                            .getTransfer(this.paymentRequest.transferId)
                            .then((transferData) => {
                            this.paymentRequest.blockchainNetworkTx =
                                transferData.blockchainNetworkTx;
                            this.paymentRequest.destAmount = transferData.destAmount;
                            this.saveWyrePaymentRequest();
                        })
                            .catch(_err => {
                            this.logger.warn('Could not get transfer for transferId: ' +
                                this.paymentRequest.transferId);
                            this.saveWyrePaymentRequest();
                        });
                    }
                    else {
                        this.saveWyrePaymentRequest();
                    }
                }
            })
                .catch(_err => {
                this.logger.warn('Could not get order details for orderId: ' +
                    this.paymentRequest.orderId);
            });
        }
    }
    saveWyrePaymentRequest() {
        this.wyreProvider
            .saveWyre(this.paymentRequest, null)
            .then(() => {
            this.logger.debug('Saved Wyre with orderId: ' + this.paymentRequest.orderId);
        })
            .catch(() => {
            this.logger.warn('Could not update payment request status');
        });
    }
    remove() {
        const title = this.translate.instant('Removing Payment Request Data');
        const message = this.translate.instant("The data of this payment request will be deleted. Make sure you don't need it");
        const okText = this.translate.instant('Remove');
        const cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.wyreProvider
                    .saveWyre(this.paymentRequest, {
                    remove: true
                })
                    .then(() => {
                    this.close(this.paymentRequest.orderId);
                });
            }
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    close(removedPaymentRequest) {
        this.viewCtrl.dismiss({ removedPaymentRequest });
    }
};
WyreDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wyre-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wyre/wyre-details/wyre-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">\n      {{\'Order Details\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="header-modal" *ngIf="paymentRequest">\n    <div class="title-modal" translate>\n      Approximate receiving amount\n    </div>\n\n    <div class="subtitle-modal">\n      <img class="icon-service" [src]="themeProvider.currentAppTheme !== \'dark\' ? \'assets/img/wyre/logo-wyre.svg\' : \'assets/img/wyre/logo-wyre-dm.svg\'" alt="Wyre" width="40">\n      {{ paymentRequest.destAmount | number:\'1.0-6\'}}\n      <span class="amount-unit">{{ paymentRequest.destCurrency }}</span>\n    </div>\n  </div>\n\n  <ion-list class="bp-list" *ngIf="paymentRequest">\n    <ion-item-divider></ion-item-divider>\n    <ion-item *ngIf="paymentRequest.fiatBaseAmount">\n      {{\'Approximate receiving fiat amount\' | translate}}\n      <ion-note item-end>\n        <span>\n          {{ paymentRequest.fiatBaseAmount }} {{ paymentRequest.sourceCurrency }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <label-tip type="warn" header="no-header">\n      <div label-tip-body>\n        <div translate>The final crypto amount you receive when the transaction is complete may differ because it is based on Wyre\'s exchange rate.</div>\n      </div>\n    </label-tip>\n\n    <ion-item>\n      {{\'Paying\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!paymentRequest.sourceAmount">...</span>\n        <span *ngIf="paymentRequest.sourceAmount">\n          {{ paymentRequest.sourceAmount }} {{ paymentRequest.sourceCurrency }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Created\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!paymentRequest.created_on">...</span>\n        <span *ngIf="paymentRequest.created_on">\n          {{ paymentRequest.created_on | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="paymentRequest.status == \'success\' || paymentRequest.status == \'failed\'">\n      {{\'Status\' | translate}}\n      <ion-note item-end>\n        <span class="assertive" *ngIf="paymentRequest.status == \'failed\'" translate>Payment request rejected</span>\n        <span *ngIf="paymentRequest.status == \'paymentRequestSent\'" translate>Payment request sent</span>\n        <span class="balanced" *ngIf="paymentRequest.status == \'success\'" translate>Payment request approved</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Deposit address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.dest">...</span>\n          <span *ngIf="paymentRequest.dest" copy-to-clipboard="{{paymentRequest.dest}}">\n            {{ paymentRequest.dest }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="paymentRequest.paymentMethodName">\n      {{\'Payment method\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span copy-to-clipboard="{{paymentRequest.paymentMethodName}}">\n            {{ paymentRequest.paymentMethodName }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item>\n      Transfer ID\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.transferId">...</span>\n          <span *ngIf="paymentRequest.transferId" copy-to-clipboard="{{paymentRequest.transferId}}">\n            {{ paymentRequest.transferId }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item class="no-border">\n      {{\'Order ID\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.orderId">...</span>\n          <span *ngIf="paymentRequest.orderId" copy-to-clipboard="{{paymentRequest.orderId}}">\n            {{ paymentRequest.orderId }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item class="no-border">\n      Blockchain Network Tx\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!paymentRequest.blockchainNetworkTx">...</span>\n          <span *ngIf="paymentRequest.blockchainNetworkTx" copy-to-clipboard="{{paymentRequest.blockchainNetworkTx}}">\n            {{ paymentRequest.blockchainNetworkTx }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n    <button class="assertive" ion-item detail-none text-center (click)="remove()">\n      {{\'Remove\' | translate}}\n    </button>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/wyre/wyre-details/wyre-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wyre_wyre__["a" /* WyreProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_theme_theme__["a" /* ThemeProvider */]])
], WyreDetailsPage);

//# sourceMappingURL=wyre-details.js.map

/***/ }),

/***/ 990:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExchangeCryptoSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_integrations_changelly_changelly__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_exchange_crypto_exchange_crypto__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__ = __webpack_require__(56);




// Pages

// Providers





let ExchangeCryptoSettingsPage = class ExchangeCryptoSettingsPage {
    constructor(configProvider, homeIntegrationsProvider, logger, themeProvider, exchangeCryptoProvider, navCtrl) {
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.themeProvider = themeProvider;
        this.exchangeCryptoProvider = exchangeCryptoProvider;
        this.navCtrl = navCtrl;
        this.serviceName = 'exchangecrypto';
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ExchangeCryptoSettingsPage');
    }
    ionViewWillEnter() {
        this.exchangeCryptoProvider.getSwapTxs().then(res => {
            this.changellySwapTxs = res.changellySwapTxs;
            // this.shpeshiftSwapTxs = res.shpeshiftSwapTxs;
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    goToChangellyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__pages_integrations_changelly_changelly__["a" /* ChangellyPage */]);
    }
};
ExchangeCryptoSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-exchange-crypto-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-crypto-settings/exchange-crypto-settings.html"*/'<wide-header-page title="{{\'Exchange Crypto Settings\' | translate}}">\n  <div page-content>\n    <ion-list class="bp-list top-padding">\n      <ion-item>\n        <ion-label>{{\'Show "Exchange Crypto"\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n      </ion-item>\n      <div *ngIf="changellySwapTxs?.length">\n        <ion-item-divider>{{\'Used Exchanges\' | translate}}</ion-item-divider>\n        <ion-list class="bp-list">\n          <button *ngIf="changellySwapTxs?.length" ion-item (click)="goToChangellyPage()">\n            <ion-icon class="item-img" item-start>\n              <img src="assets/img/exchange-crypto/changelly-vector-logo{{themeProvider.isDarkModeEnabled() ? \'-dark\' : \'\'}}.svg">\n            </ion-icon>\n          </button>\n        </ion-list>\n      </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/exchange-crypto/exchange-crypto-settings/exchange-crypto-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_theme_theme__["a" /* ThemeProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_exchange_crypto_exchange_crypto__["a" /* ExchangeCryptoProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */]])
], ExchangeCryptoSettingsPage);

//# sourceMappingURL=exchange-crypto-settings.js.map

/***/ }),

/***/ 991:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChangellyDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_changelly_changelly__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(25);




// Providers




let ChangellyDetailsPage = class ChangellyDetailsPage {
    constructor(externalLinkProvider, logger, navParams, popupProvider, changellyProvider, translate, viewCtrl) {
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.changellyProvider = changellyProvider;
        this.translate = translate;
        this.viewCtrl = viewCtrl;
        this.swapTxData = this.navParams.data.swapTxData;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ChangellyDetailsPage');
    }
    ionViewWillEnter() {
        this.updateStatusDescription();
        this.getStatus();
    }
    updateStatusDescription() {
        this.status = this.changellyProvider.getStatusDetails(this.swapTxData.status);
    }
    doRefresh(refresher) {
        this.logger.info('Forcing status query');
        this.getStatus(true);
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
    getStatus(force) {
        if (this.swapTxData.status == 'finished' && !force)
            return;
        this.changellyProvider
            .getStatus(this.swapTxData.exchangeTxId, this.swapTxData.status)
            .then(data => {
            if (data.error) {
                this.logger.error('Changelly getStatus Error: ' + data.error.message);
                return;
            }
            if (data.result != this.swapTxData.status) {
                this.logger.debug('Updating status to: ' + data.result);
                this.swapTxData.status = data.result;
                this.updateStatusDescription();
                this.changellyProvider.saveChangelly(this.swapTxData, {
                    status: data.result
                });
            }
        })
            .catch(err => {
            this.logger.error('Changelly getStatus Error: ', err);
        });
    }
    remove() {
        const title = this.translate.instant('Removing Transaction Data');
        const message = this.translate.instant("The data of this exchange will be deleted from your device. Make sure you don't need it");
        const okText = this.translate.instant('Remove');
        const cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then((res) => {
            if (res) {
                this.changellyProvider
                    .saveChangelly(this.swapTxData, {
                    remove: true
                })
                    .then(() => {
                    this.close();
                });
            }
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
ChangellyDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-changelly-details',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly-details/changelly-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title class="bp-title">\n      {{\'Details\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button class="close-container disable-hover" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="160">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="header-modal" *ngIf="swapTxData">\n    <div class="title-modal" translate>\n      Receiving amount\n    </div>\n\n    <div class="subtitle-modal">\n      <img class="icon-service" src="assets/img/exchange-crypto/changelly-icon.svg" alt="Changelly" width="40">\n      {{ swapTxData.amountTo | number:\'1.0-6\'}}\n      <span class="amount-unit">{{ swapTxData.coinTo | uppercase }}</span>\n    </div>\n  </div>\n\n  <ion-list class="bp-list" *ngIf="swapTxData">\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      {{\'Deposit address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!swapTxData.addressTo">...</span>\n          <span *ngIf="swapTxData.addressTo" copy-to-clipboard="{{swapTxData.addressTo}}">\n            {{ swapTxData.addressTo }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item>\n      {{\'Paying\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!swapTxData.amountFrom">...</span>\n        <span *ngIf="swapTxData.amountFrom">\n          {{ swapTxData.amountFrom | number:\'1.0-6\' }} {{ swapTxData.coinFrom | uppercase }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Created\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!swapTxData.date">...</span>\n        <span *ngIf="swapTxData.date">\n          {{ swapTxData.date | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="swapTxData.status && status?.statusTitle">\n      {{\'Status\' | translate}}\n      <ion-note item-end>\n        <span [ngClass]="{balanced: [\'finished\', \'refunded\'].includes(swapTxData.status), assertive: [\'failed\', \'expired\'].includes(swapTxData.status), energized: [\'waiting\', \'confirming\', \'exchanging\', \'sending\', \'hold\'].includes(swapTxData.status)}" translate>{{ status.statusTitle }}</span>\n      </ion-note>\n    </ion-item>\n\n    <label-tip class="right-arrow" type="info" header="no-header" *ngIf="swapTxData.status && status?.statusDescription">\n      <div label-tip-body>\n        <span>{{ status.statusDescription }}</span>\n        <br>\n        <div *ngIf="[\'failed\', \'hold\'].includes(swapTxData.status)">\n          <span translate>Please contact Changelly support:</span><b class="pointer" copy-to-clipboard="security@changelly.com"> security@changelly.com</b>\n          <br><br>\n          <span translate>Provide the transaction id:</span><b class="pointer" copy-to-clipboard="{{swapTxData.exchangeTxId}}"> {{swapTxData.exchangeTxId}}</b>\n        </div>\n      </div>\n    </label-tip>\n\n    <ion-item>\n      {{\'Exchange address (Payin)\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!swapTxData.payinAddress">...</span>\n          <span *ngIf="swapTxData.payinAddress" copy-to-clipboard="{{swapTxData.payinAddress}}">\n            {{ swapTxData.payinAddress }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="swapTxData.payinExtraId">\n      {{\'Destination Tag (Payin Extra Id)\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="swapTxData.payinExtraId" copy-to-clipboard="{{swapTxData.payinExtraId}}">\n            {{ swapTxData.payinExtraId }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item>\n      {{\'Refund address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!swapTxData.refundAddress">...</span>\n          <span *ngIf="swapTxData.refundAddress" copy-to-clipboard="{{swapTxData.refundAddress}}">\n            {{ swapTxData.refundAddress }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item>\n      {{\'Exchange Transaction ID\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!swapTxData.exchangeTxId">...</span>\n          <span *ngIf="swapTxData.exchangeTxId" copy-to-clipboard="{{swapTxData.exchangeTxId}}">\n            {{ swapTxData.exchangeTxId }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n\n    <ion-item-divider></ion-item-divider>\n    <button class="assertive" ion-item detail-none text-center (click)="remove()">\n      {{\'Remove\' | translate}}\n    </button>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/changelly/changelly-details/changelly-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_changelly_changelly__["a" /* ChangellyProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */]])
], ChangellyDetailsPage);

//# sourceMappingURL=changelly-details.js.map

/***/ }),

/***/ 992:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__coinbase__ = __webpack_require__(299);




// Providers





let CoinbaseSettingsPage = class CoinbaseSettingsPage {
    constructor(navCtrl, popupProvider, coinbaseProvider, configProvider, homeIntegrationsProvider) {
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'coinbase';
        this.data = {};
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewWillEnter() {
        this.hasCredentials = !!this.coinbaseProvider.oauthUrl;
        this.linkedAccount = this.coinbaseProvider.isLinked();
        if (this.linkedAccount)
            this.coinbaseProvider.getCurrentUser(this.data);
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    revokeToken() {
        this.popupProvider
            .ionicConfirm('Coinbase', 'Are you sure you would like to log out of your Coinbase account?')
            .then(res => {
            if (res) {
                this.coinbaseProvider.logout();
                this.navCtrl.popToRoot();
            }
        });
    }
    goToCoinbase() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__coinbase__["a" /* CoinbasePage */], { animate: false }).then(() => {
            const previousView = this.navCtrl.getPrevious();
            this.navCtrl.removeView(previousView);
        });
    }
};
CoinbaseSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title class="bp-title">\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img src="assets/img/coinbase/coinbase-logo.png" width="70">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea no-bounce>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          <img src="assets/img/coinbase/coinbase-logo.png" width="150">\n          <div class="email-account" *ngIf="linkedAccount">{{data?.user?.email || \'...\'}}</div>\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list">\n      <ion-item>\n        <ion-label>{{\'Show on wallet tab\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n      </ion-item>\n    </ion-list>\n\n    <div *ngIf="hasCredentials && !linkedAccount" class="connect-button">\n      <button ion-button class="button-standard" (click)="goToCoinbase()">\n        <span translate>Connect Coinbase Account</span>\n      </button>\n    </div>\n    <div *ngIf="!hasCredentials && !linkedAccount" text-center translate>\n      Missing Credentials\n    </div>\n\n    <ion-list *ngIf="linkedAccount" class="bp-list">\n      <ion-item>\n        <ion-label>{{\'Name\' | translate}}</ion-label>\n        <ion-note item-end>\n          {{ data?.user?.name }}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <ion-label>{{\'Native Currency\' | translate}}</ion-label>\n        <ion-note item-end>\n          {{ data?.user?.native_currency }}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <ion-label>{{\'Country\' | translate}}</ion-label>\n        <ion-note item-end>\n          {{ data?.user?.country?.name }}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <button *ngIf="linkedAccount" ion-button class="button-standard" color="danger" (click)="revokeToken()">\n      {{\'Log out\' | translate}}\n    </button>\n\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], CoinbaseSettingsPage);

//# sourceMappingURL=coinbase-settings.js.map

/***/ }),

/***/ 993:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardsSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gift_card_settings_gift_card_settings__ = __webpack_require__(994);






let GiftCardsSettingsPage = class GiftCardsSettingsPage {
    constructor(configProvider, giftCardProvider, homeIntegrationsProvider, nav) {
        this.configProvider = configProvider;
        this.giftCardProvider = giftCardProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.nav = nav;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.showAtHome = this.homeIntegrationsProvider.shouldShowInHome('giftcards');
            const purchasedCards = yield this.giftCardProvider.getPurchasedBrands();
            this.purchasedBrands = __WEBPACK_IMPORTED_MODULE_3_lodash__["uniqBy"](purchasedCards, ([cards]) => cards.displayName);
        });
    }
    goToCardSettings(cardName) {
        this.nav.push(__WEBPACK_IMPORTED_MODULE_5__gift_card_settings_gift_card_settings__["a" /* GiftCardSettingsPage */], { cardName });
    }
    integrationChange() {
        this.homeIntegrationsProvider.updateConfig('giftcards', this.showAtHome);
        this.configProvider.set({
            showIntegration: { giftcards: this.showAtHome }
        });
    }
};
GiftCardsSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-cards-settings-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/gift-cards-settings/gift-cards-settings.html"*/'<wide-header-page title="{{\'Gift Card Settings\' | translate}}">\n  <div page-content>\n    <ion-list class="bp-list top-padding">\n      <ion-item>\n        <ion-label>{{\'Show\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showAtHome" (ionChange)="integrationChange()"></ion-toggle>\n      </ion-item>\n      <ion-item-divider *ngIf="purchasedBrands?.length">{{\'Purchased Brands\' | translate}}</ion-item-divider>\n      <card-list-item *ngFor="let brandCards of purchasedBrands" [card]="brandCards[0]" type="settings" (click)="goToCardSettings(brandCards[0].name)"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/gift-cards-settings/gift-cards-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["s" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["L" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["M" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */]])
], GiftCardsSettingsPage);

//# sourceMappingURL=gift-cards-settings.js.map

/***/ }),

/***/ 994:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__purchased_cards_purchased_cards__ = __webpack_require__(394);







let GiftCardSettingsPage = class GiftCardSettingsPage extends __WEBPACK_IMPORTED_MODULE_6__purchased_cards_purchased_cards__["b" /* PurchasedCardsPage */] {
    constructor(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams, popupProvider, translate) {
        super(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams);
        this.popupProvider = popupProvider;
        this.translate = translate;
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.initialize();
        });
    }
    getCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            yield this.giftCardProvider
                .getAllCardsOfBrand(this.cardConfig.displayName)
                .then(cards => this.setGiftCards(cards))
                .catch(err => this.logger.error(err));
            this.giftCardProvider.updatePendingGiftCards(this.currentGiftCards);
        });
    }
    initialize() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["__awaiter"](this, void 0, void 0, function* () {
            this.email = yield this.giftCardProvider.getUserEmail();
        });
    }
    setEmail() {
        let title = this.translate.instant('Enter email address');
        let message = this.translate.instant('Where would you like to receive your Amazon gift card purchase receipts?');
        let opts = { type: 'email', defaultText: this.email || '' };
        this.popupProvider.ionicPrompt(title, message, opts).then(email => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isNull"](email))
                return;
            if (this.email == email)
                return;
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](email) && !this.giftCardProvider.emailIsValid(email)) {
                let t = this.translate.instant('Invalid Email');
                let ok = this.translate.instant('Try again');
                this.popupProvider.ionicAlert(t, null, ok).then(_ => {
                    this.setEmail();
                });
                return;
            }
            this.email = email;
            this.giftCardProvider.storeEmail(this.email);
        });
    }
    removePageFromHistory() {
        // Override extended behavior and don't remove page from history.
    }
};
GiftCardSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-card-settings-page',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/gift-card-settings/gift-card-settings.html"*/'<wide-header-page title="{{cardConfig?.displayName}}">\n  <div page-content>\n\n    <ion-list class="bp-list" [ngClass]="{\'top-padding\': cardConfig?.displayName === \'Amazon\'}">\n      <button (click)="setEmail()" ion-item *ngIf="cardConfig?.displayName === \'Amazon\'">\n        <ion-label>{{ \'Receipt Email\' | translate }}</ion-label>\n        <ion-note item-end>\n          {{ email || (\'Not set\' | translate) }}\n        </ion-note>\n      </button>\n      <ion-item-divider *ngIf="currentGiftCards && currentGiftCards.length">{{\'Current Cards\' | translate}}\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of currentGiftCards" [card]="card" type="purchased"\n        (click)="goToCardDetails(card)"></card-list-item>\n      <ion-item-divider *ngIf="archivedGiftCards && archivedGiftCards.length">{{\'Archived Cards\' | translate}}\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of archivedGiftCards" [card]="card" type="purchased"\n        (click)="goToCardDetails(card)"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/gift-cards/gift-card-settings/gift-card-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["L" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["_4" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], GiftCardSettingsPage);

//# sourceMappingURL=gift-card-settings.js.map

/***/ }),

/***/ 995:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TKCoinSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_tkcoin_account_tkcoin_account__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tkcoin_card_tkcoin_card__ = __webpack_require__(208);




// Providers







let TKCoinSettingsPage = class TKCoinSettingsPage {
    constructor(navParams, navCtrl, tkcoinAccountProvider, bitPayCardProvider, popupProvider, configProvider, translate, homeIntegrationsProvider, actionSheetCtrl, externalLinkProvider) {
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.tkcoinAccountProvider = tkcoinAccountProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.popupProvider = popupProvider;
        this.configProvider = configProvider;
        this.translate = translate;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.actionSheetCtrl = actionSheetCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.serviceName = 'debitcard';
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showAtHome = !!this.service[0].show;
    }
    ionViewWillEnter() {
        let cardId = this.navParams.data.id;
        if (cardId) {
            this.bitPayCardProvider.getCards(cards => {
                this.tkcoinCard = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](cards, { id: cardId });
            });
        }
        else {
            this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
                name: this.serviceName
            });
            this.showAtHome = !!this.service[0].show;
        }
        this.tkcoinAccountProvider.getAccounts((err, accounts) => {
            if (err) {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            }
            this.accounts = accounts;
        });
    }
    integrationChange() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showAtHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showAtHome);
        this.configProvider.set(opts);
    }
    unlinkCard(card) {
        let title = 'Unlink BitPay Card?';
        let msg = 'Are you sure you would like to remove your BitPay Card (' +
            card.lastFourDigits +
            ') from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.bitPayCardProvider.remove(card.id, err => {
                    if (err) {
                        this.popupProvider.ionicAlert('Error', 'Could not remove the card');
                        return;
                    }
                    this.navCtrl.pop();
                });
            }
        });
    }
    unlinkAccount(card) {
        let title = 'Unlink TKCoin Account?';
        let msg = 'Are you sure you would like to remove your TKCoin Account (' +
            card.email +
            ') and all associated cards from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.tkcoinAccountProvider.removeAccount(card.email, () => {
                    this.navCtrl.pop();
                });
            }
        });
    }
    connectTKCoinCard() {
        this.bitPayCardProvider.logEvent('legacycard_connect', {});
        if (this.accounts.length == 0) {
            this.startPairTKCoinAccount();
        }
        else {
            this.showAccountSelector();
        }
    }
    showAccountSelector() {
        let options = [];
        __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](this.accounts, account => {
            options.push({
                text: (account.givenName || account.familyName) +
                    ' (' +
                    account.email +
                    ')',
                handler: () => {
                    this.onAccountSelect(account);
                }
            });
        });
        // Add account
        options.push({
            text: this.translate.instant('Add account'),
            handler: () => {
                this.onAccountSelect();
            }
        });
        // Cancel
        options.push({
            text: this.translate.instant('Cancel'),
            role: 'cancel'
        });
        let actionSheet = this.actionSheetCtrl.create({
            title: this.translate.instant('From TKCoin account'),
            buttons: options
        });
        actionSheet.present();
    }
    onAccountSelect(account) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isUndefined"](account)) {
            this.startPairTKCoinAccount();
        }
        else {
            this.bitPayCardProvider.sync(account.apiContext, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    return;
                }
                this.navCtrl.pop();
            });
        }
    }
    startPairTKCoinAccount() {
        this.navCtrl.popToRoot({ animate: false }); // Back to Root
        let url = 'https://tkcoin.org/visa/dashboard/add-to-tkcoin-wallet-confirm';
        this.externalLinkProvider.open(url);
    }
};
TKCoinSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tkcoin-settings',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-settings/tkcoin-settings.html"*/'<wide-header-page title="{{\'Card Settings\'|translate}}">\n  <div page-content>\n    <ion-list class="bp-list" [ngClass]="{\'top-padding\': !tkcoinCard}">\n      <ng-container *ngIf="!tkcoinCard">\n        <ion-item>\n          <ion-label>{{\'Show\' | translate}}</ion-label>\n          <ion-toggle [(ngModel)]="showAtHome" (ionChange)="integrationChange()"></ion-toggle>\n        </ion-item>\n        <button ion-item class="pairButton" (click)="connectTKCoinCard()">\n          <span class="main-label">{{\'Pair My BitPay Card\' | translate}}</span>\n        </button>\n      </ng-container>\n\n\n\n      <div *ngIf="tkcoinCard">\n        <ion-item>\n          <ion-icon item-start>\n            <img width="60" src="assets/img/tkcoin-card/tkcoin-card-visa.svg" />\n          </ion-icon>\n          <h2>TKCoin Visa&reg; Card</h2>\n          <p *ngIf="tkcoinCard.email">{{tkcoinCard.email}}</p>\n        </ion-item>\n        <ion-item>\n          {{ \'Last four digits\' | translate}}\n          <ion-note item-end>\n            {{tkcoinCard.lastFourDigits}}\n          </ion-note>\n        </ion-item>\n\n        <button ion-item class="with-label no-border" (click)="unlinkCard(tkcoinCard)">\n          <ion-label>{{\'Unlink card\' | translate}}</ion-label>\n        </button>\n        <label-tip type="warn" header="no-header">\n          <div label-tip-body>\n            <div translate>Unlink the card will remove it from this device.</div>\n          </div>\n        </label-tip>\n\n        <button ion-item class="with-label no-border" (click)="unlinkAccount(tkcoinCard)">\n          <ion-label>{{\'Unlink account\' | translate}}</ion-label>\n        </button>\n        <label-tip type="warn" header="no-header">\n          <div label-tip-body>\n            <div translate>Unlink the account will remove it and all associated cards from this device.</div>\n          </div>\n        </label-tip>\n      </div>\n\n    </ion-list>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/integrations/tkcoin-card/tkcoin-settings/tkcoin-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_tkcoin_account_tkcoin_account__["a" /* TKCoinAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tkcoin_card_tkcoin_card__["a" /* TKCoinCardProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], TKCoinSettingsPage);

//# sourceMappingURL=tkcoin-settings.js.map

/***/ }),

/***/ 996:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SessionLogPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logs_logs__ = __webpack_require__(377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);




// providers







let SessionLogPage = class SessionLogPage {
    constructor(configProvider, logger, actionSheetCtrl, platformProvider, translate, actionSheetProvider, appProvider, logsProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.actionSheetCtrl = actionSheetCtrl;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.logsProvider = logsProvider;
        this.config = this.configProvider.get();
        this.isCordova = this.platformProvider.isCordova;
        this.platform = this.isCordova
            ? this.platformProvider.isAndroid
                ? 'android'
                : 'ios'
            : 'desktop';
        const logLevels = this.logger.getLevels();
        this.logOptions = __WEBPACK_IMPORTED_MODULE_10_lodash__["keyBy"](logLevels, 'weight');
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SessionLogPage');
    }
    ionViewWillEnter() {
        const selectedLevel = __WEBPACK_IMPORTED_MODULE_10_lodash__["has"](this.config, 'log.weight')
            ? this.logger.getWeight(this.config.log.weight)
            : this.logger.getDefaultWeight();
        this.filterValue = selectedLevel.weight;
        this.setOptionSelected(selectedLevel.weight);
        this.filterLogs(selectedLevel.weight);
    }
    filterLogs(weight) {
        this.filteredLogs = __WEBPACK_IMPORTED_MODULE_10_lodash__["sortBy"](this.logger.get(weight), 'timestamp');
    }
    setOptionSelected(weight) {
        this.filterLogs(weight);
        const opts = {
            log: {
                weight
            }
        };
        this.configProvider.set(opts);
    }
    showOptionsMenu() {
        const downloadText = this.translate.instant('Download logs');
        const shareText = this.translate.instant('Share logs');
        const button = [];
        button.push({
            text: this.isCordova ? shareText : downloadText,
            handler: () => {
                this.showWarningModal();
            }
        });
        const actionSheet = this.actionSheetCtrl.create({
            title: '',
            buttons: button
        });
        actionSheet.present();
    }
    showWarningModal() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('sensitive-info');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option)
                this.logsProvider.get(this.appProvider.info.nameCase, this.platform);
        });
    }
};
SessionLogPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-session-log',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/about/session-log/session-log.html"*/'<wide-header-page title="{{\'Session Log\' | translate}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="showOptionsMenu()" ion-button icon-only>\n      <ion-icon name="more"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div *ngIf="filteredLogs && filteredLogs.length == 0" class="no-entries-message">\n      <span translate>No entries for this log level.</span>\n    </div>\n    <ion-list class="bp-list">\n      <ion-item class="log-entry">\n        <div *ngIf="filteredLogs && filteredLogs.length > 0">\n          <div *ngFor="let l of filteredLogs">\n            <span [ngClass]="{\'energized\': l.level==\'warn\', \'royal\': l.level==\'debug\', \'info-color\': l.level==\'info\', \'assertive\': l.level==\'error\'}">\n              <span class="log-timestamp">[{{l.timestamp}}]</span>\n              <span class="log-level">[{{l.level}}]</span> {{l.msg}}\n            </span>\n          </div>\n        </div>\n      </ion-item>\n    </ion-list>\n  </div>\n  <div footer-content>\n    <ion-toolbar>\n      <div class="filter-container">\n        <div class="labels">\n          <div *ngFor="let option of logOptions | keys" [ngClass]="{\'info-label\': option.value.weight==3}">{{option.value.label}}</div>\n        </div>\n        <ion-range min="1" max="4" step="1" snaps="true" color="secondary" [(ngModel)]="filterValue" (ionChange)="setOptionSelected(filterValue)"></ion-range>\n      </div>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/about/session-log/session-log.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logs_logs__["a" /* LogsProvider */]])
], SessionLogPage);

//# sourceMappingURL=session-log.js.map

/***/ }),

/***/ 997:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__add_add__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__view_view__ = __webpack_require__(998);









let AddressbookPage = class AddressbookPage {
    constructor(navCtrl, navParams, logger, addressbookProvider, addressProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.addressbookProvider = addressbookProvider;
        this.addressProvider = addressProvider;
        this.addressbook = [];
        this.filteredAddressbook = [];
    }
    ionViewDidEnter() {
        this.initAddressbook();
    }
    initAddressbook() {
        this.addressbookProvider
            .list()
            .then(addressBook => {
            this.isEmptyList = __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](addressBook);
            setTimeout(() => {
                let contacts = [];
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](addressBook, (contact, k) => {
                    const coinInfo = this.getCoinAndNetwork(k);
                    contacts.push({
                        name: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](contact) ? contact.name : contact,
                        address: k,
                        email: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](contact) ? contact.email : null,
                        tag: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](contact) ? contact.tag : null,
                        coin: coinInfo.coin,
                        network: coinInfo.network
                    });
                });
                this.addressbook = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](contacts);
                this.filteredAddressbook = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.addressbook);
            }, 100);
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    addEntry() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__add_add__["a" /* AddressbookAddPage */]);
    }
    viewEntry(contact) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__view_view__["a" /* AddressbookViewPage */], { contact });
    }
    getItems(event) {
        // set val to the value of the searchbar
        let val = event.target.value;
        // if the value is an empty string don't filter the items
        if (val && val.trim() != '') {
            let result = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.addressbook, item => {
                let name = item['name'];
                return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](name.toLowerCase(), val.toLowerCase());
            });
            this.filteredAddressbook = result;
        }
        else {
            // Reset items back to all of the items
            this.initAddressbook();
        }
    }
    getCoinAndNetwork(addr) {
        return this.addressProvider.getCoinAndNetwork(addr);
    }
};
AddressbookPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-addressbook',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/addressbook.html"*/'<wide-header-page title="{{\'Address Book\'|translate}}">\n  <ion-buttons *ngIf="!isEmptyList" right>\n    <button clear wide-header-bar-button (click)="addEntry()" ion-button>\n      <span translate>New contact</span>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <search-bar *ngIf="!isEmptyList" [scrollArea]="wideHeaderPage?.scrollArea" (search)="getItems($event)" placeholder="{{\'Search a contact\' | translate}}"></search-bar>\n    <div class="zero-state" *ngIf="isEmptyList">\n      <ion-icon class="zero-state-icon">\n        <img class="svg" src="assets/img/address-book-add.svg" />\n      </ion-icon>\n      <div class="zero-state-heading" translate>No contacts yet</div>\n      <div class="zero-state-description" translate>Get started by adding your first one.</div>\n      <button ion-button class="button-standard" (click)="addEntry()">\n        {{\'New contact\' | translate}}\n      </button>\n    </div>\n\n    <ion-list class="bp-list" margin-top>\n      <button ion-item *ngFor="let entry of filteredAddressbook | orderBy : [\'name\']" (click)="viewEntry(entry)">\n        <ion-icon item-start>\n          <gravatar [name]="entry.name" [height]="40" [width]="40" [email]="entry.email" [coin]="entry.coin" [network]="entry.network"></gravatar>\n        </ion-icon>\n        <div class="item-title">{{ entry.name }}</div>\n        <div class="item-subtitle">{{ entry.address }}</div>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/addressbook.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_address__["a" /* AddressProvider */]])
], AddressbookPage);

//# sourceMappingURL=addressbook.js.map

/***/ }),

/***/ 998:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookViewPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_send_amount_amount__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_address_address__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_index__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(25);




// Pages

// Providers




let AddressbookViewPage = class AddressbookViewPage {
    constructor(addressBookProvider, addressProvider, navCtrl, navParams, popupProvider, translate, actionSheetProvider) {
        this.addressBookProvider = addressBookProvider;
        this.addressProvider = addressProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.address = this.navParams.data.contact.address;
        const addrData = this.addressProvider.getCoinAndNetwork(this.address);
        this.coin = addrData.coin;
        this.network = addrData.network;
        this.name = this.navParams.data.contact.name;
        this.email = this.navParams.data.contact.email;
        this.tag = this.navParams.data.contact.tag;
    }
    ionViewDidLoad() { }
    sendTo() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__pages_send_amount_amount__["a" /* AmountPage */], {
            toAddress: this.address,
            name: this.name,
            email: this.email,
            destinationTag: this.tag,
            coin: this.coin,
            recipientType: 'contact',
            network: this.network
        });
    }
    remove() {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete this contact?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (!res)
                return;
            this.addressBookProvider
                .remove(this.address)
                .then(() => {
                this.navCtrl.pop();
            })
                .catch(err => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            });
        });
    }
    showMoreOptions() {
        const optionsSheet = this.actionSheetProvider.createOptionsSheet('address-book', { coin: this.coin.toUpperCase() });
        optionsSheet.present();
        optionsSheet.onDidDismiss(option => {
            if (option == 'send-to-contact')
                this.sendTo();
            if (option == 'delete-contact')
                this.remove();
        });
    }
};
AddressbookViewPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-addressbook-view',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/view/view.html"*/'<wide-header-page title="{{ name }}">\n  <ion-buttons right>\n    <button wide-header-bar-button clear class="option-button" (click)="showMoreOptions()" ion-button icon-only>\n      <ion-icon name="ios-more" md="ios-more"></ion-icon>\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <div class="contact-view-header">\n      <gravatar [name]="name" [height]="80" [width]="80" [email]="email" [coin]="coin" [network]="network"></gravatar>\n    </div>\n    <ion-list class="bp-list">\n      <ion-item>\n        {{\'Name\' | translate}}\n        <ion-note item-end>\n          {{ name }}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="email">\n        {{\'Email\' | translate}}\n        <ion-note item-end>\n          {{ email }}\n        </ion-note>\n      </ion-item>\n      <ion-item copy-to-clipboard="{{ address }}">\n        {{\'Address\' | translate}}\n        <div class="comment ellipsis">\n          {{ address }}\n        </div>\n      </ion-item>\n      <ion-item *ngIf="coin === \'xrp\' && tag" copy-to-clipboard="{{ tag }}">\n        {{\'Destination Tag\' | translate}}\n        <div class="comment ellipsis">\n          {{ tag }}\n        </div>\n      </ion-item>\n      <ion-item>\n        {{\'Coin\' | translate}}\n        <ion-note item-end>\n          {{ coin | uppercase }}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        {{\'Network\' | translate}}\n        <ion-note item-end>\n          {{ network }}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/addressbook/view/view.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__providers_index__["a" /* ActionSheetProvider */]])
], AddressbookViewPage);

//# sourceMappingURL=view.js.map

/***/ }),

/***/ 999:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AdvancedPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_splash_screen__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__wallet_recover_page_wallet_recover_page__ = __webpack_require__(1000);






// providers


let AdvancedPage = class AdvancedPage {
    constructor(configProvider, profileProvider, navCtrl, logger, platformProvider, splashScreen, popupProvider, translate, appProvider) {
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.splashScreen = splashScreen;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.appProvider = appProvider;
        this.isCopay = this.appProvider.info.name === 'copay';
        this.profileProvider
            .getProfileLegacy()
            .then(oldProfile => {
            this.oldProfileAvailable = oldProfile ? true : false;
            if (!this.oldProfileAvailable)
                return;
            this.wallets = __WEBPACK_IMPORTED_MODULE_5_lodash__["filter"](oldProfile.credentials, value => {
                return value && (value.mnemonic || value.mnemonicEncrypted);
            });
        })
            .catch(err => {
            this.oldProfileAvailable = false;
            this.logger.info('Error retrieving old profile, ', err);
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AdvancedPage');
    }
    ionViewWillEnter() {
        let config = this.configProvider.get();
        this.spendUnconfirmed = config.wallet.spendUnconfirmed;
    }
    spendUnconfirmedChange() {
        let opts = {
            wallet: {
                spendUnconfirmed: this.spendUnconfirmed
            }
        };
        this.configProvider.set(opts);
    }
    openWalletRecoveryPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__wallet_recover_page_wallet_recover_page__["a" /* WalletRecoverPage */]);
    }
    resetAllSettings() {
        const title = this.translate.instant('Reset All Settings');
        const message = this.translate.instant('Do you want to reset all settings to default value?');
        this.popupProvider.ionicConfirm(title, message).then(ok => {
            if (!ok)
                return;
            this.configProvider.reset();
            window.location.reload();
            if (this.platformProvider.isCordova)
                this.splashScreen.show();
        });
    }
};
AdvancedPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["__decorate"]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-advanced',template:/*ion-inline-start:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/advanced.html"*/'<wide-header-page title="{{ \'Advanced\' | translate }}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button ion-item (click)="resetAllSettings()">\n        <ion-label>{{ \'Reset All Settings\' | translate }}</ion-label>\n      </button>\n      <!-- TODO FIX\n      <ion-item class="with-label no-border">\n        <ion-label>{{ \'Use Unconfirmed Funds\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="spendUnconfirmed" (ionChange)="spendUnconfirmedChange()"></ion-toggle>\n      </ion-item>\n      <label-tip type="info" header="no-header">\n        <div label-tip-body>\n          <div translate>\n            If enabled, wallets will also try to spend unconfirmed funds.\n          </div>\n          <div *ngIf="!isCopay" translate>\n            However, unconfirmed funds are not allowed for spending with merchants, BitPay Card loads, or TKCoin in-app gift card purchases.\n          </div>\n        </div>\n      </label-tip>\n      -->\n    </ion-list>\n    <ion-list class="settings-list bp-list">\n      <button ion-item *ngIf="oldProfileAvailable && wallets && wallets[0]" class="with-label no-border" (click)="openWalletRecoveryPage()" translate>\n        Recover old wallets\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/santiago/Documents/BTC/EducoinGenerator/wallet/src/pages/settings/advanced/advanced.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["__metadata"]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers__["s" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_5" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["W" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_3" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["_4" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["f" /* AppProvider */]])
], AdvancedPage);

//# sourceMappingURL=advanced.js.map

/***/ })

},[1032]);
//# sourceMappingURL=main.js.map